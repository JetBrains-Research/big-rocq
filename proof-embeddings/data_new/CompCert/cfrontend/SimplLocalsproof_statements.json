{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/SimplLocalsproof.v","fileSamples":[{"statement":"(p tp : program) (H : (do p1 <- transform_partial_program transf_fundef p;\n OK\n   {|\n     prog_defs := AST.prog_defs p1;\n     prog_public := AST.prog_public p1;\n     prog_main := AST.prog_main p1;\n     prog_types := prog_types p;\n     prog_comp_env := prog_comp_env p;\n     prog_comp_env_eq := prog_comp_env_eq p\n   |}) = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p tp : program) (H : (do p1 <- transform_partial_program transf_fundef p;\n OK\n   {|\n     prog_defs := AST.prog_defs p1;\n     prog_public := AST.prog_public p1;\n     prog_main := AST.prog_main p1;\n     prog_types := prog_types p;\n     prog_comp_env := prog_comp_env p;\n     prog_comp_env_eq := prog_comp_env_eq p\n   |}) = OK tp)","proofString":"monadInv H.\nsplit; auto.\napply match_transform_partial_program.\nrewrite EQ.\ndestruct x; auto."},{"statement":"(p : program) (x : AST.program fundef type) (EQ : transform_partial_program transf_fundef p = OK x) : match_prog p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}.","conclusion":"match_prog p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}","hypotheses":"(p : program) (x : AST.program fundef type) (EQ : transform_partial_program transf_fundef p = OK x)","proofString":"split; auto.\napply match_transform_partial_program.\nrewrite EQ.\ndestruct x; auto."},{"statement":"(p : program) (x : AST.program fundef type) (EQ : transform_partial_program transf_fundef p = OK x) : match_program\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   transf_fundef f = OK tf) eq p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}.","conclusion":"match_program\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   transf_fundef f = OK tf) eq p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}","hypotheses":"(p : program) (x : AST.program fundef type) (EQ : transform_partial_program transf_fundef p = OK x)","proofString":"apply match_transform_partial_program.\nrewrite EQ.\ndestruct x; auto."},{"statement":"(prog_defs : list (ident * globdef (Ctypes.fundef function) type)) (prog_public : list ident) (prog_main : ident) (prog_types : list composite_definition) (prog_comp_env : composite_env) (prog_comp_env_eq : build_composite_env prog_types = OK prog_comp_env) (prog_defs0 : list (ident * globdef (Ctypes.fundef function) type)) (prog_public0 : list ident) (prog_main0 : ident) (prog_types0 : list composite_definition) (prog_comp_env0 : composite_env) (prog_comp_env_eq0 : build_composite_env prog_types0 = OK prog_comp_env0) (EQ : Ctypes.prog_types\n  {|\n    prog_defs := prog_defs0;\n    prog_public := prog_public0;\n    prog_main := prog_main0;\n    prog_types := prog_types0;\n    prog_comp_env := prog_comp_env0;\n    prog_comp_env_eq := prog_comp_env_eq0\n  |} =\nCtypes.prog_types\n  {|\n    prog_defs := prog_defs;\n    prog_public := prog_public;\n    prog_main := prog_main;\n    prog_types := prog_types;\n    prog_comp_env := prog_comp_env;\n    prog_comp_env_eq := prog_comp_env_eq\n  |}) : prog_comp_env0 = prog_comp_env.","conclusion":"prog_comp_env0 = prog_comp_env","hypotheses":"(prog_defs : list (ident * globdef (Ctypes.fundef function) type)) (prog_public : list ident) (prog_main : ident) (prog_types : list composite_definition) (prog_comp_env : composite_env) (prog_comp_env_eq : build_composite_env prog_types = OK prog_comp_env) (prog_defs0 : list (ident * globdef (Ctypes.fundef function) type)) (prog_public0 : list ident) (prog_main0 : ident) (prog_types0 : list composite_definition) (prog_comp_env0 : composite_env) (prog_comp_env_eq0 : build_composite_env prog_types0 = OK prog_comp_env0) (EQ : Ctypes.prog_types\n  {|\n    prog_defs := prog_defs0;\n    prog_public := prog_public0;\n    prog_main := prog_main0;\n    prog_types := prog_types0;\n    prog_comp_env := prog_comp_env0;\n    prog_comp_env_eq := prog_comp_env_eq0\n  |} =\nCtypes.prog_types\n  {|\n    prog_defs := prog_defs;\n    prog_public := prog_public;\n    prog_main := prog_main;\n    prog_types := prog_types;\n    prog_comp_env := prog_comp_env;\n    prog_comp_env_eq := prog_comp_env_eq\n  |})","proofString":"simpl in EQ.\ncongruence."},{"statement":"(prog_defs : list (ident * globdef (Ctypes.fundef function) type)) (prog_public : list ident) (prog_main : ident) (prog_types : list composite_definition) (prog_comp_env : composite_env) (prog_comp_env_eq : build_composite_env prog_types = OK prog_comp_env) (prog_defs0 : list (ident * globdef (Ctypes.fundef function) type)) (prog_public0 : list ident) (prog_main0 : ident) (prog_types0 : list composite_definition) (prog_comp_env0 : composite_env) (prog_comp_env_eq0 : build_composite_env prog_types0 = OK prog_comp_env0) (EQ : prog_types0 = prog_types) : prog_comp_env0 = prog_comp_env.","conclusion":"prog_comp_env0 = prog_comp_env","hypotheses":"(prog_defs : list (ident * globdef (Ctypes.fundef function) type)) (prog_public : list ident) (prog_main : ident) (prog_types : list composite_definition) (prog_comp_env : composite_env) (prog_comp_env_eq : build_composite_env prog_types = OK prog_comp_env) (prog_defs0 : list (ident * globdef (Ctypes.fundef function) type)) (prog_public0 : list ident) (prog_main0 : ident) (prog_types0 : list composite_definition) (prog_comp_env0 : composite_env) (prog_comp_env_eq0 : build_composite_env prog_types0 = OK prog_comp_env0) (EQ : prog_types0 = prog_types)","proofString":"congruence."},{"statement":"(fd tfd : fundef) (H : transf_fundef fd = OK tfd) : type_of_fundef tfd = type_of_fundef fd.","conclusion":"type_of_fundef tfd = type_of_fundef fd","hypotheses":"(fd tfd : fundef) (H : transf_fundef fd = OK tfd)","proofString":"destruct fd; monadInv H; auto.\nmonadInv EQ.\nsimpl; unfold type_of_function; simpl.\nauto."},{"statement":"(f x : function) (EQ : transf_function f = OK x) : type_of_fundef (Internal x) = type_of_fundef (Internal f).","conclusion":"type_of_fundef (Internal x) = type_of_fundef (Internal f)","hypotheses":"(f x : function) (EQ : transf_function f = OK x)","proofString":"monadInv EQ.\nsimpl; unfold type_of_function; simpl.\nauto."},{"statement":"(f : function) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (x0 : statement) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) : type_of_fundef\n  (Internal\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}) = type_of_fundef (Internal f).","conclusion":"type_of_fundef\n  (Internal\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}) = type_of_fundef (Internal f)","hypotheses":"(f : function) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (x0 : statement) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0)","proofString":"simpl; unfold type_of_function; simpl.\nauto."},{"statement":"(f : function) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (x0 : statement) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) : Tfunction (type_of_params (fn_params f)) (fn_return f) (fn_callconv f) =\nTfunction (type_of_params (fn_params f)) (fn_return f) (fn_callconv f).","conclusion":"Tfunction (type_of_params (fn_params f)) (fn_return f) (fn_callconv f) =\nTfunction (type_of_params (fn_params f)) (fn_return f) (fn_callconv f)","hypotheses":"(f : function) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (x0 : statement) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0)","proofString":"auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (ME : match_envs f cenv e le m lo hi te tle tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) : match_envs f' cenv e le m' lo hi te tle tlo thi.","conclusion":"match_envs f' cenv e le m' lo hi te tle tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (ME : match_envs f cenv e le m lo hi te tle tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b)","proofString":"destruct ME; constructor; eauto.\nintros.\ngeneralize (me_vars0 id); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- MAPPED; eauto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nintros.\nexploit me_temps0; eauto.\nintros [[v' [A B]] C].\nsplit; auto.\nexists v'; eauto.\nintros.\nexploit me_mapped0; eauto.\nintros [b [A B]].\nexists b; split; auto.\nintros.\neapply me_flat0; eauto.\nrewrite <- H0.\nsymmetry.\neapply INV2; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) : forall id : ident, match_var f' cenv e m' te tle id.","conclusion":"forall id : ident, match_var f' cenv e m' te tle id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b)","proofString":"intros.\ngeneralize (me_vars0 id); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- MAPPED; eauto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : ident) : match_var f' cenv e m' te tle id.","conclusion":"match_var f' cenv e m' te tle id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : ident)","proofString":"generalize (me_vars0 id); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- MAPPED; eauto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b0 = f b0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv) : match_var f' cenv e m' te tle id.","conclusion":"match_var f' cenv e m' te tle id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b0 = f b0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv)","proofString":"eapply match_var_lifted; eauto.\nrewrite <- MAPPED; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b0 = f b0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv) : f' b = None.","conclusion":"f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b0 = f b0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv)","proofString":"rewrite <- MAPPED; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = Some (b', ty)) (LIFTED : VSet.mem id cenv = false) (MAPPED : f b = Some (b', 0)) : match_var f' cenv e m' te tle id.","conclusion":"match_var f' cenv e m' te tle id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = Some (b', ty)) (LIFTED : VSet.mem id cenv = false) (MAPPED : f b = Some (b', 0))","proofString":"eapply match_var_not_lifted; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : ident) (ENV : e ! id = None) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = false) : match_var f' cenv e m' te tle id.","conclusion":"match_var f' cenv e m' te tle id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : ident) (ENV : e ! id = None) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = false)","proofString":"eapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef).","conclusion":"forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b)","proofString":"intros.\nexploit me_temps0; eauto.\nintros [[v' [A B]] C].\nsplit; auto.\nexists v'; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v) : (exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef).","conclusion":"(exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v)","proofString":"exploit me_temps0; eauto.\nintros [[v' [A B]] C].\nsplit; auto.\nexists v'; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v) : (exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef) ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef).","conclusion":"(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef) ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v)","proofString":"intros [[v' [A B]] C].\nsplit; auto.\nexists v'; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v) (v' : val) (A : tle ! id = Some v') (B : Val.inject f v v') (C : VSet.mem id cenv = true -> v = Vundef) : (exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef).","conclusion":"(exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v) (v' : val) (A : tle ! id = Some v') (B : Val.inject f v v') (C : VSet.mem id cenv = true -> v = Vundef)","proofString":"split; auto.\nexists v'; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v) (v' : val) (A : tle ! id = Some v') (B : Val.inject f v v') (C : VSet.mem id cenv = true -> v = Vundef) : exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv.","conclusion":"exists tv : val, tle ! id = Some tv /\\ Val.inject f' v tv","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) (id : positive) (v : val) (H : le ! id = Some v) (v' : val) (A : tle ! id = Some v') (B : Val.inject f v v') (C : VSet.mem id cenv = true -> v = Vundef)","proofString":"exists v'; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b)","proofString":"intros.\nexploit me_mapped0; eauto.\nintros [b [A B]].\nexists b; split; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty0 : type),\nte ! id0 = Some (b, ty0) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b : block, f b = Some (b'0, 0) /\\ e ! id0 = Some (b, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b = Some (b'0, delta) -> e ! id0 = Some (b, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b = f b) (id : positive) (b' : block) (ty : type) (H : te ! id = Some (b', ty)) : exists b : block, f' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"exists b : block, f' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty0 : type),\nte ! id0 = Some (b, ty0) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b : block, f b = Some (b'0, 0) /\\ e ! id0 = Some (b, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b = Some (b'0, delta) -> e ! id0 = Some (b, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b = f b) (id : positive) (b' : block) (ty : type) (H : te ! id = Some (b', ty))","proofString":"exploit me_mapped0; eauto.\nintros [b [A B]].\nexists b; split; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty0 : type),\nte ! id0 = Some (b, ty0) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b : block, f b = Some (b'0, 0) /\\ e ! id0 = Some (b, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b = Some (b'0, delta) -> e ! id0 = Some (b, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b = f b) (id : positive) (b' : block) (ty : type) (H : te ! id = Some (b', ty)) : (exists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) ->\nexists b : block, f' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"(exists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) ->\nexists b : block, f' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty0 : type),\nte ! id0 = Some (b, ty0) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b : block, f b = Some (b'0, 0) /\\ e ! id0 = Some (b, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b = Some (b'0, delta) -> e ! id0 = Some (b, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b = f b) (id : positive) (b' : block) (ty : type) (H : te ! id = Some (b', ty))","proofString":"intros [b [A B]].\nexists b; split; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (H : te ! id = Some (b', ty)) (b : block) (A : f b = Some (b', 0)) (B : e ! id = Some (b, ty)) : exists b0 : block, f' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty).","conclusion":"exists b0 : block, f' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (H : te ! id = Some (b', ty)) (b : block) (A : f b = Some (b', 0)) (B : e ! id = Some (b, ty))","proofString":"exists b; split; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b) : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf' b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0.","conclusion":"forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf' b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b) (INV2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b)","proofString":"intros.\neapply me_flat0; eauto.\nrewrite <- H0.\nsymmetry.\neapply INV2; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta)) : e ! id = Some (b, ty) /\\ delta = 0.","conclusion":"e ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta))","proofString":"eapply me_flat0; eauto.\nrewrite <- H0.\nsymmetry.\neapply INV2; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta)) : f b = Some (b', delta).","conclusion":"f b = Some (b', delta)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta))","proofString":"rewrite <- H0.\nsymmetry.\neapply INV2; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta)) : f b = f' b.","conclusion":"f b = f' b","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta))","proofString":"symmetry.\neapply INV2; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta)) : f' b = f b.","conclusion":"f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (f' : meminj) (m' : mem) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta0 : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta0) -> e ! id0 = Some (b0, ty0) /\\ delta0 = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (LD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPle lo b0 /\\ Plt b0 hi ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INV1 : forall b0 : positive, Ple lo b0 /\\ Plt b0 hi -> f' b0 = f b0) (INV2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Ple tlo b'0 /\\ Plt b'0 thi -> f' b0 = f b0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H : te ! id = Some (b', ty)) (H0 : f' b = Some (b', delta))","proofString":"eapply INV2; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) : match_envs f' cenv e le m' lo hi te tle tlo thi.","conclusion":"match_envs f' cenv e le m' lo hi te tle tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm))","proofString":"eapply match_envs_invariant; eauto.\nintros.\neapply Mem.load_unchanged_on; eauto.\nred in H2.\nintros.\ndestruct (f b) as [[b' delta]|] eqn:?.\neapply H1; eauto.\ndestruct (f' b) as [[b' delta]|] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia.\nintros.\ndestruct (f b) as [[b'' delta']|] eqn:?.\neauto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm))","proofString":"intros.\neapply Mem.load_unchanged_on; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Ple lo b /\\ Plt b hi) (H7 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Some v.","conclusion":"Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Ple lo b /\\ Plt b hi) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"eapply Mem.load_unchanged_on; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b.","conclusion":"forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm))","proofString":"red in H2.\nintros.\ndestruct (f b) as [[b' delta]|] eqn:?.\neapply H1; eauto.\ndestruct (f' b) as [[b' delta]|] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b.","conclusion":"forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm))","proofString":"intros.\ndestruct (f b) as [[b' delta]|] eqn:?.\neapply H1; eauto.\ndestruct (f' b) as [[b' delta]|] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) : f' b = f b.","conclusion":"f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi)","proofString":"destruct (f b) as [[b' delta]|] eqn:?.\neapply H1; eauto.\ndestruct (f' b) as [[b' delta]|] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (b' : block) (delta : Z) (Heqo : f b = Some (b', delta)) : f' b = Some (b', delta).","conclusion":"f' b = Some (b', delta)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (b' : block) (delta : Z) (Heqo : f b = Some (b', delta))","proofString":"eapply H1; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) : f' b = None.","conclusion":"f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None)","proofString":"destruct (f' b) as [[b' delta]|] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) : Some (b', delta) = None.","conclusion":"Some (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta))","proofString":"exploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) : ~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> Some (b', delta) = None.","conclusion":"~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> Some (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta))","proofString":"unfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) : ~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) ->\nSome (b', delta) = None.","conclusion":"~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) ->\nSome (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta))","proofString":"intros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm)) : Some (b', delta) = None.","conclusion":"Some (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b : positive) (H5 : Ple lo b /\\ Plt b hi) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm))","proofString":"extlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b.","conclusion":"forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm))","proofString":"intros.\ndestruct (f b) as [[b'' delta']|] eqn:?.\neauto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) : f' b = f b.","conclusion":"f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi)","proofString":"destruct (f b) as [[b'' delta']|] eqn:?.\neauto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (b'' : block) (delta' : Z) (Heqo : f b = Some (b'', delta')) : f' b = Some (b'', delta').","conclusion":"f' b = Some (b'', delta')","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (b'' : block) (delta' : Z) (Heqo : f b = Some (b'', delta'))","proofString":"eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None) : f' b = None.","conclusion":"f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None)","proofString":"exploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None) : ~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> f' b = None.","conclusion":"~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None)","proofString":"unfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None) : ~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) -> f' b = None.","conclusion":"~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) -> f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None)","proofString":"intros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm)) : f' b = None.","conclusion":"f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple hi (Mem.nextblock m)) (H4 : Ple thi (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) (Heqo : f b = None) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm))","proofString":"extlia."},{"statement":"(v : val) (ty : type) (chunk : memory_chunk) (H : val_casted v ty) (H0 : access_mode ty = By_value chunk) : Val.load_result chunk v = v.","conclusion":"Val.load_result chunk v = v","hypotheses":"(v : val) (ty : type) (chunk : memory_chunk) (H : val_casted v ty) (H0 : access_mode ty = By_value chunk)","proofString":"inversion H; clear H; subst v ty; simpl in H0.\ndestruct sz.\ndestruct si; inversion H0; clear H0; subst chunk; simpl in *; congruence.\ndestruct si; inversion H0; clear H0; subst chunk; simpl in *; congruence.\nclear H1.\ninv H0.\nauto.\ninversion H0; clear H0; subst chunk.\nsimpl in *.\ndestruct (Int.eq n Int.zero); subst n; reflexivity.\ninv H0; auto.\ninv H0; auto.\ninv H0; auto.\ninv H0.\nunfold Mptr, Val.load_result; destruct Archi.ptr64; auto.\ninv H0.\nunfold Mptr, Val.load_result; rewrite H1; auto.\ninv H0.\nunfold Val.load_result; rewrite H1; auto.\ninv H0.\nunfold Mptr, Val.load_result; rewrite H1; auto.\ninv H0.\nunfold Val.load_result; rewrite H1; auto.\ndiscriminate.\ndiscriminate.\ndiscriminate."},{"statement":"(chunk : memory_chunk) (sz : intsize) (si : signedness) (attr : Ctypes.attr) (H0 : match sz with\n| I8 =>\n    match si with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match si with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_value chunk) (n : int) (H1 : cast_int_int sz si n = n) : Val.load_result chunk (Vint n) = Vint n.","conclusion":"Val.load_result chunk (Vint n) = Vint n","hypotheses":"(chunk : memory_chunk) (sz : intsize) (si : signedness) (attr : Ctypes.attr) (H0 : match sz with\n| I8 =>\n    match si with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match si with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_value chunk) (n : int) (H1 : cast_int_int sz si n = n)","proofString":"destruct sz.\ndestruct si; inversion H0; clear H0; subst chunk; simpl in *; congruence.\ndestruct si; inversion H0; clear H0; subst chunk; simpl in *; congruence.\nclear H1.\ninv H0.\nauto.\ninversion H0; clear H0; subst chunk.\nsimpl in *.\ndestruct (Int.eq n Int.zero); subst n; reflexivity."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : match si with\n| Signed => By_value Mint8signed\n| Unsigned => By_value Mint8unsigned\nend = By_value chunk) (n : int) (H1 : cast_int_int I8 si n = n) : Val.load_result chunk (Vint n) = Vint n.","conclusion":"Val.load_result chunk (Vint n) = Vint n","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : match si with\n| Signed => By_value Mint8signed\n| Unsigned => By_value Mint8unsigned\nend = By_value chunk) (n : int) (H1 : cast_int_int I8 si n = n)","proofString":"destruct si; inversion H0; clear H0; subst chunk; simpl in *; congruence."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : match si with\n| Signed => By_value Mint16signed\n| Unsigned => By_value Mint16unsigned\nend = By_value chunk) (n : int) (H1 : cast_int_int I16 si n = n) : Val.load_result chunk (Vint n) = Vint n.","conclusion":"Val.load_result chunk (Vint n) = Vint n","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : match si with\n| Signed => By_value Mint16signed\n| Unsigned => By_value Mint16unsigned\nend = By_value chunk) (n : int) (H1 : cast_int_int I16 si n = n)","proofString":"destruct si; inversion H0; clear H0; subst chunk; simpl in *; congruence."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint32 = By_value chunk) (n : int) (H1 : cast_int_int I32 si n = n) : Val.load_result chunk (Vint n) = Vint n.","conclusion":"Val.load_result chunk (Vint n) = Vint n","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint32 = By_value chunk) (n : int) (H1 : cast_int_int I32 si n = n)","proofString":"clear H1.\ninv H0.\nauto."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint32 = By_value chunk) (n : int) : Val.load_result chunk (Vint n) = Vint n.","conclusion":"Val.load_result chunk (Vint n) = Vint n","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint32 = By_value chunk) (n : int)","proofString":"inv H0.\nauto."},{"statement":"(si : signedness) (attr : Ctypes.attr) (n : int) : Val.load_result Mint32 (Vint n) = Vint n.","conclusion":"Val.load_result Mint32 (Vint n) = Vint n","hypotheses":"(si : signedness) (attr : Ctypes.attr) (n : int)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mbool = By_value chunk) (n : int) (H1 : cast_int_int IBool si n = n) : Val.load_result chunk (Vint n) = Vint n.","conclusion":"Val.load_result chunk (Vint n) = Vint n","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mbool = By_value chunk) (n : int) (H1 : cast_int_int IBool si n = n)","proofString":"inversion H0; clear H0; subst chunk.\nsimpl in *.\ndestruct (Int.eq n Int.zero); subst n; reflexivity."},{"statement":"(si : signedness) (attr : Ctypes.attr) (n : int) (H1 : cast_int_int IBool si n = n) : Val.load_result Mbool (Vint n) = Vint n.","conclusion":"Val.load_result Mbool (Vint n) = Vint n","hypotheses":"(si : signedness) (attr : Ctypes.attr) (n : int) (H1 : cast_int_int IBool si n = n)","proofString":"simpl in *.\ndestruct (Int.eq n Int.zero); subst n; reflexivity."},{"statement":"(si : signedness) (attr : Ctypes.attr) (n : int) (H1 : (if Int.eq n Int.zero then Int.zero else Int.one) = n) : Val.norm_bool (Vint (Int.zero_ext 8 n)) = Vint n.","conclusion":"Val.norm_bool (Vint (Int.zero_ext 8 n)) = Vint n","hypotheses":"(si : signedness) (attr : Ctypes.attr) (n : int) (H1 : (if Int.eq n Int.zero then Int.zero else Int.one) = n)","proofString":"destruct (Int.eq n Int.zero); subst n; reflexivity."},{"statement":"(chunk : memory_chunk) (attr : Ctypes.attr) (H0 : By_value Mfloat64 = By_value chunk) (n : float) : Val.load_result chunk (Vfloat n) = Vfloat n.","conclusion":"Val.load_result chunk (Vfloat n) = Vfloat n","hypotheses":"(chunk : memory_chunk) (attr : Ctypes.attr) (H0 : By_value Mfloat64 = By_value chunk) (n : float)","proofString":"inv H0; auto."},{"statement":"(chunk : memory_chunk) (attr : Ctypes.attr) (H0 : By_value Mfloat32 = By_value chunk) (n : float32) : Val.load_result chunk (Vsingle n) = Vsingle n.","conclusion":"Val.load_result chunk (Vsingle n) = Vsingle n","hypotheses":"(chunk : memory_chunk) (attr : Ctypes.attr) (H0 : By_value Mfloat32 = By_value chunk) (n : float32)","proofString":"inv H0; auto."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint64 = By_value chunk) (n : int64) : Val.load_result chunk (Vlong n) = Vlong n.","conclusion":"Val.load_result chunk (Vlong n) = Vlong n","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint64 = By_value chunk) (n : int64)","proofString":"inv H0; auto."},{"statement":"(chunk : memory_chunk) (ty0 : type) (attr : Ctypes.attr) (H0 : By_value Mptr = By_value chunk) (b : block) (ofs : ptrofs) : Val.load_result chunk (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result chunk (Vptr b ofs) = Vptr b ofs","hypotheses":"(chunk : memory_chunk) (ty0 : type) (attr : Ctypes.attr) (H0 : By_value Mptr = By_value chunk) (b : block) (ofs : ptrofs)","proofString":"inv H0.\nunfold Mptr, Val.load_result; destruct Archi.ptr64; auto."},{"statement":"(ty0 : type) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : Val.load_result Mptr (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result Mptr (Vptr b ofs) = Vptr b ofs","hypotheses":"(ty0 : type) (attr : Ctypes.attr) (b : block) (ofs : ptrofs)","proofString":"unfold Mptr, Val.load_result; destruct Archi.ptr64; auto."},{"statement":"(chunk : memory_chunk) (ty0 : type) (attr : Ctypes.attr) (H0 : By_value Mptr = By_value chunk) (n : int) (H1 : Archi.ptr64 = false) : Val.load_result chunk (Vint n) = Vint n.","conclusion":"Val.load_result chunk (Vint n) = Vint n","hypotheses":"(chunk : memory_chunk) (ty0 : type) (attr : Ctypes.attr) (H0 : By_value Mptr = By_value chunk) (n : int) (H1 : Archi.ptr64 = false)","proofString":"inv H0.\nunfold Mptr, Val.load_result; rewrite H1; auto."},{"statement":"(ty0 : type) (attr : Ctypes.attr) (n : int) (H1 : Archi.ptr64 = false) : Val.load_result Mptr (Vint n) = Vint n.","conclusion":"Val.load_result Mptr (Vint n) = Vint n","hypotheses":"(ty0 : type) (attr : Ctypes.attr) (n : int) (H1 : Archi.ptr64 = false)","proofString":"unfold Mptr, Val.load_result; rewrite H1; auto."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint32 = By_value chunk) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = false) : Val.load_result chunk (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result chunk (Vptr b ofs) = Vptr b ofs","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint32 = By_value chunk) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = false)","proofString":"inv H0.\nunfold Val.load_result; rewrite H1; auto."},{"statement":"(si : signedness) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = false) : Val.load_result Mint32 (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result Mint32 (Vptr b ofs) = Vptr b ofs","hypotheses":"(si : signedness) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = false)","proofString":"unfold Val.load_result; rewrite H1; auto."},{"statement":"(chunk : memory_chunk) (ty0 : type) (attr : Ctypes.attr) (H0 : By_value Mptr = By_value chunk) (n : int64) (H1 : Archi.ptr64 = true) : Val.load_result chunk (Vlong n) = Vlong n.","conclusion":"Val.load_result chunk (Vlong n) = Vlong n","hypotheses":"(chunk : memory_chunk) (ty0 : type) (attr : Ctypes.attr) (H0 : By_value Mptr = By_value chunk) (n : int64) (H1 : Archi.ptr64 = true)","proofString":"inv H0.\nunfold Mptr, Val.load_result; rewrite H1; auto."},{"statement":"(ty0 : type) (attr : Ctypes.attr) (n : int64) (H1 : Archi.ptr64 = true) : Val.load_result Mptr (Vlong n) = Vlong n.","conclusion":"Val.load_result Mptr (Vlong n) = Vlong n","hypotheses":"(ty0 : type) (attr : Ctypes.attr) (n : int64) (H1 : Archi.ptr64 = true)","proofString":"unfold Mptr, Val.load_result; rewrite H1; auto."},{"statement":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint64 = By_value chunk) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = true) : Val.load_result chunk (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result chunk (Vptr b ofs) = Vptr b ofs","hypotheses":"(chunk : memory_chunk) (si : signedness) (attr : Ctypes.attr) (H0 : By_value Mint64 = By_value chunk) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = true)","proofString":"inv H0.\nunfold Val.load_result; rewrite H1; auto."},{"statement":"(si : signedness) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = true) : Val.load_result Mint64 (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result Mint64 (Vptr b ofs) = Vptr b ofs","hypotheses":"(si : signedness) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = true)","proofString":"unfold Val.load_result; rewrite H1; auto."},{"statement":"(chunk : memory_chunk) (id : ident) (attr : Ctypes.attr) (H0 : By_copy = By_value chunk) (b : block) (ofs : ptrofs) : Val.load_result chunk (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result chunk (Vptr b ofs) = Vptr b ofs","hypotheses":"(chunk : memory_chunk) (id : ident) (attr : Ctypes.attr) (H0 : By_copy = By_value chunk) (b : block) (ofs : ptrofs)","proofString":"discriminate."},{"statement":"(chunk : memory_chunk) (id : ident) (attr : Ctypes.attr) (H0 : By_copy = By_value chunk) (b : block) (ofs : ptrofs) : Val.load_result chunk (Vptr b ofs) = Vptr b ofs.","conclusion":"Val.load_result chunk (Vptr b ofs) = Vptr b ofs","hypotheses":"(chunk : memory_chunk) (id : ident) (attr : Ctypes.attr) (H0 : By_copy = By_value chunk) (b : block) (ofs : ptrofs)","proofString":"discriminate."},{"statement":"(chunk : memory_chunk) (H0 : By_nothing = By_value chunk) (v0 : val) : Val.load_result chunk v0 = v0.","conclusion":"Val.load_result chunk v0 = v0","hypotheses":"(chunk : memory_chunk) (H0 : By_nothing = By_value chunk) (v0 : val)","proofString":"discriminate."},{"statement":"(f : meminj) (v v' : val) (ty : type) (H : Val.inject f v v') (H0 : val_casted v ty) : val_casted v' ty.","conclusion":"val_casted v' ty","hypotheses":"(f : meminj) (v v' : val) (ty : type) (H : Val.inject f v v') (H0 : val_casted v ty)","proofString":"inv H; auto.\ninv H0; constructor; auto.\ninv H0; constructor."},{"statement":"(f : meminj) (ty : type) (b1 : block) (ofs1 : ptrofs) (H0 : val_casted (Vptr b1 ofs1) ty) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : val_casted (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) ty.","conclusion":"val_casted (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) ty","hypotheses":"(f : meminj) (ty : type) (b1 : block) (ofs1 : ptrofs) (H0 : val_casted (Vptr b1 ofs1) ty) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta))","proofString":"inv H0; constructor; auto."},{"statement":"(f : meminj) (v' : val) (ty : type) (H0 : val_casted Vundef ty) : val_casted v' ty.","conclusion":"val_casted v' ty","hypotheses":"(f : meminj) (v' : val) (ty : type) (H0 : val_casted Vundef ty)","proofString":"inv H0; constructor."},{"statement":"(f : meminj) (v v' : val) (vl vl' : list val) (H : Val.inject f v v') (H0 : Val.inject_list f vl vl') (IHinject_list : forall tyl : list type,\nlist_forall2 val_casted vl tyl -> list_forall2 val_casted vl' tyl) (b1 : type) (bl : list type) (H3 : val_casted v b1) (H5 : list_forall2 val_casted vl bl) : val_casted v' b1.","conclusion":"val_casted v' b1","hypotheses":"(f : meminj) (v v' : val) (vl vl' : list val) (H : Val.inject f v v') (H0 : Val.inject_list f vl vl') (IHinject_list : forall tyl : list type,\nlist_forall2 val_casted vl tyl -> list_forall2 val_casted vl' tyl) (b1 : type) (bl : list type) (H3 : val_casted v b1) (H5 : list_forall2 val_casted vl bl)","proofString":"eapply val_casted_inject; eauto."},{"statement":"(vl : list val) (H : val_casted_list vl nil) : list_forall2 val_casted vl nil.","conclusion":"list_forall2 val_casted vl nil","hypotheses":"(vl : list val) (H : val_casted_list vl nil)","proofString":"inv H.\nconstructor."},{"statement":"list_forall2 val_casted nil nil.","conclusion":"list_forall2 val_casted nil nil","hypotheses":"","proofString":"constructor."},{"statement":"(a : ident * type) (params : list (ident * type)) (IHparams : forall vl0 : list val,\nval_casted_list vl0 (type_of_params params) ->\nlist_forall2 val_casted vl0 (map snd params)) (vl : list val) (H : val_casted_list vl (snd a :: type_of_params params)) : list_forall2 val_casted vl (snd a :: map snd params).","conclusion":"list_forall2 val_casted vl (snd a :: map snd params)","hypotheses":"(a : ident * type) (params : list (ident * type)) (IHparams : forall vl0 : list val,\nval_casted_list vl0 (type_of_params params) ->\nlist_forall2 val_casted vl0 (map snd params)) (vl : list val) (H : val_casted_list vl (snd a :: type_of_params params))","proofString":"destruct a as [id ty].\ninv H.\nconstructor; auto."},{"statement":"(id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall vl0 : list val,\nval_casted_list vl0 (type_of_params params) ->\nlist_forall2 val_casted vl0 (map snd params)) (vl : list val) (H : val_casted_list vl (snd (id, ty) :: type_of_params params)) : list_forall2 val_casted vl (snd (id, ty) :: map snd params).","conclusion":"list_forall2 val_casted vl (snd (id, ty) :: map snd params)","hypotheses":"(id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall vl0 : list val,\nval_casted_list vl0 (type_of_params params) ->\nlist_forall2 val_casted vl0 (map snd params)) (vl : list val) (H : val_casted_list vl (snd (id, ty) :: type_of_params params))","proofString":"inv H.\nconstructor; auto."},{"statement":"(id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall vl : list val,\nval_casted_list vl (type_of_params params) ->\nlist_forall2 val_casted vl (map snd params)) (v1 : val) (vl0 : list val) (H3 : val_casted v1 ty) (H4 : val_casted_list vl0 (type_of_params params)) : list_forall2 val_casted (v1 :: vl0) (snd (id, ty) :: map snd params).","conclusion":"list_forall2 val_casted (v1 :: vl0) (snd (id, ty) :: map snd params)","hypotheses":"(id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall vl : list val,\nval_casted_list vl (type_of_params params) ->\nlist_forall2 val_casted vl (map snd params)) (v1 : val) (vl0 : list val) (H3 : val_casted v1 ty) (H4 : val_casted_list vl0 (type_of_params params))","proofString":"constructor; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) tto m = Some v2) : eval_expr tge e le m (make_cast a tto) v2.","conclusion":"eval_expr tge e le m (make_cast a tto) v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) tto m = Some v2)","proofString":"assert (DFL: eval_expr tge e le m (Ecast a tto) v2).\neconstructor; eauto.\nunfold sem_cast, make_cast in *.\ndestruct (classify_cast (typeof a) tto); auto.\ndestruct v1; destruct Archi.ptr64; inv H0; auto.\ndestruct sz2; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto.\ndestruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto.\ninv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) tto m = Some v2) : eval_expr tge e le m (Ecast a tto) v2.","conclusion":"eval_expr tge e le m (Ecast a tto) v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) tto m = Some v2)","proofString":"econstructor; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) tto m = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m (make_cast a tto) v2.","conclusion":"eval_expr tge e le m (make_cast a tto) v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) tto m = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"unfold sem_cast, make_cast in *.\ndestruct (classify_cast (typeof a) tto); auto.\ndestruct v1; destruct Archi.ptr64; inv H0; auto.\ndestruct sz2; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto.\ndestruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto.\ninv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match classify_cast (typeof a) tto with\n| cast_case_pointer =>\n    match v1 with\n    | Vint _ => if Archi.ptr64 then None else Some v1\n    | Vlong _ => if Archi.ptr64 then Some v1 else None\n    | Vptr _ _ => Some v1\n    | _ => None\n    end\n| cast_case_i2i sz2 si2 =>\n    match v1 with\n    | Vint i => Some (Vint (cast_int_int sz2 si2 i))\n    | _ => None\n    end\n| cast_case_f2f =>\n    match v1 with\n    | Vfloat f => Some (Vfloat f)\n    | _ => None\n    end\n| cast_case_s2s =>\n    match v1 with\n    | Vsingle f => Some (Vsingle f)\n    | _ => None\n    end\n| cast_case_f2s =>\n    match v1 with\n    | Vfloat f => Some (Vsingle (Float.to_single f))\n    | _ => None\n    end\n| cast_case_s2f =>\n    match v1 with\n    | Vsingle f => Some (Vfloat (Float.of_single f))\n    | _ => None\n    end\n| cast_case_i2f si1 =>\n    match v1 with\n    | Vint i => Some (Vfloat (cast_int_float si1 i))\n    | _ => None\n    end\n| cast_case_i2s si1 =>\n    match v1 with\n    | Vint i => Some (Vsingle (cast_int_single si1 i))\n    | _ => None\n    end\n| cast_case_f2i sz2 si2 =>\n    match v1 with\n    | Vfloat f =>\n        match cast_float_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2i sz2 si2 =>\n    match v1 with\n    | Vsingle f =>\n        match cast_single_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_l2l => match v1 with\n                   | Vlong n => Some (Vlong n)\n                   | _ => None\n                   end\n| cast_case_i2l si =>\n    match v1 with\n    | Vint n => Some (Vlong (cast_int_long si n))\n    | _ => None\n    end\n| cast_case_l2i sz si =>\n    match v1 with\n    | Vlong n =>\n        Some (Vint (cast_int_int sz si (Int.repr (Int64.unsigned n))))\n    | _ => None\n    end\n| cast_case_l2f si1 =>\n    match v1 with\n    | Vlong i => Some (Vfloat (cast_long_float si1 i))\n    | _ => None\n    end\n| cast_case_l2s si1 =>\n    match v1 with\n    | Vlong i => Some (Vsingle (cast_long_single si1 i))\n    | _ => None\n    end\n| cast_case_f2l si2 =>\n    match v1 with\n    | Vfloat f =>\n        match cast_float_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2l si2 =>\n    match v1 with\n    | Vsingle f =>\n        match cast_single_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_i2bool =>\n    match v1 with\n    | Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_l2bool =>\n    match v1 with\n    | Vlong n =>\n        Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_f2bool =>\n    match v1 with\n    | Vfloat f =>\n        Some\n          (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))\n    | _ => None\n    end\n| cast_case_s2bool =>\n    match v1 with\n    | Vsingle f =>\n        Some\n          (Vint\n             (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))\n    | _ => None\n    end\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    match v1 with\n    | Vptr _ _ => if ident_eq id1 id2 then Some v1 else None\n    | _ => None\n    end\n| cast_case_void => Some v1\n| cast_case_default => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m\n  match classify_cast (typeof a) tto with\n  | cast_case_pointer | cast_case_i2i I32 _ | cast_case_f2f | \n    cast_case_s2s | cast_case_l2l | cast_case_struct _ _ |\n    cast_case_union _ _ | cast_case_void => a\n  | _ => Ecast a tto\n  end v2.","conclusion":"eval_expr tge e le m\n  match classify_cast (typeof a) tto with\n  | cast_case_pointer | cast_case_i2i I32 _ | cast_case_f2f | \n    cast_case_s2s | cast_case_l2l | cast_case_struct _ _ |\n    cast_case_union _ _ | cast_case_void => a\n  | _ => Ecast a tto\n  end v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match classify_cast (typeof a) tto with\n| cast_case_pointer =>\n    match v1 with\n    | Vint _ => if Archi.ptr64 then None else Some v1\n    | Vlong _ => if Archi.ptr64 then Some v1 else None\n    | Vptr _ _ => Some v1\n    | _ => None\n    end\n| cast_case_i2i sz2 si2 =>\n    match v1 with\n    | Vint i => Some (Vint (cast_int_int sz2 si2 i))\n    | _ => None\n    end\n| cast_case_f2f =>\n    match v1 with\n    | Vfloat f => Some (Vfloat f)\n    | _ => None\n    end\n| cast_case_s2s =>\n    match v1 with\n    | Vsingle f => Some (Vsingle f)\n    | _ => None\n    end\n| cast_case_f2s =>\n    match v1 with\n    | Vfloat f => Some (Vsingle (Float.to_single f))\n    | _ => None\n    end\n| cast_case_s2f =>\n    match v1 with\n    | Vsingle f => Some (Vfloat (Float.of_single f))\n    | _ => None\n    end\n| cast_case_i2f si1 =>\n    match v1 with\n    | Vint i => Some (Vfloat (cast_int_float si1 i))\n    | _ => None\n    end\n| cast_case_i2s si1 =>\n    match v1 with\n    | Vint i => Some (Vsingle (cast_int_single si1 i))\n    | _ => None\n    end\n| cast_case_f2i sz2 si2 =>\n    match v1 with\n    | Vfloat f =>\n        match cast_float_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2i sz2 si2 =>\n    match v1 with\n    | Vsingle f =>\n        match cast_single_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_l2l => match v1 with\n                   | Vlong n => Some (Vlong n)\n                   | _ => None\n                   end\n| cast_case_i2l si =>\n    match v1 with\n    | Vint n => Some (Vlong (cast_int_long si n))\n    | _ => None\n    end\n| cast_case_l2i sz si =>\n    match v1 with\n    | Vlong n =>\n        Some (Vint (cast_int_int sz si (Int.repr (Int64.unsigned n))))\n    | _ => None\n    end\n| cast_case_l2f si1 =>\n    match v1 with\n    | Vlong i => Some (Vfloat (cast_long_float si1 i))\n    | _ => None\n    end\n| cast_case_l2s si1 =>\n    match v1 with\n    | Vlong i => Some (Vsingle (cast_long_single si1 i))\n    | _ => None\n    end\n| cast_case_f2l si2 =>\n    match v1 with\n    | Vfloat f =>\n        match cast_float_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2l si2 =>\n    match v1 with\n    | Vsingle f =>\n        match cast_single_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_i2bool =>\n    match v1 with\n    | Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_l2bool =>\n    match v1 with\n    | Vlong n =>\n        Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_f2bool =>\n    match v1 with\n    | Vfloat f =>\n        Some\n          (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))\n    | _ => None\n    end\n| cast_case_s2bool =>\n    match v1 with\n    | Vsingle f =>\n        Some\n          (Vint\n             (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))\n    | _ => None\n    end\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    match v1 with\n    | Vptr _ _ => if ident_eq id1 id2 then Some v1 else None\n    | _ => None\n    end\n| cast_case_void => Some v1\n| cast_case_default => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct (classify_cast (typeof a) tto); auto.\ndestruct v1; destruct Archi.ptr64; inv H0; auto.\ndestruct sz2; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; inv H0; auto.\ndestruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto.\ndestruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto.\ninv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vint _ => if Archi.ptr64 then None else Some v1\n| Vlong _ => if Archi.ptr64 then Some v1 else None\n| Vptr _ _ => Some v1\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vint _ => if Archi.ptr64 then None else Some v1\n| Vlong _ => if Archi.ptr64 then Some v1 else None\n| Vptr _ _ => Some v1\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct v1; destruct Archi.ptr64; inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (sz2 : intsize) (si2 : signedness) (H0 : match v1 with\n| Vint i => Some (Vint (cast_int_int sz2 si2 i))\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m match sz2 with\n                     | I32 => a\n                     | _ => Ecast a tto\n                     end v2.","conclusion":"eval_expr tge e le m match sz2 with\n                     | I32 => a\n                     | _ => Ecast a tto\n                     end v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (sz2 : intsize) (si2 : signedness) (H0 : match v1 with\n| Vint i => Some (Vint (cast_int_int sz2 si2 i))\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct sz2; auto.\ndestruct v1; inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (si2 : signedness) (H0 : match v1 with\n| Vint i => Some (Vint (cast_int_int I32 si2 i))\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (si2 : signedness) (H0 : match v1 with\n| Vint i => Some (Vint (cast_int_int I32 si2 i))\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct v1; inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vfloat f => Some (Vfloat f)\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vfloat f => Some (Vfloat f)\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct v1; inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vsingle f => Some (Vsingle f)\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vsingle f => Some (Vsingle f)\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct v1; inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vlong n => Some (Vlong n)\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : match v1 with\n| Vlong n => Some (Vlong n)\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct v1; inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (id1 id2 : ident) (H0 : match v1 with\n| Vptr _ _ => if ident_eq id1 id2 then Some v1 else None\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (id1 id2 : ident) (H0 : match v1 with\n| Vptr _ _ => if ident_eq id1 id2 then Some v1 else None\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (tto : type) (v2 : val) (H : eval_expr tge e le m a (Vptr b i)) (id1 id2 : ident) (H0 : (if ident_eq id1 id2 then Some (Vptr b i) else None) = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (tto : type) (v2 : val) (H : eval_expr tge e le m a (Vptr b i)) (id1 id2 : ident) (H0 : (if ident_eq id1 id2 then Some (Vptr b i) else None) = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct (ident_eq id1 id2); inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (id1 id2 : ident) (H0 : match v1 with\n| Vptr _ _ => if ident_eq id1 id2 then Some v1 else None\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (id1 id2 : ident) (H0 : match v1 with\n| Vptr _ _ => if ident_eq id1 id2 then Some v1 else None\n| _ => None\nend = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct v1; try discriminate.\ndestruct (ident_eq id1 id2); inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (tto : type) (v2 : val) (H : eval_expr tge e le m a (Vptr b i)) (id1 id2 : ident) (H0 : (if ident_eq id1 id2 then Some (Vptr b i) else None) = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (tto : type) (v2 : val) (H : eval_expr tge e le m a (Vptr b i)) (id1 id2 : ident) (H0 : (if ident_eq id1 id2 then Some (Vptr b i) else None) = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"destruct (ident_eq id1 id2); inv H0; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : Some v1 = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2) : eval_expr tge e le m a v2.","conclusion":"eval_expr tge e le m a v2","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v1 : val) (tto : type) (v2 : val) (H : eval_expr tge e le m a v1) (H0 : Some v1 = Some v2) (DFL : eval_expr tge e le m (Ecast a tto) v2)","proofString":"inv H0; auto."},{"statement":"(m : mem) (sz : intsize) (si : signedness) (attr : Ctypes.attr) (n : int) (H : cast_int_int sz si n = n) : sem_cast (Vint n) (Tint sz si attr)\n  match sz with\n  | I32 => Tint sz si noattr\n  | _ => Tint I32 Signed noattr\n  end m = Some (Vint n).","conclusion":"sem_cast (Vint n) (Tint sz si attr)\n  match sz with\n  | I32 => Tint sz si noattr\n  | _ => Tint I32 Signed noattr\n  end m = Some (Vint n)","hypotheses":"(m : mem) (sz : intsize) (si : signedness) (attr : Ctypes.attr) (n : int) (H : cast_int_int sz si n = n)","proofString":"unfold sem_cast, classify_cast; destruct sz, Archi.ptr64; auto."},{"statement":"(m : mem) (attr : Ctypes.attr) (n : float) : sem_cast (Vfloat n) (Tfloat F64 attr) (Tfloat F64 noattr) m = Some (Vfloat n).","conclusion":"sem_cast (Vfloat n) (Tfloat F64 attr) (Tfloat F64 noattr) m = Some (Vfloat n)","hypotheses":"(m : mem) (attr : Ctypes.attr) (n : float)","proofString":"auto."},{"statement":"(m : mem) (attr : Ctypes.attr) (n : float32) : sem_cast (Vsingle n) (Tfloat F32 attr) (Tfloat F32 noattr) m =\nSome (Vsingle n).","conclusion":"sem_cast (Vsingle n) (Tfloat F32 attr) (Tfloat F32 noattr) m =\nSome (Vsingle n)","hypotheses":"(m : mem) (attr : Ctypes.attr) (n : float32)","proofString":"auto."},{"statement":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int64) : sem_cast (Vlong n) (Tlong si attr) (Tlong si noattr) m = Some (Vlong n).","conclusion":"sem_cast (Vlong n) (Tlong si attr) (Tlong si noattr) m = Some (Vlong n)","hypotheses":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int64)","proofString":"unfold sem_cast, classify_cast; destruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (ty : type) (attr : Ctypes.attr) : sem_cast (Vptr b ofs) (Tpointer ty attr) (Tpointer ty noattr) m =\nSome (Vptr b ofs).","conclusion":"sem_cast (Vptr b ofs) (Tpointer ty attr) (Tpointer ty noattr) m =\nSome (Vptr b ofs)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (ty : type) (attr : Ctypes.attr)","proofString":"auto."},{"statement":"(m : mem) (n : int) (ty : type) (attr : Ctypes.attr) (H : Archi.ptr64 = false) : sem_cast (Vint n) (Tpointer ty attr) (Tpointer ty noattr) m = Some (Vint n).","conclusion":"sem_cast (Vint n) (Tpointer ty attr) (Tpointer ty noattr) m = Some (Vint n)","hypotheses":"(m : mem) (n : int) (ty : type) (attr : Ctypes.attr) (H : Archi.ptr64 = false)","proofString":"unfold sem_cast; simpl; rewrite H; auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (si : signedness) (attr : Ctypes.attr) (H : Archi.ptr64 = false) : sem_cast (Vptr b ofs) (Tint I32 si attr) (Tint I32 si noattr) m =\nSome (Vptr b ofs).","conclusion":"sem_cast (Vptr b ofs) (Tint I32 si attr) (Tint I32 si noattr) m =\nSome (Vptr b ofs)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (si : signedness) (attr : Ctypes.attr) (H : Archi.ptr64 = false)","proofString":"unfold sem_cast; simpl; rewrite H; auto."},{"statement":"(m : mem) (n : int64) (ty : type) (attr : Ctypes.attr) (H : Archi.ptr64 = true) : sem_cast (Vlong n) (Tpointer ty attr) (Tpointer ty noattr) m = Some (Vlong n).","conclusion":"sem_cast (Vlong n) (Tpointer ty attr) (Tpointer ty noattr) m = Some (Vlong n)","hypotheses":"(m : mem) (n : int64) (ty : type) (attr : Ctypes.attr) (H : Archi.ptr64 = true)","proofString":"unfold sem_cast; simpl; rewrite H; auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (si : signedness) (attr : Ctypes.attr) (H : Archi.ptr64 = true) : sem_cast (Vptr b ofs) (Tlong si attr) (Tlong si noattr) m = Some (Vptr b ofs).","conclusion":"sem_cast (Vptr b ofs) (Tlong si attr) (Tlong si noattr) m = Some (Vptr b ofs)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (si : signedness) (attr : Ctypes.attr) (H : Archi.ptr64 = true)","proofString":"unfold sem_cast; simpl; rewrite H; auto."},{"statement":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : sem_cast (Vptr b ofs) (Tstruct id attr) (Tstruct id noattr) m =\nSome (Vptr b ofs).","conclusion":"sem_cast (Vptr b ofs) (Tstruct id attr) (Tstruct id noattr) m =\nSome (Vptr b ofs)","hypotheses":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs)","proofString":"unfold sem_cast; simpl.\nrewrite dec_eq_true; auto."},{"statement":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : (if ident_eq id id then Some (Vptr b ofs) else None) = Some (Vptr b ofs).","conclusion":"(if ident_eq id id then Some (Vptr b ofs) else None) = Some (Vptr b ofs)","hypotheses":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs)","proofString":"rewrite dec_eq_true; auto."},{"statement":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : sem_cast (Vptr b ofs) (Tunion id attr) (Tunion id noattr) m =\nSome (Vptr b ofs).","conclusion":"sem_cast (Vptr b ofs) (Tunion id attr) (Tunion id noattr) m =\nSome (Vptr b ofs)","hypotheses":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs)","proofString":"unfold sem_cast.\nsimpl.\nrewrite dec_eq_true; auto."},{"statement":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : match classify_cast (Tunion id attr) (Tunion id noattr) with\n| cast_case_i2bool =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_l2bool =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    if ident_eq id1 id2 then Some (Vptr b ofs) else None\n| cast_case_pointer | cast_case_void => Some (Vptr b ofs)\n| _ => None\nend = Some (Vptr b ofs).","conclusion":"match classify_cast (Tunion id attr) (Tunion id noattr) with\n| cast_case_i2bool =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_l2bool =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    if ident_eq id1 id2 then Some (Vptr b ofs) else None\n| cast_case_pointer | cast_case_void => Some (Vptr b ofs)\n| _ => None\nend = Some (Vptr b ofs)","hypotheses":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs)","proofString":"simpl.\nrewrite dec_eq_true; auto."},{"statement":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : (if ident_eq id id then Some (Vptr b ofs) else None) = Some (Vptr b ofs).","conclusion":"(if ident_eq id id then Some (Vptr b ofs) else None) = Some (Vptr b ofs)","hypotheses":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs)","proofString":"rewrite dec_eq_true; auto."},{"statement":"(m : mem) (v : val) : sem_cast v Tvoid Tvoid m = Some v.","conclusion":"sem_cast v Tvoid Tvoid m = Some v","hypotheses":"(m : mem) (v : val)","proofString":"auto."},{"statement":"(f : function) (id : positive) (ty : type) (k : cont) (e : env) (le : PTree.tree val) (m : mem) (v : val) (H : le ! id = Some v) (H0 : val_casted v ty) : step2 tge (State f (Sdebug_temp id ty) k e le m) E0 (State f Sskip k e le m).","conclusion":"step2 tge (State f (Sdebug_temp id ty) k e le m) E0 (State f Sskip k e le m)","hypotheses":"(f : function) (id : positive) (ty : type) (k : cont) (e : env) (le : PTree.tree val) (m : mem) (v : val) (H : le ! id = Some v) (H0 : val_casted v ty)","proofString":"unfold Sdebug_temp.\neapply step_builtin with (optid := None).\neconstructor.\nconstructor.\neauto.\nsimpl.\neapply cast_typeconv; eauto.\nconstructor.\nsimpl.\nconstructor."},{"statement":"(f : function) (id : positive) (ty : type) (k : cont) (e : env) (le : PTree.tree val) (m : mem) (v : val) (H : le ! id = Some v) (H0 : val_casted v ty) : step2 tge\n  (State f\n     (Sbuiltin None (EF_debug 2 id (typ_of_type ty :: nil))\n        (typeconv ty :: nil) (Etempvar id ty :: nil)) k e le m) E0\n  (State f Sskip k e le m).","conclusion":"step2 tge\n  (State f\n     (Sbuiltin None (EF_debug 2 id (typ_of_type ty :: nil))\n        (typeconv ty :: nil) (Etempvar id ty :: nil)) k e le m) E0\n  (State f Sskip k e le m)","hypotheses":"(f : function) (id : positive) (ty : type) (k : cont) (e : env) (le : PTree.tree val) (m : mem) (v : val) (H : le ! id = Some v) (H0 : val_casted v ty)","proofString":"eapply step_builtin with (optid := None).\neconstructor.\nconstructor.\neauto.\nsimpl.\neapply cast_typeconv; eauto.\nconstructor.\nsimpl.\nconstructor."},{"statement":"(f : function) (id : positive) (ty : type) (k : cont) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (b : block) (H : e ! id = Some (b, ty)) : step2 tge (State f (Sdebug_var id ty) k e le m) E0 (State f Sskip k e le m).","conclusion":"step2 tge (State f (Sdebug_var id ty) k e le m) E0 (State f Sskip k e le m)","hypotheses":"(f : function) (id : positive) (ty : type) (k : cont) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (b : block) (H : e ! id = Some (b, ty))","proofString":"unfold Sdebug_var.\neapply step_builtin with (optid := None).\neconstructor.\nconstructor.\nconstructor.\neauto.\nsimpl.\nreflexivity.\nconstructor.\nsimpl.\nconstructor."},{"statement":"(f : function) (id : positive) (ty : type) (k : cont) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (b : block) (H : e ! id = Some (b, ty)) : step2 tge\n  (State f\n     (Sbuiltin None (EF_debug 5 id (Tptr :: nil)) \n        (Tpointer ty noattr :: nil)\n        (Eaddrof (Evar id ty) (Tpointer ty noattr) :: nil)) k e le m) E0\n  (State f Sskip k e le m).","conclusion":"step2 tge\n  (State f\n     (Sbuiltin None (EF_debug 5 id (Tptr :: nil)) \n        (Tpointer ty noattr :: nil)\n        (Eaddrof (Evar id ty) (Tpointer ty noattr) :: nil)) k e le m) E0\n  (State f Sskip k e le m)","hypotheses":"(f : function) (id : positive) (ty : type) (k : cont) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (b : block) (H : e ! id = Some (b, ty))","proofString":"eapply step_builtin with (optid := None).\neconstructor.\nconstructor.\nconstructor.\neauto.\nsimpl.\nreflexivity.\nconstructor.\nsimpl.\nconstructor."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') : plus step2 tge\n  (State f\n     (if Compopts.debug tt\n      then Ssequence (Sset id (make_cast a ty)) (Sdebug_temp id ty)\n      else Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m).","conclusion":"plus step2 tge\n  (State f\n     (if Compopts.debug tt\n      then Ssequence (Sset id (make_cast a ty)) (Sdebug_temp id ty)\n      else Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m)","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v')","proofString":"assert (forall k, step2 tge (State f (Sset id (make_cast a ty)) k e le m)                           E0 (State f Sskip k e (PTree.set id v' le) m)).\nintros.\napply step_set.\neapply make_cast_correct; eauto.\ndestruct (Compopts.debug tt).\neapply plus_left.\nconstructor.\neapply star_left.\napply H1.\neapply star_left.\nconstructor.\napply star_one.\napply step_Sdebug_temp with (v := v').\napply PTree.gss.\neapply cast_val_is_casted; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\napply plus_one.\napply H1."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m).","conclusion":"forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v')","proofString":"intros.\napply step_set.\neapply make_cast_correct; eauto."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (k0 : cont) : step2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m).","conclusion":"step2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (k0 : cont)","proofString":"apply step_set.\neapply make_cast_correct; eauto."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (k0 : cont) : eval_expr tge e le m (make_cast a ty) v'.","conclusion":"eval_expr tge e le m (make_cast a ty) v'","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (k0 : cont)","proofString":"eapply make_cast_correct; eauto."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)) : plus step2 tge\n  (State f\n     (if Compopts.debug tt\n      then Ssequence (Sset id (make_cast a ty)) (Sdebug_temp id ty)\n      else Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m).","conclusion":"plus step2 tge\n  (State f\n     (if Compopts.debug tt\n      then Ssequence (Sset id (make_cast a ty)) (Sdebug_temp id ty)\n      else Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m)","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m))","proofString":"destruct (Compopts.debug tt).\neapply plus_left.\nconstructor.\neapply star_left.\napply H1.\neapply star_left.\nconstructor.\napply star_one.\napply step_Sdebug_temp with (v := v').\napply PTree.gss.\neapply cast_val_is_casted; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\napply plus_one.\napply H1."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)) : plus step2 tge\n  (State f (Ssequence (Sset id (make_cast a ty)) (Sdebug_temp id ty)) k e le\n     m) E0 (State f Sskip k e (PTree.set id v' le) m).","conclusion":"plus step2 tge\n  (State f (Ssequence (Sset id (make_cast a ty)) (Sdebug_temp id ty)) k e le\n     m) E0 (State f Sskip k e (PTree.set id v' le) m)","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m))","proofString":"eapply plus_left.\nconstructor.\neapply star_left.\napply H1.\neapply star_left.\nconstructor.\napply star_one.\napply step_Sdebug_temp with (v := v').\napply PTree.gss.\neapply cast_val_is_casted; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)) : (PTree.set id v' le) ! id = Some v'.","conclusion":"(PTree.set id v' le) ! id = Some v'","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m))","proofString":"apply PTree.gss."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)) : val_casted v' ty.","conclusion":"val_casted v' ty","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m))","proofString":"eapply cast_val_is_casted; eauto."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)) : plus step2 tge (State f (Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m).","conclusion":"plus step2 tge (State f (Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m)","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m))","proofString":"apply plus_one.\napply H1."},{"statement":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m)) : step2 tge (State f (Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m).","conclusion":"step2 tge (State f (Sset id (make_cast a ty)) k e le m) E0\n  (State f Sskip k e (PTree.set id v' le) m)","hypotheses":"(f : function) (id : ident) (ty : type) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (H : eval_expr tge e le m a v) (H0 : sem_cast v (typeof a) ty m = Some v') (H1 : forall k0 : cont,\nstep2 tge (State f (Sset id (make_cast a ty)) k0 e le m) E0\n  (State f Sskip k0 e (PTree.set id v' le) m))","proofString":"apply H1."},{"statement":"forall (f : function) (s : statement) (e : PTree.tree (block * type))\n  (le : temp_env) (m : mem) (vars : list (positive * type)) \n  (k : cont),\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge\n  (State f (if Compopts.debug tt then fold_right add_debug_var s vars else s)\n     k e le m) E0 (State f s k e le m).","conclusion":"forall (f : function) (s : statement) (e : PTree.tree (block * type))\n  (le : temp_env) (m : mem) (vars : list (positive * type)) \n  (k : cont),\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge\n  (State f (if Compopts.debug tt then fold_right add_debug_var s vars else s)\n     k e le m) E0 (State f s k e le m)","hypotheses":"","proofString":"destruct (Compopts.debug tt).\ninduction vars; simpl; intros.\napply star_refl.\ndestruct a as [id ty].\nexploit H; eauto.\nintros (b & TE).\nsimpl.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_var; eauto.\neapply star_left.\nconstructor.\napply IHvars; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\nintros.\napply star_refl."},{"statement":"forall (f : function) (s : statement) (e : PTree.tree (block * type))\n  (le : temp_env) (m : mem) (vars : list (positive * type)) \n  (k : cont),\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k e le m) E0\n  (State f s k e le m).","conclusion":"forall (f : function) (s : statement) (e : PTree.tree (block * type))\n  (le : temp_env) (m : mem) (vars : list (positive * type)) \n  (k : cont),\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k e le m) E0\n  (State f s k e le m)","hypotheses":"","proofString":"induction vars; simpl; intros.\napply star_refl.\ndestruct a as [id ty].\nexploit H; eauto.\nintros (b & TE).\nsimpl.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_var; eauto.\neapply star_left.\nconstructor.\napply IHvars; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (k : cont) (H : forall (id : positive) (ty : type),\nFalse -> exists b : block, e ! id = Some (b, ty)) : star step2 tge (State f s k e le m) E0 (State f s k e le m).","conclusion":"star step2 tge (State f s k e le m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (k : cont) (H : forall (id : positive) (ty : type),\nFalse -> exists b : block, e ! id = Some (b, ty))","proofString":"apply star_refl."},{"statement":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (a : positive * type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id : positive) (ty : type),\na = (id, ty) \\/ In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) : star step2 tge\n  (State f (add_debug_var a (fold_right add_debug_var s vars)) k e le m) E0\n  (State f s k e le m).","conclusion":"star step2 tge\n  (State f (add_debug_var a (fold_right add_debug_var s vars)) k e le m) E0\n  (State f s k e le m)","hypotheses":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (a : positive * type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id : positive) (ty : type),\na = (id, ty) \\/ In (id, ty) vars -> exists b : block, e ! id = Some (b, ty))","proofString":"destruct a as [id ty].\nexploit H; eauto.\nintros (b & TE).\nsimpl.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_var; eauto.\neapply star_left.\nconstructor.\napply IHvars; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b : block, e ! id0 = Some (b, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block, e ! id0 = Some (b, ty0)) : star step2 tge\n  (State f (add_debug_var (id, ty) (fold_right add_debug_var s vars)) k e le\n     m) E0 (State f s k e le m).","conclusion":"star step2 tge\n  (State f (add_debug_var (id, ty) (fold_right add_debug_var s vars)) k e le\n     m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b : block, e ! id0 = Some (b, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block, e ! id0 = Some (b, ty0))","proofString":"exploit H; eauto.\nintros (b & TE).\nsimpl.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_var; eauto.\neapply star_left.\nconstructor.\napply IHvars; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b : block, e ! id0 = Some (b, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block, e ! id0 = Some (b, ty0)) : (exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge\n  (State f (add_debug_var (id, ty) (fold_right add_debug_var s vars)) k e le\n     m) E0 (State f s k e le m).","conclusion":"(exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge\n  (State f (add_debug_var (id, ty) (fold_right add_debug_var s vars)) k e le\n     m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b : block, e ! id0 = Some (b, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block, e ! id0 = Some (b, ty0))","proofString":"intros (b & TE).\nsimpl.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_var; eauto.\neapply star_left.\nconstructor.\napply IHvars; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b0 : block, e ! id0 = Some (b0, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b0 : block, e ! id0 = Some (b0, ty0)) (b : block) (TE : e ! id = Some (b, ty)) : star step2 tge\n  (State f (add_debug_var (id, ty) (fold_right add_debug_var s vars)) k e le\n     m) E0 (State f s k e le m).","conclusion":"star step2 tge\n  (State f (add_debug_var (id, ty) (fold_right add_debug_var s vars)) k e le\n     m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b0 : block, e ! id0 = Some (b0, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b0 : block, e ! id0 = Some (b0, ty0)) (b : block) (TE : e ! id = Some (b, ty))","proofString":"simpl.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_var; eauto.\neapply star_left.\nconstructor.\napply IHvars; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b0 : block, e ! id0 = Some (b0, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b0 : block, e ! id0 = Some (b0, ty0)) (b : block) (TE : e ! id = Some (b, ty)) : star step2 tge\n  (State f (Ssequence (Sdebug_var id ty) (fold_right add_debug_var s vars)) k\n     e le m) E0 (State f s k e le m).","conclusion":"star step2 tge\n  (State f (Ssequence (Sdebug_var id ty) (fold_right add_debug_var s vars)) k\n     e le m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (id : positive) (ty : type) (vars : list (positive * type)) (IHvars : forall k0 : cont,\n(forall (id0 : positive) (ty0 : type),\n In (id0, ty0) vars -> exists b0 : block, e ! id0 = Some (b0, ty0)) ->\nstar step2 tge (State f (fold_right add_debug_var s vars) k0 e le m) E0\n  (State f s k0 e le m)) (k : cont) (H : forall (id0 : positive) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b0 : block, e ! id0 = Some (b0, ty0)) (b : block) (TE : e ! id = Some (b, ty))","proofString":"eapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_var; eauto.\neapply star_left.\nconstructor.\napply IHvars; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"forall (f : function) (s : statement) (e : PTree.tree (block * type))\n  (le : temp_env) (m : mem) (vars : list (positive * type)) \n  (k : cont),\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge (State f s k e le m) E0 (State f s k e le m).","conclusion":"forall (f : function) (s : statement) (e : PTree.tree (block * type))\n  (le : temp_env) (m : mem) (vars : list (positive * type)) \n  (k : cont),\n(forall (id : positive) (ty : type),\n In (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) ->\nstar step2 tge (State f s k e le m) E0 (State f s k e le m)","hypotheses":"","proofString":"intros.\napply star_refl."},{"statement":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (vars : list (positive * type)) (k : cont) (H : forall (id : positive) (ty : type),\nIn (id, ty) vars -> exists b : block, e ! id = Some (b, ty)) : star step2 tge (State f s k e le m) E0 (State f s k e le m).","conclusion":"star step2 tge (State f s k e le m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (e : PTree.tree (block * type)) (le : temp_env) (m : mem) (vars : list (positive * type)) (k : cont) (H : forall (id : positive) (ty : type),\nIn (id, ty) vars -> exists b : block, e ! id = Some (b, ty))","proofString":"apply star_refl."},{"statement":"(id : ident) (args : list val) (le le' : temp_env) (H : match args with\n| nil => Some le\n| _ :: _ => None\nend = Some le') (H0 : ~ False) : le' ! id = le ! id.","conclusion":"le' ! id = le ! id","hypotheses":"(id : ident) (args : list val) (le le' : temp_env) (H : match args with\n| nil => Some le\n| _ :: _ => None\nend = Some le') (H0 : ~ False)","proofString":"destruct args; inv H.\nauto."},{"statement":"(id : ident) (le' : temp_env) (H0 : ~ False) : le' ! id = le' ! id.","conclusion":"le' ! id = le' ! id","hypotheses":"(id : ident) (le' : temp_env) (H0 : ~ False)","proofString":"auto."},{"statement":"(id : ident) (a : ident * type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (args : list val) (le le' : temp_env) (H : (let (id0, _) := a in\n match args with\n | nil => None\n | v :: vl => bind_parameter_temps params vl (PTree.set id0 v le)\n end) = Some le') (H0 : ~ (fst a = id \\/ In id (var_names params))) : le' ! id = le ! id.","conclusion":"le' ! id = le ! id","hypotheses":"(id : ident) (a : ident * type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (args : list val) (le le' : temp_env) (H : (let (id0, _) := a in\n match args with\n | nil => None\n | v :: vl => bind_parameter_temps params vl (PTree.set id0 v le)\n end) = Some le') (H0 : ~ (fst a = id \\/ In id (var_names params)))","proofString":"destruct a as [id1 ty1].\ndestruct args; try discriminate.\ntransitivity ((PTree.set id1 v le)!id).\neapply IHparams; eauto.\napply PTree.gso.\nintuition."},{"statement":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (args : list val) (le le' : temp_env) (H : match args with\n| nil => None\n| v :: vl => bind_parameter_temps params vl (PTree.set id1 v le)\nend = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params))) : le' ! id = le ! id.","conclusion":"le' ! id = le ! id","hypotheses":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (args : list val) (le le' : temp_env) (H : match args with\n| nil => None\n| v :: vl => bind_parameter_temps params vl (PTree.set id1 v le)\nend = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params)))","proofString":"destruct args; try discriminate.\ntransitivity ((PTree.set id1 v le)!id).\neapply IHparams; eauto.\napply PTree.gso.\nintuition."},{"statement":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params))) : le' ! id = le ! id.","conclusion":"le' ! id = le ! id","hypotheses":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params)))","proofString":"transitivity ((PTree.set id1 v le)!id).\neapply IHparams; eauto.\napply PTree.gso.\nintuition."},{"statement":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params))) : le' ! id = (PTree.set id1 v le) ! id.","conclusion":"le' ! id = (PTree.set id1 v le) ! id","hypotheses":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params)))","proofString":"eapply IHparams; eauto."},{"statement":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params))) : (PTree.set id1 v le) ! id = le ! id.","conclusion":"(PTree.set id1 v le) ! id = le ! id","hypotheses":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params)))","proofString":"apply PTree.gso.\nintuition."},{"statement":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params))) : id <> id1.","conclusion":"id <> id1","hypotheses":"(id id1 : ident) (ty1 : type) (params : list (ident * type)) (IHparams : forall (args0 : list val) (le0 le'0 : temp_env),\nbind_parameter_temps params args0 le0 = Some le'0 ->\n~ In id (var_names params) -> le'0 ! id = le0 ! id) (v : val) (args : list val) (le le' : temp_env) (H : bind_parameter_temps params args (PTree.set id1 v le) = Some le') (H0 : ~ (fst (id1, ty1) = id \\/ In id (var_names params)))","proofString":"intuition."},{"statement":"forall (f : function) (s : statement) (k : cont) (e : env) \n  (le : temp_env) (m : mem) (params : list (ident * type)) \n  (vl : list val) (le1 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le1 = Some le ->\nstar step2 tge\n  (State f\n     (if Compopts.debug tt then fold_right add_debug_param s params else s) k\n     e le m) E0 (State f s k e le m).","conclusion":"forall (f : function) (s : statement) (k : cont) (e : env) \n  (le : temp_env) (m : mem) (params : list (ident * type)) \n  (vl : list val) (le1 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le1 = Some le ->\nstar step2 tge\n  (State f\n     (if Compopts.debug tt then fold_right add_debug_param s params else s) k\n     e le m) E0 (State f s k e le m)","hypotheses":"","proofString":"destruct (Compopts.debug tt).\ninduction params as [ | [id ty] params ]; simpl; intros until le1; intros NR CAST BIND; inv CAST; inv NR.\napply star_refl.\nassert (le!id = Some a1).\nerewrite bind_parameter_temps_inv by eauto.\napply PTree.gss.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_temp; eauto.\neapply star_left.\nconstructor.\neapply IHparams; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\nintros; apply star_refl."},{"statement":"forall (f : function) (s : statement) (k : cont) (e : env) \n  (le : temp_env) (m : mem) (params : list (ident * type)) \n  (vl : list val) (le1 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le1 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m).","conclusion":"forall (f : function) (s : statement) (k : cont) (e : env) \n  (le : temp_env) (m : mem) (params : list (ident * type)) \n  (vl : list val) (le1 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le1 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)","hypotheses":"","proofString":"induction params as [ | [id ty] params ]; simpl; intros until le1; intros NR CAST BIND; inv CAST; inv NR.\napply star_refl.\nassert (le!id = Some a1).\nerewrite bind_parameter_temps_inv by eauto.\napply PTree.gss.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_temp; eauto.\neapply star_left.\nconstructor.\neapply IHparams; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (le1 : temp_env) (BIND : Some le1 = Some le) : star step2 tge (State f s k e le m) E0 (State f s k e le m).","conclusion":"star step2 tge (State f s k e le m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (le1 : temp_env) (BIND : Some le1 = Some le)","proofString":"apply star_refl."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params)) : star step2 tge\n  (State f\n     (Ssequence (Sdebug_temp id ty) (fold_right add_debug_param s params)) k\n     e le m) E0 (State f s k e le m).","conclusion":"star step2 tge\n  (State f\n     (Ssequence (Sdebug_temp id ty) (fold_right add_debug_param s params)) k\n     e le m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params))","proofString":"assert (le!id = Some a1).\nerewrite bind_parameter_temps_inv by eauto.\napply PTree.gss.\neapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_temp; eauto.\neapply star_left.\nconstructor.\neapply IHparams; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params)) : le ! id = Some a1.","conclusion":"le ! id = Some a1","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params))","proofString":"erewrite bind_parameter_temps_inv by eauto.\napply PTree.gss."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params)) : (PTree.set id a1 le1) ! id = Some a1.","conclusion":"(PTree.set id a1 le1) ! id = Some a1","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params))","proofString":"apply PTree.gss."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params)) (H : le ! id = Some a1) : star step2 tge\n  (State f\n     (Ssequence (Sdebug_temp id ty) (fold_right add_debug_param s params)) k\n     e le m) E0 (State f s k e le m).","conclusion":"star step2 tge\n  (State f\n     (Ssequence (Sdebug_temp id ty) (fold_right add_debug_param s params)) k\n     e le m) E0 (State f s k e le m)","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : forall (vl : list val) (le0 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le0 = Some le ->\nstar step2 tge (State f (fold_right add_debug_param s params) k e le m) E0\n  (State f s k e le m)) (le1 : temp_env) (a1 : val) (al : list val) (BIND : bind_parameter_temps params al (PTree.set id a1 le1) = Some le) (H2 : val_casted a1 ty) (H3 : list_forall2 val_casted al (map snd params)) (H1 : ~ In id (var_names params)) (H4 : list_norepet (var_names params)) (H : le ! id = Some a1)","proofString":"eapply star_left.\nconstructor.\neapply star_left.\neapply step_Sdebug_temp; eauto.\neapply star_left.\nconstructor.\neapply IHparams; eauto.\nreflexivity.\nreflexivity.\nreflexivity."},{"statement":"forall (f : function) (s : statement) (k : cont) (e : env) \n  (le : temp_env) (m : mem) (params : list (ident * type)) \n  (vl : list val) (le1 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le1 = Some le ->\nstar step2 tge (State f s k e le m) E0 (State f s k e le m).","conclusion":"forall (f : function) (s : statement) (k : cont) (e : env) \n  (le : temp_env) (m : mem) (params : list (ident * type)) \n  (vl : list val) (le1 : temp_env),\nlist_norepet (var_names params) ->\nlist_forall2 val_casted vl (map snd params) ->\nbind_parameter_temps params vl le1 = Some le ->\nstar step2 tge (State f s k e le m) E0 (State f s k e le m)","hypotheses":"","proofString":"intros; apply star_refl."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : e ! id = Some (b, ty)) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true) : match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : e ! id = Some (b, ty)) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true)","proofString":"destruct H.\ngeneralize (me_vars0 id); intros MV; inv MV; try congruence.\nrewrite ENV in H0; inv H0.\ninv H3; try congruence.\nunfold Mem.storev in H0.\nrewrite Ptrofs.unsigned_zero in H0.\nconstructor; eauto; intros.\ndestruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nexploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : e ! id = Some (b, ty)) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true) : match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : e ! id = Some (b, ty)) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true)","proofString":"generalize (me_vars0 id); intros MV; inv MV; try congruence.\nrewrite ENV in H0; inv H0.\ninv H3; try congruence.\nunfold Mem.storev in H0.\nrewrite Ptrofs.unsigned_zero in H0.\nconstructor; eauto; intros.\ndestruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nexploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b1 : block) (ty1 : type),\ne ! id0 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id0 : positive) (b1 : block) (ty1 : type),\nte ! id0 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty1 : type),\nte ! id0 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id0 = Some (b1, ty1)) (me_flat0 : forall (id0 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id0 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id0 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : e ! id = Some (b, ty)) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true) (b0 : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b0, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b0 = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b0 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) : match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b1 : block) (ty1 : type),\ne ! id0 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id0 : positive) (b1 : block) (ty1 : type),\nte ! id0 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty1 : type),\nte ! id0 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id0 = Some (b1, ty1)) (me_flat0 : forall (id0 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id0 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id0 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : e ! id = Some (b, ty)) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true) (b0 : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b0, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b0 = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b0 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0)","proofString":"rewrite ENV in H0; inv H0.\ninv H3; try congruence.\nunfold Mem.storev in H0.\nrewrite Ptrofs.unsigned_zero in H0.\nconstructor; eauto; intros.\ndestruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nexploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) : match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H3 : assign_loc ge ty m b Ptrofs.zero Full v m') (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0)","proofString":"inv H3; try congruence.\nunfold Mem.storev in H0.\nrewrite Ptrofs.unsigned_zero in H0.\nconstructor; eauto; intros.\ndestruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nexploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.storev chunk0 m (Vptr b Ptrofs.zero) v = Some m') : match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.storev chunk0 m (Vptr b Ptrofs.zero) v = Some m')","proofString":"unfold Mem.storev in H0.\nrewrite Ptrofs.unsigned_zero in H0.\nconstructor; eauto; intros.\ndestruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nexploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b (Ptrofs.unsigned Ptrofs.zero) v = Some m') : match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b (Ptrofs.unsigned Ptrofs.zero) v = Some m')","proofString":"rewrite Ptrofs.unsigned_zero in H0.\nconstructor; eauto; intros.\ndestruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nexploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') : match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m')","proofString":"constructor; eauto; intros.\ndestruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nexploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) : match_var f cenv e m' te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m' te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident)","proofString":"destruct (peq id0 id).\nsubst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (e0 : id0 = id) : match_var f cenv e m' te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m' te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (e0 : id0 = id)","proofString":"subst id0.\neapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') : match_var f cenv e m' te (PTree.set id tv tle) id.","conclusion":"match_var f cenv e m' te (PTree.set id tv tle) id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m')","proofString":"eapply match_var_lifted with (v := v); eauto.\nexploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto.\napply PTree.gss."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') : Mem.load chunk0 m' b 0 = Some v.","conclusion":"Mem.load chunk0 m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m')","proofString":"exploit Mem.load_store_same; eauto.\nerewrite val_casted_load_result; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') : Mem.load chunk0 m' b 0 = Some (Val.load_result chunk0 v) ->\nMem.load chunk0 m' b 0 = Some v.","conclusion":"Mem.load chunk0 m' b 0 = Some (Val.load_result chunk0 v) ->\nMem.load chunk0 m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m')","proofString":"erewrite val_casted_load_result; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') : (PTree.set id tv tle) ! id = Some tv.","conclusion":"(PTree.set id tv tle) ! id = Some tv","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v1 : val),\nle ! id0 = Some v1 ->\n(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m')","proofString":"apply PTree.gss."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) : match_var f cenv e m' te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m' te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id)","proofString":"generalize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1) : match_var f cenv e m' te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m' te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1)","proofString":"eapply match_var_lifted; eauto.\nrewrite <- LOAD0.\neapply Mem.load_store_other; eauto.\nrewrite PTree.gso; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1) : Mem.load chunk1 m' b0 0 = Some v1.","conclusion":"Mem.load chunk1 m' b0 0 = Some v1","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1)","proofString":"rewrite <- LOAD0.\neapply Mem.load_store_other; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1) : Mem.load chunk1 m' b0 0 = Mem.load chunk1 m b0 0.","conclusion":"Mem.load chunk1 m' b0 0 = Mem.load chunk1 m b0 0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1)","proofString":"eapply Mem.load_store_other; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1) : (PTree.set id tv tle) ! id0 = Some tv1.","conclusion":"(PTree.set id tv tle) ! id0 = Some tv1","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty1 : type),\nte ! id1 = Some (b', ty1) ->\nexists b1 : block, f b1 = Some (b', 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b' : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b', ty1) ->\nf b1 = Some (b', delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (chunk1 : memory_chunk) (v1 tv1 : val) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = true) (MAPPED0 : f b0 = None) (MODE0 : access_mode ty0 = By_value chunk1) (LOAD0 : Mem.load chunk1 m b0 0 = Some v1) (TLENV0 : tle ! id0 = Some tv1) (VINJ0 : Val.inject f v1 tv1)","proofString":"rewrite PTree.gso; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b'0 : block) (ty1 : type),\nte ! id1 = Some (b'0, ty1) ->\nexists b1 : block, f b1 = Some (b'0, 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b'0 : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b'0, ty1) ->\nf b1 = Some (b'0, delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (b' : block) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = Some (b', ty0)) (LIFTED0 : VSet.mem id0 cenv = false) (MAPPED0 : f b0 = Some (b', 0)) : match_var f cenv e m' te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m' te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b1 : block) (ty1 : type),\ne ! id1 = Some (b1, ty1) -> Ple lo b1 /\\ Plt b1 hi) (me_trange0 : forall (id1 : positive) (b1 : block) (ty1 : type),\nte ! id1 = Some (b1, ty1) -> Ple tlo b1 /\\ Plt b1 thi) (me_mapped0 : forall (id1 : positive) (b'0 : block) (ty1 : type),\nte ! id1 = Some (b'0, ty1) ->\nexists b1 : block, f b1 = Some (b'0, 0) /\\ e ! id1 = Some (b1, ty1)) (me_flat0 : forall (id1 : positive) (b'0 : block) (ty1 : type) (b1 : block) (delta : Z),\nte ! id1 = Some (b'0, ty1) ->\nf b1 = Some (b'0, delta) -> e ! id1 = Some (b1, ty1) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (b0 : block) (ty0 : type) (b' : block) (ENV0 : e ! id0 = Some (b0, ty0)) (TENV0 : te ! id0 = Some (b', ty0)) (LIFTED0 : VSet.mem id0 cenv = false) (MAPPED0 : f b0 = Some (b', 0))","proofString":"eapply match_var_not_lifted; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (ENV0 : e ! id0 = None) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = false) : match_var f cenv e m' te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m' te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : ident) (n : id0 <> id) (ENV0 : e ! id0 = None) (TENV0 : te ! id0 = None) (LIFTED0 : VSet.mem id0 cenv = false)","proofString":"eapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v2 tv1) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) : (exists tv1 : val,\n   (PTree.set id tv tle) ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef).","conclusion":"(exists tv1 : val,\n   (PTree.set id tv tle) ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v2 tv1) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1)","proofString":"exploit me_temps0; eauto.\nintros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v2 tv1) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) : (exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef) ->\n(exists tv1 : val,\n   (PTree.set id tv tle) ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef).","conclusion":"(exists tv1 : val, tle ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef) ->\n(exists tv1 : val,\n   (PTree.set id tv tle) ! id0 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v2 tv1) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1)","proofString":"intros [[tv1 [A B]] C].\nsplit; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef) : (exists tv2 : val,\n   (PTree.set id tv tle) ! id0 = Some tv2 /\\ Val.inject f v1 tv2) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef).","conclusion":"(exists tv2 : val,\n   (PTree.set id tv tle) ! id0 = Some tv2 /\\ Val.inject f v1 tv2) /\\\n(VSet.mem id0 cenv = true -> v1 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef)","proofString":"split; auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef) : exists tv2 : val,\n  (PTree.set id tv tle) ! id0 = Some tv2 /\\ Val.inject f v1 tv2.","conclusion":"exists tv2 : val,\n  (PTree.set id tv tle) ! id0 = Some tv2 /\\ Val.inject f v1 tv2","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef)","proofString":"rewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef) : exists tv2 : val,\n  (if peq id0 id then Some tv else tle ! id0) = Some tv2 /\\\n  Val.inject f v1 tv2.","conclusion":"exists tv2 : val,\n  (if peq id0 id then Some tv else tle ! id0) = Some tv2 /\\\n  Val.inject f v1 tv2","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef)","proofString":"destruct (peq id0 id).\nsubst id0.\nexists tv; split; auto.\nrewrite C; auto.\nexists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef) (e0 : id0 = id) : exists tv2 : val, Some tv = Some tv2 /\\ Val.inject f v1 tv2.","conclusion":"exists tv2 : val, Some tv = Some tv2 /\\ Val.inject f v1 tv2","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef) (e0 : id0 = id)","proofString":"subst id0.\nexists tv; split; auto.\nrewrite C; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v2 : val),\nle ! id0 = Some v2 ->\n(exists tv2 : val, tle ! id0 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id0 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (v1 : val) (H3 : le ! id = Some v1) (tv1 : val) (A : tle ! id = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id cenv = true -> v1 = Vundef) : exists tv2 : val, Some tv = Some tv2 /\\ Val.inject f v1 tv2.","conclusion":"exists tv2 : val, Some tv = Some tv2 /\\ Val.inject f v1 tv2","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v2 : val),\nle ! id0 = Some v2 ->\n(exists tv2 : val, tle ! id0 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id0 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (v1 : val) (H3 : le ! id = Some v1) (tv1 : val) (A : tle ! id = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id cenv = true -> v1 = Vundef)","proofString":"exists tv; split; auto.\nrewrite C; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v2 : val),\nle ! id0 = Some v2 ->\n(exists tv2 : val, tle ! id0 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id0 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (v1 : val) (H3 : le ! id = Some v1) (tv1 : val) (A : tle ! id = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id cenv = true -> v1 = Vundef) : Val.inject f v1 tv.","conclusion":"Val.inject f v1 tv","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v2 : val),\nle ! id0 = Some v2 ->\n(exists tv2 : val, tle ! id0 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id0 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (v1 : val) (H3 : le ! id = Some v1) (tv1 : val) (A : tle ! id = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id cenv = true -> v1 = Vundef)","proofString":"rewrite C; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef) (n : id0 <> id) : exists tv2 : val, tle ! id0 = Some tv2 /\\ Val.inject f v1 tv2.","conclusion":"exists tv2 : val, tle ! id0 = Some tv2 /\\ Val.inject f v1 tv2","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi b : block) (ty : type) (v : val) (m' : mem) (id : positive) (tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v2 : val),\nle ! id1 = Some v2 ->\n(exists tv2 : val, tle ! id1 = Some tv2 /\\ Val.inject f v2 tv2) /\\\n(VSet.mem id1 cenv = true -> v2 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H1 : val_casted v ty) (H2 : Val.inject f v tv) (H4 : VSet.mem id cenv = true) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject f v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H0 : Mem.store chunk0 m b 0 v = Some m') (id0 : positive) (v1 : val) (H3 : le ! id0 = Some v1) (tv1 : val) (A : tle ! id0 = Some tv1) (B : Val.inject f v1 tv1) (C : VSet.mem id0 cenv = true -> v1 = Vundef) (n : id0 <> id)","proofString":"exists tv1; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_temp cenv id = OK x) : match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_temp cenv id = OK x)","proofString":"unfold check_temp in H1.\ndestruct (VSet.mem id cenv) eqn:?; monadInv H1.\ndestruct H.\nconstructor; eauto; intros.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso.\neauto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite PTree.gsspec in *.\ndestruct (peq id0 id).\ninv H.\nsplit.\nexists tv; auto.\nintros; congruence.\neapply me_temps0; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : (if VSet.mem id cenv\n then Error (MSG \"bad temporary \" :: CTX id :: nil)\n else OK tt) = OK x) : match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : (if VSet.mem id cenv\n then Error (MSG \"bad temporary \" :: CTX id :: nil)\n else OK tt) = OK x)","proofString":"destruct (VSet.mem id cenv) eqn:?; monadInv H1.\ndestruct H.\nconstructor; eauto; intros.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso.\neauto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite PTree.gsspec in *.\ndestruct (peq id0 id).\ninv H.\nsplit.\nexists tv; auto.\nintros; congruence.\neapply me_temps0; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) : match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false)","proofString":"destruct H.\nconstructor; eauto; intros.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso.\neauto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite PTree.gsspec in *.\ndestruct (peq id0 id).\ninv H.\nsplit.\nexists tv; auto.\nintros; congruence.\neapply me_temps0; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) : match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi.","conclusion":"match_envs f cenv e (PTree.set id v le) m lo hi te \n  (PTree.set id tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false)","proofString":"constructor; eauto; intros.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso.\neauto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite PTree.gsspec in *.\ndestruct (peq id0 id).\ninv H.\nsplit.\nexists tv; auto.\nintros; congruence.\neapply me_temps0; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) : match_var f cenv e m te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident)","proofString":"generalize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso.\neauto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0) : match_var f cenv e m te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0)","proofString":"eapply match_var_lifted; eauto.\nrewrite PTree.gso.\neauto.\ncongruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0) : (PTree.set id tv tle) ! id0 = Some tv0.","conclusion":"(PTree.set id tv tle) ! id0 = Some tv0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0)","proofString":"rewrite PTree.gso.\neauto.\ncongruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0) : tle ! id0 = Some tv0.","conclusion":"tle ! id0 = Some tv0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0)","proofString":"eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0) : id0 <> id.","conclusion":"id0 <> id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv1 : val, tle ! id1 = Some tv1 /\\ Val.inject f v1 tv1) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv0) (VINJ : Val.inject f v0 tv0)","proofString":"congruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b'0 : block) (ty0 : type),\nte ! id1 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = Some (b', ty)) (LIFTED : VSet.mem id0 cenv = false) (MAPPED : f b = Some (b', 0)) : match_var f cenv e m te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b'0 : block) (ty0 : type),\nte ! id1 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = Some (b', ty)) (LIFTED : VSet.mem id0 cenv = false) (MAPPED : f b = Some (b', 0))","proofString":"eapply match_var_not_lifted; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (ENV : e ! id0 = None) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = false) : match_var f cenv e m te (PTree.set id tv tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id tv tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : ident) (ENV : e ! id0 = None) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = false)","proofString":"eapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : (PTree.set id v le) ! id0 = Some v0) : (exists tv0 : val,\n   (PTree.set id tv tle) ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef).","conclusion":"(exists tv0 : val,\n   (PTree.set id tv tle) ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : (PTree.set id v le) ! id0 = Some v0)","proofString":"rewrite PTree.gsspec in *.\ndestruct (peq id0 id).\ninv H.\nsplit.\nexists tv; auto.\nintros; congruence.\neapply me_temps0; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : (if peq id0 id then Some v else le ! id0) = Some v0) : (exists tv0 : val,\n   (if peq id0 id then Some tv else tle ! id0) = Some tv0 /\\\n   Val.inject f v0 tv0) /\\ (VSet.mem id0 cenv = true -> v0 = Vundef).","conclusion":"(exists tv0 : val,\n   (if peq id0 id then Some tv else tle ! id0) = Some tv0 /\\\n   Val.inject f v0 tv0) /\\ (VSet.mem id0 cenv = true -> v0 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : (if peq id0 id then Some v else le ! id0) = Some v0)","proofString":"destruct (peq id0 id).\ninv H.\nsplit.\nexists tv; auto.\nintros; congruence.\neapply me_temps0; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (e0 : id0 = id) (H : Some v = Some v0) : (exists tv0 : val, Some tv = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef).","conclusion":"(exists tv0 : val, Some tv = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (e0 : id0 = id) (H : Some v = Some v0)","proofString":"inv H.\nsplit.\nexists tv; auto.\nintros; congruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v tv0) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (v0 : val) (H0 : Val.inject f v0 tv) (Heqb : VSet.mem id cenv = false) : (exists tv0 : val, Some tv = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id cenv = true -> v0 = Vundef).","conclusion":"(exists tv0 : val, Some tv = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id cenv = true -> v0 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v tv0) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (v0 : val) (H0 : Val.inject f v0 tv) (Heqb : VSet.mem id cenv = false)","proofString":"split.\nexists tv; auto.\nintros; congruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v tv0) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (v0 : val) (H0 : Val.inject f v0 tv) (Heqb : VSet.mem id cenv = false) : exists tv0 : val, Some tv = Some tv0 /\\ Val.inject f v0 tv0.","conclusion":"exists tv0 : val, Some tv = Some tv0 /\\ Val.inject f v0 tv0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v tv0) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (v0 : val) (H0 : Val.inject f v0 tv) (Heqb : VSet.mem id cenv = false)","proofString":"exists tv; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v tv0) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (v0 : val) (H0 : Val.inject f v0 tv) (Heqb : VSet.mem id cenv = false) : VSet.mem id cenv = true -> v0 = Vundef.","conclusion":"VSet.mem id cenv = true -> v0 = Vundef","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (tv : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v tv0) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (v0 : val) (H0 : Val.inject f v0 tv) (Heqb : VSet.mem id cenv = false)","proofString":"intros; congruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (n : id0 <> id) (H : le ! id0 = Some v0) : (exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef).","conclusion":"(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : ident) (v tv : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : Val.inject f v tv) (Heqb : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (n : id0 <> id) (H : le ! id0 = Some v0)","proofString":"eapply me_temps0; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (optid : option ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_opttemp cenv optid = OK x) : match_envs f cenv e (set_opttemp optid v le) m lo hi te\n  (set_opttemp optid tv tle) tlo thi.","conclusion":"match_envs f cenv e (set_opttemp optid v le) m lo hi te\n  (set_opttemp optid tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (optid : option ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_opttemp cenv optid = OK x)","proofString":"unfold set_opttemp.\ndestruct optid; simpl in H1.\neapply match_envs_set_temp; eauto.\nauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (optid : option ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_opttemp cenv optid = OK x) : match_envs f cenv e\n  match optid with\n  | Some id => PTree.set id v le\n  | None => le\n  end m lo hi te\n  match optid with\n  | Some id => PTree.set id tv tle\n  | None => tle\n  end tlo thi.","conclusion":"match_envs f cenv e\n  match optid with\n  | Some id => PTree.set id v le\n  | None => le\n  end m lo hi te\n  match optid with\n  | Some id => PTree.set id tv tle\n  | None => tle\n  end tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (optid : option ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_opttemp cenv optid = OK x)","proofString":"destruct optid; simpl in H1.\neapply match_envs_set_temp; eauto.\nauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (i : ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_temp cenv i = OK x) : match_envs f cenv e (PTree.set i v le) m lo hi te \n  (PTree.set i tv tle) tlo thi.","conclusion":"match_envs f cenv e (PTree.set i v le) m lo hi te \n  (PTree.set i tv tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (i : ident) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : check_temp cenv i = OK x)","proofString":"eapply match_envs_set_temp; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : OK tt = OK x) : match_envs f cenv e le m lo hi te tle tlo thi.","conclusion":"match_envs f cenv e le m lo hi te tle tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (v tv : val) (x : unit) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : Val.inject f v tv) (H1 : OK tt = OK x)","proofString":"auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : forall id : positive, tle' ! id = tle ! id) : match_envs f cenv e le m lo hi te tle' tlo thi.","conclusion":"match_envs f cenv e le m lo hi te tle' tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : forall id : positive, tle' ! id = tle ! id)","proofString":"destruct H.\nconstructor; auto; intros.\ngeneralize (me_vars0 id); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite H0; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite H0.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id : positive, tle' ! id = tle ! id) : match_envs f cenv e le m lo hi te tle' tlo thi.","conclusion":"match_envs f cenv e le m lo hi te tle' tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id : ident, match_var f cenv e m te tle id) (me_temps0 : forall (id : positive) (v : val),\nle ! id = Some v ->\n(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id : positive) (b : block) (ty : type),\nte ! id = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id : positive) (b' : block) (ty : type),\nte ! id = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id = Some (b, ty)) (me_flat0 : forall (id : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id : positive, tle' ! id = tle ! id)","proofString":"constructor; auto; intros.\ngeneralize (me_vars0 id); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite H0; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite H0.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) : match_var f cenv e m te tle' id.","conclusion":"match_var f cenv e m te tle' id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident)","proofString":"generalize (me_vars0 id); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite H0; auto.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv) : match_var f cenv e m te tle' id.","conclusion":"match_var f cenv e m te tle' id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv)","proofString":"eapply match_var_lifted; eauto.\nrewrite H0; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv) : tle' ! id = Some tv.","conclusion":"tle' ! id = Some tv","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv0 : val, tle ! id0 = Some tv0 /\\ Val.inject f v0 tv0) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty0 : type),\nte ! id0 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (b : block) (ty : type) (chunk : memory_chunk) (v tv : val) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v) (TLENV : tle ! id = Some tv) (VINJ : Val.inject f v tv)","proofString":"rewrite H0; auto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = Some (b', ty)) (LIFTED : VSet.mem id cenv = false) (MAPPED : f b = Some (b', 0)) : match_var f cenv e m te tle' id.","conclusion":"match_var f cenv e m te tle' id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id0 : positive) (b0 : block) (ty0 : type),\nte ! id0 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id0 : positive) (b'0 : block) (ty0 : type),\nte ! id0 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id0 = Some (b0, ty0)) (me_flat0 : forall (id0 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id0 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id0 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id = Some (b, ty)) (TENV : te ! id = Some (b', ty)) (LIFTED : VSet.mem id cenv = false) (MAPPED : f b = Some (b', 0))","proofString":"eapply match_var_not_lifted; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (ENV : e ! id = None) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = false) : match_var f cenv e m te tle' id.","conclusion":"match_var f cenv e m te tle' id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v : val),\nle ! id0 = Some v ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id0 cenv = true -> v = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : ident) (ENV : e ! id = None) (TENV : te ! id = None) (LIFTED : VSet.mem id cenv = false)","proofString":"eapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : positive) (v : val) (H : le ! id = Some v) : (exists tv : val, tle' ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef).","conclusion":"(exists tv : val, tle' ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : positive) (v : val) (H : le ! id = Some v)","proofString":"rewrite H0.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : positive) (v : val) (H : le ! id = Some v) : (exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef).","conclusion":"(exists tv : val, tle ! id = Some tv /\\ Val.inject f v tv) /\\\n(VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tle' : PTree.tree val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : forall id0 : positive, tle' ! id0 = tle ! id0) (id : positive) (v : val) (H : le ! id = Some v)","proofString":"eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) : match_envs f cenv e le m lo hi te (PTree.set id v tle) tlo thi.","conclusion":"match_envs f cenv e le m lo hi te (PTree.set id v tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false)","proofString":"destruct H.\nconstructor; auto; intros.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso; auto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite PTree.gso.\neauto.\ncongruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) : match_envs f cenv e le m lo hi te (PTree.set id v tle) tlo thi.","conclusion":"match_envs f cenv e le m lo hi te (PTree.set id v tle) tlo thi","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id0 : ident, match_var f cenv e m te tle id0) (me_temps0 : forall (id0 : positive) (v0 : val),\nle ! id0 = Some v0 ->\n(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id0 : positive) (b : block) (ty : type),\nte ! id0 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id0 : positive) (b' : block) (ty : type),\nte ! id0 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id0 = Some (b, ty)) (me_flat0 : forall (id0 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id0 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id0 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false)","proofString":"constructor; auto; intros.\ngeneralize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso; auto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto.\nrewrite PTree.gso.\neauto.\ncongruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) : match_var f cenv e m te (PTree.set id v tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id v tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident)","proofString":"generalize (me_vars0 id0); intros MV; inv MV.\neapply match_var_lifted; eauto.\nrewrite PTree.gso; auto.\ncongruence.\neapply match_var_not_lifted; eauto.\neapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv) (VINJ : Val.inject f v0 tv) : match_var f cenv e m te (PTree.set id v tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id v tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv) (VINJ : Val.inject f v0 tv)","proofString":"eapply match_var_lifted; eauto.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv) (VINJ : Val.inject f v0 tv) : (PTree.set id v tle) ! id0 = Some tv.","conclusion":"(PTree.set id v tle) ! id0 = Some tv","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv) (VINJ : Val.inject f v0 tv)","proofString":"rewrite PTree.gso; auto.\ncongruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv) (VINJ : Val.inject f v0 tv) : id0 <> id.","conclusion":"id0 <> id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv0 : val, tle ! id1 = Some tv0 /\\ Val.inject f v1 tv0) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty0 : type),\nte ! id1 = Some (b', ty0) ->\nexists b0 : block, f b0 = Some (b', 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b' : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b', ty0) ->\nf b0 = Some (b', delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (chunk : memory_chunk) (v0 tv : val) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = true) (MAPPED : f b = None) (MODE : access_mode ty = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id0 = Some tv) (VINJ : Val.inject f v0 tv)","proofString":"congruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b'0 : block) (ty0 : type),\nte ! id1 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = Some (b', ty)) (LIFTED : VSet.mem id0 cenv = false) (MAPPED : f b = Some (b', 0)) : match_var f cenv e m te (PTree.set id v tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id v tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b0 : block) (ty0 : type),\ne ! id1 = Some (b0, ty0) -> Ple lo b0 /\\ Plt b0 hi) (me_trange0 : forall (id1 : positive) (b0 : block) (ty0 : type),\nte ! id1 = Some (b0, ty0) -> Ple tlo b0 /\\ Plt b0 thi) (me_mapped0 : forall (id1 : positive) (b'0 : block) (ty0 : type),\nte ! id1 = Some (b'0, ty0) ->\nexists b0 : block, f b0 = Some (b'0, 0) /\\ e ! id1 = Some (b0, ty0)) (me_flat0 : forall (id1 : positive) (b'0 : block) (ty0 : type) (b0 : block) (delta : Z),\nte ! id1 = Some (b'0, ty0) ->\nf b0 = Some (b'0, delta) -> e ! id1 = Some (b0, ty0) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (b : block) (ty : type) (b' : block) (ENV : e ! id0 = Some (b, ty)) (TENV : te ! id0 = Some (b', ty)) (LIFTED : VSet.mem id0 cenv = false) (MAPPED : f b = Some (b', 0))","proofString":"eapply match_var_not_lifted; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (ENV : e ! id0 = None) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = false) : match_var f cenv e m te (PTree.set id v tle) id0.","conclusion":"match_var f cenv e m te (PTree.set id v tle) id0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v0 : val),\nle ! id1 = Some v0 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id1 cenv = true -> v0 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : ident) (ENV : e ! id0 = None) (TENV : te ! id0 = None) (LIFTED : VSet.mem id0 cenv = false)","proofString":"eapply match_var_not_local; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v1 tv) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : le ! id0 = Some v0) : (exists tv : val, (PTree.set id v tle) ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef).","conclusion":"(exists tv : val, (PTree.set id v tle) ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v1 tv) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : le ! id0 = Some v0)","proofString":"rewrite PTree.gso.\neauto.\ncongruence."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v1 tv) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : le ! id0 = Some v0) : (exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef).","conclusion":"(exists tv : val, tle ! id0 = Some tv /\\ Val.inject f v0 tv) /\\\n(VSet.mem id0 cenv = true -> v0 = Vundef)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v1 tv) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : le ! id0 = Some v0)","proofString":"eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v1 tv) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : le ! id0 = Some v0) : id0 <> id.","conclusion":"id0 <> id","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (id : positive) (v : val) (me_vars0 : forall id1 : ident, match_var f cenv e m te tle id1) (me_temps0 : forall (id1 : positive) (v1 : val),\nle ! id1 = Some v1 ->\n(exists tv : val, tle ! id1 = Some tv /\\ Val.inject f v1 tv) /\\\n(VSet.mem id1 cenv = true -> v1 = Vundef)) (me_inj0 : forall (id1 : positive) (b1 : block) (ty1 : type) \n  (id2 : positive) (b2 : block) (ty2 : type),\ne ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (me_range0 : forall (id1 : positive) (b : block) (ty : type),\ne ! id1 = Some (b, ty) -> Ple lo b /\\ Plt b hi) (me_trange0 : forall (id1 : positive) (b : block) (ty : type),\nte ! id1 = Some (b, ty) -> Ple tlo b /\\ Plt b thi) (me_mapped0 : forall (id1 : positive) (b' : block) (ty : type),\nte ! id1 = Some (b', ty) ->\nexists b : block, f b = Some (b', 0) /\\ e ! id1 = Some (b, ty)) (me_flat0 : forall (id1 : positive) (b' : block) (ty : type) (b : block) (delta : Z),\nte ! id1 = Some (b', ty) ->\nf b = Some (b', delta) -> e ! id1 = Some (b, ty) /\\ delta = 0) (me_incr0 : Ple lo hi) (me_tincr0 : Ple tlo thi) (H0 : le ! id = None) (H1 : VSet.mem id cenv = false) (id0 : positive) (v0 : val) (H : le ! id0 = Some v0)","proofString":"congruence."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) : VSet.In id1 (add_local_variable atk (id, ty) cenv) <->\nVSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false).","conclusion":"VSet.In id1 (add_local_variable atk (id, ty) cenv) <->\nVSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt)","proofString":"unfold add_local_variable.\nsplit; intros.\ndestruct (access_mode ty) eqn:?; auto.\ndestruct (VSet.mem id atk) eqn:?; auto.\nrewrite VSF.add_iff in H.\ndestruct H; auto.\nright; exists m; auto.\ndestruct H as [A | [chunk [A [B C]]]].\ndestruct (access_mode ty); auto.\ndestruct (VSet.mem id atk); auto.\nrewrite VSF.add_iff; auto.\nrewrite A.\nrewrite <- B.\nrewrite C.\napply VSet.add_1; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) : VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end <->\nVSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false).","conclusion":"VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end <->\nVSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt)","proofString":"split; intros.\ndestruct (access_mode ty) eqn:?; auto.\ndestruct (VSet.mem id atk) eqn:?; auto.\nrewrite VSF.add_iff in H.\ndestruct H; auto.\nright; exists m; auto.\ndestruct H as [A | [chunk [A [B C]]]].\ndestruct (access_mode ty); auto.\ndestruct (VSet.mem id atk); auto.\nrewrite VSF.add_iff; auto.\nrewrite A.\nrewrite <- B.\nrewrite C.\napply VSet.add_1; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (H : VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end) : VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false).","conclusion":"VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (H : VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end)","proofString":"destruct (access_mode ty) eqn:?; auto.\ndestruct (VSet.mem id atk) eqn:?; auto.\nrewrite VSF.add_iff in H.\ndestruct H; auto.\nright; exists m; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (H : VSet.In id1 (if VSet.mem id atk then cenv else VSet.add id cenv)) : VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false).","conclusion":"VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (H : VSet.In id1 (if VSet.mem id atk then cenv else VSet.add id cenv))","proofString":"destruct (VSet.mem id atk) eqn:?; auto.\nrewrite VSF.add_iff in H.\ndestruct H; auto.\nright; exists m; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (Heqb : VSet.mem id atk = false) (H : VSet.In id1 (VSet.add id cenv)) : VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ false = false).","conclusion":"VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ false = false)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (Heqb : VSet.mem id atk = false) (H : VSet.In id1 (VSet.add id cenv))","proofString":"rewrite VSF.add_iff in H.\ndestruct H; auto.\nright; exists m; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (Heqb : VSet.mem id atk = false) (H : id = id1 \\/ VSet.In id1 cenv) : VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ false = false).","conclusion":"VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ false = false)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (Heqb : VSet.mem id atk = false) (H : id = id1 \\/ VSet.In id1 cenv)","proofString":"destruct H; auto.\nright; exists m; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (Heqb : VSet.mem id atk = false) (H : id = id1) : VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ false = false).","conclusion":"VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   By_value m = By_value chunk /\\ id = id1 /\\ false = false)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (m : memory_chunk) (Heqm : access_mode ty = By_value m) (Heqb : VSet.mem id atk = false) (H : id = id1)","proofString":"right; exists m; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (H : VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false)) : VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end.","conclusion":"VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (H : VSet.In id1 cenv \\/\n(exists chunk : memory_chunk,\n   access_mode ty = By_value chunk /\\ id = id1 /\\ VSet.mem id atk = false))","proofString":"destruct H as [A | [chunk [A [B C]]]].\ndestruct (access_mode ty); auto.\ndestruct (VSet.mem id atk); auto.\nrewrite VSF.add_iff; auto.\nrewrite A.\nrewrite <- B.\nrewrite C.\napply VSet.add_1; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (A : VSet.In id1 cenv) : VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end.","conclusion":"VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (A : VSet.In id1 cenv)","proofString":"destruct (access_mode ty); auto.\ndestruct (VSet.mem id atk); auto.\nrewrite VSF.add_iff; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (A : VSet.In id1 cenv) (m : memory_chunk) : VSet.In id1 (if VSet.mem id atk then cenv else VSet.add id cenv).","conclusion":"VSet.In id1 (if VSet.mem id atk then cenv else VSet.add id cenv)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (A : VSet.In id1 cenv) (m : memory_chunk)","proofString":"destruct (VSet.mem id atk); auto.\nrewrite VSF.add_iff; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (A : VSet.In id1 cenv) (m : memory_chunk) : VSet.In id1 (VSet.add id cenv).","conclusion":"VSet.In id1 (VSet.add id cenv)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (A : VSet.In id1 cenv) (m : memory_chunk)","proofString":"rewrite VSF.add_iff; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false) : VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end.","conclusion":"VSet.In id1\n  match access_mode ty with\n  | By_value _ => if VSet.mem id atk then cenv else VSet.add id cenv\n  | _ => cenv\n  end","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false)","proofString":"rewrite A.\nrewrite <- B.\nrewrite C.\napply VSet.add_1; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false) : VSet.In id1 (if VSet.mem id atk then cenv else VSet.add id cenv).","conclusion":"VSet.In id1 (if VSet.mem id atk then cenv else VSet.add id cenv)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false)","proofString":"rewrite <- B.\nrewrite C.\napply VSet.add_1; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false) : VSet.In id (if VSet.mem id atk then cenv else VSet.add id cenv).","conclusion":"VSet.In id (if VSet.mem id atk then cenv else VSet.add id cenv)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false)","proofString":"rewrite C.\napply VSet.add_1; auto."},{"statement":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false) : VSet.In id (VSet.add id cenv).","conclusion":"VSet.In id (VSet.add id cenv)","hypotheses":"(id : ident) (ty : type) (atk : VSet.t) (cenv : compilenv) (id1 : VSet.elt) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (B : id = id1) (C : VSet.mem id atk = false)","proofString":"apply VSet.add_1; auto."},{"statement":"(atk : VSet.t) (id : VSet.elt) (H : VSet.In id VSet.empty) : False.","conclusion":"False","hypotheses":"(atk : VSet.t) (id : VSet.elt) (H : VSet.In id VSet.empty)","proofString":"rewrite VSF.empty_iff in H.\nauto."},{"statement":"(atk : VSet.t) (id : VSet.elt) (H : False) : False.","conclusion":"False","hypotheses":"(atk : VSet.t) (id : VSet.elt) (H : False)","proofString":"auto."},{"statement":"(atk : VSet.t) (id : VSet.elt) (a : ident * type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> In id (var_names vars)) (H : VSet.In id (add_local_variable atk a (cenv_for_gen atk vars))) : fst a = id \\/ In id (var_names vars).","conclusion":"fst a = id \\/ In id (var_names vars)","hypotheses":"(atk : VSet.t) (id : VSet.elt) (a : ident * type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> In id (var_names vars)) (H : VSet.In id (add_local_variable atk a (cenv_for_gen atk vars)))","proofString":"destruct a as [id1 ty1].\nrewrite add_local_variable_charact in H.\ndestruct H as [A | [chunk [A [B C]]]]; auto."},{"statement":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> In id (var_names vars)) (H : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars))) : fst (id1, ty1) = id \\/ In id (var_names vars).","conclusion":"fst (id1, ty1) = id \\/ In id (var_names vars)","hypotheses":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> In id (var_names vars)) (H : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars)))","proofString":"rewrite add_local_variable_charact in H.\ndestruct H as [A | [chunk [A [B C]]]]; auto."},{"statement":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> In id (var_names vars)) (H : VSet.In id (cenv_for_gen atk vars) \\/\n(exists chunk : memory_chunk,\n   access_mode ty1 = By_value chunk /\\ id1 = id /\\ VSet.mem id1 atk = false)) : fst (id1, ty1) = id \\/ In id (var_names vars).","conclusion":"fst (id1, ty1) = id \\/ In id (var_names vars)","hypotheses":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> In id (var_names vars)) (H : VSet.In id (cenv_for_gen atk vars) \\/\n(exists chunk : memory_chunk,\n   access_mode ty1 = By_value chunk /\\ id1 = id /\\ VSet.mem id1 atk = false))","proofString":"destruct H as [A | [chunk [A [B C]]]]; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (a : ident * type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : a = (id, ty) \\/ In (id, ty) vars) (H0 : list_norepet (fst a :: var_names vars)) (H1 : VSet.In id (add_local_variable atk a (cenv_for_gen atk vars))) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (a : ident * type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : a = (id, ty) \\/ In (id, ty) vars) (H0 : list_norepet (fst a :: var_names vars)) (H1 : VSet.In id (add_local_variable atk a (cenv_for_gen atk vars)))","proofString":"destruct a as [id1 ty1].\nsimpl in H0.\ninv H0.\nrewrite add_local_variable_charact in H1.\ndestruct H; destruct H1 as [A | [chunk [A [B C]]]].\ninv H.\nelim H4.\neapply cenv_for_gen_domain; eauto.\ninv H.\nexists chunk; auto.\neauto.\nsubst id1.\nelim H4.\nchange id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H0 : list_norepet (fst (id1, ty1) :: var_names vars)) (H1 : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars))) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H0 : list_norepet (fst (id1, ty1) :: var_names vars)) (H1 : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars)))","proofString":"simpl in H0.\ninv H0.\nrewrite add_local_variable_charact in H1.\ndestruct H; destruct H1 as [A | [chunk [A [B C]]]].\ninv H.\nelim H4.\neapply cenv_for_gen_domain; eauto.\ninv H.\nexists chunk; auto.\neauto.\nsubst id1.\nelim H4.\nchange id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H0 : list_norepet (id1 :: var_names vars)) (H1 : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars))) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H0 : list_norepet (id1 :: var_names vars)) (H1 : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars)))","proofString":"inv H0.\nrewrite add_local_variable_charact in H1.\ndestruct H; destruct H1 as [A | [chunk [A [B C]]]].\ninv H.\nelim H4.\neapply cenv_for_gen_domain; eauto.\ninv H.\nexists chunk; auto.\neauto.\nsubst id1.\nelim H4.\nchange id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H1 : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars))) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars)) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H1 : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars))) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"rewrite add_local_variable_charact in H1.\ndestruct H; destruct H1 as [A | [chunk [A [B C]]]].\ninv H.\nelim H4.\neapply cenv_for_gen_domain; eauto.\ninv H.\nexists chunk; auto.\neauto.\nsubst id1.\nelim H4.\nchange id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H1 : VSet.In id (cenv_for_gen atk vars) \\/\n(exists chunk : memory_chunk,\n   access_mode ty1 = By_value chunk /\\ id1 = id /\\ VSet.mem id1 atk = false)) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars)) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty) \\/ In (id, ty) vars) (H1 : VSet.In id (cenv_for_gen atk vars) \\/\n(exists chunk : memory_chunk,\n   access_mode ty1 = By_value chunk /\\ id1 = id /\\ VSet.mem id1 atk = false)) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"destruct H; destruct H1 as [A | [chunk [A [B C]]]].\ninv H.\nelim H4.\neapply cenv_for_gen_domain; eauto.\ninv H.\nexists chunk; auto.\neauto.\nsubst id1.\nelim H4.\nchange id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty)) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars)) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : (id1, ty1) = (id, ty)) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"inv H.\nelim H4.\neapply cenv_for_gen_domain; eauto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id (var_names vars)) (H5 : list_norepet (var_names vars)) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"elim H4.\neapply cenv_for_gen_domain; eauto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id (var_names vars)) (H5 : list_norepet (var_names vars)) : In id (var_names vars).","conclusion":"In id (var_names vars)","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"eapply cenv_for_gen_domain; eauto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : (id1, ty1) = (id, ty)) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (B : id1 = id) (C : VSet.mem id1 atk = false) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars)) : exists chunk0 : memory_chunk, access_mode ty = By_value chunk0.","conclusion":"exists chunk0 : memory_chunk, access_mode ty = By_value chunk0","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : (id1, ty1) = (id, ty)) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (B : id1 = id) (C : VSet.mem id1 atk = false) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"inv H.\nexists chunk; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars)) (H1 : id = id) : exists chunk0 : memory_chunk, access_mode ty = By_value chunk0.","conclusion":"exists chunk0 : memory_chunk, access_mode ty = By_value chunk0","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars)) (H1 : id = id)","proofString":"exists chunk; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : In (id, ty) vars) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars)) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H : In (id, ty) vars) (A : VSet.In id (cenv_for_gen atk vars)) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"eauto."},{"statement":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (B : id1 = id) (C : VSet.mem id1 atk = false) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars)) : exists chunk0 : memory_chunk, access_mode ty = By_value chunk0.","conclusion":"exists chunk0 : memory_chunk, access_mode ty = By_value chunk0","hypotheses":"(atk : VSet.t) (id : ident) (ty : type) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (B : id1 = id) (C : VSet.mem id1 atk = false) (H4 : ~ In id1 (var_names vars)) (H5 : list_norepet (var_names vars))","proofString":"subst id1.\nelim H4.\nchange id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars)) : exists chunk0 : memory_chunk, access_mode ty = By_value chunk0.","conclusion":"exists chunk0 : memory_chunk, access_mode ty = By_value chunk0","hypotheses":"(atk : VSet.t) (id : ident) (ty ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars))","proofString":"elim H4.\nchange id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars)) : In id (var_names vars).","conclusion":"In id (var_names vars)","hypotheses":"(atk : VSet.t) (id : ident) (ty ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars))","proofString":"change id with (fst (id, ty)).\napply in_map; auto."},{"statement":"(atk : VSet.t) (id : ident) (ty ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars)) : In (fst (id, ty)) (var_names vars).","conclusion":"In (fst (id, ty)) (var_names vars)","hypotheses":"(atk : VSet.t) (id : ident) (ty ty1 : type) (vars : list (ident * type)) (IHvars : In (id, ty) vars ->\nlist_norepet (var_names vars) ->\nVSet.In id (cenv_for_gen atk vars) ->\nexists chunk0 : memory_chunk, access_mode ty = By_value chunk0) (H : In (id, ty) vars) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (H4 : ~ In id (var_names vars)) (C : VSet.mem id atk = false) (H5 : list_norepet (var_names vars))","proofString":"apply in_map; auto."},{"statement":"(atk : VSet.t) (id : VSet.elt) (H : VSet.In id VSet.empty) : VSet.mem id atk = false.","conclusion":"VSet.mem id atk = false","hypotheses":"(atk : VSet.t) (id : VSet.elt) (H : VSet.In id VSet.empty)","proofString":"rewrite VSF.empty_iff in H.\ncontradiction."},{"statement":"(atk : VSet.t) (id : VSet.elt) (H : False) : VSet.mem id atk = false.","conclusion":"VSet.mem id atk = false","hypotheses":"(atk : VSet.t) (id : VSet.elt) (H : False)","proofString":"contradiction."},{"statement":"(atk : VSet.t) (id : VSet.elt) (a : ident * type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (H : VSet.In id (add_local_variable atk a (cenv_for_gen atk vars))) : VSet.mem id atk = false.","conclusion":"VSet.mem id atk = false","hypotheses":"(atk : VSet.t) (id : VSet.elt) (a : ident * type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (H : VSet.In id (add_local_variable atk a (cenv_for_gen atk vars)))","proofString":"destruct a as [id1 ty1].\nrewrite add_local_variable_charact in H.\ndestruct H as [A | [chunk [A [B C]]]].\nauto.\ncongruence."},{"statement":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (H : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars))) : VSet.mem id atk = false.","conclusion":"VSet.mem id atk = false","hypotheses":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (H : VSet.In id (add_local_variable atk (id1, ty1) (cenv_for_gen atk vars)))","proofString":"rewrite add_local_variable_charact in H.\ndestruct H as [A | [chunk [A [B C]]]].\nauto.\ncongruence."},{"statement":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (H : VSet.In id (cenv_for_gen atk vars) \\/\n(exists chunk : memory_chunk,\n   access_mode ty1 = By_value chunk /\\ id1 = id /\\ VSet.mem id1 atk = false)) : VSet.mem id atk = false.","conclusion":"VSet.mem id atk = false","hypotheses":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (H : VSet.In id (cenv_for_gen atk vars) \\/\n(exists chunk : memory_chunk,\n   access_mode ty1 = By_value chunk /\\ id1 = id /\\ VSet.mem id1 atk = false))","proofString":"destruct H as [A | [chunk [A [B C]]]].\nauto.\ncongruence."},{"statement":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (A : VSet.In id (cenv_for_gen atk vars)) : VSet.mem id atk = false.","conclusion":"VSet.mem id atk = false","hypotheses":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (A : VSet.In id (cenv_for_gen atk vars))","proofString":"auto."},{"statement":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (B : id1 = id) (C : VSet.mem id1 atk = false) : VSet.mem id atk = false.","conclusion":"VSet.mem id atk = false","hypotheses":"(atk : VSet.t) (id : VSet.elt) (id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : VSet.In id (cenv_for_gen atk vars) -> VSet.mem id atk = false) (chunk : memory_chunk) (A : access_mode ty1 = By_value chunk) (B : id1 = id) (C : VSet.mem id1 atk = false)","proofString":"congruence."},{"statement":"(f : function) (id : VSet.elt) (H : VSet.In id (addr_taken_stmt (fn_body f))) (H0 : VSet.In id (cenv_for f)) : False.","conclusion":"False","hypotheses":"(f : function) (id : VSet.elt) (H : VSet.In id (addr_taken_stmt (fn_body f))) (H0 : VSet.In id (cenv_for f))","proofString":"assert (VSet.mem id (addr_taken_stmt (fn_body f)) = false).\neapply cenv_for_gen_compat.\neexact H0.\nrewrite VSF.mem_iff in H.\ncongruence."},{"statement":"(f : function) (id : VSet.elt) (H : VSet.In id (addr_taken_stmt (fn_body f))) (H0 : VSet.In id (cenv_for f)) : VSet.mem id (addr_taken_stmt (fn_body f)) = false.","conclusion":"VSet.mem id (addr_taken_stmt (fn_body f)) = false","hypotheses":"(f : function) (id : VSet.elt) (H : VSet.In id (addr_taken_stmt (fn_body f))) (H0 : VSet.In id (cenv_for f))","proofString":"eapply cenv_for_gen_compat.\neexact H0."},{"statement":"(f : function) (id : VSet.elt) (H : VSet.In id (addr_taken_stmt (fn_body f))) (H0 : VSet.In id (cenv_for f)) (H1 : VSet.mem id (addr_taken_stmt (fn_body f)) = false) : False.","conclusion":"False","hypotheses":"(f : function) (id : VSet.elt) (H : VSet.In id (addr_taken_stmt (fn_body f))) (H0 : VSet.In id (cenv_for f)) (H1 : VSet.mem id (addr_taken_stmt (fn_body f)) = false)","proofString":"rewrite VSF.mem_iff in H.\ncongruence."},{"statement":"(f : function) (id : VSet.elt) (H : VSet.mem id (addr_taken_stmt (fn_body f)) = true) (H0 : VSet.In id (cenv_for f)) (H1 : VSet.mem id (addr_taken_stmt (fn_body f)) = false) : False.","conclusion":"False","hypotheses":"(f : function) (id : VSet.elt) (H : VSet.mem id (addr_taken_stmt (fn_body f)) = true) (H0 : VSet.In id (cenv_for f)) (H1 : VSet.mem id (addr_taken_stmt (fn_body f)) = false)","proofString":"congruence."},{"statement":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk1) (H1 : VSet.In id cenv) : False.","conclusion":"False","hypotheses":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk1) (H1 : VSet.In id cenv)","proofString":"eapply H; eauto.\napply VSet.union_2; auto."},{"statement":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk1) (H1 : VSet.In id cenv) : VSet.In id (VSet.union atk1 atk2).","conclusion":"VSet.In id (VSet.union atk1 atk2)","hypotheses":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk1) (H1 : VSet.In id cenv)","proofString":"apply VSet.union_2; auto."},{"statement":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk2) (H1 : VSet.In id cenv) : False.","conclusion":"False","hypotheses":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk2) (H1 : VSet.In id cenv)","proofString":"eapply H; eauto.\napply VSet.union_3; auto."},{"statement":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk2) (H1 : VSet.In id cenv) : VSet.In id (VSet.union atk1 atk2).","conclusion":"VSet.In id (VSet.union atk1 atk2)","hypotheses":"(atk1 atk2 : VSet.t) (cenv : compilenv) (H : compat_cenv (VSet.union atk1 atk2) cenv) (id : VSet.elt) (H0 : VSet.In id atk2) (H1 : VSet.In id cenv)","proofString":"apply VSet.union_3; auto."},{"statement":"(cenv : compilenv) (id : VSet.elt) (H : VSet.In id VSet.empty) (H0 : VSet.In id cenv) : False.","conclusion":"False","hypotheses":"(cenv : compilenv) (id : VSet.elt) (H : VSet.In id VSet.empty) (H0 : VSet.In id cenv)","proofString":"eapply VSet.empty_1; eauto."},{"statement":"(ge0 : genv) (e : env) (m : mem) : Ple (Mem.nextblock m) (Mem.nextblock m).","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m)","hypotheses":"(ge0 : genv) (e : env) (m : mem)","proofString":"apply Ple_refl."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2)) : Ple (Mem.nextblock m) (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2))","proofString":"eapply Ple_trans; eauto.\nexploit Mem.nextblock_alloc; eauto.\nintros EQ; rewrite EQ.\napply Ple_succ."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2)) : Ple (Mem.nextblock m) (Mem.nextblock m1).","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2))","proofString":"exploit Mem.nextblock_alloc; eauto.\nintros EQ; rewrite EQ.\napply Ple_succ."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2)) : Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nPle (Mem.nextblock m) (Mem.nextblock m1).","conclusion":"Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nPle (Mem.nextblock m) (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2))","proofString":"intros EQ; rewrite EQ.\napply Ple_succ."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (EQ : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : Ple (Mem.nextblock m) (Pos.succ (Mem.nextblock m)).","conclusion":"Ple (Mem.nextblock m) (Pos.succ (Mem.nextblock m))","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (EQ : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"apply Ple_succ."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : env) (m : mem) (H : e ! id = Some (b, ty)) : e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m).","conclusion":"e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : env) (m : mem) (H : e ! id = Some (b, ty))","proofString":"auto."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) : e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty))","proofString":"exploit IHalloc_variables; eauto.\nrewrite PTree.gsspec.\nintros [A|A].\ndestruct (peq id id0).\ninv A.\nright.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ.\nauto.\nright.\nexploit Mem.nextblock_alloc; eauto.\nintros B.\nrewrite B in A.\nextlia."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) : (PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2) ->\ne ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2) ->\ne ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty))","proofString":"rewrite PTree.gsspec.\nintros [A|A].\ndestruct (peq id id0).\ninv A.\nright.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ.\nauto.\nright.\nexploit Mem.nextblock_alloc; eauto.\nintros B.\nrewrite B in A.\nextlia."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) : (if peq id id0 then Some (b1, ty0) else e ! id) = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2) ->\ne ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"(if peq id id0 then Some (b1, ty0) else e ! id) = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2) ->\ne ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty))","proofString":"intros [A|A].\ndestruct (peq id id0).\ninv A.\nright.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ.\nauto.\nright.\nexploit Mem.nextblock_alloc; eauto.\nintros B.\nrewrite B in A.\nextlia."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : (if peq id id0 then Some (b1, ty0) else e ! id) = Some (b, ty)) : e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : (if peq id id0 then Some (b1, ty0) else e ! id) = Some (b, ty))","proofString":"destruct (peq id id0).\ninv A.\nright.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ.\nauto."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (e0 : id = id0) (A : Some (b1, ty0) = Some (b, ty)) : e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (e0 : id = id0) (A : Some (b1, ty0) = Some (b, ty))","proofString":"inv A.\nright.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : e ! id0 = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"e ! id0 = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"right.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"exploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : b = Mem.nextblock m -> Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"b = Mem.nextblock m -> Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"exploit Mem.nextblock_alloc; eauto.\ngeneralize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nb = Mem.nextblock m -> Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nb = Mem.nextblock m -> Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"generalize (alloc_variables_nextblock _ _ _ _ _ _ H0).\nintros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : Ple (Mem.nextblock m1) (Mem.nextblock m2) ->\nMem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nb = Mem.nextblock m -> Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m1) (Mem.nextblock m2) ->\nMem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nb = Mem.nextblock m -> Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"intros A B C.\nsubst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) (C : b = Mem.nextblock m) : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id0 (b, ty) e) m1 vars e2 m2) (H1 : e2 ! id0 = Some (b, ty)) (IHalloc_variables : e2 ! id0 = Some (b, ty) ->\n(PTree.set id0 (b, ty) e) ! id0 = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) (C : b = Mem.nextblock m)","proofString":"subst b.\nsplit.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : Ple (Mem.nextblock m) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"split.\napply Ple_refl.\neapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : Ple (Mem.nextblock m) (Mem.nextblock m).","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m)","hypotheses":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"apply Ple_refl."},{"statement":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : Plt (Mem.nextblock m) (Mem.nextblock m2).","conclusion":"Plt (Mem.nextblock m) (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"eapply Pos.lt_le_trans; eauto.\nrewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : (Mem.nextblock m < Mem.nextblock m1)%positive.","conclusion":"(Mem.nextblock m < Mem.nextblock m1)%positive","hypotheses":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"rewrite B.\napply Plt_succ."},{"statement":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : (Mem.nextblock m < Pos.succ (Mem.nextblock m))%positive.","conclusion":"(Mem.nextblock m < Pos.succ (Mem.nextblock m))%positive","hypotheses":"(ge0 : genv) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (IHalloc_variables : e2 ! id0 = Some (Mem.nextblock m, ty) ->\n(PTree.set id0 (Mem.nextblock m, ty) e) ! id0 = Some (Mem.nextblock m, ty) \\/\nPle (Mem.nextblock m1) (Mem.nextblock m) /\\\nPlt (Mem.nextblock m) (Mem.nextblock m2)) (H1 : e2 ! id0 = Some (Mem.nextblock m, ty)) (H0 : alloc_variables ge0 (PTree.set id0 (Mem.nextblock m, ty) e) m1 vars e2 m2) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, Mem.nextblock m)) (A : Ple (Mem.nextblock m1) (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"apply Plt_succ."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (n : id <> id0) (A : e ! id = Some (b, ty)) : e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (n : id <> id0) (A : e ! id = Some (b, ty))","proofString":"auto."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"e ! id = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"right.\nexploit Mem.nextblock_alloc; eauto.\nintros B.\nrewrite B in A.\nextlia."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"exploit Mem.nextblock_alloc; eauto.\nintros B.\nrewrite B in A.\nextlia."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) : Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nPle (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nPle (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2))","proofString":"intros B.\nrewrite B in A.\nextlia."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"rewrite B in A.\nextlia."},{"statement":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Pos.succ (Mem.nextblock m)) b /\\ Plt b (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m)) : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m2)","hypotheses":"(ge0 : genv) (id : positive) (b : block) (ty : type) (e : PTree.tree (block * type)) (m : mem) (id0 : positive) (ty0 : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id0 (b1, ty0) e) m1 vars e2 m2) (IHalloc_variables : e2 ! id = Some (b, ty) ->\n(PTree.set id0 (b1, ty0) e) ! id = Some (b, ty) \\/\nPle (Mem.nextblock m1) b /\\ Plt b (Mem.nextblock m2)) (H1 : e2 ! id = Some (b, ty)) (A : Ple (Pos.succ (Mem.nextblock m)) b /\\ Plt b (Mem.nextblock m2)) (B : Mem.nextblock m1 = Pos.succ (Mem.nextblock m))","proofString":"extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : env) (m : mem) (H : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Plt b (Mem.nextblock m)) (H1 : e ! id1 = Some (b1, ty1)) (H2 : e ! id2 = Some (b2, ty2)) (H3 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : env) (m : mem) (H : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H0 : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Plt b (Mem.nextblock m)) (H1 : e ! id1 = Some (b1, ty1)) (H2 : e ! id2 = Some (b2, ty2)) (H3 : id1 <> id2)","proofString":"eauto."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2)","proofString":"eapply IHalloc_variables; eauto.\nrepeat rewrite PTree.gsspec; intros.\ndestruct (peq id1 id); destruct (peq id2 id).\ncongruence.\ninv H6.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia.\ninv H7.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia.\neauto.\nintros.\nrewrite PTree.gsspec in H6.\ndestruct (peq id0 id).\ninv H6.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia.\nexploit H2; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) : (PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n(PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2.","conclusion":"(PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n(PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2)","proofString":"repeat rewrite PTree.gsspec; intros.\ndestruct (peq id1 id); destruct (peq id2 id).\ncongruence.\ninv H6.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia.\ninv H7.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia.\neauto."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (H6 : (if peq id1 id then Some (b0, ty) else e ! id1) = Some (b1, ty1)) (H7 : (if peq id2 id then Some (b0, ty) else e ! id2) = Some (b2, ty2)) (H8 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (H6 : (if peq id1 id then Some (b0, ty) else e ! id1) = Some (b1, ty1)) (H7 : (if peq id2 id then Some (b0, ty) else e ! id2) = Some (b2, ty2)) (H8 : id1 <> id2)","proofString":"destruct (peq id1 id); destruct (peq id2 id).\ncongruence.\ninv H6.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia.\ninv H7.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia.\neauto."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (e0 : id1 = id) (H6 : Some (b0, ty) = Some (b1, ty1)) (e1 : id2 = id) (H7 : Some (b0, ty) = Some (b2, ty2)) (H8 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (e0 : id1 = id) (H6 : Some (b0, ty) = Some (b1, ty1)) (e1 : id2 = id) (H7 : Some (b0, ty) = Some (b2, ty2)) (H8 : id1 <> id2)","proofString":"congruence."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (e0 : id1 = id) (H6 : Some (b0, ty) = Some (b1, ty1)) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (e0 : id1 = id) (H6 : Some (b0, ty) = Some (b1, ty1)) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id1 <> id2)","proofString":"inv H6.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty1) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty1) e) m1 vars e2 m2) (H1 : e ! id = Some (b1, ty1) -> e ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b1, ty1) e) ! id = Some (b1, ty1) ->\n (PTree.set id (b1, ty1) e) ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b1, ty1) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id <> id2) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty1) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty1) e) m1 vars e2 m2) (H1 : e ! id = Some (b1, ty1) -> e ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b1, ty1) e) ! id = Some (b1, ty1) ->\n (PTree.set id (b1, ty1) e) ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b1, ty1) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id <> id2) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id <> id2)","proofString":"exploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty1) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty1) e) m1 vars e2 m2) (H1 : e ! id = Some (b1, ty1) -> e ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b1, ty1) e) ! id = Some (b1, ty1) ->\n (PTree.set id (b1, ty1) e) ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b1, ty1) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id <> id2) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id <> id2) : b1 = Mem.nextblock m -> b1 <> b2.","conclusion":"b1 = Mem.nextblock m -> b1 <> b2","hypotheses":"(ge0 : genv) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty1) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty1) e) m1 vars e2 m2) (H1 : e ! id = Some (b1, ty1) -> e ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b1, ty1) e) ! id = Some (b1, ty1) ->\n (PTree.set id (b1, ty1) e) ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b1, ty1) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id <> id2) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id <> id2)","proofString":"exploit H2; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty1) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty1) e) m1 vars e2 m2) (H1 : e ! id = Some (b1, ty1) -> e ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b1, ty1) e) ! id = Some (b1, ty1) ->\n (PTree.set id (b1, ty1) e) ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b1, ty1) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id <> id2) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id <> id2) : Plt b2 (Mem.nextblock m) -> b1 = Mem.nextblock m -> b1 <> b2.","conclusion":"Plt b2 (Mem.nextblock m) -> b1 = Mem.nextblock m -> b1 <> b2","hypotheses":"(ge0 : genv) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty1) = (m1, b1)) (H0 : alloc_variables ge0 (PTree.set id (b1, ty1) e) m1 vars e2 m2) (H1 : e ! id = Some (b1, ty1) -> e ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b1, ty1) e) ! id = Some (b1, ty1) ->\n (PTree.set id (b1, ty1) e) ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b1, ty1) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id <> id2) (n : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id <> id2)","proofString":"unfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (e0 : id2 = id) (H7 : Some (b0, ty) = Some (b2, ty2)) (H8 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (e0 : id2 = id) (H7 : Some (b0, ty) = Some (b2, ty2)) (H8 : id1 <> id2)","proofString":"inv H7.\nexploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty2) = (m1, b2)) (H0 : alloc_variables ge0 (PTree.set id (b2, ty2) e) m1 vars e2 m2) (H1 : e ! id1 = Some (b1, ty1) -> e ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b2, ty2) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b2, ty2) e) ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b2, ty2) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H5 : id1 <> id) (H4 : e2 ! id = Some (b2, ty2)) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (H8 : id1 <> id) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty2) = (m1, b2)) (H0 : alloc_variables ge0 (PTree.set id (b2, ty2) e) m1 vars e2 m2) (H1 : e ! id1 = Some (b1, ty1) -> e ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b2, ty2) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b2, ty2) e) ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b2, ty2) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H5 : id1 <> id) (H4 : e2 ! id = Some (b2, ty2)) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (H8 : id1 <> id)","proofString":"exploit Mem.alloc_result; eauto.\nexploit H2; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty2) = (m1, b2)) (H0 : alloc_variables ge0 (PTree.set id (b2, ty2) e) m1 vars e2 m2) (H1 : e ! id1 = Some (b1, ty1) -> e ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b2, ty2) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b2, ty2) e) ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b2, ty2) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H5 : id1 <> id) (H4 : e2 ! id = Some (b2, ty2)) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (H8 : id1 <> id) : b2 = Mem.nextblock m -> b1 <> b2.","conclusion":"b2 = Mem.nextblock m -> b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty2) = (m1, b2)) (H0 : alloc_variables ge0 (PTree.set id (b2, ty2) e) m1 vars e2 m2) (H1 : e ! id1 = Some (b1, ty1) -> e ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b2, ty2) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b2, ty2) e) ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b2, ty2) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H5 : id1 <> id) (H4 : e2 ! id = Some (b2, ty2)) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (H8 : id1 <> id)","proofString":"exploit H2; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty2) = (m1, b2)) (H0 : alloc_variables ge0 (PTree.set id (b2, ty2) e) m1 vars e2 m2) (H1 : e ! id1 = Some (b1, ty1) -> e ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b2, ty2) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b2, ty2) e) ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b2, ty2) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H5 : id1 <> id) (H4 : e2 ! id = Some (b2, ty2)) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (H8 : id1 <> id) : Plt b1 (Mem.nextblock m) -> b2 = Mem.nextblock m -> b1 <> b2.","conclusion":"Plt b1 (Mem.nextblock m) -> b2 = Mem.nextblock m -> b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty2) = (m1, b2)) (H0 : alloc_variables ge0 (PTree.set id (b2, ty2) e) m1 vars e2 m2) (H1 : e ! id1 = Some (b1, ty1) -> e ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (IHalloc_variables : ((PTree.set id (b2, ty2) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b2, ty2) e) ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty : type),\n (PTree.set id (b2, ty2) e) ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id = Some (b2, ty2) -> id1 <> id -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty : type),\ne ! id0 = Some (b, ty) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H5 : id1 <> id) (H4 : e2 ! id = Some (b2, ty2)) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (H8 : id1 <> id)","proofString":"unfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (n0 : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (n : id1 <> id) (H6 : e ! id1 = Some (b1, ty1)) (n0 : id2 <> id) (H7 : e ! id2 = Some (b2, ty2)) (H8 : id1 <> id2)","proofString":"eauto."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) : forall (id0 : positive) (b : block) (ty0 : type),\n(PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1).","conclusion":"forall (id0 : positive) (b : block) (ty0 : type),\n(PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b : block) (ty0 : type),\n (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b : block) (ty0 : type),\ne ! id0 = Some (b, ty0) -> Plt b (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2)","proofString":"intros.\nrewrite PTree.gsspec in H6.\ndestruct (peq id0 id).\ninv H6.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia.\nexploit H2; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (H6 : (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0)) : Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (H6 : (PTree.set id (b0, ty) e) ! id0 = Some (b, ty0))","proofString":"rewrite PTree.gsspec in H6.\ndestruct (peq id0 id).\ninv H6.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia.\nexploit H2; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (H6 : (if peq id0 id then Some (b0, ty) else e ! id0) = Some (b, ty0)) : Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (H6 : (if peq id0 id then Some (b0, ty) else e ! id0) = Some (b, ty0))","proofString":"destruct (peq id0 id).\ninv H6.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia.\nexploit H2; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (e0 : id0 = id) (H6 : Some (b0, ty) = Some (b, ty0)) : Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (e0 : id0 = id) (H6 : Some (b0, ty) = Some (b, ty0))","proofString":"inv H6.\nexploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b, ty0) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b, ty0) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b0 : block) (ty : type),\n (PTree.set id (b, ty0) e) ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b0 : block) (ty : type),\ne ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) : Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b, ty0) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b, ty0) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b0 : block) (ty : type),\n (PTree.set id (b, ty0) e) ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b0 : block) (ty : type),\ne ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2)","proofString":"exploit Mem.alloc_result; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b, ty0) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b, ty0) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b0 : block) (ty : type),\n (PTree.set id (b, ty0) e) ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b0 : block) (ty : type),\ne ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) : b = Mem.nextblock m -> Plt b (Mem.nextblock m1).","conclusion":"b = Mem.nextblock m -> Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b, ty0) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b, ty0) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b0 : block) (ty : type),\n (PTree.set id (b, ty0) e) ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b0 : block) (ty : type),\ne ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2)","proofString":"exploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b, ty0) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b, ty0) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b0 : block) (ty : type),\n (PTree.set id (b, ty0) e) ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b0 : block) (ty : type),\ne ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) : Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nb = Mem.nextblock m -> Plt b (Mem.nextblock m1).","conclusion":"Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nb = Mem.nextblock m -> Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge0 ty0) = (m1, b)) (H0 : alloc_variables ge0 (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b, ty0) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b, ty0) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id0 : positive) (b0 : block) (ty : type),\n (PTree.set id (b, ty0) e) ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id0 : positive) (b0 : block) (ty : type),\ne ! id0 = Some (b0, ty) -> Plt b0 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2)","proofString":"unfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H6 : e ! id0 = Some (b, ty0)) : Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H6 : e ! id0 = Some (b, ty0))","proofString":"exploit H2; eauto.\nexploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H6 : e ! id0 = Some (b, ty0)) : Plt b (Mem.nextblock m) -> Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m) -> Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H6 : e ! id0 = Some (b, ty0))","proofString":"exploit Mem.nextblock_alloc; eauto.\nunfold block; extlia."},{"statement":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H6 : e ! id0 = Some (b, ty0)) : Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nPlt b (Mem.nextblock m) -> Plt b (Mem.nextblock m1).","conclusion":"Mem.nextblock m1 = Pos.succ (Mem.nextblock m) ->\nPlt b (Mem.nextblock m) -> Plt b (Mem.nextblock m1)","hypotheses":"(ge0 : genv) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b0 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge0 ty) = (m1, b0)) (H0 : alloc_variables ge0 (PTree.set id (b0, ty) e) m1 vars e2 m2) (IHalloc_variables : ((PTree.set id (b0, ty) e) ! id1 = Some (b1, ty1) ->\n (PTree.set id (b0, ty) e) ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) ->\n(forall (id3 : positive) (b3 : block) (ty3 : type),\n (PTree.set id (b0, ty) e) ! id3 = Some (b3, ty3) ->\n Plt b3 (Mem.nextblock m1)) ->\ne2 ! id1 = Some (b1, ty1) ->\ne2 ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H1 : e ! id1 = Some (b1, ty1) ->\ne ! id2 = Some (b2, ty2) -> id1 <> id2 -> b1 <> b2) (H2 : forall (id3 : positive) (b3 : block) (ty3 : type),\ne ! id3 = Some (b3, ty3) -> Plt b3 (Mem.nextblock m)) (H3 : e2 ! id1 = Some (b1, ty1)) (H4 : e2 ! id2 = Some (b2, ty2)) (H5 : id1 <> id2) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H6 : e ! id0 = Some (b, ty0))","proofString":"unfold block; extlia."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv nil) te' tm' /\\\n  Mem.inject j' m tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id : positive) (ty : type),\n     e ! id = Some (b, ty) /\\ te' ! id = Some (b', ty) /\\ delta = 0) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) nil ->\n   exists b : block,\n     e ! id = Some (b, ty) /\\\n     (if VSet.mem id cenv\n      then te' ! id = te ! id /\\ j' b = None\n      else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) /\\\n  (forall id : ident,\n   ~ In id (var_names nil) -> e ! id = e ! id /\\ te' ! id = te ! id).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv nil) te' tm' /\\\n  Mem.inject j' m tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id : positive) (ty : type),\n     e ! id = Some (b, ty) /\\ te' ! id = Some (b', ty) /\\ delta = 0) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) nil ->\n   exists b : block,\n     e ! id = Some (b, ty) /\\\n     (if VSet.mem id cenv\n      then te' ! id = te ! id /\\ j' b = None\n      else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) /\\\n  (forall id : ident,\n   ~ In id (var_names nil) -> e ! id = e ! id /\\ te' ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"exists j; exists te; exists tm.\nsimpl.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : alloc_variables tge te tm (remove_lifted cenv nil) te tm /\\\nMem.inject j m tm /\\\ninject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) nil ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident,\n ~ In id (var_names nil) -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"alloc_variables tge te tm (remove_lifted cenv nil) te tm /\\\nMem.inject j m tm /\\\ninject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) nil ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident,\n ~ In id (var_names nil) -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"simpl.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : alloc_variables tge te tm nil te tm /\\\nMem.inject j m tm /\\\ninject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"alloc_variables tge te tm nil te tm /\\\nMem.inject j m tm /\\\ninject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"split.\nconstructor.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : alloc_variables tge te tm nil te tm.","conclusion":"alloc_variables tge te tm nil te tm","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"constructor."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : Mem.inject j m tm /\\\ninject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"Mem.inject j m tm /\\\ninject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"split.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : Mem.inject j m tm.","conclusion":"Mem.inject j m tm","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : inject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"inject_incr j j /\\\n(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"split.\nauto.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : inject_incr j j.","conclusion":"inject_incr j j","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : (forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"(forall b : block, Mem.valid_block m b -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"split.\nauto.\nsplit.\nauto.\nsplit.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : forall b : block, Mem.valid_block m b -> j b = j b.","conclusion":"forall b : block, Mem.valid_block m b -> j b = j b","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : (forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"split.\nauto.\nsplit.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : forall (b b' : block) (delta : Z),\nj b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b.","conclusion":"forall (b b' : block) (delta : Z),\nj b = Some (b', delta) -> Mem.valid_block tm b' -> j b = j b","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : (forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"(forall (b b' : block) (delta : Z),\n j b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id : positive) (ty : type),\n   e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) /\\\n(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"split.\nintros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto.\nsplit.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : forall (b b' : block) (delta : Z),\nj b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0.","conclusion":"forall (b b' : block) (delta : Z),\nj b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"intros.\nelim H2.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) (b b' : block) (delta : Z) (H1 : j b = Some (b', delta)) (H2 : ~ Mem.valid_block tm b') : exists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0.","conclusion":"exists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) (b b' : block) (delta : Z) (H1 : j b = Some (b', delta)) (H2 : ~ Mem.valid_block tm b')","proofString":"elim H2.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) (b b' : block) (delta : Z) (H1 : j b = Some (b', delta)) (H2 : ~ Mem.valid_block tm b') : Mem.valid_block tm b'.","conclusion":"Mem.valid_block tm b'","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) (b b' : block) (delta : Z) (H1 : j b = Some (b', delta)) (H2 : ~ Mem.valid_block tm b')","proofString":"eapply Mem.mi_mappedblocks; eauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : (forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id).","conclusion":"(forall (id : ident) (ty : type),\n False ->\n exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = te ! id /\\ j b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))) /\\\n(forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id)","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"split.\ntauto.\nauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : forall (id : ident) (ty : type),\nFalse ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = te ! id /\\ j b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0)).","conclusion":"forall (id : ident) (ty : type),\nFalse ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = te ! id /\\ j b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"tauto."},{"statement":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm) : forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id.","conclusion":"forall id : ident, ~ False -> e ! id = e ! id /\\ te ! id = te ! id","hypotheses":"(cenv : compilenv) (e : env) (m : mem) (j : meminj) (tm : mem) (te : env) (H : list_norepet (var_names nil)) (H0 : Mem.inject j m tm)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H1 : list_norepet (var_names ((id, ty) :: vars))) (H2 : Mem.inject j m tm) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv ((id, ty) :: vars)) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) ((id, ty) :: vars) ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names ((id, ty) :: vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv ((id, ty) :: vars)) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) ((id, ty) :: vars) ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names ((id, ty) :: vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H1 : list_norepet (var_names ((id, ty) :: vars))) (H2 : Mem.inject j m tm)","proofString":"simpl in H1.\ninv H1.\nsimpl.\ndestruct (VSet.mem id cenv) eqn:?.\nsimpl.\nexploit Mem.alloc_left_unmapped_inject; eauto.\nintros [j1 [A [B [C D]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [j1 [tm1 [tb1 [A [B [C [D E]]]]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := PTree.set id (tb1, ty) te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H1 : list_norepet (id :: var_names vars)) (H2 : Mem.inject j m tm) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv ((id, ty) :: vars)) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) ((id, ty) :: vars) ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names ((id, ty) :: vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv ((id, ty) :: vars)) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) ((id, ty) :: vars) ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names ((id, ty) :: vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H1 : list_norepet (id :: var_names vars)) (H2 : Mem.inject j m tm)","proofString":"inv H1.\nsimpl.\ndestruct (VSet.mem id cenv) eqn:?.\nsimpl.\nexploit Mem.alloc_left_unmapped_inject; eauto.\nintros [j1 [A [B [C D]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [j1 [tm1 [tb1 [A [B [C [D E]]]]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := PTree.set id (tb1, ty) te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv ((id, ty) :: vars)) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) ((id, ty) :: vars) ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names ((id, ty) :: vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv ((id, ty) :: vars)) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) ((id, ty) :: vars) ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names ((id, ty) :: vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars))","proofString":"simpl.\ndestruct (VSet.mem id cenv) eqn:?.\nsimpl.\nexploit Mem.alloc_left_unmapped_inject; eauto.\nintros [j1 [A [B [C D]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [j1 [tm1 [tb1 [A [B [C [D E]]]]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := PTree.set id (tb1, ty) te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb (VSet.mem id cenv)\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb (VSet.mem id cenv)\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars))","proofString":"destruct (VSet.mem id cenv) eqn:?.\nsimpl.\nexploit Mem.alloc_left_unmapped_inject; eauto.\nintros [j1 [A [B [C D]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [j1 [tm1 [tb1 [A [B [C [D E]]]]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := PTree.set id (tb1, ty) te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb true\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb true\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true)","proofString":"simpl.\nexploit Mem.alloc_left_unmapped_inject; eauto.\nintros [j1 [A [B [C D]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true)","proofString":"exploit Mem.alloc_left_unmapped_inject; eauto.\nintros [j1 [A [B [C D]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) : (exists f' : meminj,\n   Mem.inject f' m1 tm /\\\n   inject_incr j f' /\\\n   f' b1 = None /\\ (forall b : block, b <> b1 -> f' b = j b)) ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(exists f' : meminj,\n   Mem.inject f' m1 tm /\\\n   inject_incr j f' /\\\n   f' b1 = None /\\ (forall b : block, b <> b1 -> f' b = j b)) ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true)","proofString":"intros [j1 [A [B [C D]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b)","proofString":"exploit IHalloc_variables; eauto.\ninstantiate (1 := te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) : (exists (j' : meminj) (te' : env) (tm' : mem),\n   alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n   Mem.inject j' m2 tm' /\\\n   inject_incr j1 j' /\\\n   (forall b : block, Mem.valid_block m1 b -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) ->\n    ~ Mem.valid_block tm b' ->\n    exists (id0 : positive) (ty0 : type),\n      e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n   (forall (id0 : ident) (ty0 : type),\n    In (id0, ty0) vars ->\n    exists b : block,\n      e2 ! id0 = Some (b, ty0) /\\\n      (if VSet.mem id0 cenv\n       then te' ! id0 = te ! id0 /\\ j' b = None\n       else\n        exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n   (forall id0 : ident,\n    ~ In id0 (var_names vars) ->\n    e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)) ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(exists (j' : meminj) (te' : env) (tm' : mem),\n   alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n   Mem.inject j' m2 tm' /\\\n   inject_incr j1 j' /\\\n   (forall b : block, Mem.valid_block m1 b -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) ->\n    ~ Mem.valid_block tm b' ->\n    exists (id0 : positive) (ty0 : type),\n      e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n   (forall (id0 : ident) (ty0 : type),\n    In (id0, ty0) vars ->\n    exists b : block,\n      e2 ! id0 = Some (b, ty0) /\\\n      (if VSet.mem id0 cenv\n       then te' ! id0 = te ! id0 /\\ j' b = None\n       else\n        exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n   (forall id0 : ident,\n    ~ In id0 (var_names vars) ->\n    e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)) ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b)","proofString":"intros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : exists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j j'0 /\\\n  (forall b : block, Mem.valid_block m b -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm b' -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te'0 ! id0 = te ! id0).","conclusion":"exists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te tm (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j j'0 /\\\n  (forall b : block, Mem.valid_block m b -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm b' -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te'0 ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"exists j'; exists te'; exists tm'.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\nMem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"alloc_variables tge te tm (remove_lifted cenv vars) te' tm' /\\\nMem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"split.\nauto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : alloc_variables tge te tm (remove_lifted cenv vars) te' tm'.","conclusion":"alloc_variables tge te tm (remove_lifted cenv vars) te' tm'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : Mem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"Mem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"split.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : Mem.inject j' m2 tm'.","conclusion":"Mem.inject j' m2 tm'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : inject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"inject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"split.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : inject_incr j j'.","conclusion":"inject_incr j j'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"eapply inject_incr_trans; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"split.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : forall b : block, Mem.valid_block m b -> j' b = j b.","conclusion":"forall b : block, Mem.valid_block m b -> j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"intros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b) : j' b = j b.","conclusion":"j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"transitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b) : j' b = j1 b.","conclusion":"j' b = j1 b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"apply M.\neapply Mem.valid_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b) : Mem.valid_block m1 b.","conclusion":"Mem.valid_block m1 b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"eapply Mem.valid_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b) : j1 b = j b.","conclusion":"j1 b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"apply D.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b) : b <> b1.","conclusion":"b <> b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"apply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b) : ~ Mem.valid_block m b1.","conclusion":"~ Mem.valid_block m b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"eapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : (forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"split.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence.\nsplit.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b.","conclusion":"forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"intros.\ntransitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') : j' b = j b.","conclusion":"j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"transitivity (j1 b).\neapply N; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') : j' b = j1 b.","conclusion":"j' b = j1 b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"eapply N; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') : j1 b = j b.","conclusion":"j1 b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"destruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') (e0 : b = b1) : j1 b = j b.","conclusion":"j1 b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') (e0 : b = b1)","proofString":"subst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') : j1 b1 = j b1.","conclusion":"j1 b1 = j b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"assert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\ncongruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') : j' b1 = j1 b1.","conclusion":"j' b1 = j1 b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"apply M.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') : Mem.valid_block m1 b1.","conclusion":"Mem.valid_block m1 b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"eapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1) : j1 b1 = j b1.","conclusion":"j1 b1 = j b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1)","proofString":"congruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : (forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"split.\nexact Q.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0.","conclusion":"forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"exact Q."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : (forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"split.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : forall (id0 : ident) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"forall (id0 : ident) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"intros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) : exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars)","proofString":"destruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\neapply O; eauto.\ndestruct H1.\ncongruence.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (e0 : id0 = id) : exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (e0 : id0 = id)","proofString":"subst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) : exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars)","proofString":"assert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) : ty0 = ty.","conclusion":"ty0 = ty","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars)","proofString":"destruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0)) : ty0 = ty.","conclusion":"ty0 = ty","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0))","proofString":"congruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : ty0 = ty.","conclusion":"ty0 = ty","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"elim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : In id (var_names vars).","conclusion":"In id (var_names vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"unfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : In id (map fst vars).","conclusion":"In id (map fst vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"change id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : In (fst (id, ty0)) (map fst vars).","conclusion":"In (fst (id, ty0)) (map fst vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"apply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) (H3 : ty0 = ty) : exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) (H3 : ty0 = ty)","proofString":"subst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) : exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars)","proofString":"exploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) : e2 ! id = (PTree.set id (b1, ty) e) ! id /\\ te' ! id = te ! id ->\nexists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"e2 ! id = (PTree.set id (b1, ty) e) ! id /\\ te' ! id = te ! id ->\nexists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars)","proofString":"intros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"rewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : exists b : block, e2 ! id = Some (b, ty) /\\ te' ! id = te ! id /\\ j' b = None.","conclusion":"exists b : block, e2 ! id = Some (b, ty) /\\ te' ! id = te ! id /\\ j' b = None","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"rewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  te' ! id = te ! id /\\ j' b = None.","conclusion":"exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  te' ! id = te ! id /\\ j' b = None","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"rewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  te ! id = te ! id /\\ j' b = None.","conclusion":"exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  te ! id = te ! id /\\ j' b = None","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"exists b1.\nsplit.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : (PTree.set id (b1, ty) e) ! id = Some (b1, ty) /\\\nte ! id = te ! id /\\ j' b1 = None.","conclusion":"(PTree.set id (b1, ty) e) ! id = Some (b1, ty) /\\\nte ! id = te ! id /\\ j' b1 = None","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"split.\napply PTree.gss.\nsplit.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : (PTree.set id (b1, ty) e) ! id = Some (b1, ty).","conclusion":"(PTree.set id (b1, ty) e) ! id = Some (b1, ty)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"apply PTree.gss."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : te ! id = te ! id /\\ j' b1 = None.","conclusion":"te ! id = te ! id /\\ j' b1 = None","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"split.\nauto.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : te ! id = te ! id.","conclusion":"te ! id = te ! id","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : j' b1 = None.","conclusion":"j' b1 = None","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"rewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : j1 b1 = None.","conclusion":"j1 b1 = None","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id) : Mem.valid_block m1 b1.","conclusion":"Mem.valid_block m1 b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = te ! id)","proofString":"eapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id) : exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id)","proofString":"eapply O; eauto.\ndestruct H1.\ncongruence.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id) : In (id0, ty0) vars.","conclusion":"In (id0, ty0) vars","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id)","proofString":"destruct H1.\ncongruence.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0)) (n : id0 <> id) : In (id0, ty0) vars.","conclusion":"In (id0, ty0) vars","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0)) (n : id0 <> id)","proofString":"congruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : In (id0, ty0) vars) (n : id0 <> id) : In (id0, ty0) vars.","conclusion":"In (id0, ty0) vars","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (ty0 : type) (H1 : In (id0, ty0) vars) (n : id0 <> id)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0) : forall id0 : ident,\n~ (id = id0 \\/ In id0 (var_names vars)) ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"forall id0 : ident,\n~ (id = id0 \\/ In id0 (var_names vars)) ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0)","proofString":"intros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) : e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars)))","proofString":"exploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) : ~ In id0 (var_names vars).","conclusion":"~ In id0 (var_names vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars)))","proofString":"tauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0 ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te ! id0 ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars)))","proofString":"intros [X Y].\nrewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0) : e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0)","proofString":"rewrite X; rewrite Y.\nsplit; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0) : (PTree.set id (b1, ty) e) ! id0 = e ! id0 /\\ te ! id0 = te ! id0.","conclusion":"(PTree.set id (b1, ty) e) ! id0 = e ! id0 /\\ te ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0)","proofString":"split; auto.\napply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0) : (PTree.set id (b1, ty) e) ! id0 = e ! id0.","conclusion":"(PTree.set id (b1, ty) e) ! id0 = e ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0)","proofString":"apply PTree.gso.\nintuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0) : id0 <> id.","conclusion":"id0 <> id","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = true) (j1 : meminj) (A : Mem.inject j1 m1 tm) (B : inject_incr j j1) (C : j1 b1 = None) (D : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge te tm (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = te ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te' ! id1 = te ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = te ! id0)","proofString":"intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false)","proofString":"exploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [j1 [tm1 [tb1 [A [B [C [D E]]]]]]].\nexploit IHalloc_variables; eauto.\ninstantiate (1 := PTree.set id (tb1, ty) te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) : exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"exists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b)","proofString":"exploit IHalloc_variables; eauto.\ninstantiate (1 := PTree.set id (tb1, ty) te).\nintros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) : (exists (j' : meminj) (te' : env) (tm' : mem),\n   alloc_variables tge (PTree.set id (tb1, ty) te) tm1\n     (remove_lifted cenv vars) te' tm' /\\\n   Mem.inject j' m2 tm' /\\\n   inject_incr j1 j' /\\\n   (forall b : block, Mem.valid_block m1 b -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) ->\n    ~ Mem.valid_block tm1 b' ->\n    exists (id0 : positive) (ty0 : type),\n      e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n   (forall (id0 : ident) (ty0 : type),\n    In (id0, ty0) vars ->\n    exists b : block,\n      e2 ! id0 = Some (b, ty0) /\\\n      (if VSet.mem id0 cenv\n       then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n       else\n        exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n   (forall id0 : ident,\n    ~ In id0 (var_names vars) ->\n    e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\n    te' ! id0 = (PTree.set id (tb1, ty) te) ! id0)) ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(exists (j' : meminj) (te' : env) (tm' : mem),\n   alloc_variables tge (PTree.set id (tb1, ty) te) tm1\n     (remove_lifted cenv vars) te' tm' /\\\n   Mem.inject j' m2 tm' /\\\n   inject_incr j1 j' /\\\n   (forall b : block, Mem.valid_block m1 b -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) ->\n    ~ Mem.valid_block tm1 b' ->\n    exists (id0 : positive) (ty0 : type),\n      e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n   (forall (id0 : ident) (ty0 : type),\n    In (id0, ty0) vars ->\n    exists b : block,\n      e2 ! id0 = Some (b, ty0) /\\\n      (if VSet.mem id0 cenv\n       then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n       else\n        exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n   (forall id0 : ident,\n    ~ In id0 (var_names vars) ->\n    e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\n    te' ! id0 = (PTree.set id (tb1, ty) te) ! id0)) ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j' : meminj) (te' : env) (tm' : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te' tm' /\\\n  Mem.inject j' m2 tm' /\\\n  inject_incr j0 j' /\\\n  (forall b : block, Mem.valid_block m1 b -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm0 b' -> j' b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te' ! id0 = te0 ! id0 /\\ j' b = None\n      else\n       exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te' ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b)","proofString":"intros [j' [te' [tm' [J [K [L [M [N [Q [O P]]]]]]]]]].\nexists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : exists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j j'0 /\\\n  (forall b : block, Mem.valid_block m b -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm b' -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te'0 ! id0 = te ! id0).","conclusion":"exists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te tm\n    (if negb false\n     then (id, ty) :: remove_lifted cenv vars\n     else remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j j'0 /\\\n  (forall b : block, Mem.valid_block m b -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm b' -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ (id = id0 \\/ In id0 (var_names vars)) ->\n   e2 ! id0 = e ! id0 /\\ te'0 ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"exists j'; exists te'; exists tm'.\nsplit.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : alloc_variables tge te tm\n  (if negb false\n   then (id, ty) :: remove_lifted cenv vars\n   else remove_lifted cenv vars) te' tm' /\\\nMem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"alloc_variables tge te tm\n  (if negb false\n   then (id, ty) :: remove_lifted cenv vars\n   else remove_lifted cenv vars) te' tm' /\\\nMem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split.\nsimpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto.\nsplit.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : alloc_variables tge te tm\n  (if negb false\n   then (id, ty) :: remove_lifted cenv vars\n   else remove_lifted cenv vars) te' tm'.","conclusion":"alloc_variables tge te tm\n  (if negb false\n   then (id, ty) :: remove_lifted cenv vars\n   else remove_lifted cenv vars) te' tm'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"simpl.\neconstructor; eauto.\nrewrite comp_env_preserved; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : alloc_variables tge te tm ((id, ty) :: remove_lifted cenv vars) te' tm'.","conclusion":"alloc_variables tge te tm ((id, ty) :: remove_lifted cenv vars) te' tm'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"econstructor; eauto.\nrewrite comp_env_preserved; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : Mem.alloc tm 0 (sizeof tge ty) = (tm1, tb1).","conclusion":"Mem.alloc tm 0 (sizeof tge ty) = (tm1, tb1)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"rewrite comp_env_preserved; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : Mem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"Mem.inject j' m2 tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split.\nauto.\nsplit.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : Mem.inject j' m2 tm'.","conclusion":"Mem.inject j' m2 tm'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : inject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"inject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split.\neapply inject_incr_trans; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : inject_incr j j'.","conclusion":"inject_incr j j'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"eapply inject_incr_trans; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split.\nintros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : forall b : block, Mem.valid_block m b -> j' b = j b.","conclusion":"forall b : block, Mem.valid_block m b -> j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"intros.\ntransitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b) : j' b = j b.","conclusion":"j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"transitivity (j1 b).\napply M.\neapply Mem.valid_block_alloc; eauto.\napply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b) : j' b = j1 b.","conclusion":"j' b = j1 b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"apply M.\neapply Mem.valid_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b) : Mem.valid_block m1 b.","conclusion":"Mem.valid_block m1 b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"eapply Mem.valid_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b) : j1 b = j b.","conclusion":"j1 b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"apply E.\napply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b) : b <> b1.","conclusion":"b <> b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"apply Mem.valid_not_valid_diff with m; auto.\neapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b) : ~ Mem.valid_block m b1.","conclusion":"~ Mem.valid_block m b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta : Z),\n   j'0 b0 = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (H1 : Mem.valid_block m b)","proofString":"eapply Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : (forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split.\nintros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto.\nsplit.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b.","conclusion":"forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"intros.\ntransitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') : j' b = j b.","conclusion":"j' b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"transitivity (j1 b).\neapply N; eauto.\neapply Mem.valid_block_alloc; eauto.\ndestruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') : j' b = j1 b.","conclusion":"j' b = j1 b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"eapply N; eauto.\neapply Mem.valid_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') : Mem.valid_block tm1 b'.","conclusion":"Mem.valid_block tm1 b'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"eapply Mem.valid_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') : j1 b = j b.","conclusion":"j1 b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"destruct (eq_block b b1); auto.\nsubst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') (e0 : b = b1) : j1 b = j b.","conclusion":"j1 b = j b","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : Mem.valid_block tm b') (e0 : b = b1)","proofString":"subst.\nassert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') : j1 b1 = j b1.","conclusion":"j1 b1 = j b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"assert (j' b1 = j1 b1).\napply M.\neapply Mem.valid_new_block; eauto.\nrewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') : j' b1 = j1 b1.","conclusion":"j' b1 = j1 b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"apply M.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') : Mem.valid_block m1 b1.","conclusion":"Mem.valid_block m1 b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b')","proofString":"eapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1) : j1 b1 = j b1.","conclusion":"j1 b1 = j b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j' b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1)","proofString":"rewrite H4 in H1.\nrewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j1 b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1) : j1 b1 = j b1.","conclusion":"j1 b1 = j b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : j1 b1 = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1)","proofString":"rewrite D in H1.\ninv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : Some (tb1, 0) = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1) : j1 b1 = j b1.","conclusion":"j1 b1 = j b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta0 : Z),\n   j'0 b = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta0 : Z),\nj' b = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b' : block) (delta : Z) (H1 : Some (tb1, 0) = Some (b', delta)) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1)","proofString":"inv H1.\neelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta : Z),\n   j'0 b = Some (b'0, delta) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta : Z),\n   j'0 b = Some (b'0, delta) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (b' : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, b')) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (b', 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (b', ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta = 0) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (b', ty) te) ! id0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (b', ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1) : j1 b1 = j b1.","conclusion":"j1 b1 = j b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta : Z),\n   j'0 b = Some (b'0, delta) -> Mem.valid_block tm0 b'0 -> j'0 b = j0 b) /\\\n  (forall (b b'0 : block) (delta : Z),\n   j'0 b = Some (b'0, delta) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (b' : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, b')) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (b', 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (b', ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm1 b'0 -> j' b = j1 b) (Q : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta = 0) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (b', ty) te) ! id0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (b', ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (H3 : Mem.valid_block tm b') (H4 : j' b1 = j1 b1)","proofString":"eelim Mem.fresh_block_alloc; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : (forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) ->\n ~ Mem.valid_block tm b' ->\n exists (id0 : positive) (ty0 : type),\n   e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split.\nintros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia.\nsplit.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0.","conclusion":"forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"intros.\ndestruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b') : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b')","proofString":"destruct (eq_block b' tb1).\nsubst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto.\neapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b') (e0 : b' = tb1) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b') (e0 : b' = tb1)","proofString":"subst b'.\nrewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j' b = Some (tb1, delta)) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j' b = Some (tb1, delta))","proofString":"rewrite (N _ _ _ H1) in H1.\ndestruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b = Some (tb1, delta)) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b = Some (tb1, delta))","proofString":"destruct (eq_block b b1).\nsubst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto.\nrewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b = Some (tb1, delta)) (e0 : b = b1) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b = Some (tb1, delta)) (e0 : b = b1)","proofString":"subst b.\nrewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta0 : Z),\n   j'0 b = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta0 : Z),\n   j'0 b = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta0 : Z),\nj' b = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta0 : Z),\nj' b = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b1 = Some (tb1, delta)) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta0 : Z),\n   j'0 b = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta0 : Z),\n   j'0 b = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta0 : Z),\nj' b = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta0 : Z),\nj' b = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b1 = Some (tb1, delta))","proofString":"rewrite D in H1; inv H1.\nexploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ 0 = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ 0 = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1)","proofString":"exploit (P id); auto.\nintros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) : e2 ! id = (PTree.set id (b1, ty) e) ! id /\\\nte' ! id = (PTree.set id (tb1, ty) te) ! id ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ 0 = 0.","conclusion":"e2 ! id = (PTree.set id (b1, ty) e) ! id /\\\nte' ! id = (PTree.set id (tb1, ty) te) ! id ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ 0 = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1)","proofString":"intros [X Y].\nexists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ 0 = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b1, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ 0 = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"exists id; exists ty.\nrewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : e2 ! id = Some (b1, ty) /\\ te' ! id = Some (tb1, ty) /\\ 0 = 0.","conclusion":"e2 ! id = Some (b1, ty) /\\ te' ! id = Some (tb1, ty) /\\ 0 = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"rewrite X; rewrite Y.\nrepeat rewrite PTree.gss.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : (PTree.set id (b1, ty) e) ! id = Some (b1, ty) /\\\n(PTree.set id (tb1, ty) te) ! id = Some (tb1, ty) /\\ 0 = 0.","conclusion":"(PTree.set id (b1, ty) e) ! id = Some (b1, ty) /\\\n(PTree.set id (tb1, ty) te) ! id = Some (tb1, ty) /\\ 0 = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"repeat rewrite PTree.gss.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : Some (b1, ty) = Some (b1, ty) /\\ Some (tb1, ty) = Some (tb1, ty) /\\ 0 = 0.","conclusion":"Some (b1, ty) = Some (b1, ty) /\\ Some (tb1, ty) = Some (tb1, ty) /\\ 0 = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H3 : ~ Mem.valid_block tm tb1) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b = Some (tb1, delta)) (n : b <> b1) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j1 b = Some (tb1, delta)) (n : b <> b1)","proofString":"rewrite E in H1; auto.\nelim H3.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j b = Some (tb1, delta)) (n : b <> b1) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (tb1, ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j b = Some (tb1, delta)) (n : b <> b1)","proofString":"elim H3.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j b = Some (tb1, delta)) (n : b <> b1) : Mem.valid_block tm tb1.","conclusion":"Mem.valid_block tm tb1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j b = Some (tb1, delta)) (n : b <> b1)","proofString":"eapply Mem.mi_mappedblocks; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j' b = Some (tb1, delta)) : Mem.valid_block tm1 tb1.","conclusion":"Mem.valid_block tm1 tb1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) -> Mem.valid_block tm0 b' -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b' : block) (delta0 : Z),\n   j'0 b0 = Some (b', delta0) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) -> Mem.valid_block tm1 b' -> j' b0 = j1 b0) (Q : forall (b0 b' : block) (delta0 : Z),\nj' b0 = Some (b', delta0) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b : block) (delta : Z) (H3 : ~ Mem.valid_block tm tb1) (H1 : j' b = Some (tb1, delta))","proofString":"eapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b') (n : b' <> tb1) : exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0.","conclusion":"exists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b') (n : b' <> tb1)","proofString":"eapply Q; eauto.\nunfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b') (n : b' <> tb1) : ~ Mem.valid_block tm1 b'.","conclusion":"~ Mem.valid_block tm1 b'","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Mem.valid_block m1 b0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) -> Mem.valid_block tm0 b'0 -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Mem.valid_block tm0 b'0 ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Mem.valid_block m1 b0 -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm1 b'0 -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm1 b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Mem.valid_block tm b') (n : b' <> tb1)","proofString":"unfold Mem.valid_block in *.\nexploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Plt b0 (Mem.nextblock m1) -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   Plt b'0 (Mem.nextblock tm0) -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Plt b'0 (Mem.nextblock tm0) ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Plt b0 (Mem.nextblock m1) -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Plt b'0 (Mem.nextblock tm1) -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Plt b'0 (Mem.nextblock tm1) ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Plt b' (Mem.nextblock tm)) (n : b' <> tb1) : ~ Plt b' (Mem.nextblock tm1).","conclusion":"~ Plt b' (Mem.nextblock tm1)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b0 : block, Plt b0 (Mem.nextblock m1) -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   Plt b'0 (Mem.nextblock tm0) -> j'0 b0 = j0 b0) /\\\n  (forall (b0 b'0 : block) (delta0 : Z),\n   j'0 b0 = Some (b'0, delta0) ->\n   ~ Plt b'0 (Mem.nextblock tm0) ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b0, ty0) /\\ te'0 ! id0 = Some (b'0, ty0) /\\ delta0 = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b0 : block,\n     e2 ! id0 = Some (b0, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b0 = None\n      else\n       exists tb : block,\n         te'0 ! id0 = Some (tb, ty0) /\\ j'0 b0 = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b0 : block, b0 <> b1 -> j1 b0 = j b0) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b0 : block, Plt b0 (Mem.nextblock m1) -> j' b0 = j1 b0) (N : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Plt b'0 (Mem.nextblock tm1) -> j' b0 = j1 b0) (Q : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Plt b'0 (Mem.nextblock tm1) ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b0, ty0) /\\ te' ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e2 ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b0 = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (b b' : block) (delta : Z) (H1 : j' b = Some (b', delta)) (H3 : ~ Plt b' (Mem.nextblock tm)) (n : b' <> tb1)","proofString":"exploit Mem.nextblock_alloc.\neexact A.\nexploit Mem.alloc_result.\neexact A.\nunfold block; extlia."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : (forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0).","conclusion":"(forall (id0 : ident) (ty0 : type),\n (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\n exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = te ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) /\\\n(forall id0 : ident,\n ~ (id = id0 \\/ In id0 (var_names vars)) ->\n e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split.\nintros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto.\nintros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : forall (id0 : ident) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"forall (id0 : ident) (ty0 : type),\n(id, ty) = (id0, ty0) \\/ In (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"intros.\ndestruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) : exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars)","proofString":"destruct (ident_eq id0 id).\nsubst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto.\nexploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (e0 : id0 = id) : exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (e0 : id0 = id)","proofString":"subst id0.\nassert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) : exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars)","proofString":"assert (ty0 = ty).\ndestruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto.\nsubst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) : ty0 = ty.","conclusion":"ty0 = ty","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars)","proofString":"destruct H1.\ncongruence.\nelim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0)) : ty0 = ty.","conclusion":"ty0 = ty","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0))","proofString":"congruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : ty0 = ty.","conclusion":"ty0 = ty","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"elim H5.\nunfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : In id (var_names vars).","conclusion":"In id (var_names vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"unfold var_names.\nchange id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : In id (map fst vars).","conclusion":"In id (map fst vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"change id with (fst (id, ty0)).\napply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars) : In (fst (id, ty0)) (map fst vars).","conclusion":"In (fst (id, ty0)) (map fst vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : In (id, ty0) vars)","proofString":"apply in_map; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) (H3 : ty0 = ty) : exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty0) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty1 : type),\n     e2 ! id0 = Some (b, ty1) /\\ te'0 ! id0 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty1 : type),\n   In (id0, ty1) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty1) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty1 : type),\n  e2 ! id0 = Some (b, ty1) /\\ te' ! id0 = Some (b', ty1) /\\ delta = 0) (O : forall (id0 : ident) (ty1 : type),\nIn (id0, ty1) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty1) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (ty0 : type) (H1 : (id, ty) = (id, ty0) \\/ In (id, ty0) vars) (H3 : ty0 = ty)","proofString":"subst ty0.\nexploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) : exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars)","proofString":"exploit P; eauto.\nintros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) : e2 ! id = (PTree.set id (b1, ty) e) ! id /\\\nte' ! id = (PTree.set id (tb1, ty) te) ! id ->\nexists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"e2 ! id = (PTree.set id (b1, ty) e) ! id /\\\nte' ! id = (PTree.set id (tb1, ty) te) ! id ->\nexists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars)","proofString":"intros [X Y].\nrewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te' ! id = te ! id /\\ j' b = None\n   else exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"rewrite Heqb.\nrewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id = Some (b, ty) /\\\n  (exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"rewrite X.\nrewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  (exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  (exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"rewrite Y.\nexists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  (exists tb : block,\n     (PTree.set id (tb1, ty) te) ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  (PTree.set id (b1, ty) e) ! id = Some (b, ty) /\\\n  (exists tb : block,\n     (PTree.set id (tb1, ty) te) ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"exists b1.\nsplit.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : (PTree.set id (b1, ty) e) ! id = Some (b1, ty) /\\\n(exists tb : block,\n   (PTree.set id (tb1, ty) te) ! id = Some (tb, ty) /\\ j' b1 = Some (tb, 0)).","conclusion":"(PTree.set id (b1, ty) e) ! id = Some (b1, ty) /\\\n(exists tb : block,\n   (PTree.set id (tb1, ty) te) ! id = Some (tb, ty) /\\ j' b1 = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"split.\napply PTree.gss.\nexists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : (PTree.set id (b1, ty) e) ! id = Some (b1, ty).","conclusion":"(PTree.set id (b1, ty) e) ! id = Some (b1, ty)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"apply PTree.gss."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : exists tb : block,\n  (PTree.set id (tb1, ty) te) ! id = Some (tb, ty) /\\ j' b1 = Some (tb, 0).","conclusion":"exists tb : block,\n  (PTree.set id (tb1, ty) te) ! id = Some (tb, ty) /\\ j' b1 = Some (tb, 0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"exists tb1; split.\napply PTree.gss.\nrewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : (PTree.set id (tb1, ty) te) ! id = Some (tb1, ty).","conclusion":"(PTree.set id (tb1, ty) te) ! id = Some (tb1, ty)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"apply PTree.gss."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : j' b1 = Some (tb1, 0).","conclusion":"j' b1 = Some (tb1, 0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"rewrite M.\nauto.\neapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : j1 b1 = Some (tb1, 0).","conclusion":"j1 b1 = Some (tb1, 0)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id) : Mem.valid_block m1 b1.","conclusion":"Mem.valid_block m1 b1","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) (H1 : (id, ty) = (id, ty) \\/ In (id, ty) vars) (X : e2 ! id = (PTree.set id (b1, ty) e) ! id) (Y : te' ! id = (PTree.set id (tb1, ty) te) ! id)","proofString":"eapply Mem.valid_new_block; eauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id) : exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"exists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id)","proofString":"exploit (O id0 ty0).\ndestruct H1.\ncongruence.\nauto.\nrewrite PTree.gso; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id) : In (id0, ty0) vars.","conclusion":"In (id0, ty0) vars","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id)","proofString":"destruct H1.\ncongruence.\nauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0)) (n : id0 <> id) : In (id0, ty0) vars.","conclusion":"In (id0, ty0) vars","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0)) (n : id0 <> id)","proofString":"congruence."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : In (id0, ty0) vars) (n : id0 <> id) : In (id0, ty0) vars.","conclusion":"In (id0, ty0) vars","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : In (id0, ty0) vars) (n : id0 <> id)","proofString":"auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id) : (exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0)).","conclusion":"(exists b : block,\n   e2 ! id0 = Some (b, ty0) /\\\n   (if VSet.mem id0 cenv\n    then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n    else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = te ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty1 : type),\n     e2 ! id1 = Some (b, ty1) /\\ te'0 ! id1 = Some (b', ty1) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty1 : type),\n   In (id1, ty1) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty1) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty1) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty1 : type),\n  e2 ! id1 = Some (b, ty1) /\\ te' ! id1 = Some (b', ty1) /\\ delta = 0) (O : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty1) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (ty0 : type) (H1 : (id, ty) = (id0, ty0) \\/ In (id0, ty0) vars) (n : id0 <> id)","proofString":"rewrite PTree.gso; auto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : forall id0 : ident,\n~ (id = id0 \\/ In id0 (var_names vars)) ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"forall id0 : ident,\n~ (id = id0 \\/ In id0 (var_names vars)) ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id0 : positive) (ty0 : type),\n     e2 ! id0 = Some (b, ty0) /\\ te'0 ! id0 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id0 : ident) (ty0 : type),\n   In (id0, ty0) vars ->\n   exists b : block,\n     e2 ! id0 = Some (b, ty0) /\\\n     (if VSet.mem id0 cenv\n      then te'0 ! id0 = te0 ! id0 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id0 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id0 : ident,\n   ~ In id0 (var_names vars) ->\n   e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\ te'0 ! id0 = te0 ! id0)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id0 : positive) (ty0 : type),\n  e2 ! id0 = Some (b, ty0) /\\ te' ! id0 = Some (b', ty0) /\\ delta = 0) (O : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e2 ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te' ! id0 = (PTree.set id (tb1, ty) te) ! id0 /\\ j' b = None\n   else exists tb : block, te' ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"intros.\nexploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) : e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars)))","proofString":"exploit (P id0).\ntauto.\nintros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) : ~ In id0 (var_names vars).","conclusion":"~ In id0 (var_names vars)","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars)))","proofString":"tauto."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0 ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"e2 ! id0 = (PTree.set id (b1, ty) e) ! id0 /\\\nte' ! id0 = (PTree.set id (tb1, ty) te) ! id0 ->\ne2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars)))","proofString":"intros [X Y].\nrewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0.","conclusion":"e2 ! id0 = e ! id0 /\\ te' ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"rewrite X; rewrite Y.\nsplit; apply PTree.gso; intuition."},{"statement":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = (PTree.set id (tb1, ty) te) ! id0) : (PTree.set id (b1, ty) e) ! id0 = e ! id0 /\\\n(PTree.set id (tb1, ty) te) ! id0 = te ! id0.","conclusion":"(PTree.set id (b1, ty) e) ! id0 = e ! id0 /\\\n(PTree.set id (tb1, ty) te) ! id0 = te ! id0","hypotheses":"(cenv : compilenv) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (j0 : meminj) (tm0 : mem) (te0 : env),\nlist_norepet (var_names vars) ->\nMem.inject j0 m1 tm0 ->\nexists (j'0 : meminj) (te'0 : env) (tm'0 : mem),\n  alloc_variables tge te0 tm0 (remove_lifted cenv vars) te'0 tm'0 /\\\n  Mem.inject j'0 m2 tm'0 /\\\n  inject_incr j0 j'0 /\\\n  (forall b : block, Mem.valid_block m1 b -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm0 b' -> j'0 b = j0 b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) ->\n   ~ Mem.valid_block tm0 b' ->\n   exists (id1 : positive) (ty0 : type),\n     e2 ! id1 = Some (b, ty0) /\\ te'0 ! id1 = Some (b', ty0) /\\ delta = 0) /\\\n  (forall (id1 : ident) (ty0 : type),\n   In (id1, ty0) vars ->\n   exists b : block,\n     e2 ! id1 = Some (b, ty0) /\\\n     (if VSet.mem id1 cenv\n      then te'0 ! id1 = te0 ! id1 /\\ j'0 b = None\n      else\n       exists tb : block, te'0 ! id1 = Some (tb, ty0) /\\ j'0 b = Some (tb, 0))) /\\\n  (forall id1 : ident,\n   ~ In id1 (var_names vars) ->\n   e2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\ te'0 ! id1 = te0 ! id1)) (j : meminj) (tm : mem) (te : env) (H2 : Mem.inject j m tm) (H5 : ~ In id (var_names vars)) (H6 : list_norepet (var_names vars)) (Heqb : VSet.mem id cenv = false) (j1 : meminj) (tm1 : Mem.mem') (tb1 : block) (A : Mem.alloc tm 0 (sizeof ge ty) = (tm1, tb1)) (B : Mem.inject j1 m1 tm1) (C : inject_incr j j1) (D : j1 b1 = Some (tb1, 0)) (E : forall b : block, b <> b1 -> j1 b = j b) (j' : meminj) (te' : env) (tm' : mem) (J : alloc_variables tge (PTree.set id (tb1, ty) te) tm1 \n  (remove_lifted cenv vars) te' tm') (K : Mem.inject j' m2 tm') (L : inject_incr j1 j') (M : forall b : block, Mem.valid_block m1 b -> j' b = j1 b) (N : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm1 b' -> j' b = j1 b) (Q : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm1 b' ->\nexists (id1 : positive) (ty0 : type),\n  e2 ! id1 = Some (b, ty0) /\\ te' ! id1 = Some (b', ty0) /\\ delta = 0) (O : forall (id1 : ident) (ty0 : type),\nIn (id1, ty0) vars ->\nexists b : block,\n  e2 ! id1 = Some (b, ty0) /\\\n  (if VSet.mem id1 cenv\n   then te' ! id1 = (PTree.set id (tb1, ty) te) ! id1 /\\ j' b = None\n   else exists tb : block, te' ! id1 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (P : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne2 ! id1 = (PTree.set id (b1, ty) e) ! id1 /\\\nte' ! id1 = (PTree.set id (tb1, ty) te) ! id1) (id0 : ident) (H1 : ~ (id = id0 \\/ In id0 (var_names vars))) (X : e2 ! id0 = (PTree.set id (b1, ty) e) ! id0) (Y : te' ! id0 = (PTree.set id (tb1, ty) te) ! id0)","proofString":"split; apply PTree.gso; intuition."},{"statement":"(e : env) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : Mem.load chunk m b ofs = Some v.","conclusion":"Mem.load chunk m b ofs = Some v","hypotheses":"(e : env) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"auto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (chunk0 : memory_chunk) (b0 : block) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m1 b0 ofs0 = Some v0 -> Mem.load chunk0 m2 b0 ofs0 = Some v0) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v) : Mem.load chunk m2 b ofs = Some v.","conclusion":"Mem.load chunk m2 b ofs = Some v","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (chunk0 : memory_chunk) (b0 : block) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m1 b0 ofs0 = Some v0 -> Mem.load chunk0 m2 b0 ofs0 = Some v0) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v)","proofString":"apply IHalloc_variables.\neapply Mem.load_alloc_other; eauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (chunk0 : memory_chunk) (b0 : block) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m1 b0 ofs0 = Some v0 -> Mem.load chunk0 m2 b0 ofs0 = Some v0) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v) : Mem.load chunk m1 b ofs = Some v.","conclusion":"Mem.load chunk m1 b ofs = Some v","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (chunk0 : memory_chunk) (b0 : block) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m1 b0 ofs0 = Some v0 -> Mem.load chunk0 m2 b0 ofs0 = Some v0) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v)","proofString":"eapply Mem.load_alloc_other; eauto."},{"statement":"(ty : type) (chunk : memory_chunk) (H : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk) : size_chunk chunk <= sizeof ge ty.","conclusion":"size_chunk chunk <= sizeof ge ty","hypotheses":"(ty : type) (chunk : memory_chunk) (H : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk)","proofString":"assert (size_chunk chunk = sizeof ge ty).\ndestruct ty; try destruct i; try destruct s; try destruct f; inv H; auto;    unfold Mptr; simpl; destruct Archi.ptr64; auto.\nlia."},{"statement":"(ty : type) (chunk : memory_chunk) (H : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk) : size_chunk chunk = sizeof ge ty.","conclusion":"size_chunk chunk = sizeof ge ty","hypotheses":"(ty : type) (chunk : memory_chunk) (H : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk)","proofString":"destruct ty; try destruct i; try destruct s; try destruct f; inv H; auto;    unfold Mptr; simpl; destruct Archi.ptr64; auto."},{"statement":"(ty : type) (chunk : memory_chunk) (H : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk) (H0 : size_chunk chunk = sizeof ge ty) : size_chunk chunk <= sizeof ge ty.","conclusion":"size_chunk chunk <= sizeof ge ty","hypotheses":"(ty : type) (chunk : memory_chunk) (H : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk) (H0 : size_chunk chunk = sizeof ge ty)","proofString":"lia."},{"statement":"(e : env) (m : mem) (H : env_initial_value e m) : env_initial_value e m.","conclusion":"env_initial_value e m","hypotheses":"(e : env) (m : mem) (H : env_initial_value e m)","proofString":"auto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) : env_initial_value e2 m2.","conclusion":"env_initial_value e2 m2","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m)","proofString":"apply IHalloc_variables.\nred; intros.\nrewrite PTree.gsspec in H2.\ndestruct (peq id0 id).\ninv H2.\neapply Mem.load_alloc_same'; eauto.\nlia.\nrewrite Z.add_0_l.\neapply sizeof_by_value; eauto.\napply Z.divide_0_r.\neapply Mem.load_alloc_other; eauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) : env_initial_value (PTree.set id (b1, ty) e) m1.","conclusion":"env_initial_value (PTree.set id (b1, ty) e) m1","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m)","proofString":"red; intros.\nrewrite PTree.gsspec in H2.\ndestruct (peq id0 id).\ninv H2.\neapply Mem.load_alloc_same'; eauto.\nlia.\nrewrite Z.add_0_l.\neapply sizeof_by_value; eauto.\napply Z.divide_0_r.\neapply Mem.load_alloc_other; eauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (H2 : (PTree.set id (b1, ty) e) ! id0 = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk) : Mem.load chunk m1 b 0 = Some Vundef.","conclusion":"Mem.load chunk m1 b 0 = Some Vundef","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (H2 : (PTree.set id (b1, ty) e) ! id0 = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk)","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq id0 id).\ninv H2.\neapply Mem.load_alloc_same'; eauto.\nlia.\nrewrite Z.add_0_l.\neapply sizeof_by_value; eauto.\napply Z.divide_0_r.\neapply Mem.load_alloc_other; eauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (H2 : (if peq id0 id then Some (b1, ty) else e ! id0) = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk) : Mem.load chunk m1 b 0 = Some Vundef.","conclusion":"Mem.load chunk m1 b 0 = Some Vundef","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (H2 : (if peq id0 id then Some (b1, ty) else e ! id0) = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk)","proofString":"destruct (peq id0 id).\ninv H2.\neapply Mem.load_alloc_same'; eauto.\nlia.\nrewrite Z.add_0_l.\neapply sizeof_by_value; eauto.\napply Z.divide_0_r.\neapply Mem.load_alloc_other; eauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (e0 : id0 = id) (H2 : Some (b1, ty) = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk) : Mem.load chunk m1 b 0 = Some Vundef.","conclusion":"Mem.load chunk m1 b 0 = Some Vundef","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (e0 : id0 = id) (H2 : Some (b1, ty) = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk)","proofString":"inv H2.\neapply Mem.load_alloc_same'; eauto.\nlia.\nrewrite Z.add_0_l.\neapply sizeof_by_value; eauto.\napply Z.divide_0_r."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk) : Mem.load chunk m1 b 0 = Some Vundef.","conclusion":"Mem.load chunk m1 b 0 = Some Vundef","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk)","proofString":"eapply Mem.load_alloc_same'; eauto.\nlia.\nrewrite Z.add_0_l.\neapply sizeof_by_value; eauto.\napply Z.divide_0_r."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk) : 0 <= 0.","conclusion":"0 <= 0","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk)","proofString":"lia."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk) : 0 + size_chunk chunk <= sizeof ge ty0.","conclusion":"0 + size_chunk chunk <= sizeof ge ty0","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk)","proofString":"rewrite Z.add_0_l.\neapply sizeof_by_value; eauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk) : size_chunk chunk <= sizeof ge ty0.","conclusion":"size_chunk chunk <= sizeof ge ty0","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk)","proofString":"eapply sizeof_by_value; eauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk) : (align_chunk chunk | 0).","conclusion":"(align_chunk chunk | 0)","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (vars : list (ident * type)) (m1 : Mem.mem') (m2 : mem) (e2 : env) (b : block) (ty0 : type) (H : Mem.alloc m 0 (sizeof ge ty0) = (m1, b)) (H0 : alloc_variables ge (PTree.set id (b, ty0) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b, ty0) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (chunk : memory_chunk) (H3 : access_mode ty0 = By_value chunk)","proofString":"apply Z.divide_0_r."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (n : id0 <> id) (H2 : e ! id0 = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk) : Mem.load chunk m1 b 0 = Some Vundef.","conclusion":"Mem.load chunk m1 b 0 = Some Vundef","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : env_initial_value (PTree.set id (b1, ty) e) m1 -> env_initial_value e2 m2) (H1 : env_initial_value e m) (id0 : positive) (b : block) (ty0 : type) (chunk : memory_chunk) (n : id0 <> id) (H2 : e ! id0 = Some (b, ty0)) (H3 : access_mode ty0 = By_value chunk)","proofString":"eapply Mem.load_alloc_other; eauto."},{"statement":"(id : positive) (ty : type) (H : False) : (PTree.empty val) ! id = Some Vundef.","conclusion":"(PTree.empty val) ! id = Some Vundef","hypotheses":"(id : positive) (ty : type) (H : False)","proofString":"contradiction."},{"statement":"(id : positive) (ty : type) (a : positive * type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : a = (id, ty) \\/ In (id, ty) vars) : (let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome Vundef.","conclusion":"(let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome Vundef","hypotheses":"(id : positive) (ty : type) (a : positive * type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : a = (id, ty) \\/ In (id, ty) vars)","proofString":"destruct H.\nsubst a.\napply PTree.gss.\ndestruct a as [id1 ty1].\nrewrite PTree.gsspec.\ndestruct (peq id id1); auto."},{"statement":"(id : positive) (ty : type) (a : positive * type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : a = (id, ty)) : (let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome Vundef.","conclusion":"(let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome Vundef","hypotheses":"(id : positive) (ty : type) (a : positive * type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : a = (id, ty))","proofString":"subst a.\napply PTree.gss."},{"statement":"(id : positive) (ty : type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) : (PTree.set id Vundef (create_undef_temps vars)) ! id = Some Vundef.","conclusion":"(PTree.set id Vundef (create_undef_temps vars)) ! id = Some Vundef","hypotheses":"(id : positive) (ty : type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef)","proofString":"apply PTree.gss."},{"statement":"(id : positive) (ty : type) (a : positive * type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : In (id, ty) vars) : (let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome Vundef.","conclusion":"(let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome Vundef","hypotheses":"(id : positive) (ty : type) (a : positive * type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : In (id, ty) vars)","proofString":"destruct a as [id1 ty1].\nrewrite PTree.gsspec.\ndestruct (peq id id1); auto."},{"statement":"(id : positive) (ty : type) (id1 : positive) (ty1 : type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : In (id, ty) vars) : (PTree.set id1 Vundef (create_undef_temps vars)) ! id = Some Vundef.","conclusion":"(PTree.set id1 Vundef (create_undef_temps vars)) ! id = Some Vundef","hypotheses":"(id : positive) (ty : type) (id1 : positive) (ty1 : type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : In (id, ty) vars)","proofString":"rewrite PTree.gsspec.\ndestruct (peq id id1); auto."},{"statement":"(id : positive) (ty : type) (id1 : positive) (ty1 : type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : In (id, ty) vars) : (if peq id id1 then Some Vundef else (create_undef_temps vars) ! id) =\nSome Vundef.","conclusion":"(if peq id id1 then Some Vundef else (create_undef_temps vars) ! id) =\nSome Vundef","hypotheses":"(id : positive) (ty : type) (id1 : positive) (ty1 : type) (vars : list (positive * type)) (IHvars : In (id, ty) vars -> (create_undef_temps vars) ! id = Some Vundef) (H : In (id, ty) vars)","proofString":"destruct (peq id id1); auto."},{"statement":"(id : positive) (v : val) (H : (PTree.empty val) ! id = Some v) : v = Vundef /\\ False.","conclusion":"v = Vundef /\\ False","hypotheses":"(id : positive) (v : val) (H : (PTree.empty val) ! id = Some v)","proofString":"rewrite PTree.gempty in H; congruence."},{"statement":"(a : ident * type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (H : (let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome v) : v = Vundef /\\ (fst a = id \\/ In id (var_names vars)).","conclusion":"v = Vundef /\\ (fst a = id \\/ In id (var_names vars))","hypotheses":"(a : ident * type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (H : (let (id0, _) := a in PTree.set id0 Vundef (create_undef_temps vars)) ! id =\nSome v)","proofString":"destruct a as [id1 ty1].\nrewrite PTree.gsspec in H.\ndestruct (peq id id1).\ninv H.\nauto.\nexploit IHvars; eauto.\ntauto."},{"statement":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (H : (PTree.set id1 Vundef (create_undef_temps vars)) ! id = Some v) : v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars)).","conclusion":"v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars))","hypotheses":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (H : (PTree.set id1 Vundef (create_undef_temps vars)) ! id = Some v)","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq id id1).\ninv H.\nauto.\nexploit IHvars; eauto.\ntauto."},{"statement":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (H : (if peq id id1 then Some Vundef else (create_undef_temps vars) ! id) = Some v) : v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars)).","conclusion":"v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars))","hypotheses":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (H : (if peq id id1 then Some Vundef else (create_undef_temps vars) ! id) = Some v)","proofString":"destruct (peq id id1).\ninv H.\nauto.\nexploit IHvars; eauto.\ntauto."},{"statement":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (e : id = id1) (H : Some Vundef = Some v) : v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars)).","conclusion":"v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars))","hypotheses":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (e : id = id1) (H : Some Vundef = Some v)","proofString":"inv H.\nauto."},{"statement":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id : positive) (v : val),\n(create_undef_temps vars) ! id = Some v ->\nv = Vundef /\\ In id (var_names vars)) : Vundef = Vundef /\\ (fst (id1, ty1) = id1 \\/ In id1 (var_names vars)).","conclusion":"Vundef = Vundef /\\ (fst (id1, ty1) = id1 \\/ In id1 (var_names vars))","hypotheses":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id : positive) (v : val),\n(create_undef_temps vars) ! id = Some v ->\nv = Vundef /\\ In id (var_names vars))","proofString":"auto."},{"statement":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (n : id <> id1) (H : (create_undef_temps vars) ! id = Some v) : v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars)).","conclusion":"v = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars))","hypotheses":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (n : id <> id1) (H : (create_undef_temps vars) ! id = Some v)","proofString":"exploit IHvars; eauto.\ntauto."},{"statement":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (n : id <> id1) (H : (create_undef_temps vars) ! id = Some v) : v = Vundef /\\ In id (var_names vars) ->\nv = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars)).","conclusion":"v = Vundef /\\ In id (var_names vars) ->\nv = Vundef /\\ (fst (id1, ty1) = id \\/ In id (var_names vars))","hypotheses":"(id1 : ident) (ty1 : type) (vars : list (ident * type)) (IHvars : forall (id0 : positive) (v0 : val),\n(create_undef_temps vars) ! id0 = Some v0 ->\nv0 = Vundef /\\ In id0 (var_names vars)) (id : positive) (v : val) (n : id <> id1) (H : (create_undef_temps vars) ! id = Some v)","proofString":"tauto."},{"statement":"forall (id : ident) (l1 l2 : list (ident * type)),\n(In id (var_names l1) -> In id (var_names l2)) ->\n(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id.","conclusion":"forall (id : ident) (l1 l2 : list (ident * type)),\n(In id (var_names l1) -> In id (var_names l2)) ->\n(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id","hypotheses":"","proofString":"intros.\ndestruct ((create_undef_temps l1)!id) as [v1|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [A B].\nsubst v1.\nexploit list_in_map_inv.\nunfold var_names in H.\napply H.\neexact B.\nintros [[id1 ty1] [P Q]].\nsimpl in P; subst id1.\nright; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) : (create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id.","conclusion":"(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2))","proofString":"destruct ((create_undef_temps l1)!id) as [v1|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [A B].\nsubst v1.\nexploit list_in_map_inv.\nunfold var_names in H.\napply H.\neexact B.\nintros [[id1 ty1] [P Q]].\nsimpl in P; subst id1.\nright; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (v1 : val) (Heqo : (create_undef_temps l1) ! id = Some v1) : Some v1 = None \\/ Some v1 = (create_undef_temps l2) ! id.","conclusion":"Some v1 = None \\/ Some v1 = (create_undef_temps l2) ! id","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (v1 : val) (Heqo : (create_undef_temps l1) ! id = Some v1)","proofString":"exploit create_undef_temps_inv; eauto.\nintros [A B].\nsubst v1.\nexploit list_in_map_inv.\nunfold var_names in H.\napply H.\neexact B.\nintros [[id1 ty1] [P Q]].\nsimpl in P; subst id1.\nright; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (v1 : val) (Heqo : (create_undef_temps l1) ! id = Some v1) : v1 = Vundef /\\ In id (var_names l1) ->\nSome v1 = None \\/ Some v1 = (create_undef_temps l2) ! id.","conclusion":"v1 = Vundef /\\ In id (var_names l1) ->\nSome v1 = None \\/ Some v1 = (create_undef_temps l2) ! id","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (v1 : val) (Heqo : (create_undef_temps l1) ! id = Some v1)","proofString":"intros [A B].\nsubst v1.\nexploit list_in_map_inv.\nunfold var_names in H.\napply H.\neexact B.\nintros [[id1 ty1] [P Q]].\nsimpl in P; subst id1.\nright; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (v1 : val) (Heqo : (create_undef_temps l1) ! id = Some v1) (A : v1 = Vundef) (B : In id (var_names l1)) : Some v1 = None \\/ Some v1 = (create_undef_temps l2) ! id.","conclusion":"Some v1 = None \\/ Some v1 = (create_undef_temps l2) ! id","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (v1 : val) (Heqo : (create_undef_temps l1) ! id = Some v1) (A : v1 = Vundef) (B : In id (var_names l1))","proofString":"subst v1.\nexploit list_in_map_inv.\nunfold var_names in H.\napply H.\neexact B.\nintros [[id1 ty1] [P Q]].\nsimpl in P; subst id1.\nright; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1)) : Some Vundef = None \\/ Some Vundef = (create_undef_temps l2) ! id.","conclusion":"Some Vundef = None \\/ Some Vundef = (create_undef_temps l2) ! id","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1))","proofString":"exploit list_in_map_inv.\nunfold var_names in H.\napply H.\neexact B.\nintros [[id1 ty1] [P Q]].\nsimpl in P; subst id1.\nright; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (map fst l1) -> In id (map fst l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1)) : In id (map fst l1).","conclusion":"In id (map fst l1)","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (map fst l1) -> In id (map fst l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1))","proofString":"eexact B."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1)) (id1 : ident) (ty1 : type) (P : id = fst (id1, ty1)) (Q : In (id1, ty1) l2) : Some Vundef = None \\/ Some Vundef = (create_undef_temps l2) ! id.","conclusion":"Some Vundef = None \\/ Some Vundef = (create_undef_temps l2) ! id","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1)) (id1 : ident) (ty1 : type) (P : id = fst (id1, ty1)) (Q : In (id1, ty1) l2)","proofString":"simpl in P; subst id1.\nright; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1)) (ty1 : type) (Q : In (id, ty1) l2) : Some Vundef = None \\/ Some Vundef = (create_undef_temps l2) ! id.","conclusion":"Some Vundef = None \\/ Some Vundef = (create_undef_temps l2) ! id","hypotheses":"(id : ident) (l1 l2 : list (ident * type)) (H : In id (var_names l1) -> In id (var_names l2)) (Heqo : (create_undef_temps l1) ! id = Some Vundef) (B : In id (var_names l1)) (ty1 : type) (Q : In (id, ty1) l2)","proofString":"right; symmetry; eapply create_undef_temps_charact; eauto."},{"statement":"(H : forall (id : ident) (l1 l2 : list (ident * type)),\n(In id (var_names l1) -> In id (var_names l2)) ->\n(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id) : forall (id : ident) (l1 l2 : list (ident * type)),\nIn id (var_names l1) <-> In id (var_names l2) ->\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id.","conclusion":"forall (id : ident) (l1 l2 : list (ident * type)),\nIn id (var_names l1) <-> In id (var_names l2) ->\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id","hypotheses":"(H : forall (id : ident) (l1 l2 : list (ident * type)),\n(In id (var_names l1) -> In id (var_names l2)) ->\n(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id)","proofString":"intros.\nexploit (H id l1 l2).\ntauto.\nexploit (H id l2 l1).\ntauto.\nintuition congruence."},{"statement":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2)) : (create_undef_temps l1) ! id = (create_undef_temps l2) ! id.","conclusion":"(create_undef_temps l1) ! id = (create_undef_temps l2) ! id","hypotheses":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2))","proofString":"exploit (H id l1 l2).\ntauto.\nexploit (H id l2 l1).\ntauto.\nintuition congruence."},{"statement":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2)) : In id (var_names l1) -> In id (var_names l2).","conclusion":"In id (var_names l1) -> In id (var_names l2)","hypotheses":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2))","proofString":"tauto."},{"statement":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2)) : (create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id ->\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id.","conclusion":"(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id ->\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id","hypotheses":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2))","proofString":"exploit (H id l2 l1).\ntauto.\nintuition congruence."},{"statement":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2)) : In id (var_names l2) -> In id (var_names l1).","conclusion":"In id (var_names l2) -> In id (var_names l1)","hypotheses":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2))","proofString":"tauto."},{"statement":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2)) : (create_undef_temps l2) ! id = None \\/\n(create_undef_temps l2) ! id = (create_undef_temps l1) ! id ->\n(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id ->\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id.","conclusion":"(create_undef_temps l2) ! id = None \\/\n(create_undef_temps l2) ! id = (create_undef_temps l1) ! id ->\n(create_undef_temps l1) ! id = None \\/\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id ->\n(create_undef_temps l1) ! id = (create_undef_temps l2) ! id","hypotheses":"(H : forall (id0 : ident) (l0 l3 : list (ident * type)),\n(In id0 (var_names l0) -> In id0 (var_names l3)) ->\n(create_undef_temps l0) ! id0 = None \\/\n(create_undef_temps l0) ! id0 = (create_undef_temps l3) ! id0) (id : ident) (l1 l2 : list (ident * type)) (H0 : In id (var_names l1) <-> In id (var_names l2))","proofString":"intuition congruence."},{"statement":"(vars1 vars2 : list (ident * type)) : var_names (vars1 ++ vars2) = var_names vars1 ++ var_names vars2.","conclusion":"var_names (vars1 ++ vars2) = var_names vars1 ++ var_names vars2","hypotheses":"(vars1 vars2 : list (ident * type))","proofString":"apply map_app."},{"statement":"(A : Type) (f : A -> bool) (l2 : list A) : filter f l2 = filter f l2.","conclusion":"filter f l2 = filter f l2","hypotheses":"(A : Type) (f : A -> bool) (l2 : list A)","proofString":"auto."},{"statement":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A) : (if f a then a :: filter f (l1 ++ l2) else filter f (l1 ++ l2)) =\n(if f a then a :: filter f l1 else filter f l1) ++ filter f l2.","conclusion":"(if f a then a :: filter f (l1 ++ l2) else filter f (l1 ++ l2)) =\n(if f a then a :: filter f l1 else filter f l1) ++ filter f l2","hypotheses":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A)","proofString":"destruct (f a).\nsimpl.\ndecEq; auto.\nauto."},{"statement":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A) : a :: filter f (l1 ++ l2) = (a :: filter f l1) ++ filter f l2.","conclusion":"a :: filter f (l1 ++ l2) = (a :: filter f l1) ++ filter f l2","hypotheses":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A)","proofString":"simpl.\ndecEq; auto."},{"statement":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A) : a :: filter f (l1 ++ l2) = a :: filter f l1 ++ filter f l2.","conclusion":"a :: filter f (l1 ++ l2) = a :: filter f l1 ++ filter f l2","hypotheses":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A)","proofString":"decEq; auto."},{"statement":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A) : filter f (l1 ++ l2) = filter f l1 ++ filter f l2.","conclusion":"filter f (l1 ++ l2) = filter f l1 ++ filter f l2","hypotheses":"(A : Type) (f : A -> bool) (a : A) (l1 : list A) (IHl1 : forall l0 : list A, filter f (l1 ++ l0) = filter f l1 ++ filter f l0) (l2 : list A)","proofString":"auto."},{"statement":"(A : Type) (f : A -> bool) (x : A) : False <-> False /\\ f x = true.","conclusion":"False <-> False /\\ f x = true","hypotheses":"(A : Type) (f : A -> bool) (x : A)","proofString":"tauto."},{"statement":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) : In x (if f a then a :: filter f l else filter f l) <->\n(a = x \\/ In x l) /\\ f x = true.","conclusion":"In x (if f a then a :: filter f l else filter f l) <->\n(a = x \\/ In x l) /\\ f x = true","hypotheses":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true)","proofString":"destruct (f a) eqn:?.\nsimpl.\nrewrite IHl.\nintuition congruence.\nintuition congruence."},{"statement":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = true) : In x (a :: filter f l) <-> (a = x \\/ In x l) /\\ f x = true.","conclusion":"In x (a :: filter f l) <-> (a = x \\/ In x l) /\\ f x = true","hypotheses":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = true)","proofString":"simpl.\nrewrite IHl.\nintuition congruence."},{"statement":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = true) : a = x \\/ In x (filter f l) <-> (a = x \\/ In x l) /\\ f x = true.","conclusion":"a = x \\/ In x (filter f l) <-> (a = x \\/ In x l) /\\ f x = true","hypotheses":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = true)","proofString":"rewrite IHl.\nintuition congruence."},{"statement":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = true) : a = x \\/ In x l /\\ f x = true <-> (a = x \\/ In x l) /\\ f x = true.","conclusion":"a = x \\/ In x l /\\ f x = true <-> (a = x \\/ In x l) /\\ f x = true","hypotheses":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = true)","proofString":"intuition congruence."},{"statement":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = false) : In x (filter f l) <-> (a = x \\/ In x l) /\\ f x = true.","conclusion":"In x (filter f l) <-> (a = x \\/ In x l) /\\ f x = true","hypotheses":"(A : Type) (f : A -> bool) (x a : A) (l : list A) (IHl : In x (filter f l) <-> In x l /\\ f x = true) (Heqb : f a = false)","proofString":"intuition congruence."},{"statement":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl)) : list_norepet (if f hd then hd :: filter f tl else filter f tl).","conclusion":"list_norepet (if f hd then hd :: filter f tl else filter f tl)","hypotheses":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl))","proofString":"destruct (f hd); auto.\nconstructor; auto.\nrewrite filter_charact.\ntauto."},{"statement":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl)) : list_norepet (hd :: filter f tl).","conclusion":"list_norepet (hd :: filter f tl)","hypotheses":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl))","proofString":"constructor; auto.\nrewrite filter_charact.\ntauto."},{"statement":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl)) : ~ In hd (filter f tl).","conclusion":"~ In hd (filter f tl)","hypotheses":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl))","proofString":"rewrite filter_charact.\ntauto."},{"statement":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl)) : ~ (In hd tl /\\ f hd = true).","conclusion":"~ (In hd tl /\\ f hd = true)","hypotheses":"(A : Type) (f : A -> bool) (hd : A) (tl : list A) (H : ~ In hd tl) (H0 : list_norepet tl) (IHlist_norepet : list_norepet (filter f tl))","proofString":"tauto."},{"statement":"(A : Type) (B : Type) (f : A -> B) (pa : A -> bool) (pb : B -> bool) (H : forall a0 : A, pb (f a0) = pa a0) (a : A) (l : list A) (IHl : map f (filter pa l) = filter pb (map f l)) : map f (if pa a then a :: filter pa l else filter pa l) =\n(if pb (f a) then f a :: filter pb (map f l) else filter pb (map f l)).","conclusion":"map f (if pa a then a :: filter pa l else filter pa l) =\n(if pb (f a) then f a :: filter pb (map f l) else filter pb (map f l))","hypotheses":"(A : Type) (B : Type) (f : A -> B) (pa : A -> bool) (pb : B -> bool) (H : forall a0 : A, pb (f a0) = pa a0) (a : A) (l : list A) (IHl : map f (filter pa l) = filter pb (map f l))","proofString":"rewrite H.\ndestruct (pa a); simpl; congruence."},{"statement":"(A : Type) (B : Type) (f : A -> B) (pa : A -> bool) (pb : B -> bool) (H : forall a0 : A, pb (f a0) = pa a0) (a : A) (l : list A) (IHl : map f (filter pa l) = filter pb (map f l)) : map f (if pa a then a :: filter pa l else filter pa l) =\n(if pa a then f a :: filter pb (map f l) else filter pb (map f l)).","conclusion":"map f (if pa a then a :: filter pa l else filter pa l) =\n(if pa a then f a :: filter pb (map f l) else filter pb (map f l))","hypotheses":"(A : Type) (B : Type) (f : A -> B) (pa : A -> bool) (pb : B -> bool) (H : forall a0 : A, pb (f a0) = pa a0) (a : A) (l : list A) (IHl : map f (filter pa l) = filter pb (map f l))","proofString":"destruct (pa a); simpl; congruence."},{"statement":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f))) : (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) ! id =\n(create_undef_temps\n   (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f))) ! id.","conclusion":"(create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) ! id =\n(create_undef_temps\n   (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f))) ! id","hypotheses":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f)))","proofString":"apply create_undef_temps_exten.\nunfold add_lifted.\nrewrite filter_app.\nunfold var_names in *.\nrepeat rewrite map_app.\nrepeat rewrite in_app.\nintuition.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f))) : In id (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) <->\nIn id\n  (var_names\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f))).","conclusion":"In id (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) <->\nIn id\n  (var_names\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))","hypotheses":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f)))","proofString":"unfold add_lifted.\nrewrite filter_app.\nunfold var_names in *.\nrepeat rewrite map_app.\nrepeat rewrite in_app.\nintuition.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f))) : In id\n  (var_names\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f) ++ fn_temps f)) <->\nIn id\n  (var_names\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f ++ fn_vars f) ++ fn_temps f)).","conclusion":"In id\n  (var_names\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f) ++ fn_temps f)) <->\nIn id\n  (var_names\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f ++ fn_vars f) ++ fn_temps f))","hypotheses":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f)))","proofString":"rewrite filter_app.\nunfold var_names in *.\nrepeat rewrite map_app.\nrepeat rewrite in_app.\nintuition.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f))) : In id\n  (var_names\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f) ++ fn_temps f)) <->\nIn id\n  (var_names\n     ((filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f) ++\n       filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f)) ++ fn_temps f)).","conclusion":"In id\n  (var_names\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f) ++ fn_temps f)) <->\nIn id\n  (var_names\n     ((filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f) ++\n       filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f)) ++ fn_temps f))","hypotheses":"(id : ident) (f : function) (H : ~ In id (var_names (fn_params f)))","proofString":"unfold var_names in *.\nrepeat rewrite map_app.\nrepeat rewrite in_app.\nintuition.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : ~ In id (map fst (fn_params f))) : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f) ++ fn_temps f)) <->\nIn id\n  (map fst\n     ((filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f) ++\n       filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f)) ++ fn_temps f)).","conclusion":"In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f) ++ fn_temps f)) <->\nIn id\n  (map fst\n     ((filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f) ++\n       filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f)) ++ fn_temps f))","hypotheses":"(id : ident) (f : function) (H : ~ In id (map fst (fn_params f)))","proofString":"repeat rewrite map_app.\nrepeat rewrite in_app.\nintuition.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : ~ In id (map fst (fn_params f))) : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f)) ++ map fst (fn_temps f)) <->\nIn id\n  ((map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f)) ++\n    map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f))) ++ map fst (fn_temps f)).","conclusion":"In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f)) ++ map fst (fn_temps f)) <->\nIn id\n  ((map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f)) ++\n    map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f))) ++ map fst (fn_temps f))","hypotheses":"(id : ident) (f : function) (H : ~ In id (map fst (fn_params f)))","proofString":"repeat rewrite in_app.\nintuition.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : ~ In id (map fst (fn_params f))) : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f)) <->\n(In id\n   (map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f))) \\/\n In id\n   (map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f)))) \\/ In id (map fst (fn_temps f)).","conclusion":"In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f)) <->\n(In id\n   (map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_params f))) \\/\n In id\n   (map fst\n      (filter\n         (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n         (fn_vars f)))) \\/ In id (map fst (fn_temps f))","hypotheses":"(id : ident) (f : function) (H : ~ In id (map fst (fn_params f)))","proofString":"intuition.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f)).","conclusion":"In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f))","hypotheses":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f))))","proofString":"exploit list_in_map_inv; eauto.\nintros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) : (exists x : ident * type,\n   id = fst x /\\\n   In x\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f))) ->\nIn id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f)).","conclusion":"(exists x : ident * type,\n   id = fst x /\\\n   In x\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f))) ->\nIn id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f))","hypotheses":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f))))","proofString":"intros [[id1 ty1] [P Q]].\nsimpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (id1 : ident) (ty1 : type) (P : id = fst (id1, ty1)) (Q : In (id1, ty1)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n     (fn_params f))) : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f)).","conclusion":"In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f))","hypotheses":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (id1 : ident) (ty1 : type) (P : id = fst (id1, ty1)) (Q : In (id1, ty1)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n     (fn_params f)))","proofString":"simpl in P.\nsubst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (id1 : ident) (ty1 : type) (P : id = id1) (Q : In (id1, ty1)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n     (fn_params f))) : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f)).","conclusion":"In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id (map fst (fn_temps f))","hypotheses":"(id : ident) (f : function) (H : In id (map fst (fn_params f)) -> False) (H0 : In id\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (id1 : ident) (ty1 : type) (P : id = id1) (Q : In (id1, ty1)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n     (fn_params f)))","proofString":"subst id.\nrewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (Q : In (id1, ty1)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n     (fn_params f))) : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id1 (map fst (fn_temps f)).","conclusion":"In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id1 (map fst (fn_temps f))","hypotheses":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (Q : In (id1, ty1)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n     (fn_params f)))","proofString":"rewrite filter_charact in Q.\ndestruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (Q : In (id1, ty1) (fn_params f) /\\ VSet.mem (fst (id1, ty1)) (cenv_for f) = true) : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id1 (map fst (fn_temps f)).","conclusion":"In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id1 (map fst (fn_temps f))","hypotheses":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (Q : In (id1, ty1) (fn_params f) /\\ VSet.mem (fst (id1, ty1)) (cenv_for f) = true)","proofString":"destruct Q.\nelim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true) : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id1 (map fst (fn_temps f)).","conclusion":"In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_vars f))) \\/ In id1 (map fst (fn_temps f))","hypotheses":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true)","proofString":"elim H.\nchange id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true) : In id1 (map fst (fn_params f)).","conclusion":"In id1 (map fst (fn_params f))","hypotheses":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true)","proofString":"change id1 with (fst (id1, ty1)).\napply List.in_map.\nauto."},{"statement":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true) : In (fst (id1, ty1)) (map fst (fn_params f)).","conclusion":"In (fst (id1, ty1)) (map fst (fn_params f))","hypotheses":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true)","proofString":"apply List.in_map.\nauto."},{"statement":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true) : In (id1, ty1) (fn_params f).","conclusion":"In (id1, ty1) (fn_params f)","hypotheses":"(f : function) (id1 : ident) (H0 : In id1\n  (map fst\n     (filter\n        (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) (cenv_for f))\n        (fn_params f)))) (H : In id1 (map fst (fn_params f)) -> False) (ty1 : type) (H1 : In (id1, ty1) (fn_params f)) (H2 : VSet.mem (fst (id1, ty1)) (cenv_for f) = true)","proofString":"auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) : exists (j' : meminj) (te : env) (tm' : mem),\n  alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm' /\\\n  match_envs j' cenv e (create_undef_temps temps) m' \n    (Mem.nextblock m) (Mem.nextblock m') te\n    (create_undef_temps (add_lifted cenv vars temps)) \n    (Mem.nextblock tm) (Mem.nextblock tm') /\\\n  Mem.inject j' m' tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) vars ->\n   VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty)).","conclusion":"exists (j' : meminj) (te : env) (tm' : mem),\n  alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm' /\\\n  match_envs j' cenv e (create_undef_temps temps) m' \n    (Mem.nextblock m) (Mem.nextblock m') te\n    (create_undef_temps (add_lifted cenv vars temps)) \n    (Mem.nextblock tm) (Mem.nextblock tm') /\\\n  Mem.inject j' m' tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) vars ->\n   VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty))","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars))","proofString":"exploit (match_alloc_variables cenv); eauto.\ninstantiate (1 := empty_env).\nintros [j' [te [tm' [A [B [C [D [E [K [F G]]]]]]]]]].\nexists j'; exists te; exists tm'.\nsplit.\nauto.\nsplit; auto.\nconstructor; intros.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto.\nexploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto.\neapply alloc_variables_injective.\neexact H.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gempty in H7.\ncongruence.\neauto.\neauto.\nauto.\nexploit alloc_variables_range.\neexact H.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence.\nexploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence.\neapply alloc_variables_nextblock; eauto.\neapply alloc_variables_nextblock; eauto.\nintuition auto.\nedestruct F as (b & X & Y); eauto.\nrewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) : (exists (j' : meminj) (te' : env) (tm' : mem),\n   alloc_variables tge empty_env tm (remove_lifted cenv vars) te' tm' /\\\n   Mem.inject j' m' tm' /\\\n   inject_incr j j' /\\\n   (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) ->\n    ~ Mem.valid_block tm b' ->\n    exists (id : positive) (ty : type),\n      e ! id = Some (b, ty) /\\ te' ! id = Some (b', ty) /\\ delta = 0) /\\\n   (forall (id : ident) (ty : type),\n    In (id, ty) vars ->\n    exists b : block,\n      e ! id = Some (b, ty) /\\\n      (if VSet.mem id cenv\n       then te' ! id = empty_env ! id /\\ j' b = None\n       else\n        exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) /\\\n   (forall id : ident,\n    ~ In id (var_names vars) ->\n    e ! id = empty_env ! id /\\ te' ! id = empty_env ! id)) ->\nexists (j' : meminj) (te : env) (tm' : mem),\n  alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm' /\\\n  match_envs j' cenv e (create_undef_temps temps) m' \n    (Mem.nextblock m) (Mem.nextblock m') te\n    (create_undef_temps (add_lifted cenv vars temps)) \n    (Mem.nextblock tm) (Mem.nextblock tm') /\\\n  Mem.inject j' m' tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) vars ->\n   VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty)).","conclusion":"(exists (j' : meminj) (te' : env) (tm' : mem),\n   alloc_variables tge empty_env tm (remove_lifted cenv vars) te' tm' /\\\n   Mem.inject j' m' tm' /\\\n   inject_incr j j' /\\\n   (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n   (forall (b b' : block) (delta : Z),\n    j' b = Some (b', delta) ->\n    ~ Mem.valid_block tm b' ->\n    exists (id : positive) (ty : type),\n      e ! id = Some (b, ty) /\\ te' ! id = Some (b', ty) /\\ delta = 0) /\\\n   (forall (id : ident) (ty : type),\n    In (id, ty) vars ->\n    exists b : block,\n      e ! id = Some (b, ty) /\\\n      (if VSet.mem id cenv\n       then te' ! id = empty_env ! id /\\ j' b = None\n       else\n        exists tb : block, te' ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) /\\\n   (forall id : ident,\n    ~ In id (var_names vars) ->\n    e ! id = empty_env ! id /\\ te' ! id = empty_env ! id)) ->\nexists (j' : meminj) (te : env) (tm' : mem),\n  alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm' /\\\n  match_envs j' cenv e (create_undef_temps temps) m' \n    (Mem.nextblock m) (Mem.nextblock m') te\n    (create_undef_temps (add_lifted cenv vars temps)) \n    (Mem.nextblock tm) (Mem.nextblock tm') /\\\n  Mem.inject j' m' tm' /\\\n  inject_incr j j' /\\\n  (forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) vars ->\n   VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty))","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars))","proofString":"intros [j' [te [tm' [A [B [C [D [E [K [F G]]]]]]]]]].\nexists j'; exists te; exists tm'.\nsplit.\nauto.\nsplit; auto.\nconstructor; intros.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto.\nexploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto.\neapply alloc_variables_injective.\neexact H.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gempty in H7.\ncongruence.\neauto.\neauto.\nauto.\nexploit alloc_variables_range.\neexact H.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence.\nexploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence.\neapply alloc_variables_nextblock; eauto.\neapply alloc_variables_nextblock; eauto.\nintuition auto.\nedestruct F as (b & X & Y); eauto.\nrewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : exists (j'0 : meminj) (te0 : env) (tm'0 : mem),\n  alloc_variables tge empty_env tm (remove_lifted cenv vars) te0 tm'0 /\\\n  match_envs j'0 cenv e (create_undef_temps temps) m' \n    (Mem.nextblock m) (Mem.nextblock m') te0\n    (create_undef_temps (add_lifted cenv vars temps)) \n    (Mem.nextblock tm) (Mem.nextblock tm'0) /\\\n  Mem.inject j'0 m' tm'0 /\\\n  inject_incr j j'0 /\\\n  (forall b : block, Mem.valid_block m b -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm b' -> j'0 b = j b) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) vars ->\n   VSet.mem id cenv = false -> exists b : block, te0 ! id = Some (b, ty)).","conclusion":"exists (j'0 : meminj) (te0 : env) (tm'0 : mem),\n  alloc_variables tge empty_env tm (remove_lifted cenv vars) te0 tm'0 /\\\n  match_envs j'0 cenv e (create_undef_temps temps) m' \n    (Mem.nextblock m) (Mem.nextblock m') te0\n    (create_undef_temps (add_lifted cenv vars temps)) \n    (Mem.nextblock tm) (Mem.nextblock tm'0) /\\\n  Mem.inject j'0 m' tm'0 /\\\n  inject_incr j j'0 /\\\n  (forall b : block, Mem.valid_block m b -> j'0 b = j b) /\\\n  (forall (b b' : block) (delta : Z),\n   j'0 b = Some (b', delta) -> Mem.valid_block tm b' -> j'0 b = j b) /\\\n  (forall (id : ident) (ty : type),\n   In (id, ty) vars ->\n   VSet.mem id cenv = false -> exists b : block, te0 ! id = Some (b, ty))","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"exists j'; exists te; exists tm'.\nsplit.\nauto.\nsplit; auto.\nconstructor; intros.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto.\nexploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto.\neapply alloc_variables_injective.\neexact H.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gempty in H7.\ncongruence.\neauto.\neauto.\nauto.\nexploit alloc_variables_range.\neexact H.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence.\nexploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence.\neapply alloc_variables_nextblock; eauto.\neapply alloc_variables_nextblock; eauto.\nintuition auto.\nedestruct F as (b & X & Y); eauto.\nrewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm' /\\\nmatch_envs j' cenv e (create_undef_temps temps) m' \n  (Mem.nextblock m) (Mem.nextblock m') te\n  (create_undef_temps (add_lifted cenv vars temps)) \n  (Mem.nextblock tm) (Mem.nextblock tm') /\\\nMem.inject j' m' tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) vars ->\n VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty)).","conclusion":"alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm' /\\\nmatch_envs j' cenv e (create_undef_temps temps) m' \n  (Mem.nextblock m) (Mem.nextblock m') te\n  (create_undef_temps (add_lifted cenv vars temps)) \n  (Mem.nextblock tm) (Mem.nextblock tm') /\\\nMem.inject j' m' tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) vars ->\n VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty))","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"split.\nauto.\nsplit; auto.\nconstructor; intros.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto.\nexploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto.\neapply alloc_variables_injective.\neexact H.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gempty in H7.\ncongruence.\neauto.\neauto.\nauto.\nexploit alloc_variables_range.\neexact H.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence.\nexploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence.\neapply alloc_variables_nextblock; eauto.\neapply alloc_variables_nextblock; eauto.\nintuition auto.\nedestruct F as (b & X & Y); eauto.\nrewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm'.","conclusion":"alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm'","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : match_envs j' cenv e (create_undef_temps temps) m' \n  (Mem.nextblock m) (Mem.nextblock m') te\n  (create_undef_temps (add_lifted cenv vars temps)) \n  (Mem.nextblock tm) (Mem.nextblock tm') /\\\nMem.inject j' m' tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) vars ->\n VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty)).","conclusion":"match_envs j' cenv e (create_undef_temps temps) m' \n  (Mem.nextblock m) (Mem.nextblock m') te\n  (create_undef_temps (add_lifted cenv vars temps)) \n  (Mem.nextblock tm) (Mem.nextblock tm') /\\\nMem.inject j' m' tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) vars ->\n VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty))","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"split; auto.\nconstructor; intros.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto.\nexploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto.\neapply alloc_variables_injective.\neexact H.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gempty in H7.\ncongruence.\neauto.\neauto.\nauto.\nexploit alloc_variables_range.\neexact H.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence.\nexploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence.\neapply alloc_variables_nextblock; eauto.\neapply alloc_variables_nextblock; eauto.\nintuition auto.\nedestruct F as (b & X & Y); eauto.\nrewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : match_envs j' cenv e (create_undef_temps temps) m' \n  (Mem.nextblock m) (Mem.nextblock m') te\n  (create_undef_temps (add_lifted cenv vars temps)) \n  (Mem.nextblock tm) (Mem.nextblock tm').","conclusion":"match_envs j' cenv e (create_undef_temps temps) m' \n  (Mem.nextblock m) (Mem.nextblock m') te\n  (create_undef_temps (add_lifted cenv vars temps)) \n  (Mem.nextblock tm) (Mem.nextblock tm')","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"constructor; intros.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto.\nexploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto.\neapply alloc_variables_injective.\neexact H.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gempty in H7.\ncongruence.\neauto.\neauto.\nauto.\nexploit alloc_variables_range.\neexact H.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintuition congruence.\ndestruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence.\nexploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence.\nexploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence.\neapply alloc_variables_nextblock; eauto.\neapply alloc_variables_nextblock; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident)","proofString":"destruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto.\nexploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (var_names vars)) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (var_names vars))","proofString":"unfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars))","proofString":"exploit list_in_map_inv; eauto.\nintros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) : (exists x : ident * type, id = fst x /\\ In x vars) ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"(exists x : ident * type, id = fst x /\\ In x vars) ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars))","proofString":"intros [[id' ty] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars)","proofString":"exploit F; eauto.\nintros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) : (exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = empty_env ! id /\\ j' b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"(exists b : block,\n   e ! id = Some (b, ty) /\\\n   (if VSet.mem id cenv\n    then te ! id = empty_env ! id /\\ j' b = None\n    else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars)","proofString":"intros [b [P R]].\ndestruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (R : if VSet.mem id cenv\nthen te ! id = empty_env ! id /\\ j' b = None\nelse exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (R : if VSet.mem id cenv\nthen te ! id = empty_env ! id /\\ j' b = None\nelse exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","proofString":"destruct (VSet.mem id cenv) eqn:?.\ndestruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto.\ndestruct R as [tb [U V]].\neapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (R : te ! id = empty_env ! id /\\ j' b = None) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (R : te ! id = empty_env ! id /\\ j' b = None)","proofString":"destruct R as [U V].\nexploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None)","proofString":"exploit H2; eauto.\nintros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) : (exists chunk : memory_chunk, access_mode ty = By_value chunk) ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"(exists chunk : memory_chunk, access_mode ty = By_value chunk) ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None)","proofString":"intros [chunk X].\neapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"eapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.\neapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : Mem.load chunk m' b 0 = Some Vundef.","conclusion":"Mem.load chunk m' b 0 = Some Vundef","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"eapply alloc_variables_initial_value; eauto.\nred.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : env_initial_value empty_env m.","conclusion":"env_initial_value empty_env m","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"red.\nunfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : forall (id0 : positive) (b0 : block) (ty0 : type) (chunk0 : memory_chunk),\nempty_env ! id0 = Some (b0, ty0) ->\naccess_mode ty0 = By_value chunk0 -> Mem.load chunk0 m b0 0 = Some Vundef.","conclusion":"forall (id0 : positive) (b0 : block) (ty0 : type) (chunk0 : memory_chunk),\nempty_env ! id0 = Some (b0, ty0) ->\naccess_mode ty0 = By_value chunk0 -> Mem.load chunk0 m b0 0 = Some Vundef","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"unfold empty_env; intros.\nrewrite PTree.gempty in H4; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk1 : memory_chunk, access_mode ty1 = By_value chunk1) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b1 : block, Mem.valid_block m b1 -> j' b1 = j b1) (E : forall (b1 b' : block) (delta : Z),\nj' b1 = Some (b', delta) -> Mem.valid_block tm b' -> j' b1 = j b1) (K : forall (b1 b' : block) (delta : Z),\nj' b1 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b1, ty1) /\\ te ! id1 = Some (b', ty1) /\\ delta = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b1 : block,\n  e ! id1 = Some (b1, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b1 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b1 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) (id0 : positive) (b0 : block) (ty0 : type) (chunk0 : memory_chunk) (H4 : (PTree.empty (block * type)) ! id0 = Some (b0, ty0)) (H5 : access_mode ty0 = By_value chunk0) : Mem.load chunk0 m b0 0 = Some Vundef.","conclusion":"Mem.load chunk0 m b0 0 = Some Vundef","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk1 : memory_chunk, access_mode ty1 = By_value chunk1) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b1 : block, Mem.valid_block m b1 -> j' b1 = j b1) (E : forall (b1 b' : block) (delta : Z),\nj' b1 = Some (b', delta) -> Mem.valid_block tm b' -> j' b1 = j b1) (K : forall (b1 b' : block) (delta : Z),\nj' b1 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b1, ty1) /\\ te ! id1 = Some (b', ty1) /\\ delta = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b1 : block,\n  e ! id1 = Some (b1, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b1 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b1 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) (id0 : positive) (b0 : block) (ty0 : type) (chunk0 : memory_chunk) (H4 : (PTree.empty (block * type)) ! id0 = Some (b0, ty0)) (H5 : access_mode ty0 = By_value chunk0)","proofString":"rewrite PTree.gempty in H4; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : (create_undef_temps (add_lifted cenv vars temps)) ! id = Some Vundef.","conclusion":"(create_undef_temps (add_lifted cenv vars temps)) ! id = Some Vundef","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"apply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : In (id, ty) (add_lifted cenv vars temps).","conclusion":"In (id, ty) (add_lifted cenv vars temps)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"unfold add_lifted.\napply in_or_app.\nleft.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars ++\n   temps).","conclusion":"In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars ++\n   temps)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"apply in_or_app.\nleft.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars) \\/\nIn (id, ty) temps.","conclusion":"In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars) \\/\nIn (id, ty) temps","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"left.\nrewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars).","conclusion":"In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"rewrite filter_In.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk) : In (id, ty) vars /\\ VSet.mem (fst (id, ty)) cenv = true.","conclusion":"In (id, ty) vars /\\ VSet.mem (fst (id, ty)) cenv = true","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk0 : memory_chunk, access_mode ty0 = By_value chunk0) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = true) (U : te ! id = empty_env ! id) (V : j' b = None) (chunk : memory_chunk) (X : access_mode ty = By_value chunk)","proofString":"auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = false) (R : exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = false) (R : exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","proofString":"destruct R as [tb [U V]].\neapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else\n    exists tb0 : block, te ! id0 = Some (tb0, ty0) /\\ j' b0 = Some (tb0, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = false) (tb : block) (U : te ! id = Some (tb, ty)) (V : j' b = Some (tb, 0)) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else\n    exists tb0 : block, te ! id0 = Some (tb0, ty0) /\\ j' b0 = Some (tb0, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (i : In id (map fst vars)) (ty : type) (IN : In (id, ty) vars) (b : block) (P : e ! id = Some (b, ty)) (Heqb0 : VSet.mem id cenv = false) (tb : block) (U : te ! id = Some (tb, ty)) (V : j' b = Some (tb, 0))","proofString":"eapply match_var_not_lifted; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars))","proofString":"exploit G; eauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) : e ! id = empty_env ! id /\\ te ! id = empty_env ! id ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"e ! id = empty_env ! id /\\ te ! id = empty_env ! id ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars))","proofString":"unfold empty_env.\nrewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) : e ! id = (PTree.empty (block * type)) ! id /\\\nte ! id = (PTree.empty (block * type)) ! id ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"e ! id = (PTree.empty (block * type)) ! id /\\\nte ! id = (PTree.empty (block * type)) ! id ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars))","proofString":"rewrite PTree.gempty.\nintros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) : e ! id = None /\\ te ! id = None ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"e ! id = None /\\ te ! id = None ->\nmatch_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars))","proofString":"intros [U V].\neapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) (U : e ! id = None) (V : te ! id = None) : match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id.","conclusion":"match_var j' cenv e m' te (create_undef_temps (add_lifted cenv vars temps))\n  id","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) (U : e ! id = None) (V : te ! id = None)","proofString":"eapply match_var_not_local; eauto.\ndestruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) (U : e ! id = None) (V : te ! id = None) : VSet.mem id cenv = false.","conclusion":"VSet.mem id cenv = false","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) (U : e ! id = None) (V : te ! id = None)","proofString":"destruct (VSet.mem id cenv) eqn:?; auto.\nelim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) (U : e ! id = None) (V : te ! id = None) (Heqb : VSet.mem id cenv = true) : true = false.","conclusion":"true = false","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (n : ~ In id (var_names vars)) (U : e ! id = None) (V : te ! id = None) (Heqb : VSet.mem id cenv = true)","proofString":"elim n; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (v : val) (H4 : (create_undef_temps temps) ! id = Some v) : (exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' v tv) /\\ (VSet.mem id cenv = true -> v = Vundef).","conclusion":"(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' v tv) /\\ (VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (v : val) (H4 : (create_undef_temps temps) ! id = Some v)","proofString":"exploit create_undef_temps_inv; eauto.\nintros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (v : val) (H4 : (create_undef_temps temps) ! id = Some v) : v = Vundef /\\ In id (var_names temps) ->\n(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' v tv) /\\ (VSet.mem id cenv = true -> v = Vundef).","conclusion":"v = Vundef /\\ In id (var_names temps) ->\n(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' v tv) /\\ (VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (v : val) (H4 : (create_undef_temps temps) ! id = Some v)","proofString":"intros [P Q].\nsubst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (v : val) (H4 : (create_undef_temps temps) ! id = Some v) (P : v = Vundef) (Q : In id (var_names temps)) : (exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' v tv) /\\ (VSet.mem id cenv = true -> v = Vundef).","conclusion":"(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' v tv) /\\ (VSet.mem id cenv = true -> v = Vundef)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (v : val) (H4 : (create_undef_temps temps) ! id = Some v) (P : v = Vundef) (Q : In id (var_names temps))","proofString":"subst v.\nunfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (var_names temps)) : (exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef).","conclusion":"(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (var_names temps))","proofString":"unfold var_names in Q.\nexploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) : (exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef).","conclusion":"(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps))","proofString":"exploit list_in_map_inv; eauto.\nintros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) : (exists x : ident * type, id = fst x /\\ In x temps) ->\n(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef).","conclusion":"(exists x : ident * type, id = fst x /\\ In x temps) ->\n(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty : type),\n  e ! id0 = Some (b, ty) /\\ te ! id0 = Some (b', ty) /\\ delta = 0) (F : forall (id0 : ident) (ty : type),\nIn (id0, ty) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps))","proofString":"intros [[id1 ty] [EQ IN]]; simpl in EQ; subst id1.\nsplit; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps) : (exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef).","conclusion":"(exists tv : val,\n   (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n   Val.inject j' Vundef tv) /\\ (VSet.mem id cenv = true -> Vundef = Vundef)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps)","proofString":"split; auto.\nexists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps) : exists tv : val,\n  (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n  Val.inject j' Vundef tv.","conclusion":"exists tv : val,\n  (create_undef_temps (add_lifted cenv vars temps)) ! id = Some tv /\\\n  Val.inject j' Vundef tv","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps)","proofString":"exists Vundef; split; auto.\napply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps) : (create_undef_temps (add_lifted cenv vars temps)) ! id = Some Vundef.","conclusion":"(create_undef_temps (add_lifted cenv vars temps)) ! id = Some Vundef","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps)","proofString":"apply create_undef_temps_charact with ty.\nunfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps) : In (id, ty) (add_lifted cenv vars temps).","conclusion":"In (id, ty) (add_lifted cenv vars temps)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps)","proofString":"unfold add_lifted.\napply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps) : In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars ++\n   temps).","conclusion":"In (id, ty)\n  (filter (fun id_ty : VSet.elt * type => VSet.mem (fst id_ty) cenv) vars ++\n   temps)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (H4 : (create_undef_temps temps) ! id = Some Vundef) (Q : In id (map fst temps)) (ty : type) (IN : In (id, ty) temps)","proofString":"apply in_or_app; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (H4 : e ! id1 = Some (b1, ty1)) (H5 : e ! id2 = Some (b2, ty2)) (H6 : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (H4 : e ! id1 = Some (b1, ty1)) (H5 : e ! id2 = Some (b2, ty2)) (H6 : id1 <> id2)","proofString":"eapply alloc_variables_injective.\neexact H.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gempty in H7.\ncongruence.\neauto.\neauto.\nauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (H4 : e ! id1 = Some (b1, ty1)) (H5 : e ! id2 = Some (b2, ty2)) (H6 : id1 <> id2) (id : positive) (b : block) (ty : type) (H7 : empty_env ! id = Some (b, ty)) : Plt b (Mem.nextblock m).","conclusion":"Plt b (Mem.nextblock m)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (H4 : e ! id1 = Some (b1, ty1)) (H5 : e ! id2 = Some (b2, ty2)) (H6 : id1 <> id2) (id : positive) (b : block) (ty : type) (H7 : empty_env ! id = Some (b, ty))","proofString":"rewrite PTree.gempty in H7.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (H4 : e ! id1 = Some (b1, ty1)) (H5 : e ! id2 = Some (b2, ty2)) (H6 : id1 <> id2) (id : positive) (b : block) (ty : type) (H7 : None = Some (b, ty)) : Plt b (Mem.nextblock m).","conclusion":"Plt b (Mem.nextblock m)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id1 : positive) (b1 : block) (ty1 : type) (id2 : positive) (b2 : block) (ty2 : type) (H4 : e ! id1 = Some (b1, ty1)) (H5 : e ! id2 = Some (b2, ty2)) (H6 : id1 <> id2) (id : positive) (b : block) (ty : type) (H7 : None = Some (b, ty))","proofString":"congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : e ! id = Some (b, ty)) : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m').","conclusion":"Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m')","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : e ! id = Some (b, ty))","proofString":"exploit alloc_variables_range.\neexact H.\neauto.\nrewrite PTree.gempty.\nintuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : e ! id = Some (b, ty)) : None = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m') ->\nPle (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m').","conclusion":"None = Some (b, ty) \\/ Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m') ->\nPle (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m')","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : e ! id = Some (b, ty))","proofString":"intuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : te ! id = Some (b, ty)) : Ple (Mem.nextblock tm) b /\\ Plt b (Mem.nextblock tm').","conclusion":"Ple (Mem.nextblock tm) b /\\ Plt b (Mem.nextblock tm')","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : te ! id = Some (b, ty))","proofString":"exploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : te ! id = Some (b, ty)) : None = Some (b, ty) \\/ Ple (Mem.nextblock tm) b /\\ Plt b (Mem.nextblock tm') ->\nPle (Mem.nextblock tm) b /\\ Plt b (Mem.nextblock tm').","conclusion":"None = Some (b, ty) \\/ Ple (Mem.nextblock tm) b /\\ Plt b (Mem.nextblock tm') ->\nPle (Mem.nextblock tm) b /\\ Plt b (Mem.nextblock tm')","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b : block) (ty : type) (H4 : te ! id = Some (b, ty))","proofString":"intuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) : exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty))","proofString":"destruct (In_dec ident_eq id (var_names vars)).\nunfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence.\nexploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (var_names vars)) : exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (var_names vars))","proofString":"unfold var_names in i.\nexploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) : exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars))","proofString":"exploit list_in_map_inv; eauto.\nintros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) : (exists x : ident * type, id = fst x /\\ In x vars) ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"(exists x : ident * type, id = fst x /\\ In x vars) ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars))","proofString":"intros [[id' ty'] [EQ IN]]; simpl in EQ; subst id'.\nexploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) : exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars)","proofString":"exploit F; eauto.\nintros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) : (exists b : block,\n   e ! id = Some (b, ty') /\\\n   (if VSet.mem id cenv\n    then te ! id = empty_env ! id /\\ j' b = None\n    else exists tb : block, te ! id = Some (tb, ty') /\\ j' b = Some (tb, 0))) ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"(exists b : block,\n   e ! id = Some (b, ty') /\\\n   (if VSet.mem id cenv\n    then te ! id = empty_env ! id /\\ j' b = None\n    else exists tb : block, te ! id = Some (tb, ty') /\\ j' b = Some (tb, 0))) ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars)","proofString":"intros [b [P Q]].\ndestruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : if VSet.mem id cenv\nthen te ! id = empty_env ! id /\\ j' b = None\nelse exists tb : block, te ! id = Some (tb, ty') /\\ j' b = Some (tb, 0)) : exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty).","conclusion":"exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : if VSet.mem id cenv\nthen te ! id = empty_env ! id /\\ j' b = None\nelse exists tb : block, te ! id = Some (tb, ty') /\\ j' b = Some (tb, 0))","proofString":"destruct (VSet.mem id cenv).\nrewrite PTree.gempty in Q.\ndestruct Q; congruence.\ndestruct Q as [tb [U V]].\nexists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : te ! id = empty_env ! id /\\ j' b = None) : exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty).","conclusion":"exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : te ! id = empty_env ! id /\\ j' b = None)","proofString":"rewrite PTree.gempty in Q.\ndestruct Q; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : te ! id = None /\\ j' b = None) : exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty).","conclusion":"exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : te ! id = None /\\ j' b = None)","proofString":"destruct Q; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : exists tb : block, te ! id = Some (tb, ty') /\\ j' b = Some (tb, 0)) : exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty).","conclusion":"exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (Q : exists tb : block, te ! id = Some (tb, ty') /\\ j' b = Some (tb, 0))","proofString":"destruct Q as [tb [U V]].\nexists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else\n    exists tb0 : block, te ! id0 = Some (tb0, ty0) /\\ j' b0 = Some (tb0, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (tb : block) (U : te ! id = Some (tb, ty')) (V : j' b = Some (tb, 0)) : exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty).","conclusion":"exists b0 : block, j' b0 = Some (b', 0) /\\ e ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta : Z),\nj' b0 = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else\n    exists tb0 : block, te ! id0 = Some (tb0, ty0) /\\ j' b0 = Some (tb0, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (i : In id (map fst vars)) (ty' : type) (IN : In (id, ty') vars) (b : block) (P : e ! id = Some (b, ty')) (tb : block) (U : te ! id = Some (tb, ty')) (V : j' b = Some (tb, 0))","proofString":"exists b; split; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (n : ~ In id (var_names vars)) : exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"exists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (n : ~ In id (var_names vars))","proofString":"exploit G; eauto.\nrewrite PTree.gempty.\nintuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (n : ~ In id (var_names vars)) : e ! id = empty_env ! id /\\ te ! id = empty_env ! id ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"e ! id = empty_env ! id /\\ te ! id = empty_env ! id ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (n : ~ In id (var_names vars))","proofString":"rewrite PTree.gempty.\nintuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (n : ~ In id (var_names vars)) : e ! id = None /\\ te ! id = None ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty).","conclusion":"e ! id = None /\\ te ! id = None ->\nexists b : block, j' b = Some (b', 0) /\\ e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b = j b) (K : forall (b b'0 : block) (delta : Z),\nj' b = Some (b'0, delta) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (H4 : te ! id = Some (b', ty)) (n : ~ In id (var_names vars))","proofString":"intuition congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) : e ! id = Some (b, ty) /\\ delta = 0.","conclusion":"e ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta))","proofString":"exploit alloc_variables_range.\neexact A.\neauto.\nrewrite PTree.gempty.\nintros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) : None = Some (b', ty) \\/\nPle (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm') ->\ne ! id = Some (b, ty) /\\ delta = 0.","conclusion":"None = Some (b', ty) \\/\nPle (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm') ->\ne ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta))","proofString":"intros [P|P].\ncongruence.\nexploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : None = Some (b', ty)) : e ! id = Some (b, ty) /\\ delta = 0.","conclusion":"e ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : None = Some (b', ty))","proofString":"congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) : e ! id = Some (b, ty) /\\ delta = 0.","conclusion":"e ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm'))","proofString":"exploit K; eauto.\nunfold Mem.valid_block.\nextlia.\nintros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) : ~ Mem.valid_block tm b'.","conclusion":"~ Mem.valid_block tm b'","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm'))","proofString":"unfold Mem.valid_block.\nextlia."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) : ~ Plt b' (Mem.nextblock tm).","conclusion":"~ Plt b' (Mem.nextblock tm)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm'))","proofString":"extlia."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) : (exists (id0 : positive) (ty0 : type),\n   e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) ->\ne ! id = Some (b, ty) /\\ delta = 0.","conclusion":"(exists (id0 : positive) (ty0 : type),\n   e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) ->\ne ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b'0, ty0) /\\ delta0 = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n~ In id0 (var_names vars) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm'))","proofString":"intros [id0 [ty0 [U [V W]]]].\nsplit; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) : e ! id = Some (b, ty) /\\ delta = 0.","conclusion":"e ! id = Some (b, ty) /\\ delta = 0","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0)","proofString":"split; auto.\ndestruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) : e ! id = Some (b, ty).","conclusion":"e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0)","proofString":"destruct (ident_eq id id0).\ncongruence.\nassert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (e0 : id = id0) : e ! id = Some (b, ty).","conclusion":"e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (e0 : id = id0)","proofString":"congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0) : e ! id = Some (b, ty).","conclusion":"e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0)","proofString":"assert (b' <> b').\neapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence.\ncongruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0) : b' <> b'.","conclusion":"b' <> b'","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0)","proofString":"eapply alloc_variables_injective with (e' := te) (id1 := id) (id2 := id0); eauto.\nrewrite PTree.gempty; congruence.\nintros until ty1; rewrite PTree.gempty; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0) : empty_env ! id = Some (b', ty) ->\nempty_env ! id0 = Some (b', ty0) -> id <> id0 -> b' <> b'.","conclusion":"empty_env ! id = Some (b', ty) ->\nempty_env ! id0 = Some (b', ty0) -> id <> id0 -> b' <> b'","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0)","proofString":"rewrite PTree.gempty; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0) : forall (id1 : positive) (b0 : block) (ty1 : type),\nempty_env ! id1 = Some (b0, ty1) -> Plt b0 (Mem.nextblock tm).","conclusion":"forall (id1 : positive) (b0 : block) (ty1 : type),\nempty_env ! id1 = Some (b0, ty1) -> Plt b0 (Mem.nextblock tm)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0)","proofString":"intros until ty1; rewrite PTree.gempty; congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0) (H6 : b' <> b') : e ! id = Some (b, ty).","conclusion":"e ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nVSet.mem id1 cenv = true ->\nexists chunk : memory_chunk, access_mode ty1 = By_value chunk) (H3 : forall id1 : VSet.elt, VSet.mem id1 cenv = true -> In id1 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (K : forall (b0 b'0 : block) (delta0 : Z),\nj' b0 = Some (b'0, delta0) ->\n~ Mem.valid_block tm b'0 ->\nexists (id1 : positive) (ty1 : type),\n  e ! id1 = Some (b0, ty1) /\\ te ! id1 = Some (b'0, ty1) /\\ delta0 = 0) (F : forall (id1 : ident) (ty1 : type),\nIn (id1, ty1) vars ->\nexists b0 : block,\n  e ! id1 = Some (b0, ty1) /\\\n  (if VSet.mem id1 cenv\n   then te ! id1 = empty_env ! id1 /\\ j' b0 = None\n   else exists tb : block, te ! id1 = Some (tb, ty1) /\\ j' b0 = Some (tb, 0))) (G : forall id1 : ident,\n~ In id1 (var_names vars) ->\ne ! id1 = empty_env ! id1 /\\ te ! id1 = empty_env ! id1) (id : positive) (b' : block) (ty : type) (b : block) (delta : Z) (H4 : te ! id = Some (b', ty)) (H5 : j' b = Some (b', delta)) (P : Ple (Mem.nextblock tm) b' /\\ Plt b' (Mem.nextblock tm')) (id0 : positive) (ty0 : type) (U : e ! id0 = Some (b, ty0)) (V : te ! id0 = Some (b', ty0)) (W : delta = 0) (n : id <> id0) (H6 : b' <> b')","proofString":"congruence."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : Ple (Mem.nextblock m) (Mem.nextblock m').","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m')","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"eapply alloc_variables_nextblock; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : Ple (Mem.nextblock tm) (Mem.nextblock tm').","conclusion":"Ple (Mem.nextblock tm) (Mem.nextblock tm')","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"eapply alloc_variables_nextblock; eauto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id) : Mem.inject j' m' tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) vars ->\n VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty)).","conclusion":"Mem.inject j' m' tm' /\\\ninject_incr j j' /\\\n(forall b : block, Mem.valid_block m b -> j' b = j b) /\\\n(forall (b b' : block) (delta : Z),\n j' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) /\\\n(forall (id : ident) (ty : type),\n In (id, ty) vars ->\n VSet.mem id cenv = false -> exists b : block, te ! id = Some (b, ty))","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nVSet.mem id cenv = true ->\nexists chunk : memory_chunk, access_mode ty = By_value chunk) (H3 : forall id : VSet.elt, VSet.mem id cenv = true -> In id (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n~ Mem.valid_block tm b' ->\nexists (id : positive) (ty : type),\n  e ! id = Some (b, ty) /\\ te ! id = Some (b', ty) /\\ delta = 0) (F : forall (id : ident) (ty : type),\nIn (id, ty) vars ->\nexists b : block,\n  e ! id = Some (b, ty) /\\\n  (if VSet.mem id cenv\n   then te ! id = empty_env ! id /\\ j' b = None\n   else exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))) (G : forall id : ident,\n~ In id (var_names vars) ->\ne ! id = empty_env ! id /\\ te ! id = empty_env ! id)","proofString":"intuition auto.\nedestruct F as (b & X & Y); eauto.\nrewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false) : exists b : block, te ! id = Some (b, ty).","conclusion":"exists b : block, te ! id = Some (b, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b : block, Mem.valid_block m b -> j' b = j b) (E : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (K : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b : block,\n  e ! id0 = Some (b, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b = Some (tb, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false)","proofString":"edestruct F as (b & X & Y); eauto.\nrewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false) (b : block) (X : e ! id = Some (b, ty)) (Y : if VSet.mem id cenv\nthen te ! id = empty_env ! id /\\ j' b = None\nelse exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)) : exists b0 : block, te ! id = Some (b0, ty).","conclusion":"exists b0 : block, te ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false) (b : block) (X : e ! id = Some (b, ty)) (Y : if VSet.mem id cenv\nthen te ! id = empty_env ! id /\\ j' b = None\nelse exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","proofString":"rewrite H5 in Y.\ndestruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false) (b : block) (X : e ! id = Some (b, ty)) (Y : exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0)) : exists b0 : block, te ! id = Some (b0, ty).","conclusion":"exists b0 : block, te ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else exists tb : block, te ! id0 = Some (tb, ty0) /\\ j' b0 = Some (tb, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false) (b : block) (X : e ! id = Some (b, ty)) (Y : exists tb : block, te ! id = Some (tb, ty) /\\ j' b = Some (tb, 0))","proofString":"destruct Y as (tb & U & V).\nexists tb; auto."},{"statement":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else\n    exists tb0 : block, te ! id0 = Some (tb0, ty0) /\\ j' b0 = Some (tb0, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false) (b : block) (X : e ! id = Some (b, ty)) (tb : block) (U : te ! id = Some (tb, ty)) (V : j' b = Some (tb, 0)) : exists b0 : block, te ! id = Some (b0, ty).","conclusion":"exists b0 : block, te ! id = Some (b0, ty)","hypotheses":"(cenv : VSet.t) (m : mem) (vars : list (ident * type)) (e : env) (m' : mem) (temps : list (ident * type)) (j : meminj) (tm : mem) (H : alloc_variables ge empty_env m vars e m') (H0 : list_norepet (var_names vars)) (H1 : Mem.inject j m tm) (H2 : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nVSet.mem id0 cenv = true ->\nexists chunk : memory_chunk, access_mode ty0 = By_value chunk) (H3 : forall id0 : VSet.elt, VSet.mem id0 cenv = true -> In id0 (var_names vars)) (j' : meminj) (te : env) (tm' : mem) (A : alloc_variables tge empty_env tm (remove_lifted cenv vars) te tm') (B : Mem.inject j' m' tm') (C : inject_incr j j') (D : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (E : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (K : forall (b0 b' : block) (delta : Z),\nj' b0 = Some (b', delta) ->\n(Mem.valid_block tm b' -> False) ->\nexists (id0 : positive) (ty0 : type),\n  e ! id0 = Some (b0, ty0) /\\ te ! id0 = Some (b', ty0) /\\ delta = 0) (F : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) vars ->\nexists b0 : block,\n  e ! id0 = Some (b0, ty0) /\\\n  (if VSet.mem id0 cenv\n   then te ! id0 = empty_env ! id0 /\\ j' b0 = None\n   else\n    exists tb0 : block, te ! id0 = Some (tb0, ty0) /\\ j' b0 = Some (tb0, 0))) (G : forall id0 : ident,\n(In id0 (var_names vars) -> False) ->\ne ! id0 = empty_env ! id0 /\\ te ! id0 = empty_env ! id0) (id : ident) (ty : type) (H4 : In (id, ty) vars) (H5 : VSet.mem id cenv = false) (b : block) (X : e ! id = Some (b, ty)) (tb : block) (U : te ! id = Some (tb, ty)) (V : j' b = Some (tb, 0))","proofString":"exists tb; auto."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H : assign_loc ge ty m loc ofs bf v m') (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) : exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' bf v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' bf v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H : assign_loc ge ty m loc ofs bf v m') (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm)","proofString":"inv H.\nexploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\nexists tm'; split.\neapply assign_loc_value; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H5.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence.\ninv H0.\ninv H1.\nrename b' into bsrc.\nrename ofs'0 into osrc.\nrename loc into bdst.\nrename ofs into odst.\nrename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\ninv H3.\nexploit Mem.loadv_inject; eauto.\nintros (vc' & LD' & INJ).\ninv INJ.\nexploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\ninv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') : exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m')","proofString":"exploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\nexists tm'; split.\neapply assign_loc_value; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H5.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') : (exists n2 : mem,\n   Mem.storev chunk tm (Vptr loc' ofs') v' = Some n2 /\\ Mem.inject f m' n2) ->\nexists tm' : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0).","conclusion":"(exists n2 : mem,\n   Mem.storev chunk tm (Vptr loc' ofs') v' = Some n2 /\\ Mem.inject f m' n2) ->\nexists tm' : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m')","proofString":"intros [tm' [A B]].\nexists tm'; split.\neapply assign_loc_value; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H5.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') : exists tm'0 : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0).","conclusion":"exists tm'0 : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm')","proofString":"exists tm'; split.\neapply assign_loc_value; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H5.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') : assign_loc tge ty tm loc' ofs' Full v' tm'.","conclusion":"assign_loc tge ty tm loc' ofs' Full v' tm'","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm')","proofString":"eapply assign_loc_value; eauto."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') : Mem.inject f m' tm' /\\\n(forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n f b = None ->\n Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0).","conclusion":"Mem.inject f m' tm' /\\\n(forall (b : block) (chunk0 : memory_chunk) (v0 : val),\n f b = None ->\n Mem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm')","proofString":"split.\nauto.\nintros.\nrewrite <- H5.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') : Mem.inject f m' tm'.","conclusion":"Mem.inject f m' tm'","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm')","proofString":"auto."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') : forall (b : block) (chunk0 : memory_chunk) (v0 : val),\nf b = None ->\nMem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0.","conclusion":"forall (b : block) (chunk0 : memory_chunk) (v0 : val),\nf b = None ->\nMem.load chunk0 m b 0 = Some v0 -> Mem.load chunk0 m' b 0 = Some v0","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm')","proofString":"intros.\nrewrite <- H5.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0) : Mem.load chunk0 m' b 0 = Some v0.","conclusion":"Mem.load chunk0 m' b 0 = Some v0","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0)","proofString":"rewrite <- H5.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0) : Mem.load chunk0 m' b 0 = Mem.load chunk0 m b 0.","conclusion":"Mem.load chunk0 m' b 0 = Mem.load chunk0 m b 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0)","proofString":"eapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0) : b <> loc \\/\n0 + size_chunk chunk0 <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= 0.","conclusion":"b <> loc \\/\n0 + size_chunk chunk0 <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0)","proofString":"left.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0) : b <> loc.","conclusion":"b <> loc","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (A : Mem.storev chunk tm (Vptr loc' ofs') v' = Some tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0)","proofString":"inv H0.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (v' : val) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (delta : Z) (A : Mem.storev chunk tm (Vptr loc' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0) (H9 : f loc = Some (loc', delta)) : b <> loc.","conclusion":"b <> loc","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (v' : val) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (chunk : memory_chunk) (H3 : access_mode ty = By_value chunk) (H4 : Mem.storev chunk m (Vptr loc ofs) v = Some m') (tm' : mem) (delta : Z) (A : Mem.storev chunk tm (Vptr loc' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk0 : memory_chunk) (v0 : val) (H : f b = None) (H5 : Mem.load chunk0 m b 0 = Some v0) (H9 : f loc = Some (loc', delta))","proofString":"congruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (b' : block) (ofs'0 : ptrofs) (H1 : Val.inject f (Vptr b' ofs'0) v') (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : b' <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m b' (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') : exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (b' : block) (ofs'0 : ptrofs) (H1 : Val.inject f (Vptr b' ofs'0) v') (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : b' <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m b' (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"inv H0.\ninv H1.\nrename b' into bsrc.\nrename ofs'0 into osrc.\nrename loc into bdst.\nrename ofs into odst.\nrename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (v' : val) (b' : block) (ofs'0 : ptrofs) (H1 : Val.inject f (Vptr b' ofs'0) v') (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : b' <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m b' (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta)) : exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (v' : val) (b' : block) (ofs'0 : ptrofs) (H1 : Val.inject f (Vptr b' ofs'0) v') (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : b' <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m b' (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta))","proofString":"inv H1.\nrename b' into bsrc.\nrename ofs'0 into osrc.\nrename loc into bdst.\nrename ofs into odst.\nrename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' b' : block) (ofs'0 : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : b' <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m b' (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f b' = Some (b2, delta0)) : exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add ofs'0 (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add ofs'0 (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' b' : block) (ofs'0 : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : b' <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m b' (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f b' = Some (b2, delta0))","proofString":"rename b' into bsrc.\nrename ofs'0 into osrc.\nrename loc into bdst.\nrename ofs into odst.\nrename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' bsrc : block) (ofs'0 : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : bsrc <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0)) : exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add ofs'0 (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add ofs'0 (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' bsrc : block) (ofs'0 : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs'0)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : bsrc <> loc \\/\nPtrofs.unsigned ofs'0 = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs'0 + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'0) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned ofs'0) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0))","proofString":"rename ofs'0 into osrc.\nrename loc into bdst.\nrename ofs into odst.\nrename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : bsrc <> loc \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0)) : exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : bsrc <> loc \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f loc = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0))","proofString":"rename loc into bdst.\nrename ofs into odst.\nrename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (ofs : ptrofs) (m' tm : mem) (loc' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f bdst = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0)) : exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add ofs (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (ofs : ptrofs) (m' tm : mem) (loc' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned ofs) bytes = Some m') (delta : Z) (H11 : f bdst = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0))","proofString":"rename ofs into odst.\nrename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (loc' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0)) : exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (loc' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (loc', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0))","proofString":"rename loc' into bdst'.\nrename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0)) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (b2 : block) (delta0 : Z) (H9 : f bsrc = Some (b2, delta0))","proofString":"rename b2 into bsrc'.\nrewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned osrc)) (H5 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof ge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof ge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof ge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0))","proofString":"rewrite <- comp_env_preserved in *.\ndestruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0))","proofString":"destruct (zeq (sizeof tge ty) 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0)","proofString":"assert (bytes = nil).\nexploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) : bytes = nil.","conclusion":"bytes = nil","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0)","proofString":"exploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).\nlia.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) : sizeof tge ty <= 0.","conclusion":"sizeof tge ty <= 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0)","proofString":"lia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil ->\nbytes = nil.","conclusion":"Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil ->\nbytes = nil","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0)","proofString":"congruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (H : bytes = nil) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (H : bytes = nil)","proofString":"subst.\ndestruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0)","proofString":"destruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)  as [tm' SB].\nsimpl.\nred; intros; extlia.\nexists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) : Mem.range_perm tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)))\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) + 0) Cur Writable.","conclusion":"Mem.range_perm tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)))\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) + 0) Cur Writable","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0)","proofString":"red; intros; extlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : exists tm'0 : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm'0 : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"exists tm'.\nsplit.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\nMem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\nMem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"split.\neapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'.","conclusion":"assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"eapply assign_loc_copy; eauto.\nintros; extlia.\nintros; extlia.\nrewrite e; right; lia.\napply Mem.loadbytes_empty.\nlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty\n| Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0))).","conclusion":"sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty\n| Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)))","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"intros; extlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty\n| Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))).","conclusion":"sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty\n| Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)))","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"intros; extlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : bsrc' <> bdst' \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) + sizeof tge ty <=\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) \\/\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) + sizeof tge ty <=\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)).","conclusion":"bsrc' <> bdst' \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) + sizeof tge ty <=\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) \\/\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) + sizeof tge ty <=\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0))","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"rewrite e; right; lia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : Mem.loadbytes tm bsrc'\n  (Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0))) \n  (sizeof tge ty) = Some nil.","conclusion":"Mem.loadbytes tm bsrc'\n  (Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0))) \n  (sizeof tge ty) = Some nil","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"apply Mem.loadbytes_empty.\nlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : sizeof tge ty <= 0.","conclusion":"sizeof tge ty <= 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"lia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : Mem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"Mem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"split.\neapply Mem.storebytes_empty_inject; eauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : Mem.inject f m' tm'.","conclusion":"Mem.inject f m' tm'","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"eapply Mem.storebytes_empty_inject; eauto."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm')","proofString":"intros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Some v.","conclusion":"Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v)","proofString":"rewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v)","proofString":"eapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v) : b <> bdst.","conclusion":"b <> bdst","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) nil = Some m') (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some nil) (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (e : sizeof tge ty = 0) (tm' : mem) (SB : Mem.storebytes tm bdst'\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil = \nSome tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v)","proofString":"congruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0)","proofString":"exploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) : Datatypes.length bytes = Z.to_nat (sizeof tge ty) ->\nexists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"Datatypes.length bytes = Z.to_nat (sizeof tge ty) ->\nexists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0)","proofString":"intros LEN.\nassert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty))","proofString":"assert (SZPOS: sizeof tge ty > 0).\ngeneralize (sizeof_pos tge ty); lia.\nassert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) : sizeof tge ty > 0.","conclusion":"sizeof tge ty > 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty))","proofString":"generalize (sizeof_pos tge ty); lia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0)","proofString":"assert (RPSRC: Mem.range_perm m bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty.","conclusion":"Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0)","proofString":"eapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty)","proofString":"assert (RPDST: Mem.range_perm m bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty).\nreplace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty.","conclusion":"Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty)","proofString":"replace (sizeof tge ty) with (Z.of_nat (List.length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)) Cur Nonempty.","conclusion":"Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)) Cur Nonempty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty)","proofString":"eapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) : Z.of_nat (Datatypes.length bytes) = sizeof tge ty.","conclusion":"Z.of_nat (Datatypes.length bytes) = sizeof tge ty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty)","proofString":"rewrite LEN.\napply Z2Nat.id.\nlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) : Z.of_nat (Z.to_nat (sizeof tge ty)) = sizeof tge ty.","conclusion":"Z.of_nat (Z.to_nat (sizeof tge ty)) = sizeof tge ty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty)","proofString":"apply Z2Nat.id.\nlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) : 0 <= sizeof tge ty.","conclusion":"0 <= sizeof tge ty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty)","proofString":"lia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty)","proofString":"assert (PSRC: Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty.","conclusion":"Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty)","proofString":"apply RPSRC.\nlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) : Ptrofs.unsigned osrc <= Ptrofs.unsigned osrc <\nPtrofs.unsigned osrc + sizeof tge ty.","conclusion":"Ptrofs.unsigned osrc <= Ptrofs.unsigned osrc <\nPtrofs.unsigned osrc + sizeof tge ty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty)","proofString":"lia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty)","proofString":"assert (PDST: Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty.","conclusion":"Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty)","proofString":"apply RPDST.\nlia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) : Ptrofs.unsigned odst <= Ptrofs.unsigned odst <\nPtrofs.unsigned odst + sizeof tge ty.","conclusion":"Ptrofs.unsigned odst <= Ptrofs.unsigned odst <\nPtrofs.unsigned odst + sizeof tge ty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty)","proofString":"lia."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty)","proofString":"exploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0)","proofString":"exploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta)","proofString":"exploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) : (exists bytes2 : list memval,\n   Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\n   Some bytes2 /\\ list_forall2 (memval_inject f) bytes bytes2) ->\nexists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"(exists bytes2 : list memval,\n   Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\n   Some bytes2 /\\ list_forall2 (memval_inject f) bytes bytes2) ->\nexists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta)","proofString":"intros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) : exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2)","proofString":"exploit Mem.storebytes_mapped_inject; eauto.\nintros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) : (exists n2 : mem,\n   Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some n2 /\\\n   Mem.inject f m' n2) ->\nexists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"(exists n2 : mem,\n   Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some n2 /\\\n   Mem.inject f m' n2) ->\nexists tm' : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2)","proofString":"intros [tm' [C D]].\nexists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : exists tm'0 : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm'0 : mem,\n  assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n    (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"exists tm'.\nsplit.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\nMem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm' /\\\nMem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"split.\neapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nsplit.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'.","conclusion":"assign_loc tge ty tm bdst' (Ptrofs.add odst (Ptrofs.repr delta)) Full\n  (Vptr bsrc' (Ptrofs.add osrc (Ptrofs.repr delta0))) tm'","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"eapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\nintros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat.\neapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty | Ptrofs.unsigned osrc + delta0).","conclusion":"sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty | Ptrofs.unsigned osrc + delta0)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"intros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0) : alignof_blockcopy tge ty = 1 \\/\nalignof_blockcopy tge ty = 2 \\/\nalignof_blockcopy tge ty = 4 \\/ alignof_blockcopy tge ty = 8.","conclusion":"alignof_blockcopy tge ty = 1 \\/\nalignof_blockcopy tge ty = 2 \\/\nalignof_blockcopy tge ty = 4 \\/ alignof_blockcopy tge ty = 8","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0)","proofString":"apply alignof_blockcopy_1248."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0) : (alignof_blockcopy tge ty | sizeof tge ty).","conclusion":"(alignof_blockcopy tge ty | sizeof tge ty)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0)","proofString":"apply sizeof_alignof_blockcopy_compat."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty | Ptrofs.unsigned odst + delta).","conclusion":"sizeof tge ty > 0 ->\n(alignof_blockcopy tge ty | Ptrofs.unsigned odst + delta)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"intros; eapply Mem.aligned_area_inject with (m := m); eauto.\napply alignof_blockcopy_1248.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0) : alignof_blockcopy tge ty = 1 \\/\nalignof_blockcopy tge ty = 2 \\/\nalignof_blockcopy tge ty = 4 \\/ alignof_blockcopy tge ty = 8.","conclusion":"alignof_blockcopy tge ty = 1 \\/\nalignof_blockcopy tge ty = 2 \\/\nalignof_blockcopy tge ty = 4 \\/ alignof_blockcopy tge ty = 8","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0)","proofString":"apply alignof_blockcopy_1248."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0) : (alignof_blockcopy tge ty | sizeof tge ty).","conclusion":"(alignof_blockcopy tge ty | sizeof tge ty)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (H : sizeof tge ty > 0)","proofString":"apply sizeof_alignof_blockcopy_compat."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : bsrc' <> bdst' \\/\nPtrofs.unsigned osrc + delta0 = Ptrofs.unsigned odst + delta \\/\nPtrofs.unsigned osrc + delta0 + sizeof tge ty <= Ptrofs.unsigned odst + delta \\/\nPtrofs.unsigned odst + delta + sizeof tge ty <= Ptrofs.unsigned osrc + delta0.","conclusion":"bsrc' <> bdst' \\/\nPtrofs.unsigned osrc + delta0 = Ptrofs.unsigned odst + delta \\/\nPtrofs.unsigned osrc + delta0 + sizeof tge ty <= Ptrofs.unsigned odst + delta \\/\nPtrofs.unsigned odst + delta + sizeof tge ty <= Ptrofs.unsigned osrc + delta0","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"eapply Mem.disjoint_or_equal_inject with (m := m); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Max Nonempty.","conclusion":"Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Max Nonempty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"apply Mem.range_perm_max with Cur; auto."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Max Nonempty.","conclusion":"Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Max Nonempty","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"apply Mem.range_perm_max with Cur; auto."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : Mem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"Mem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"split.\nauto.\nintros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : Mem.inject f m' tm'.","conclusion":"Mem.inject f m' tm'","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"auto."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm')","proofString":"intros.\nrewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Some v.","conclusion":"Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v)","proofString":"rewrite <- H0.\neapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v)","proofString":"eapply Mem.load_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v) : b <> bdst \\/\n0 + size_chunk chunk <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes) <= 0.","conclusion":"b <> bdst \\/\n0 + size_chunk chunk <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes) <= 0","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v)","proofString":"left.\ncongruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v) : b <> bdst.","conclusion":"b <> bdst","hypotheses":"(f : meminj) (ty : type) (m : mem) (bdst : block) (odst : ptrofs) (m' tm : mem) (bdst' bsrc : block) (osrc : ptrofs) (H2 : Mem.inject f m tm) (bytes : list memval) (H3 : access_mode ty = By_copy) (H4 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned osrc)) (H5 : sizeof tge ty > 0 -> (alignof_blockcopy tge ty | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sizeof tge ty <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sizeof tge ty <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty) = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (delta : Z) (H11 : f bdst = Some (bdst', delta)) (bsrc' : block) (delta0 : Z) (H9 : f bsrc = Some (bsrc', delta0)) (n : sizeof tge ty <> 0) (LEN : Datatypes.length bytes = Z.to_nat (sizeof tge ty)) (SZPOS : sizeof tge ty > 0) (RPSRC : Mem.range_perm m bsrc (Ptrofs.unsigned osrc)\n  (Ptrofs.unsigned osrc + sizeof tge ty) Cur Nonempty) (RPDST : Mem.range_perm m bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + sizeof tge ty) Cur Nonempty) (PSRC : Mem.perm m bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta0)) =\nPtrofs.unsigned osrc + delta0) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta)) =\nPtrofs.unsigned odst + delta) (bytes2 : list memval) (A : Mem.loadbytes tm bsrc' (Ptrofs.unsigned osrc + delta0) (sizeof tge ty) =\nSome bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (tm' : mem) (C : Mem.storebytes tm bdst' (Ptrofs.unsigned odst + delta) bytes2 = Some tm') (D : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H : f b = None) (H0 : Mem.load chunk m b 0 = Some v)","proofString":"congruence."},{"statement":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (v'0 : val) (H3 : store_bitfield ty sz sg pos width m (Vptr loc ofs) v m' v'0) : exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0).","conclusion":"exists tm' : mem,\n  assign_loc tge ty tm loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v0 : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0)","hypotheses":"(f : meminj) (ty : type) (m : mem) (loc : block) (ofs : ptrofs) (v : val) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : Val.inject f v v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (v'0 : val) (H3 : store_bitfield ty sz sg pos width m (Vptr loc ofs) v m' v'0)","proofString":"inv H3.\nexploit Mem.loadv_inject; eauto.\nintros (vc' & LD' & INJ).\ninv INJ.\nexploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\ninv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : exists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"exploit Mem.loadv_inject; eauto.\nintros (vc' & LD' & INJ).\ninv INJ.\nexploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\ninv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : (exists v2 : val,\n   Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some v2 /\\\n   Val.inject f (Vint c) v2) ->\nexists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"(exists v2 : val,\n   Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some v2 /\\\n   Val.inject f (Vint c) v2) ->\nexists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"intros (vc' & LD' & INJ).\ninv INJ.\nexploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\ninv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (vc' : val) (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some vc') (INJ : Val.inject f (Vint c) vc') : exists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (vc' : val) (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some vc') (INJ : Val.inject f (Vint c) vc')","proofString":"inv INJ.\nexploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\ninv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) : exists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c))","proofString":"exploit Mem.storev_mapped_inject; eauto.\nintros [tm' [A B]].\ninv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) : (exists n2 : mem,\n   Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n     (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) =\n   Some n2 /\\ Mem.inject f m' n2) ->\nexists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"(exists n2 : mem,\n   Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n     (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) =\n   Some n2 /\\ Mem.inject f m' n2) ->\nexists tm' : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm' /\\\n  Mem.inject f m' tm' /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c))","proofString":"intros [tm' [A B]].\ninv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') : exists tm'0 : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm'0 : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) v' tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (v' : val) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H1 : Val.inject f (Vint n) v') (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm')","proofString":"inv H1.\nexists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') : exists tm'0 : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) (Vint n) tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"exists tm'0 : mem,\n  assign_loc tge\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) (Vint n) tm'0 /\\\n  Mem.inject f m' tm'0 /\\\n  (forall (b : block) (chunk : memory_chunk) (v : val),\n   f b = None ->\n   Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm')","proofString":"exists tm'; split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nsplit.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') : assign_loc tge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n  loc' ofs' (Bits sz sg pos width) (Vint n) tm'.","conclusion":"assign_loc tge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n  loc' ofs' (Bits sz sg pos width) (Vint n) tm'","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm')","proofString":"eapply assign_loc_bitfield; eauto.\neconstructor; eauto."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') : Mem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).","conclusion":"Mem.inject f m' tm' /\\\n(forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v)","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm')","proofString":"split.\nauto.\nintros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') : Mem.inject f m' tm'.","conclusion":"Mem.inject f m' tm'","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm')","proofString":"auto."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm')","proofString":"intros.\nrewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Some v.","conclusion":"Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v)","proofString":"rewrite <- H3.\neapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v)","proofString":"eapply Mem.load_store_other; eauto.\nleft.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v) : b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk (chunk_for_carrier sz) <= 0.","conclusion":"b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk (chunk_for_carrier sz) <= 0","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v)","proofString":"left.\ninv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v) : b <> loc.","conclusion":"b <> loc","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (LD' : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm (Vptr loc' ofs')\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v)","proofString":"inv H0.\ncongruence."},{"statement":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (delta : Z) (LD' : Mem.loadv (chunk_for_carrier sz) tm\n  (Vptr loc' (Ptrofs.add ofs (Ptrofs.repr delta))) = \nSome (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm\n  (Vptr loc' (Ptrofs.add ofs (Ptrofs.repr delta)))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v) (H11 : f loc = Some (loc', delta)) : b <> loc.","conclusion":"b <> loc","hypotheses":"(f : meminj) (m : mem) (loc : block) (ofs : ptrofs) (m' tm : mem) (loc' : block) (n : int) (H2 : Mem.inject f m tm) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H4 : 0 < width <= bitsize_intsize sz) (H5 : pos + width <= bitsize_carrier sz) (H7 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H8 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (delta : Z) (LD' : Mem.loadv (chunk_for_carrier sz) tm\n  (Vptr loc' (Ptrofs.add ofs (Ptrofs.repr delta))) = \nSome (Vint c)) (tm' : mem) (A : Mem.storev (chunk_for_carrier sz) tm\n  (Vptr loc' (Ptrofs.add ofs (Ptrofs.repr delta)))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome tm') (B : Mem.inject f m' tm') (b : block) (chunk : memory_chunk) (v : val) (H1 : f b = None) (H3 : Mem.load chunk m b 0 = Some v) (H11 : f loc = Some (loc', delta))","proofString":"congruence."},{"statement":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (m' : mem) (H : access_mode ty = By_value chunk) (H0 : Mem.storev chunk m (Vptr b ofs) v = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (m' : mem) (H : access_mode ty = By_value chunk) (H0 : Mem.storev chunk m (Vptr b ofs) v = Some m')","proofString":"simpl in H0.\neapply Mem.nextblock_store; eauto."},{"statement":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (m' : mem) (H : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (m' : mem) (H : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m')","proofString":"eapply Mem.nextblock_store; eauto."},{"statement":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (bytes : list memval) (m' : mem) (H : access_mode ty = By_copy) (H0 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned ofs')) (H1 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned ofs)) (H2 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge0 ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge0 ty <= Ptrofs.unsigned ofs') (H3 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge0 ty) = Some bytes) (H4 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (bytes : list memval) (m' : mem) (H : access_mode ty = By_copy) (H0 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned ofs')) (H1 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned ofs)) (H2 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge0 ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge0 ty <= Ptrofs.unsigned ofs') (H3 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge0 ty) = Some bytes) (H4 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"eapply Mem.nextblock_storebytes; eauto."},{"statement":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (m' : mem) (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(ge0 : composite_env) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (m' : mem) (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v')","proofString":"inv H.\neapply Mem.nextblock_store; eauto."},{"statement":"(ge0 : composite_env) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(ge0 : composite_env) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"eapply Mem.nextblock_store; eauto."},{"statement":"(ge0 : genv) (e : env) (m : mem) : Mem.nextblock m = Mem.nextblock m.","conclusion":"Mem.nextblock m = Mem.nextblock m","hypotheses":"(ge0 : genv) (e : env) (m : mem)","proofString":"auto."},{"statement":"(ge0 : genv) (e : env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H0 : assign_loc ge0 ty m b Ptrofs.zero Full v1 m1) (H1 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.nextblock m2 = Mem.nextblock m1) : Mem.nextblock m2 = Mem.nextblock m.","conclusion":"Mem.nextblock m2 = Mem.nextblock m","hypotheses":"(ge0 : genv) (e : env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H0 : assign_loc ge0 ty m b Ptrofs.zero Full v1 m1) (H1 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.nextblock m2 = Mem.nextblock m1)","proofString":"rewrite IHbind_parameters.\neapply assign_loc_nextblock; eauto."},{"statement":"(ge0 : genv) (e : env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H0 : assign_loc ge0 ty m b Ptrofs.zero Full v1 m1) (H1 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.nextblock m2 = Mem.nextblock m1) : Mem.nextblock m1 = Mem.nextblock m.","conclusion":"Mem.nextblock m1 = Mem.nextblock m","hypotheses":"(ge0 : genv) (e : env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H0 : assign_loc ge0 ty m b Ptrofs.zero Full v1 m1) (H1 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.nextblock m2 = Mem.nextblock m1)","proofString":"eapply assign_loc_nextblock; eauto."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id : positive) (b' : block) (ty : type),\ne ! id = Some (b', ty) -> b <> b') (m : mem) : Mem.load chunk m b ofs = Mem.load chunk m b ofs.","conclusion":"Mem.load chunk m b ofs = Mem.load chunk m b ofs","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id : positive) (b' : block) (ty : type),\ne ! id = Some (b', ty) -> b <> b') (m : mem)","proofString":"auto."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H1 : assign_loc ge0 ty m b0 Ptrofs.zero Full v1 m1) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) : Mem.load chunk m2 b ofs = Mem.load chunk m b ofs.","conclusion":"Mem.load chunk m2 b ofs = Mem.load chunk m b ofs","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H1 : assign_loc ge0 ty m b0 Ptrofs.zero Full v1 m1) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs)","proofString":"rewrite IHbind_parameters.\nassert (b <> b0) by eauto.\ninv H1.\nsimpl in H5.\neapply Mem.load_store_other; eauto.\neapply Mem.load_storebytes_other; eauto."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H1 : assign_loc ge0 ty m b0 Ptrofs.zero Full v1 m1) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) : Mem.load chunk m1 b ofs = Mem.load chunk m b ofs.","conclusion":"Mem.load chunk m1 b ofs = Mem.load chunk m b ofs","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H1 : assign_loc ge0 ty m b0 Ptrofs.zero Full v1 m1) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs)","proofString":"assert (b <> b0) by eauto.\ninv H1.\nsimpl in H5.\neapply Mem.load_store_other; eauto.\neapply Mem.load_storebytes_other; eauto."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H1 : assign_loc ge0 ty m b0 Ptrofs.zero Full v1 m1) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0) : Mem.load chunk m1 b ofs = Mem.load chunk m b ofs.","conclusion":"Mem.load chunk m1 b ofs = Mem.load chunk m b ofs","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H1 : assign_loc ge0 ty m b0 Ptrofs.zero Full v1 m1) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0)","proofString":"inv H1.\nsimpl in H5.\neapply Mem.load_store_other; eauto.\neapply Mem.load_storebytes_other; eauto."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0) (chunk0 : memory_chunk) (H4 : access_mode ty = By_value chunk0) (H5 : Mem.storev chunk0 m (Vptr b0 Ptrofs.zero) v1 = Some m1) : Mem.load chunk m1 b ofs = Mem.load chunk m b ofs.","conclusion":"Mem.load chunk m1 b ofs = Mem.load chunk m b ofs","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0) (chunk0 : memory_chunk) (H4 : access_mode ty = By_value chunk0) (H5 : Mem.storev chunk0 m (Vptr b0 Ptrofs.zero) v1 = Some m1)","proofString":"simpl in H5.\neapply Mem.load_store_other; eauto."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0) (chunk0 : memory_chunk) (H4 : access_mode ty = By_value chunk0) (H5 : Mem.store chunk0 m b0 (Ptrofs.unsigned Ptrofs.zero) v1 = Some m1) : Mem.load chunk m1 b ofs = Mem.load chunk m b ofs.","conclusion":"Mem.load chunk m1 b ofs = Mem.load chunk m b ofs","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b' : block) (ty0 : type),\ne ! id0 = Some (b', ty0) -> b <> b') (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0) (chunk0 : memory_chunk) (H4 : access_mode ty = By_value chunk0) (H5 : Mem.store chunk0 m b0 (Ptrofs.unsigned Ptrofs.zero) v1 = Some m1)","proofString":"eapply Mem.load_store_other; eauto."},{"statement":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b'0 : block) (ty0 : type),\ne ! id0 = Some (b'0, ty0) -> b <> b'0) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned ofs')) (H6 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned Ptrofs.zero)) (H7 : b' <> b0 \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned ofs' + sizeof ge0 ty <= Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned Ptrofs.zero + sizeof ge0 ty <= Ptrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge0 ty) = Some bytes) (H9 : Mem.storebytes m b0 (Ptrofs.unsigned Ptrofs.zero) bytes = Some m1) : Mem.load chunk m1 b ofs = Mem.load chunk m b ofs.","conclusion":"Mem.load chunk m1 b ofs = Mem.load chunk m b ofs","hypotheses":"(ge0 : genv) (e : PTree.tree (block * type)) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall (id0 : positive) (b'0 : block) (ty0 : type),\ne ! id0 = Some (b'0, ty0) -> b <> b'0) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (b0 : block) (m1 m2 : mem) (H0 : e ! id = Some (b0, ty)) (H2 : bind_parameters ge0 e m1 params vl m2) (IHbind_parameters : Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs) (H3 : b <> b0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned ofs')) (H6 : sizeof ge0 ty > 0 -> (alignof_blockcopy ge0 ty | Ptrofs.unsigned Ptrofs.zero)) (H7 : b' <> b0 \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned ofs' + sizeof ge0 ty <= Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned Ptrofs.zero + sizeof ge0 ty <= Ptrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge0 ty) = Some bytes) (H9 : Mem.storebytes m b0 (Ptrofs.unsigned Ptrofs.zero) bytes = Some m1)","proofString":"eapply Mem.load_storebytes_other; eauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) : False.","conclusion":"False","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty)","proofString":"exploit Mem.perm_free_list; eauto.\nintros [A B].\napply B with 0 (sizeof ce ty); auto.\nunfold blocks_of_env.\nchange (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) : Mem.perm m b ofs k p /\\\n(forall lo hi : Z,\n In (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) -> False.","conclusion":"Mem.perm m b ofs k p /\\\n(forall lo hi : Z,\n In (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) -> False","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty)","proofString":"intros [A B].\napply B with 0 (sizeof ce ty); auto.\nunfold blocks_of_env.\nchange (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) : False.","conclusion":"False","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False)","proofString":"apply B with 0 (sizeof ce ty); auto.\nunfold blocks_of_env.\nchange (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) : In (b, 0, sizeof ce ty) (blocks_of_env ce e).","conclusion":"In (b, 0, sizeof ce ty) (blocks_of_env ce e)","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False)","proofString":"unfold blocks_of_env.\nchange (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) : In (b, 0, sizeof ce ty) (map (block_of_binding ce) (PTree.elements e)).","conclusion":"In (b, 0, sizeof ce ty) (map (block_of_binding ce) (PTree.elements e))","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False)","proofString":"change (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) : In (block_of_binding ce (id, (b, ty)))\n  (map (block_of_binding ce) (PTree.elements e)).","conclusion":"In (block_of_binding ce (id, (b, ty)))\n  (map (block_of_binding ce) (PTree.elements e))","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False)","proofString":"apply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) : In (id, (b, ty)) (PTree.elements e).","conclusion":"In (id, (b, ty)) (PTree.elements e)","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False)","proofString":"apply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False) : e ! id = Some (b, ty).","conclusion":"e ! id = Some (b, ty)","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) (H1 : Mem.perm m' b ofs k p) (H2 : 0 <= ofs < sizeof ce ty) (A : Mem.perm m b ofs k p) (B : forall lo hi : Z,\nIn (b, lo, hi) (blocks_of_env ce e) -> lo <= ofs < hi -> False)","proofString":"auto."},{"statement":"(b : block) (lo hi : Z) (m m' : mem) (H : Some m = Some m') (H0 : False) : Mem.range_perm m b lo hi Cur Freeable.","conclusion":"Mem.range_perm m b lo hi Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (m m' : mem) (H : Some m = Some m') (H0 : False)","proofString":"contradiction."},{"statement":"(b : block) (lo hi : Z) (a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' : mem) (H : (let (p0, hi0) := a in\n let (b0, lo0) := p0 in\n match Mem.free m b0 lo0 hi0 with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') (H0 : a = (b, lo, hi) \\/ In (b, lo, hi) l) : Mem.range_perm m b lo hi Cur Freeable.","conclusion":"Mem.range_perm m b lo hi Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' : mem) (H : (let (p0, hi0) := a in\n let (b0, lo0) := p0 in\n match Mem.free m b0 lo0 hi0 with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') (H0 : a = (b, lo, hi) \\/ In (b, lo, hi) l)","proofString":"destruct a as [[b1 lo1] hi1].\ndestruct (Mem.free m b1 lo1 hi1) as [m1|] eqn:?; try discriminate.\ndestruct H0.\ninv H0.\neapply Mem.free_range_perm; eauto.\nred; intros.\neapply Mem.perm_free_3; eauto.\neapply IHl; eauto."},{"statement":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' : mem) (H : match Mem.free m b1 lo1 hi1 with\n| Some m'0 => Mem.free_list m'0 l\n| None => None\nend = Some m') (H0 : (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l) : Mem.range_perm m b lo hi Cur Freeable.","conclusion":"Mem.range_perm m b lo hi Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' : mem) (H : match Mem.free m b1 lo1 hi1 with\n| Some m'0 => Mem.free_list m'0 l\n| None => None\nend = Some m') (H0 : (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l)","proofString":"destruct (Mem.free m b1 lo1 hi1) as [m1|] eqn:?; try discriminate.\ndestruct H0.\ninv H0.\neapply Mem.free_range_perm; eauto.\nred; intros.\neapply Mem.perm_free_3; eauto.\neapply IHl; eauto."},{"statement":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l) : Mem.range_perm m b lo hi Cur Freeable.","conclusion":"Mem.range_perm m b lo hi Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l)","proofString":"destruct H0.\ninv H0.\neapply Mem.free_range_perm; eauto.\nred; intros.\neapply Mem.perm_free_3; eauto.\neapply IHl; eauto."},{"statement":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : (b1, lo1, hi1) = (b, lo, hi)) : Mem.range_perm m b lo hi Cur Freeable.","conclusion":"Mem.range_perm m b lo hi Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : (b1, lo1, hi1) = (b, lo, hi))","proofString":"inv H0.\neapply Mem.free_range_perm; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b lo hi = Some m1) (H : Mem.free_list m1 l = Some m') : Mem.range_perm m b lo hi Cur Freeable.","conclusion":"Mem.range_perm m b lo hi Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b lo hi = Some m1) (H : Mem.free_list m1 l = Some m')","proofString":"eapply Mem.free_range_perm; eauto."},{"statement":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : In (b, lo, hi) l) : Mem.range_perm m b lo hi Cur Freeable.","conclusion":"Mem.range_perm m b lo hi Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : In (b, lo, hi) l)","proofString":"red; intros.\neapply Mem.perm_free_3; eauto.\neapply IHl; eauto."},{"statement":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : In (b, lo, hi) l) (ofs : Z) (H1 : lo <= ofs < hi) : Mem.perm m b ofs Cur Freeable.","conclusion":"Mem.perm m b ofs Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : In (b, lo, hi) l) (ofs : Z) (H1 : lo <= ofs < hi)","proofString":"eapply Mem.perm_free_3; eauto.\neapply IHl; eauto."},{"statement":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : In (b, lo, hi) l) (ofs : Z) (H1 : lo <= ofs < hi) : Mem.perm m1 b ofs Cur Freeable.","conclusion":"Mem.perm m1 b ofs Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nIn (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) (m m' m1 : mem) (Heqo : Mem.free m b1 lo1 hi1 = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : In (b, lo, hi) l) (ofs : Z) (H1 : lo <= ofs < hi)","proofString":"eapply IHl; eauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) : Mem.range_perm m b 0 (sizeof ce ty) Cur Freeable.","conclusion":"Mem.range_perm m b 0 (sizeof ce ty) Cur Freeable","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty))","proofString":"eapply free_list_perm'; eauto.\nunfold blocks_of_env.\nchange (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) : In (b, 0, sizeof ce ty) (blocks_of_env ce e).","conclusion":"In (b, 0, sizeof ce ty) (blocks_of_env ce e)","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty))","proofString":"unfold blocks_of_env.\nchange (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) : In (b, 0, sizeof ce ty) (map (block_of_binding ce) (PTree.elements e)).","conclusion":"In (b, 0, sizeof ce ty) (map (block_of_binding ce) (PTree.elements e))","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty))","proofString":"change (b, 0, sizeof ce ty) with (block_of_binding ce (id, (b, ty))).\napply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) : In (block_of_binding ce (id, (b, ty)))\n  (map (block_of_binding ce) (PTree.elements e)).","conclusion":"In (block_of_binding ce (id, (b, ty)))\n  (map (block_of_binding ce) (PTree.elements e))","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty))","proofString":"apply in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) : In (id, (b, ty)) (PTree.elements e).","conclusion":"In (id, (b, ty)) (PTree.elements e)","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty))","proofString":"apply PTree.elements_correct.\nauto."},{"statement":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty)) : e ! id = Some (b, ty).","conclusion":"e ! id = Some (b, ty)","hypotheses":"(ce : genv) (m : mem) (e : env) (m' : mem) (id : positive) (b : block) (ty : type) (H : Mem.free_list m (blocks_of_env ce e) = Some m') (H0 : e ! id = Some (b, ty))","proofString":"auto."},{"statement":"(m : mem) (H : forall (b : block) (lo hi : Z),\nFalse -> Mem.range_perm m b lo hi Cur Freeable) (H0 : True) : exists m' : mem, Some m = Some m'.","conclusion":"exists m' : mem, Some m = Some m'","hypotheses":"(m : mem) (H : forall (b : block) (lo hi : Z),\nFalse -> Mem.range_perm m b lo hi Cur Freeable) (H0 : True)","proofString":"exists m; auto."},{"statement":"(a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b : block) (lo hi : Z),\n In (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b : block) (lo hi : Z),\na = (b, lo, hi) \\/ In (b, lo, hi) l -> Mem.range_perm m b lo hi Cur Freeable) (H0 : let (p0, hi) := a in\nlet (b, lo) := p0 in\nfreelist_no_overlap l /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo')) : exists m' : mem,\n  (let (p0, hi) := a in\n   let (b, lo) := p0 in\n   match Mem.free m b lo hi with\n   | Some m'0 => Mem.free_list m'0 l\n   | None => None\n   end) = Some m'.","conclusion":"exists m' : mem,\n  (let (p0, hi) := a in\n   let (b, lo) := p0 in\n   match Mem.free m b lo hi with\n   | Some m'0 => Mem.free_list m'0 l\n   | None => None\n   end) = Some m'","hypotheses":"(a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b : block) (lo hi : Z),\n In (b, lo, hi) l -> Mem.range_perm m0 b lo hi Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b : block) (lo hi : Z),\na = (b, lo, hi) \\/ In (b, lo, hi) l -> Mem.range_perm m b lo hi Cur Freeable) (H0 : let (p0, hi) := a in\nlet (b, lo) := p0 in\nfreelist_no_overlap l /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo'))","proofString":"destruct a as [[b lo] hi].\ndestruct H0.\ndestruct (Mem.range_perm_free m b lo hi) as [m1 A]; auto.\nrewrite A.\napply IHl; auto.\nintros.\nred; intros.\neapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo')) : exists m' : mem,\n  match Mem.free m b lo hi with\n  | Some m'0 => Mem.free_list m'0 l\n  | None => None\n  end = Some m'.","conclusion":"exists m' : mem,\n  match Mem.free m b lo hi with\n  | Some m'0 => Mem.free_list m'0 l\n  | None => None\n  end = Some m'","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo'))","proofString":"destruct H0.\ndestruct (Mem.range_perm_free m b lo hi) as [m1 A]; auto.\nrewrite A.\napply IHl; auto.\nintros.\nred; intros.\neapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') : exists m' : mem,\n  match Mem.free m b lo hi with\n  | Some m'0 => Mem.free_list m'0 l\n  | None => None\n  end = Some m'.","conclusion":"exists m' : mem,\n  match Mem.free m b lo hi with\n  | Some m'0 => Mem.free_list m'0 l\n  | None => None\n  end = Some m'","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo')","proofString":"destruct (Mem.range_perm_free m b lo hi) as [m1 A]; auto.\nrewrite A.\napply IHl; auto.\nintros.\nred; intros.\neapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) : exists m' : mem,\n  match Mem.free m b lo hi with\n  | Some m'0 => Mem.free_list m'0 l\n  | None => None\n  end = Some m'.","conclusion":"exists m' : mem,\n  match Mem.free m b lo hi with\n  | Some m'0 => Mem.free_list m'0 l\n  | None => None\n  end = Some m'","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1)","proofString":"rewrite A.\napply IHl; auto.\nintros.\nred; intros.\neapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) : exists m' : mem, Mem.free_list m1 l = Some m'.","conclusion":"exists m' : mem, Mem.free_list m1 l = Some m'","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1)","proofString":"apply IHl; auto.\nintros.\nred; intros.\neapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) : forall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m1 b0 lo0 hi0 Cur Freeable.","conclusion":"forall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m1 b0 lo0 hi0 Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b0 : block) (lo0 hi0 : Z),\n In (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b0 : block) (lo0 hi0 : Z),\n(b, lo, hi) = (b0, lo0, hi0) \\/ In (b0, lo0, hi0) l ->\nMem.range_perm m b0 lo0 hi0 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1)","proofString":"intros.\nred; intros.\neapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) : Mem.range_perm m1 b0 lo0 hi0 Cur Freeable.","conclusion":"Mem.range_perm m1 b0 lo0 hi0 Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l)","proofString":"red; intros.\neapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) : Mem.perm m1 b0 ofs Cur Freeable.","conclusion":"Mem.perm m1 b0 ofs Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0)","proofString":"eapply Mem.perm_free_1; eauto.\nexploit H1; eauto.\nintros [B|B].\nauto.\nright; lia.\neapply H; eauto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","conclusion":"b0 <> b \\/ ofs < lo \\/ hi <= ofs","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0)","proofString":"exploit H1; eauto.\nintros [B|B].\nauto.\nright; lia."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) : b0 <> b \\/ hi0 <= lo \\/ hi <= lo0 -> b0 <> b \\/ ofs < lo \\/ hi <= ofs.","conclusion":"b0 <> b \\/ hi0 <= lo \\/ hi <= lo0 -> b0 <> b \\/ ofs < lo \\/ hi <= ofs","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0)","proofString":"intros [B|B].\nauto.\nright; lia."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) (B : b0 <> b) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","conclusion":"b0 <> b \\/ ofs < lo \\/ hi <= ofs","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) (B : b0 <> b)","proofString":"auto."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) (B : hi0 <= lo \\/ hi <= lo0) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","conclusion":"b0 <> b \\/ ofs < lo \\/ hi <= ofs","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) (B : hi0 <= lo \\/ hi <= lo0)","proofString":"right; lia."},{"statement":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0) : Mem.perm m b0 ofs Cur Freeable.","conclusion":"Mem.perm m b0 ofs Cur Freeable","hypotheses":"(b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 : mem,\n(forall (b1 : block) (lo1 hi1 : Z),\n In (b1, lo1, hi1) l -> Mem.range_perm m0 b1 lo1 hi1 Cur Freeable) ->\nfreelist_no_overlap l -> exists m' : mem, Mem.free_list m0 l = Some m') (m : mem) (H : forall (b1 : block) (lo1 hi1 : Z),\n(b, lo, hi) = (b1, lo1, hi1) \\/ In (b1, lo1, hi1) l ->\nMem.range_perm m b1 lo1 hi1 Cur Freeable) (H0 : freelist_no_overlap l) (H1 : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') l -> b' <> b \\/ hi' <= lo \\/ hi <= lo') (m1 : mem) (A : Mem.free m b lo hi = Some m1) (b0 : block) (lo0 hi0 : Z) (H2 : In (b0, lo0, hi0) l) (ofs : Z) (H3 : lo0 <= ofs < hi0)","proofString":"eapply H; eauto."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Mem.range_perm m b 0 (sizeof ge0 ty) Cur Freeable) : forall l : list (positive * (block * type)),\nlist_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l).","conclusion":"forall l : list (positive * (block * type)),\nlist_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Mem.range_perm m b 0 (sizeof ge0 ty) Cur Freeable)","proofString":"induction l; simpl; intros.\nauto.\ndestruct a as [id [b ty]].\nsimpl in *.\ninv H.\nsplit.\napply IHl; auto.\nintros.\nexploit list_in_map_inv; eauto.\nintros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Mem.range_perm m b 0 (sizeof ge0 ty) Cur Freeable) (a : positive * (block * type)) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H : list_norepet (fst a :: map fst l)) (H0 : forall (id : positive) (bty : block * type),\na = (id, bty) \\/ In (id, bty) l -> te ! id = Some bty) : let (p0, hi0) := block_of_binding ge0 a in\nlet (b, lo0) := p0 in\nfreelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b \\/ hi' <= lo0 \\/ hi0 <= lo').","conclusion":"let (p0, hi0) := block_of_binding ge0 a in\nlet (b, lo0) := p0 in\nfreelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b \\/ hi' <= lo0 \\/ hi0 <= lo')","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b : block) (ty : type),\ne ! id = Some (b, ty) -> Mem.range_perm m b 0 (sizeof ge0 ty) Cur Freeable) (a : positive * (block * type)) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H : list_norepet (fst a :: map fst l)) (H0 : forall (id : positive) (bty : block * type),\na = (id, bty) \\/ In (id, bty) l -> te ! id = Some bty)","proofString":"destruct a as [id [b ty]].\nsimpl in *.\ninv H.\nsplit.\napply IHl; auto.\nintros.\nexploit list_in_map_inv; eauto.\nintros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H : list_norepet (fst (id, (b, ty)) :: map fst l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) : let (p0, hi0) := block_of_binding ge0 (id, (b, ty)) in\nlet (b0, lo0) := p0 in\nfreelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b0 \\/ hi' <= lo0 \\/ hi0 <= lo').","conclusion":"let (p0, hi0) := block_of_binding ge0 (id, (b, ty)) in\nlet (b0, lo0) := p0 in\nfreelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b0 \\/ hi' <= lo0 \\/ hi0 <= lo')","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H : list_norepet (fst (id, (b, ty)) :: map fst l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty)","proofString":"simpl in *.\ninv H.\nsplit.\napply IHl; auto.\nintros.\nexploit list_in_map_inv; eauto.\nintros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H : list_norepet (id :: map fst l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) : freelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo').","conclusion":"freelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo')","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H : list_norepet (id :: map fst l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty)","proofString":"inv H.\nsplit.\napply IHl; auto.\nintros.\nexploit list_in_map_inv; eauto.\nintros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) : freelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo').","conclusion":"freelist_no_overlap (map (block_of_binding ge0) l) /\\\n(forall (b' : block) (lo' hi' : Z),\n In (b', lo', hi') (map (block_of_binding ge0) l) ->\n b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo')","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l))","proofString":"split.\napply IHl; auto.\nintros.\nexploit list_in_map_inv; eauto.\nintros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) : freelist_no_overlap (map (block_of_binding ge0) l).","conclusion":"freelist_no_overlap (map (block_of_binding ge0) l)","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l))","proofString":"apply IHl; auto."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) : forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') (map (block_of_binding ge0) l) ->\nb' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'.","conclusion":"forall (b' : block) (lo' hi' : Z),\nIn (b', lo', hi') (map (block_of_binding ge0) l) ->\nb' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l))","proofString":"intros.\nexploit list_in_map_inv; eauto.\nintros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l)) : b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'.","conclusion":"b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l))","proofString":"exploit list_in_map_inv; eauto.\nintros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l)) : (exists x : ident * (block * type),\n   (b', lo', hi') = block_of_binding ge0 x /\\ In x l) ->\nb' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'.","conclusion":"(exists x : ident * (block * type),\n   (b', lo', hi') = block_of_binding ge0 x /\\ In x l) ->\nb' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l))","proofString":"intros [[id' [b'' ty']] [A B]].\nsimpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l)) (id' : ident) (b'' : block) (ty' : type) (A : (b', lo', hi') = block_of_binding ge0 (id', (b'', ty'))) (B : In (id', (b'', ty')) l) : b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'.","conclusion":"b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l)) (id' : ident) (b'' : block) (ty' : type) (A : (b', lo', hi') = block_of_binding ge0 (id', (b'', ty'))) (B : In (id', (b'', ty')) l)","proofString":"simpl in A.\ninv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l)) (id' : ident) (b'' : block) (ty' : type) (A : (b', lo', hi') = (b'', 0, sizeof ge0 ty')) (B : In (id', (b'', ty')) l) : b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'.","conclusion":"b' <> b \\/ hi' <= 0 \\/ sizeof ge0 ty <= lo'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (lo' hi' : Z) (H : In (b', lo', hi') (map (block_of_binding ge0) l)) (id' : ident) (b'' : block) (ty' : type) (A : (b', lo', hi') = (b'', 0, sizeof ge0 ty')) (B : In (id', (b'', ty')) l)","proofString":"inv A.\nrename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b'' : block) (ty' : type) (H : In (b'', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b'', ty')) l) : b'' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b'' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b'' : block) (ty' : type) (H : In (b'', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b'', ty')) l)","proofString":"rename b'' into b'.\nassert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l)","proofString":"assert (TE: te!id = Some(b, ty)) by eauto.\nassert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty))","proofString":"assert (TE': te!id' = Some(b', ty')) by eauto.\nexploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b0 : block) (ty0 : type),\ne ! id0 = Some (b0, ty0) ->\nMem.range_perm m b0 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty'))","proofString":"exploit me_mapped.\neauto.\neexact TE.\nintros [b0 [INJ E]].\nexploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty))","proofString":"exploit me_mapped.\neauto.\neexact TE'.\nintros [b0' [INJ' E']].\ndestruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty'))","proofString":"destruct (zle (sizeof ge0 ty) 0); auto.\ndestruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0)","proofString":"destruct (zle (sizeof ge0 ty') 0); auto.\nassert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0)","proofString":"assert (b0 <> b0').\neapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto.\nassert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) : b0 <> b0'.","conclusion":"b0 <> b0'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0)","proofString":"eapply me_inj; eauto.\nred; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) : id <> id'.","conclusion":"id <> id'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0)","proofString":"red; intros; subst; elim H3.\nchange id' with (fst (id', (b', ty'))).\napply List.in_map; auto."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b1 : block) (ty0 : type),\ne ! id = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (id' : ident) (H3 : ~ In id' (map fst l)) (H0 : forall (id : positive) (bty : block * type),\n(id', (b, ty)) = (id, bty) \\/ In (id, bty) l -> te ! id = Some bty) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (B : In (id', (b', ty')) l) (TE : te ! id' = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id' = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) : In id' (map fst l).","conclusion":"In id' (map fst l)","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b1 : block) (ty0 : type),\ne ! id = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (id' : ident) (H3 : ~ In id' (map fst l)) (H0 : forall (id : positive) (bty : block * type),\n(id', (b, ty)) = (id, bty) \\/ In (id, bty) l -> te ! id = Some bty) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (B : In (id', (b', ty')) l) (TE : te ! id' = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id' = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0)","proofString":"change id' with (fst (id', (b', ty'))).\napply List.in_map; auto."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b1 : block) (ty0 : type),\ne ! id = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (id' : ident) (H3 : ~ In id' (map fst l)) (H0 : forall (id : positive) (bty : block * type),\n(id', (b, ty)) = (id, bty) \\/ In (id, bty) l -> te ! id = Some bty) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (B : In (id', (b', ty')) l) (TE : te ! id' = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id' = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) : In (fst (id', (b', ty'))) (map fst l).","conclusion":"In (fst (id', (b', ty'))) (map fst l)","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id : positive) (b1 : block) (ty0 : type),\ne ! id = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id : positive) (bty : block * type),\n In (id, bty) l -> te ! id = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (id' : ident) (H3 : ~ In id' (map fst l)) (H0 : forall (id : positive) (bty : block * type),\n(id', (b, ty)) = (id, bty) \\/ In (id, bty) l -> te ! id = Some bty) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (B : In (id', (b', ty')) l) (TE : te ! id' = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id' = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0)","proofString":"apply List.in_map; auto."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0')","proofString":"assert (Mem.perm m b0 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nassert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') : Mem.perm m b0 0 Max Nonempty.","conclusion":"Mem.perm m b0 0 Max Nonempty","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0')","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') : Mem.perm m b0 0 Cur Nonempty.","conclusion":"Mem.perm m b0 0 Cur Nonempty","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0')","proofString":"apply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') : Mem.perm m b0 0 Cur Freeable.","conclusion":"Mem.perm m b0 0 Cur Freeable","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0')","proofString":"eapply PERMS; eauto.\nlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') : 0 <= 0 < sizeof ge0 ty.","conclusion":"0 <= 0 < sizeof ge0 ty","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0')","proofString":"lia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') : perm_order Freeable Nonempty.","conclusion":"perm_order Freeable Nonempty","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0')","proofString":"auto with mem."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty)","proofString":"assert (Mem.perm m b0' 0 Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem.\nexploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) : Mem.perm m b0' 0 Max Nonempty.","conclusion":"Mem.perm m b0' 0 Max Nonempty","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty)","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) : Mem.perm m b0' 0 Cur Nonempty.","conclusion":"Mem.perm m b0' 0 Cur Nonempty","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty)","proofString":"apply Mem.perm_implies with Freeable.\neapply PERMS; eauto.\nlia.\nauto with mem."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) : Mem.perm m b0' 0 Cur Freeable.","conclusion":"Mem.perm m b0' 0 Cur Freeable","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty)","proofString":"eapply PERMS; eauto.\nlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) : 0 <= 0 < sizeof ge0 ty'.","conclusion":"0 <= 0 < sizeof ge0 ty'","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty)","proofString":"lia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) : perm_order Freeable Nonempty.","conclusion":"perm_order Freeable Nonempty","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty)","proofString":"auto with mem."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty)","proofString":"exploit Mem.mi_no_overlap; eauto.\nintros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty) : b <> b' \\/ 0 + 0 <> 0 + 0 ->\nb' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b <> b' \\/ 0 + 0 <> 0 + 0 ->\nb' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty)","proofString":"intros [A|A].\nauto.\nextlia."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty) (A : b <> b') : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty) (A : b <> b')","proofString":"auto."},{"statement":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty) (A : 0 + 0 <> 0 + 0) : b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0.","conclusion":"b' <> b \\/ sizeof ge0 ty' <= 0 \\/ sizeof ge0 ty <= 0","hypotheses":"(ge0 : genv) (j : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tlo thi : block) (tm : mem) (ME : match_envs j cenv e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (PERMS : forall (id0 : positive) (b1 : block) (ty0 : type),\ne ! id0 = Some (b1, ty0) ->\nMem.range_perm m b1 0 (sizeof ge0 ty0) Cur Freeable) (id : positive) (b : block) (ty : type) (l : list (positive * (block * type))) (IHl : list_norepet (map fst l) ->\n(forall (id0 : positive) (bty : block * type),\n In (id0, bty) l -> te ! id0 = Some bty) ->\nfreelist_no_overlap (map (block_of_binding ge0) l)) (H0 : forall (id0 : positive) (bty : block * type),\n(id, (b, ty)) = (id0, bty) \\/ In (id0, bty) l -> te ! id0 = Some bty) (H3 : ~ In id (map fst l)) (H4 : list_norepet (map fst l)) (b' : block) (ty' : type) (H : In (b', 0, sizeof ge0 ty') (map (block_of_binding ge0) l)) (id' : ident) (B : In (id', (b', ty')) l) (TE : te ! id = Some (b, ty)) (TE' : te ! id' = Some (b', ty')) (b0 : block) (INJ : j b0 = Some (b, 0)) (E : e ! id = Some (b0, ty)) (b0' : block) (INJ' : j b0' = Some (b', 0)) (E' : e ! id' = Some (b0', ty')) (g : sizeof ge0 ty > 0) (g0 : sizeof ge0 ty' > 0) (H1 : b0 <> b0') (H2 : Mem.perm m b0 0 Max Nonempty) (H5 : Mem.perm m b0' 0 Max Nonempty) (A : 0 + 0 <> 0 + 0)","proofString":"extlia."},{"statement":"(j : meminj) (m1 m2 m2' : mem) (H : Mem.inject j m1 m2) (H0 : Some m2 = Some m2') (H1 : forall (b1 b2 : block) (delta lo hi ofs : Z) (k : perm_kind) (p : permission),\nj b1 = Some (b2, delta) ->\nFalse -> Mem.perm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) : Mem.inject j m1 m2'.","conclusion":"Mem.inject j m1 m2'","hypotheses":"(j : meminj) (m1 m2 m2' : mem) (H : Mem.inject j m1 m2) (H0 : Some m2 = Some m2') (H1 : forall (b1 b2 : block) (delta lo hi ofs : Z) (k : perm_kind) (p : permission),\nj b1 = Some (b2, delta) ->\nFalse -> Mem.perm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False)","proofString":"congruence."},{"statement":"(j : meminj) (m1 : mem) (b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 m2'0 : mem,\nMem.inject j m1 m0 ->\nMem.free_list m0 l = Some m2'0 ->\n(forall (b1 b2 : block) (delta lo0 hi0 ofs : Z) (k : perm_kind)\n   (p : permission),\n j b1 = Some (b2, delta) ->\n In (b2, lo0, hi0) l ->\n Mem.perm m1 b1 ofs k p -> lo0 <= ofs + delta < hi0 -> False) ->\nMem.inject j m1 m2'0) (m2 m2' : mem) (H : Mem.inject j m1 m2) (m21 : mem) (Heqo : Mem.free m2 b lo hi = Some m21) (H0 : Mem.free_list m21 l = Some m2') (H1 : forall (b1 b2 : block) (delta lo0 hi0 ofs : Z) (k : perm_kind)\n  (p : permission),\nj b1 = Some (b2, delta) ->\n(b, lo, hi) = (b2, lo0, hi0) \\/ In (b2, lo0, hi0) l ->\nMem.perm m1 b1 ofs k p -> lo0 <= ofs + delta < hi0 -> False) : Mem.inject j m1 m21.","conclusion":"Mem.inject j m1 m21","hypotheses":"(j : meminj) (m1 : mem) (b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 m2'0 : mem,\nMem.inject j m1 m0 ->\nMem.free_list m0 l = Some m2'0 ->\n(forall (b1 b2 : block) (delta lo0 hi0 ofs : Z) (k : perm_kind)\n   (p : permission),\n j b1 = Some (b2, delta) ->\n In (b2, lo0, hi0) l ->\n Mem.perm m1 b1 ofs k p -> lo0 <= ofs + delta < hi0 -> False) ->\nMem.inject j m1 m2'0) (m2 m2' : mem) (H : Mem.inject j m1 m2) (m21 : mem) (Heqo : Mem.free m2 b lo hi = Some m21) (H0 : Mem.free_list m21 l = Some m2') (H1 : forall (b1 b2 : block) (delta lo0 hi0 ofs : Z) (k : perm_kind)\n  (p : permission),\nj b1 = Some (b2, delta) ->\n(b, lo, hi) = (b2, lo0, hi0) \\/ In (b2, lo0, hi0) l ->\nMem.perm m1 b1 ofs k p -> lo0 <= ofs + delta < hi0 -> False)","proofString":"eapply Mem.free_right_inject; eauto."},{"statement":"(e : env) : blocks_of_env tge e = blocks_of_env ge e.","conclusion":"blocks_of_env tge e = blocks_of_env ge e","hypotheses":"(e : env)","proofString":"unfold blocks_of_env, block_of_binding.\nrewrite comp_env_preserved; auto."},{"statement":"(e : env) : map\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof tge ty))\n  (PTree.elements e) =\nmap\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e).","conclusion":"map\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof tge ty))\n  (PTree.elements e) =\nmap\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e)","hypotheses":"(e : env)","proofString":"rewrite comp_env_preserved; auto."},{"statement":"(f : meminj) (H : exists bound : block, match_globalenvs f bound) : meminj_preserves_globals ge f.","conclusion":"meminj_preserves_globals ge f","hypotheses":"(f : meminj) (H : exists bound : block, match_globalenvs f bound)","proofString":"destruct H as [bound MG].\ninv MG.\nsplit; intros.\neauto.\nsplit; intros.\neauto.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (bound : block) (MG : match_globalenvs f bound) : meminj_preserves_globals ge f.","conclusion":"meminj_preserves_globals ge f","hypotheses":"(f : meminj) (bound : block) (MG : match_globalenvs f bound)","proofString":"inv MG.\nsplit; intros.\neauto.\nsplit; intros.\neauto.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound) : meminj_preserves_globals ge f.","conclusion":"meminj_preserves_globals ge f","hypotheses":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound)","proofString":"split; intros.\neauto.\nsplit; intros.\neauto.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (bound : block) (DOMAIN : forall b0 : positive, Plt b0 bound -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar type),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) : f b = Some (b, 0).","conclusion":"f b = Some (b, 0)","hypotheses":"(f : meminj) (bound : block) (DOMAIN : forall b0 : positive, Plt b0 bound -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar type),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b)","proofString":"eauto."},{"statement":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound) : (forall (b : block) (gv : globvar type),\n Genv.find_var_info ge b = Some gv -> f b = Some (b, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar type),\n Genv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1).","conclusion":"(forall (b : block) (gv : globvar type),\n Genv.find_var_info ge b = Some gv -> f b = Some (b, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar type),\n Genv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1)","hypotheses":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound)","proofString":"split; intros.\neauto.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (bound : block) (DOMAIN : forall b0 : positive, Plt b0 bound -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv0 : globvar type),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 bound) (b : block) (gv : globvar type) (H : Genv.find_var_info ge b = Some gv) : f b = Some (b, 0).","conclusion":"f b = Some (b, 0)","hypotheses":"(f : meminj) (bound : block) (DOMAIN : forall b0 : positive, Plt b0 bound -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv0 : globvar type),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 bound) (b : block) (gv : globvar type) (H : Genv.find_var_info ge b = Some gv)","proofString":"eauto."},{"statement":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv0 : globvar type),\nGenv.find_var_info ge b = Some gv0 -> Plt b bound) (b1 b2 : block) (delta : Z) (gv : globvar type) (H : Genv.find_var_info ge b2 = Some gv) (H0 : f b1 = Some (b2, delta)) : b2 = b1.","conclusion":"b2 = b1","hypotheses":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv0 : globvar type),\nGenv.find_var_info ge b = Some gv0 -> Plt b bound) (b1 b2 : block) (delta : Z) (gv : globvar type) (H : Genv.find_var_info ge b2 = Some gv) (H0 : f b1 = Some (b2, delta))","proofString":"symmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv0 : globvar type),\nGenv.find_var_info ge b = Some gv0 -> Plt b bound) (b1 b2 : block) (delta : Z) (gv : globvar type) (H : Genv.find_var_info ge b2 = Some gv) (H0 : f b1 = Some (b2, delta)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(f : meminj) (bound : block) (DOMAIN : forall b : positive, Plt b bound -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv0 : globvar type),\nGenv.find_var_info ge b = Some gv0 -> Plt b bound) (b1 b2 : block) (delta : Z) (gv : globvar type) (H : Genv.find_var_info ge b2 = Some gv) (H0 : f b1 = Some (b2, delta))","proofString":"eapply IMAGE; eauto."},{"statement":"(i : ident) (t : type) : typeof (if VSet.mem i cenv then Etempvar i t else Evar i t) = t.","conclusion":"typeof (if VSet.mem i cenv then Etempvar i t else Evar i t) = t","hypotheses":"(i : ident) (t : type)","proofString":"destruct (VSet.mem i cenv); auto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (loc' : block) (ofs' : ptrofs) (H : deref_loc ty m loc ofs bf v) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) : exists tv : val, deref_loc ty tm loc' ofs' bf tv /\\ Val.inject f v tv.","conclusion":"exists tv : val, deref_loc ty tm loc' ofs' bf tv /\\ Val.inject f v tv","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (loc' : block) (ofs' : ptrofs) (H : deref_loc ty m loc ofs bf v) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs'))","proofString":"inv H.\nexploit Mem.loadv_inject; eauto.\nintros [tv [A B]].\nexists tv; split; auto.\neapply deref_loc_value; eauto.\nexists (Vptr loc' ofs'); split; auto.\neapply deref_loc_reference; eauto.\nexists (Vptr loc' ofs'); split; auto.\neapply deref_loc_copy; eauto.\ninv H1.\nexploit Mem.loadv_inject; eauto.\nintros [tc [A B]].\ninv B.\neconstructor; split.\neapply deref_loc_bitfield.\neconstructor; eauto.\nconstructor."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v) : exists tv : val, deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f v tv.","conclusion":"exists tv : val, deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f v tv","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v)","proofString":"exploit Mem.loadv_inject; eauto.\nintros [tv [A B]].\nexists tv; split; auto.\neapply deref_loc_value; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v) : (exists v2 : val,\n   Mem.loadv chunk tm (Vptr loc' ofs') = Some v2 /\\ Val.inject f v v2) ->\nexists tv : val, deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f v tv.","conclusion":"(exists v2 : val,\n   Mem.loadv chunk tm (Vptr loc' ofs') = Some v2 /\\ Val.inject f v v2) ->\nexists tv : val, deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f v tv","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v)","proofString":"intros [tv [A B]].\nexists tv; split; auto.\neapply deref_loc_value; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v) (tv : val) (A : Mem.loadv chunk tm (Vptr loc' ofs') = Some tv) (B : Val.inject f v tv) : exists tv0 : val, deref_loc ty tm loc' ofs' Full tv0 /\\ Val.inject f v tv0.","conclusion":"exists tv0 : val, deref_loc ty tm loc' ofs' Full tv0 /\\ Val.inject f v tv0","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v) (tv : val) (A : Mem.loadv chunk tm (Vptr loc' ofs') = Some tv) (B : Val.inject f v tv)","proofString":"exists tv; split; auto.\neapply deref_loc_value; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v) (tv : val) (A : Mem.loadv chunk tm (Vptr loc' ofs') = Some tv) (B : Val.inject f v tv) : deref_loc ty tm loc' ofs' Full tv.","conclusion":"deref_loc ty tm loc' ofs' Full tv","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : Mem.loadv chunk m (Vptr loc ofs) = Some v) (tv : val) (A : Mem.loadv chunk tm (Vptr loc' ofs') = Some tv) (B : Val.inject f v tv)","proofString":"eapply deref_loc_value; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_reference) : exists tv : val,\n  deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f (Vptr loc ofs) tv.","conclusion":"exists tv : val,\n  deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f (Vptr loc ofs) tv","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_reference)","proofString":"exists (Vptr loc' ofs'); split; auto.\neapply deref_loc_reference; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_reference) : deref_loc ty tm loc' ofs' Full (Vptr loc' ofs').","conclusion":"deref_loc ty tm loc' ofs' Full (Vptr loc' ofs')","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_reference)","proofString":"eapply deref_loc_reference; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_copy) : exists tv : val,\n  deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f (Vptr loc ofs) tv.","conclusion":"exists tv : val,\n  deref_loc ty tm loc' ofs' Full tv /\\ Val.inject f (Vptr loc ofs) tv","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_copy)","proofString":"exists (Vptr loc' ofs'); split; auto.\neapply deref_loc_copy; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_copy) : deref_loc ty tm loc' ofs' Full (Vptr loc' ofs').","conclusion":"deref_loc ty tm loc' ofs' Full (Vptr loc' ofs')","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (H1 : access_mode ty = By_copy)","proofString":"eapply deref_loc_copy; eauto."},{"statement":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (H1 : load_bitfield ty sz sg pos width m (Vptr loc ofs) v) : exists tv : val,\n  deref_loc ty tm loc' ofs' (Bits sz sg pos width) tv /\\ Val.inject f v tv.","conclusion":"exists tv : val,\n  deref_loc ty tm loc' ofs' (Bits sz sg pos width) tv /\\ Val.inject f v tv","hypotheses":"(ty : type) (loc : block) (ofs : ptrofs) (v : val) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (H1 : load_bitfield ty sz sg pos width m (Vptr loc ofs) v)","proofString":"inv H1.\nexploit Mem.loadv_inject; eauto.\nintros [tc [A B]].\ninv B.\neconstructor; split.\neapply deref_loc_bitfield.\neconstructor; eauto.\nconstructor."},{"statement":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) : exists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv.","conclusion":"exists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv","hypotheses":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c))","proofString":"exploit Mem.loadv_inject; eauto.\nintros [tc [A B]].\ninv B.\neconstructor; split.\neapply deref_loc_bitfield.\neconstructor; eauto.\nconstructor."},{"statement":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) : (exists v2 : val,\n   Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some v2 /\\\n   Val.inject f (Vint c) v2) ->\nexists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv.","conclusion":"(exists v2 : val,\n   Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some v2 /\\\n   Val.inject f (Vint c) v2) ->\nexists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv","hypotheses":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c))","proofString":"intros [tc [A B]].\ninv B.\neconstructor; split.\neapply deref_loc_bitfield.\neconstructor; eauto.\nconstructor."},{"statement":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (tc : val) (A : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some tc) (B : Val.inject f (Vint c) tc) : exists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv.","conclusion":"exists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv","hypotheses":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (tc : val) (A : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some tc) (B : Val.inject f (Vint c) tc)","proofString":"inv B.\neconstructor; split.\neapply deref_loc_bitfield.\neconstructor; eauto.\nconstructor."},{"statement":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (A : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c)) : exists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv.","conclusion":"exists tv : val,\n  deref_loc\n    (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) tm\n    loc' ofs' (Bits sz sg pos width) tv /\\\n  Val.inject f (Vint (bitfield_extract sz sg pos width c)) tv","hypotheses":"(loc : block) (ofs : ptrofs) (loc' : block) (ofs' : ptrofs) (H0 : Val.inject f (Vptr loc ofs) (Vptr loc' ofs')) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (A : Mem.loadv (chunk_for_carrier sz) tm (Vptr loc' ofs') = Some (Vint c))","proofString":"econstructor; split.\neapply deref_loc_bitfield.\neconstructor; eauto.\nconstructor."},{"statement":"(H : compat_cenv VSet.empty cenv) : val_casted_list nil nil /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm nil nil tvl /\\ Val.inject_list f nil tvl).","conclusion":"val_casted_list nil nil /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm nil nil tvl /\\ Val.inject_list f nil tvl)","hypotheses":"(H : compat_cenv VSet.empty cenv)","proofString":"split.\nconstructor.\neconstructor; split.\nconstructor.\nauto."},{"statement":"(H : compat_cenv VSet.empty cenv) : val_casted_list nil nil.","conclusion":"val_casted_list nil nil","hypotheses":"(H : compat_cenv VSet.empty cenv)","proofString":"constructor."},{"statement":"(H : compat_cenv VSet.empty cenv) : exists tvl : list val,\n  eval_exprlist tge te tle tm nil nil tvl /\\ Val.inject_list f nil tvl.","conclusion":"exists tvl : list val,\n  eval_exprlist tge te tle tm nil nil tvl /\\ Val.inject_list f nil tvl","hypotheses":"(H : compat_cenv VSet.empty cenv)","proofString":"econstructor; split.\nconstructor.\nauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) : val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl).","conclusion":"val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv)","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tv1 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv2 [C D]].\nexploit IHeval_exprlist; eauto with compat.\nintros [E [tvl [F G]]].\nsplit.\nconstructor; auto.\neapply cast_val_is_casted; eauto.\nexists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr cenv a) tv /\\ Val.inject f v1 tv) ->\nval_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl).","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr cenv a) tv /\\ Val.inject f v1 tv) ->\nval_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv)","proofString":"intros [tv1 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv2 [C D]].\nexploit IHeval_exprlist; eauto with compat.\nintros [E [tvl [F G]]].\nsplit.\nconstructor; auto.\neapply cast_val_is_casted; eauto.\nexists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) : val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl).","conclusion":"val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1)","proofString":"exploit sem_cast_inject; eauto.\nintros [tv2 [C D]].\nexploit IHeval_exprlist; eauto with compat.\nintros [E [tvl [F G]]].\nsplit.\nconstructor; auto.\neapply cast_val_is_casted; eauto.\nexists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) : (exists tv : val,\n   sem_cast tv1 (typeof a) ty tm = Some tv /\\ Val.inject f v2 tv) ->\nval_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl).","conclusion":"(exists tv : val,\n   sem_cast tv1 (typeof a) ty tm = Some tv /\\ Val.inject f v2 tv) ->\nval_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1)","proofString":"intros [tv2 [C D]].\nexploit IHeval_exprlist; eauto with compat.\nintros [E [tvl [F G]]].\nsplit.\nconstructor; auto.\neapply cast_val_is_casted; eauto.\nexists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) : val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl).","conclusion":"val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2)","proofString":"exploit IHeval_exprlist; eauto with compat.\nintros [E [tvl [F G]]].\nsplit.\nconstructor; auto.\neapply cast_val_is_casted; eauto.\nexists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) : val_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl) ->\nval_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl).","conclusion":"val_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl) ->\nval_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl /\\ Val.inject_list f (v2 :: vl) tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl /\\\n   Val.inject_list f vl tvl)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2)","proofString":"intros [E [tvl [F G]]].\nsplit.\nconstructor; auto.\neapply cast_val_is_casted; eauto.\nexists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl) : val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl0 /\\ Val.inject_list f (v2 :: vl) tvl0).","conclusion":"val_casted_list (v2 :: vl) (ty :: tyl) /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n     (ty :: tyl) tvl0 /\\ Val.inject_list f (v2 :: vl) tvl0)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl)","proofString":"split.\nconstructor; auto.\neapply cast_val_is_casted; eauto.\nexists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl) : val_casted_list (v2 :: vl) (ty :: tyl).","conclusion":"val_casted_list (v2 :: vl) (ty :: tyl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl)","proofString":"constructor; auto.\neapply cast_val_is_casted; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl) : val_casted v2 ty.","conclusion":"val_casted v2 ty","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl)","proofString":"eapply cast_val_is_casted; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl) : exists tvl0 : list val,\n  eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n    (ty :: tyl) tvl0 /\\ Val.inject_list f (v2 :: vl) tvl0.","conclusion":"exists tvl0 : list val,\n  eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n    (ty :: tyl) tvl0 /\\ Val.inject_list f (v2 :: vl) tvl0","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl)","proofString":"exists (tv2 :: tvl); split.\neconstructor; eauto.\nrewrite typeof_simpl_expr; auto.\neconstructor; eauto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl) : eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n  (ty :: tyl) (tv2 :: tvl).","conclusion":"eval_exprlist tge te tle tm (simpl_expr cenv a :: simpl_exprlist cenv bl)\n  (ty :: tyl) (tv2 :: tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl)","proofString":"econstructor; eauto.\nrewrite typeof_simpl_expr; auto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl) : sem_cast tv1 (typeof (simpl_expr cenv a)) ty tm = Some tv2.","conclusion":"sem_cast tv1 (typeof (simpl_expr cenv a)) ty tm = Some tv2","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl)","proofString":"rewrite typeof_simpl_expr; auto."},{"statement":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl) : Val.inject_list f (v2 :: vl) (tv2 :: tvl).","conclusion":"Val.inject_list f (v2 :: vl) (tv2 :: tvl)","hypotheses":"(a : expr) (bl : list expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : compat_cenv (addr_taken_exprlist bl) cenv ->\nval_casted_list vl tyl /\\\n(exists tvl0 : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl0 /\\\n   Val.inject_list f vl tvl0)) (H2 : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)) cenv) (tv1 : val) (A : eval_expr tge te tle tm (simpl_expr cenv a) tv1) (B : Val.inject f v1 tv1) (tv2 : val) (C : sem_cast tv1 (typeof a) ty tm = Some tv2) (D : Val.inject f v2 tv2) (E : val_casted_list vl tyl) (tvl : list val) (F : eval_exprlist tge te tle tm (simpl_exprlist cenv bl) tyl tvl) (G : Val.inject_list f vl tvl)","proofString":"econstructor; eauto."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H : match_globalenvs f hi) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) : match_globalenvs f' hi.","conclusion":"match_globalenvs f' hi","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H : match_globalenvs f hi) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b)","proofString":"inv H.\nconstructor; intros; eauto.\nassert (f b1 = Some (b2, delta)).\nrewrite <- H; symmetry; eapply INJ2; eauto.\nextlia.\neapply IMAGE; eauto."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : match_globalenvs f' hi.","conclusion":"match_globalenvs f' hi","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi)","proofString":"constructor; intros; eauto.\nassert (f b1 = Some (b2, delta)).\nrewrite <- H; symmetry; eapply INJ2; eauto.\nextlia.\neapply IMAGE; eauto."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi)","proofString":"assert (f b1 = Some (b2, delta)).\nrewrite <- H; symmetry; eapply INJ2; eauto.\nextlia.\neapply IMAGE; eauto."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi) : f b1 = Some (b2, delta).","conclusion":"f b1 = Some (b2, delta)","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi)","proofString":"rewrite <- H; symmetry; eapply INJ2; eauto.\nextlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi) : Plt b2 tbound.","conclusion":"Plt b2 tbound","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi)","proofString":"extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi) (H3 : f b1 = Some (b2, delta)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H0 : Ple hi bound) (H1 : Ple hi tbound) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> Plt b' tbound -> f' b = f b) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f' b1 = Some (b2, delta)) (H2 : Plt b2 hi) (H3 : f b1 = Some (b2, delta))","proofString":"eapply IMAGE; eauto."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPle lo b /\\ Plt b hi ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b)","proofString":"intros.\napply LOAD; auto.\nextlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Ple lo b /\\ Plt b hi) (H7 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Some v.","conclusion":"Mem.load chunk m' b 0 = Some v","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Ple lo b /\\ Plt b hi) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"apply LOAD; auto.\nextlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Ple lo b /\\ Plt b hi) (H7 : Mem.load chunk m b 0 = Some v) : Plt b bound.","conclusion":"Plt b bound","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Ple lo b /\\ Plt b hi) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) : forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b.","conclusion":"forall b : positive, Ple lo b /\\ Plt b hi -> f' b = f b","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b)","proofString":"intros.\napply INJ1; auto; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : positive) (H5 : Ple lo b /\\ Plt b hi) : f' b = f b.","conclusion":"f' b = f b","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : positive) (H5 : Ple lo b /\\ Plt b hi)","proofString":"apply INJ1; auto; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b.","conclusion":"forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Ple tlo b' /\\ Plt b' thi -> f' b = f b","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b)","proofString":"intros.\neapply INJ2; eauto; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b'0 : block) (delta0 : Z),\n f' b0 = Some (b'0, delta0) -> Plt b'0 tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Plt b'0 tbound -> f' b0 = f b0) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi) : f' b = f b.","conclusion":"f' b = f b","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b'0 : block) (delta0 : Z),\n f' b0 = Some (b'0, delta0) -> Plt b'0 tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Plt b'0 tbound -> f' b0 = f b0) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Ple tlo b' /\\ Plt b' thi)","proofString":"eapply INJ2; eauto; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b)","proofString":"intros; apply LOAD; auto.\ninv H0; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) : Plt b bound.","conclusion":"Plt b bound","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk0 : memory_chunk) (v0 : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk0 m b0 0 = Some v0 -> Mem.load chunk0 m' b0 0 = Some v0) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"inv H0; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) : forall b : positive, Plt b lo -> f' b = f b.","conclusion":"forall b : positive, Plt b lo -> f' b = f b","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b)","proofString":"intros; apply INJ1.\ninv H0; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : positive) (H5 : Plt b lo) : Plt b bound.","conclusion":"Plt b bound","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b' : block) (delta : Z),\n f' b0 = Some (b', delta) -> Plt b' tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> Plt b' tbound -> f' b0 = f b0) (b : positive) (H5 : Plt b lo)","proofString":"inv H0; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b) : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tlo -> f' b = f b.","conclusion":"forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tlo -> f' b = f b","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b : block) (chunk : memory_chunk) (v : val),\n f b = None ->\n Plt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->\ninject_incr f f' ->\n(forall b : positive, Plt b lo -> f' b = f b) ->\n(forall (b b' : block) (delta : Z),\n f' b = Some (b', delta) -> Plt b' tlo -> f' b = f b) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b : positive, Plt b bound -> f' b = f b) (INJ2 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b)","proofString":"intros; eapply INJ2; eauto.\ninv H0; extlia."},{"statement":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b'0 : block) (delta0 : Z),\n f' b0 = Some (b'0, delta0) -> Plt b'0 tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Plt b'0 tbound -> f' b0 = f b0) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tlo) : Plt b' tbound.","conclusion":"Plt b' tbound","hypotheses":"(f' : meminj) (m' : mem) (f : meminj) (cenv : compilenv) (optid : option ident) (fn : function) (e : env) (le : temp_env) (k : cont) (tfn : function) (te : env) (tle : temp_env) (tk : cont) (m : mem) (hi thi lo tlo : block) (bound tbound : positive) (x : unit) (H : transf_function fn = OK tfn) (H0 : match_envs f (cenv_for fn) e le m lo hi te tle tlo thi) (H1 : match_cont f (cenv_for fn) k tk m lo tlo) (H2 : check_opttemp (cenv_for fn) optid = OK x) (H3 : Ple hi bound) (H4 : Ple thi tbound) (IHmatch_cont : (forall (b0 : block) (chunk : memory_chunk) (v : val),\n f b0 = None ->\n Plt b0 lo ->\n Mem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) ->\ninject_incr f f' ->\n(forall b0 : positive, Plt b0 lo -> f' b0 = f b0) ->\n(forall (b0 b'0 : block) (delta0 : Z),\n f' b0 = Some (b'0, delta0) -> Plt b'0 tlo -> f' b0 = f b0) ->\nmatch_cont f' (cenv_for fn) k tk m' lo tlo) (LOAD : forall (b0 : block) (chunk : memory_chunk) (v : val),\nf b0 = None ->\nPlt b0 bound ->\nMem.load chunk m b0 0 = Some v -> Mem.load chunk m' b0 0 = Some v) (INCR : inject_incr f f') (INJ1 : forall b0 : positive, Plt b0 bound -> f' b0 = f b0) (INJ2 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> Plt b'0 tbound -> f' b0 = f b0) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tlo)","proofString":"inv H0; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc) : match_cont f cenv k tk m' bound tbound.","conclusion":"match_cont f cenv k tk m' bound tbound","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc)","proofString":"eapply match_cont_invariant; eauto.\nintros.\nrewrite <- H4.\ninv H0.\nsimpl in H6.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia.\neapply Mem.load_storebytes_other; eauto.\nleft.\nunfold block; extlia.\ninv H5.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc) : forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0.","conclusion":"forall (b : block) (chunk : memory_chunk) (v0 : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc)","proofString":"intros.\nrewrite <- H4.\ninv H0.\nsimpl in H6.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia.\neapply Mem.load_storebytes_other; eauto.\nleft.\nunfold block; extlia.\ninv H5.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) : Mem.load chunk m' b 0 = Some v0.","conclusion":"Mem.load chunk m' b 0 = Some v0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0)","proofString":"rewrite <- H4.\ninv H0.\nsimpl in H6.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia.\neapply Mem.load_storebytes_other; eauto.\nleft.\nunfold block; extlia.\ninv H5.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : assign_loc ge ty m loc ofs bf v m') (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0)","proofString":"inv H0.\nsimpl in H6.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia.\neapply Mem.load_storebytes_other; eauto.\nleft.\nunfold block; extlia.\ninv H5.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.storev chunk0 m (Vptr loc ofs) v = Some m') : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.storev chunk0 m (Vptr loc ofs) v = Some m')","proofString":"simpl in H6.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.store chunk0 m loc (Ptrofs.unsigned ofs) v = Some m') : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.store chunk0 m loc (Ptrofs.unsigned ofs) v = Some m')","proofString":"eapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.store chunk0 m loc (Ptrofs.unsigned ofs) v = Some m') : b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk0 <= 0.","conclusion":"b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk0 <= 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.store chunk0 m loc (Ptrofs.unsigned ofs) v = Some m')","proofString":"left.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.store chunk0 m loc (Ptrofs.unsigned ofs) v = Some m') : b <> loc.","conclusion":"b <> loc","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (chunk0 : memory_chunk) (H5 : access_mode ty = By_value chunk0) (H6 : Mem.store chunk0 m loc (Ptrofs.unsigned ofs) v = Some m')","proofString":"unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H5 : access_mode ty = By_copy) (H6 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H7 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H8 : b' <> loc \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H9 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H10 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H5 : access_mode ty = By_copy) (H6 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H7 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H8 : b' <> loc \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H9 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H10 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"eapply Mem.load_storebytes_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H5 : access_mode ty = By_copy) (H6 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H7 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H8 : b' <> loc \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H9 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H10 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') : b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= 0.","conclusion":"b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H5 : access_mode ty = By_copy) (H6 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H7 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H8 : b' <> loc \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H9 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H10 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"left.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H5 : access_mode ty = By_copy) (H6 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H7 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H8 : b' <> loc \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H9 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H10 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m') : b <> loc.","conclusion":"b <> loc","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H5 : access_mode ty = By_copy) (H6 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H7 : sizeof ge ty > 0 -> (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H8 : b' <> loc \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H9 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H10 : Mem.storebytes m loc (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (v' : val) (H5 : store_bitfield ty sz sg pos width m (Vptr loc ofs) v m' v') : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (ty : type) (loc : block) (ofs : ptrofs) (v : val) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (v' : val) (H5 : store_bitfield ty sz sg pos width m (Vptr loc ofs) v m' v')","proofString":"inv H5.\neapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H6 : 0 < width <= bitsize_intsize sz) (H7 : pos + width <= bitsize_carrier sz) (H9 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H10 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H6 : 0 < width <= bitsize_intsize sz) (H7 : pos + width <= bitsize_carrier sz) (H9 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H10 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"eapply Mem.load_store_other; eauto.\nleft.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H6 : 0 < width <= bitsize_intsize sz) (H7 : pos + width <= bitsize_carrier sz) (H9 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H10 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk (chunk_for_carrier sz) <= 0.","conclusion":"b <> loc \\/\n0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk (chunk_for_carrier sz) <= 0","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H6 : 0 < width <= bitsize_intsize sz) (H7 : pos + width <= bitsize_carrier sz) (H9 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H10 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"left.\nunfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H6 : 0 < width <= bitsize_intsize sz) (H7 : pos + width <= bitsize_carrier sz) (H9 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H10 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : b <> loc.","conclusion":"b <> loc","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound loc : block) (ofs : ptrofs) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H1 : Ple bound loc) (b : block) (chunk : memory_chunk) (v0 : val) (H2 : f b = None) (H3 : Plt b bound) (H4 : Mem.load chunk m b 0 = Some v0) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H0 : 0 <= pos) (H6 : 0 < width <= bitsize_intsize sz) (H7 : pos + width <= bitsize_carrier sz) (H9 : Mem.loadv (chunk_for_carrier sz) m (Vptr loc ofs) = Some (Vint c)) (H10 : Mem.storev (chunk_for_carrier sz) m (Vptr loc ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) : match_cont f' cenv k tk m' bound tbound.","conclusion":"match_cont f' cenv k tk m' bound tbound","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm))","proofString":"eapply match_cont_invariant; eauto.\nintros.\neapply Mem.load_unchanged_on; eauto.\nred in H2.\nintros.\ndestruct (f b) as [[b' delta] | ] eqn:?.\nauto.\ndestruct (f' b) as [[b' delta] | ] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia.\nred in H2.\nintros.\ndestruct (f b) as [[b'' delta''] | ] eqn:?.\nauto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b bound ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm))","proofString":"intros.\neapply Mem.load_unchanged_on; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b bound) (H7 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Some v.","conclusion":"Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b bound) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"eapply Mem.load_unchanged_on; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) : forall b : positive, Plt b bound -> f' b = f b.","conclusion":"forall b : positive, Plt b bound -> f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm))","proofString":"red in H2.\nintros.\ndestruct (f b) as [[b' delta] | ] eqn:?.\nauto.\ndestruct (f' b) as [[b' delta] | ] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) : forall b : positive, Plt b bound -> f' b = f b.","conclusion":"forall b : positive, Plt b bound -> f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm))","proofString":"intros.\ndestruct (f b) as [[b' delta] | ] eqn:?.\nauto.\ndestruct (f' b) as [[b' delta] | ] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) : f' b = f b.","conclusion":"f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound)","proofString":"destruct (f b) as [[b' delta] | ] eqn:?.\nauto.\ndestruct (f' b) as [[b' delta] | ] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (b' : block) (delta : Z) (Heqo : f b = Some (b', delta)) : f' b = Some (b', delta).","conclusion":"f' b = Some (b', delta)","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (b' : block) (delta : Z) (Heqo : f b = Some (b', delta))","proofString":"auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) : f' b = None.","conclusion":"f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None)","proofString":"destruct (f' b) as [[b' delta] | ] eqn:?; auto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) : Some (b', delta) = None.","conclusion":"Some (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta))","proofString":"exploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) : ~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> Some (b', delta) = None.","conclusion":"~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> Some (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta))","proofString":"unfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) : ~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) ->\nSome (b', delta) = None.","conclusion":"~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) ->\nSome (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta))","proofString":"intros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm)) : Some (b', delta) = None.","conclusion":"Some (b', delta) = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b : positive) (H5 : Plt b bound) (Heqo : f b = None) (b' : block) (delta : Z) (Heqo0 : f' b = Some (b', delta)) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm))","proofString":"extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b.","conclusion":"forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : inject_separated f f' m tm) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm))","proofString":"red in H2.\nintros.\ndestruct (f b) as [[b'' delta''] | ] eqn:?.\nauto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b.","conclusion":"forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> Plt b' tbound -> f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta) -> ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm))","proofString":"intros.\ndestruct (f b) as [[b'' delta''] | ] eqn:?.\nauto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) : f' b = f b.","conclusion":"f' b = f b","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound)","proofString":"destruct (f b) as [[b'' delta''] | ] eqn:?.\nauto.\nexploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (b'' : block) (delta'' : Z) (Heqo : f b = Some (b'', delta'')) : f' b = Some (b'', delta'').","conclusion":"f' b = Some (b'', delta'')","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (b'' : block) (delta'' : Z) (Heqo : f b = Some (b'', delta''))","proofString":"auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None) : f' b = None.","conclusion":"f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None)","proofString":"exploit H2; eauto.\nunfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None) : ~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> f' b = None.","conclusion":"~ Mem.valid_block m b /\\ ~ Mem.valid_block tm b' -> f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None)","proofString":"unfold Mem.valid_block.\nintros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None) : ~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) -> f' b = None.","conclusion":"~ Plt b (Mem.nextblock m) /\\ ~ Plt b' (Mem.nextblock tm) -> f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None)","proofString":"intros [A B].\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm)) : f' b = None.","conclusion":"f' b = None","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (tm : mem) (f' : meminj) (m' : mem) (H : match_cont f cenv k tk m bound tbound) (H0 : Mem.unchanged_on (loc_unmapped f) m m') (H1 : inject_incr f f') (H2 : forall (b1 b2 : block) (delta0 : Z),\nf b1 = None ->\nf' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2) (H3 : Ple bound (Mem.nextblock m)) (H4 : Ple tbound (Mem.nextblock tm)) (b b' : block) (delta : Z) (H5 : f' b = Some (b', delta)) (H6 : Plt b' tbound) (Heqo : f b = None) (A : ~ Plt b (Mem.nextblock m)) (B : ~ Plt b' (Mem.nextblock tm))","proofString":"extlia."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (cenv' : compilenv) (H : match_cont f cenv k tk m bound tbound) (H0 : is_call_cont k) : match_cont f cenv' k tk m bound tbound.","conclusion":"match_cont f cenv' k tk m bound tbound","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (cenv' : compilenv) (H : match_cont f cenv k tk m bound tbound) (H0 : is_call_cont k)","proofString":"inv H; simpl in H0; try contradiction; econstructor; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (H : match_cont f cenv k tk m bound tbound) (H0 : is_call_cont k) : is_call_cont tk.","conclusion":"is_call_cont tk","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (H : match_cont f cenv k tk m bound tbound) (H0 : is_call_cont k)","proofString":"inv H; auto."},{"statement":"(m m' : mem) (H : Some m = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(m m' : mem) (H : Some m = Some m')","proofString":"congruence."},{"statement":"(a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) (H : (let (p0, hi) := a in\n let (b, lo) := p0 in\n match Mem.free m b lo hi with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) (H : (let (p0, hi) := a in\n let (b, lo) := p0 in\n match Mem.free m b lo hi with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m')","proofString":"destruct a.\ndestruct p.\ndestruct (Mem.free m b z0 z) as [m1|] eqn:?; try discriminate.\ntransitivity (Mem.nextblock m1).\neauto.\neapply Mem.nextblock_free; eauto."},{"statement":"(p : block * Z) (z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) (H : (let (b, lo) := p in\n match Mem.free m b lo z with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(p : block * Z) (z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) (H : (let (b, lo) := p in\n match Mem.free m b lo z with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m')","proofString":"destruct p.\ndestruct (Mem.free m b z0 z) as [m1|] eqn:?; try discriminate.\ntransitivity (Mem.nextblock m1).\neauto.\neapply Mem.nextblock_free; eauto."},{"statement":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) (H : match Mem.free m b z0 z with\n| Some m'0 => Mem.free_list m'0 l\n| None => None\nend = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) (H : match Mem.free m b z0 z with\n| Some m'0 => Mem.free_list m'0 l\n| None => None\nend = Some m')","proofString":"destruct (Mem.free m b z0 z) as [m1|] eqn:?; try discriminate.\ntransitivity (Mem.nextblock m1).\neauto.\neapply Mem.nextblock_free; eauto."},{"statement":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') : Mem.nextblock m' = Mem.nextblock m.","conclusion":"Mem.nextblock m' = Mem.nextblock m","hypotheses":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m')","proofString":"transitivity (Mem.nextblock m1).\neauto.\neapply Mem.nextblock_free; eauto."},{"statement":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') : Mem.nextblock m' = Mem.nextblock m1.","conclusion":"Mem.nextblock m' = Mem.nextblock m1","hypotheses":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m')","proofString":"eauto."},{"statement":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') : Mem.nextblock m1 = Mem.nextblock m.","conclusion":"Mem.nextblock m1 = Mem.nextblock m","hypotheses":"(b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m')","proofString":"eapply Mem.nextblock_free; eauto."},{"statement":"(chunk : memory_chunk) (b' : positive) (m m' : mem) (H : Some m = Some m') (H0 : forall b : block, Z -> Z -> False -> Plt b' b) : Mem.load chunk m' b' 0 = Mem.load chunk m b' 0.","conclusion":"Mem.load chunk m' b' 0 = Mem.load chunk m b' 0","hypotheses":"(chunk : memory_chunk) (b' : positive) (m m' : mem) (H : Some m = Some m') (H0 : forall b : block, Z -> Z -> False -> Plt b' b)","proofString":"inv H; auto."},{"statement":"(chunk : memory_chunk) (b' : positive) (a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b : block) (lo hi : Z), In (b, lo, hi) l -> Plt b' b) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' : mem) (H : (let (p0, hi) := a in\n let (b, lo) := p0 in\n match Mem.free m b lo hi with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') (H0 : forall (b : block) (lo hi : Z),\na = (b, lo, hi) \\/ In (b, lo, hi) l -> Plt b' b) : Mem.load chunk m' b' 0 = Mem.load chunk m b' 0.","conclusion":"Mem.load chunk m' b' 0 = Mem.load chunk m b' 0","hypotheses":"(chunk : memory_chunk) (b' : positive) (a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b : block) (lo hi : Z), In (b, lo, hi) l -> Plt b' b) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' : mem) (H : (let (p0, hi) := a in\n let (b, lo) := p0 in\n match Mem.free m b lo hi with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') (H0 : forall (b : block) (lo hi : Z),\na = (b, lo, hi) \\/ In (b, lo, hi) l -> Plt b' b)","proofString":"destruct a.\ndestruct p.\ndestruct (Mem.free m b z0 z) as [m1|] eqn:?; try discriminate.\ntransitivity (Mem.load chunk m1 b' 0).\neauto.\neapply Mem.load_free.\neauto.\nleft.\nassert (Plt b' b) by eauto.\nunfold block; extlia."},{"statement":"(chunk : memory_chunk) (b' : positive) (p : block * Z) (z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b : block) (lo hi : Z), In (b, lo, hi) l -> Plt b' b) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' : mem) (H : (let (b, lo) := p in\n match Mem.free m b lo z with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') (H0 : forall (b : block) (lo hi : Z),\n(p, z) = (b, lo, hi) \\/ In (b, lo, hi) l -> Plt b' b) : Mem.load chunk m' b' 0 = Mem.load chunk m b' 0.","conclusion":"Mem.load chunk m' b' 0 = Mem.load chunk m b' 0","hypotheses":"(chunk : memory_chunk) (b' : positive) (p : block * Z) (z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b : block) (lo hi : Z), In (b, lo, hi) l -> Plt b' b) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' : mem) (H : (let (b, lo) := p in\n match Mem.free m b lo z with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') (H0 : forall (b : block) (lo hi : Z),\n(p, z) = (b, lo, hi) \\/ In (b, lo, hi) l -> Plt b' b)","proofString":"destruct p.\ndestruct (Mem.free m b z0 z) as [m1|] eqn:?; try discriminate.\ntransitivity (Mem.load chunk m1 b' 0).\neauto.\neapply Mem.load_free.\neauto.\nleft.\nassert (Plt b' b) by eauto.\nunfold block; extlia."},{"statement":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' : mem) (H : match Mem.free m b z0 z with\n| Some m'0 => Mem.free_list m'0 l\n| None => None\nend = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0) : Mem.load chunk m' b' 0 = Mem.load chunk m b' 0.","conclusion":"Mem.load chunk m' b' 0 = Mem.load chunk m b' 0","hypotheses":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' : mem) (H : match Mem.free m b z0 z with\n| Some m'0 => Mem.free_list m'0 l\n| None => None\nend = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0)","proofString":"destruct (Mem.free m b z0 z) as [m1|] eqn:?; try discriminate.\ntransitivity (Mem.load chunk m1 b' 0).\neauto.\neapply Mem.load_free.\neauto.\nleft.\nassert (Plt b' b) by eauto.\nunfold block; extlia."},{"statement":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0) : Mem.load chunk m' b' 0 = Mem.load chunk m b' 0.","conclusion":"Mem.load chunk m' b' 0 = Mem.load chunk m b' 0","hypotheses":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0)","proofString":"transitivity (Mem.load chunk m1 b' 0).\neauto.\neapply Mem.load_free.\neauto.\nleft.\nassert (Plt b' b) by eauto.\nunfold block; extlia."},{"statement":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0) : Mem.load chunk m' b' 0 = Mem.load chunk m1 b' 0.","conclusion":"Mem.load chunk m' b' 0 = Mem.load chunk m1 b' 0","hypotheses":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0)","proofString":"eauto."},{"statement":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0) : Mem.load chunk m1 b' 0 = Mem.load chunk m b' 0.","conclusion":"Mem.load chunk m1 b' 0 = Mem.load chunk m b' 0","hypotheses":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0)","proofString":"eapply Mem.load_free.\neauto.\nleft.\nassert (Plt b' b) by eauto.\nunfold block; extlia."},{"statement":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0) : b' <> b.","conclusion":"b' <> b","hypotheses":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0)","proofString":"assert (Plt b' b) by eauto.\nunfold block; extlia."},{"statement":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0) (H1 : Plt b' b) : b' <> b.","conclusion":"b' <> b","hypotheses":"(chunk : memory_chunk) (b' : positive) (b : block) (z0 z : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\n(forall (b0 : block) (lo hi : Z), In (b0, lo, hi) l -> Plt b' b0) ->\nMem.load chunk m'0 b' 0 = Mem.load chunk m0 b' 0) (m m' m1 : mem) (Heqo : Mem.free m b z0 z = Some m1) (H : Mem.free_list m1 l = Some m') (H0 : forall (b0 : block) (lo hi : Z),\n(b, z0, z) = (b0, lo, hi) \\/ In (b0, lo, hi) l -> Plt b' b0) (H1 : Plt b' b)","proofString":"unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') : match_cont f cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"match_cont f cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm')","proofString":"apply match_cont_incr_bounds with lo tlo.\neapply match_cont_invariant; eauto.\nintros.\nrewrite <- H7.\neapply free_list_load; eauto.\nunfold blocks_of_env; intros.\nexploit list_in_map_inv; eauto.\nintros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia.\nrewrite (free_list_nextblock _ _ _ H3).\ninv H; extlia.\nrewrite (free_list_nextblock _ _ _ H4).\ninv H; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') : match_cont f cenv k tk m' lo tlo.","conclusion":"match_cont f cenv k tk m' lo tlo","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm')","proofString":"eapply match_cont_invariant; eauto.\nintros.\nrewrite <- H7.\neapply free_list_load; eauto.\nunfold blocks_of_env; intros.\nexploit list_in_map_inv; eauto.\nintros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') : forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nf b = None ->\nPlt b lo -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm')","proofString":"intros.\nrewrite <- H7.\neapply free_list_load; eauto.\nunfold blocks_of_env; intros.\nexploit list_in_map_inv; eauto.\nintros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Some v.","conclusion":"Mem.load chunk m' b 0 = Some v","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"rewrite <- H7.\neapply free_list_load; eauto.\nunfold blocks_of_env; intros.\nexploit list_in_map_inv; eauto.\nintros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m' b 0 = Mem.load chunk m b 0.","conclusion":"Mem.load chunk m' b 0 = Mem.load chunk m b 0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"eapply free_list_load; eauto.\nunfold blocks_of_env; intros.\nexploit list_in_map_inv; eauto.\nintros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) : forall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) (blocks_of_env ge e) -> Plt b b0.","conclusion":"forall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) (blocks_of_env ge e) -> Plt b b0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v)","proofString":"unfold blocks_of_env; intros.\nexploit list_in_map_inv; eauto.\nintros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e))) : Plt b b0.","conclusion":"Plt b b0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e)))","proofString":"exploit list_in_map_inv; eauto.\nintros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e))) : (exists x : ident * (block * type),\n   (b0, lo0, hi0) = block_of_binding ge x /\\ In x (PTree.elements e)) ->\nPlt b b0.","conclusion":"(exists x : ident * (block * type),\n   (b0, lo0, hi0) = block_of_binding ge x /\\ In x (PTree.elements e)) ->\nPlt b b0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e)))","proofString":"intros [[id [b1 ty]] [P Q]].\nsimpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e))) (id : ident) (b1 : block) (ty : type) (P : (b0, lo0, hi0) = block_of_binding ge (id, (b1, ty))) (Q : In (id, (b1, ty)) (PTree.elements e)) : Plt b b0.","conclusion":"Plt b b0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e))) (id : ident) (b1 : block) (ty : type) (P : (b0, lo0, hi0) = block_of_binding ge (id, (b1, ty))) (Q : In (id, (b1, ty)) (PTree.elements e))","proofString":"simpl in P.\ninv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e))) (id : ident) (b1 : block) (ty : type) (P : (b0, lo0, hi0) = (b1, 0, sizeof ge ty)) (Q : In (id, (b1, ty)) (PTree.elements e)) : Plt b b0.","conclusion":"Plt b b0","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b0 : block) (lo0 hi0 : Z) (H8 : In (b0, lo0, hi0) (map (block_of_binding ge) (PTree.elements e))) (id : ident) (b1 : block) (ty : type) (P : (b0, lo0, hi0) = (b1, 0, sizeof ge ty)) (Q : In (id, (b1, ty)) (PTree.elements e))","proofString":"inv P.\nexploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b1 : block) (ty : type) (H8 : In (b1, 0, sizeof ge ty) (map (block_of_binding ge) (PTree.elements e))) (id : ident) (Q : In (id, (b1, ty)) (PTree.elements e)) : Plt b b1.","conclusion":"Plt b b1","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') (b : block) (chunk : memory_chunk) (v : val) (H5 : f b = None) (H6 : Plt b lo) (H7 : Mem.load chunk m b 0 = Some v) (b1 : block) (ty : type) (H8 : In (b1, 0, sizeof ge ty) (map (block_of_binding ge) (PTree.elements e))) (id : ident) (Q : In (id, (b1, ty)) (PTree.elements e))","proofString":"exploit me_range; eauto.\neapply PTree.elements_complete; eauto.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') : Ple lo (Mem.nextblock m').","conclusion":"Ple lo (Mem.nextblock m')","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm')","proofString":"rewrite (free_list_nextblock _ _ _ H3).\ninv H; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') : Ple lo (Mem.nextblock m).","conclusion":"Ple lo (Mem.nextblock m)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm')","proofString":"inv H; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') : Ple tlo (Mem.nextblock tm').","conclusion":"Ple tlo (Mem.nextblock tm')","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm')","proofString":"rewrite (free_list_nextblock _ _ _ H4).\ninv H; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm') : Ple tlo (Mem.nextblock tm).","conclusion":"Ple tlo (Mem.nextblock tm)","hypotheses":"(f : meminj) (cenv : compilenv) (e : env) (le : temp_env) (m : mem) (lo hi : block) (te : env) (tle : temp_env) (tm : Mem.mem') (tlo thi : block) (k tk : cont) (m' tm' : mem) (H : match_envs f cenv e le m lo hi te tle tlo thi) (H0 : match_cont f cenv k tk m lo tlo) (H1 : Ple hi (Mem.nextblock m)) (H2 : Ple thi (Mem.nextblock tm)) (H3 : Mem.free_list m (blocks_of_env ge e) = Some m') (H4 : Mem.free_list tm (blocks_of_env tge te) = Some tm')","proofString":"inv H; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H : match_globalenvs f hi) (H0 : Ple hi bound) (H1 : Ple hi tbound) : exists bound0 : block, match_globalenvs f bound0.","conclusion":"exists bound0 : block, match_globalenvs f bound0","hypotheses":"(f : meminj) (cenv : compilenv) (m : mem) (bound tbound : positive) (hi : block) (H : match_globalenvs f hi) (H0 : Ple hi bound) (H1 : Ple hi tbound)","proofString":"exists hi; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf) : exists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf)","proofString":"exploit match_cont_globalenv; eauto.\nintros [bound1 MG].\ndestruct MG.\ninv H1; simpl in H0; try discriminate.\ndestruct (Ptrofs.eq_dec ofs1 Ptrofs.zero); try discriminate.\nsubst ofs1.\nassert (f b1 = Some(b1, 0)).\napply DOMAIN.\neapply FUNCTIONS; eauto.\nrewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf) : (exists bound0 : block, match_globalenvs f bound0) ->\nexists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"(exists bound0 : block, match_globalenvs f bound0) ->\nexists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf)","proofString":"intros [bound1 MG].\ndestruct MG.\ninv H1; simpl in H0; try discriminate.\ndestruct (Ptrofs.eq_dec ofs1 Ptrofs.zero); try discriminate.\nsubst ofs1.\nassert (f b1 = Some(b1, 0)).\napply DOMAIN.\neapply FUNCTIONS; eauto.\nrewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf) (bound1 : block) (MG : match_globalenvs f bound1) : exists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf) (bound1 : block) (MG : match_globalenvs f bound1)","proofString":"destruct MG.\ninv H1; simpl in H0; try discriminate.\ndestruct (Ptrofs.eq_dec ofs1 Ptrofs.zero); try discriminate.\nsubst ofs1.\nassert (f b1 = Some(b1, 0)).\napply DOMAIN.\neapply FUNCTIONS; eauto.\nrewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound1 -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) : exists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (vf : val) (fd : fundef) (tvf : val) (H : match_cont f cenv k tk m bound tbound) (H0 : Genv.find_funct ge vf = Some fd) (H1 : Val.inject f vf tvf) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound1 -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1)","proofString":"inv H1; simpl in H0; try discriminate.\ndestruct (Ptrofs.eq_dec ofs1 Ptrofs.zero); try discriminate.\nsubst ofs1.\nassert (f b1 = Some(b1, 0)).\napply DOMAIN.\neapply FUNCTIONS; eauto.\nrewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (ofs1 : ptrofs) (H0 : (if Ptrofs.eq_dec ofs1 Ptrofs.zero then Genv.find_funct_ptr ge b1 else None) =\nSome fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (ofs1 : ptrofs) (H0 : (if Ptrofs.eq_dec ofs1 Ptrofs.zero then Genv.find_funct_ptr ge b1 else None) =\nSome fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta))","proofString":"destruct (Ptrofs.eq_dec ofs1 Ptrofs.zero); try discriminate.\nsubst ofs1.\nassert (f b1 = Some(b1, 0)).\napply DOMAIN.\neapply FUNCTIONS; eauto.\nrewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (ofs1 : ptrofs) (e : ofs1 = Ptrofs.zero) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (ofs1 : ptrofs) (e : ofs1 = Ptrofs.zero) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta))","proofString":"subst ofs1.\nassert (f b1 = Some(b1, 0)).\napply DOMAIN.\neapply FUNCTIONS; eauto.\nrewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta))","proofString":"assert (f b1 = Some(b1, 0)).\napply DOMAIN.\neapply FUNCTIONS; eauto.\nrewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : f b1 = Some (b1, 0).","conclusion":"f b1 = Some (b1, 0)","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta))","proofString":"apply DOMAIN.\neapply FUNCTIONS; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : Plt b1 bound1.","conclusion":"Plt b1 bound1","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta))","proofString":"eapply FUNCTIONS; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H1 : f b1 = Some (b1, 0)) : exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\n  Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b1 : block) (H0 : Genv.find_funct_ptr ge b1 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 bound1 -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H1 : f b1 = Some (b1, 0))","proofString":"rewrite H1 in H2; inv H2.\nrewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0)) : exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0))) =\n  Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0))) =\n  Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0))","proofString":"rewrite Ptrofs.add_zero.\nsimpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0)) : exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 Ptrofs.zero) = Some tfd /\\\n  transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (Vptr b2 Ptrofs.zero) = Some tfd /\\\n  transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0))","proofString":"simpl.\nrewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0)) : exists tfd : fundef,\n  (if Ptrofs.eq_dec Ptrofs.zero Ptrofs.zero\n   then Genv.find_funct_ptr tge b2\n   else None) = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  (if Ptrofs.eq_dec Ptrofs.zero Ptrofs.zero\n   then Genv.find_funct_ptr tge b2\n   else None) = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0))","proofString":"rewrite dec_eq_true.\napply function_ptr_translated; auto."},{"statement":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0)) : exists tfd : fundef,\n  Genv.find_funct_ptr tge b2 = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct_ptr tge b2 = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(f : meminj) (cenv : compilenv) (k tk : cont) (m : mem) (bound tbound : block) (fd : fundef) (H : match_cont f cenv k tk m bound tbound) (b2 : block) (H0 : Genv.find_funct_ptr ge b2 = Some fd) (bound1 : block) (DOMAIN : forall b : positive, Plt b bound1 -> f b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) -> Plt b0 bound1 -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound1) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound1) (VARINFOS : forall (b : block) (gv : globvar type),\nGenv.find_var_info ge b = Some gv -> Plt b bound1) (H1 : f b2 = Some (b2, 0))","proofString":"apply function_ptr_translated; auto."},{"statement":"(cenv : compilenv) (a : expr) : match is_liftable_var cenv a with\n| Some id => exists ty : type, a = Evar id ty /\\ VSet.mem id cenv = true\n| None =>\n    match a with\n    | Evar id _ => VSet.mem id cenv = false\n    | _ => True\n    end\nend.","conclusion":"match is_liftable_var cenv a with\n| Some id => exists ty : type, a = Evar id ty /\\ VSet.mem id cenv = true\n| None =>\n    match a with\n    | Evar id _ => VSet.mem id cenv = false\n    | _ => True\n    end\nend","hypotheses":"(cenv : compilenv) (a : expr)","proofString":"destruct a; simpl; auto.\ndestruct (VSet.mem i cenv) eqn:?.\nexists t; auto.\nauto."},{"statement":"(cenv : compilenv) (i : ident) (t : type) : match (if VSet.mem i cenv then Some i else None) with\n| Some id =>\n    exists ty : type, Evar i t = Evar id ty /\\ VSet.mem id cenv = true\n| None => VSet.mem i cenv = false\nend.","conclusion":"match (if VSet.mem i cenv then Some i else None) with\n| Some id =>\n    exists ty : type, Evar i t = Evar id ty /\\ VSet.mem id cenv = true\n| None => VSet.mem i cenv = false\nend","hypotheses":"(cenv : compilenv) (i : ident) (t : type)","proofString":"destruct (VSet.mem i cenv) eqn:?.\nexists t; auto.\nauto."},{"statement":"(cenv : compilenv) (i : ident) (t : type) (Heqb : VSet.mem i cenv = true) : exists ty : type, Evar i t = Evar i ty /\\ VSet.mem i cenv = true.","conclusion":"exists ty : type, Evar i t = Evar i ty /\\ VSet.mem i cenv = true","hypotheses":"(cenv : compilenv) (i : ident) (t : type) (Heqb : VSet.mem i cenv = true)","proofString":"exists t; auto."},{"statement":"(cenv : compilenv) (i : ident) (t : type) (Heqb : VSet.mem i cenv = false) : false = false.","conclusion":"false = false","hypotheses":"(cenv : compilenv) (i : ident) (t : type) (Heqb : VSet.mem i cenv = false)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch n ls) = OK (select_switch n tls).","conclusion":"forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch n ls) = OK (select_switch n tls)","hypotheses":"(cenv : compilenv) (n : Z)","proofString":"assert (DFL:    forall ls tls,    simpl_lblstmt cenv ls = OK tls ->    simpl_lblstmt cenv (select_switch_default ls) = OK (select_switch_default tls)).\ninduction ls; simpl; intros; monadInv H.\nauto.\nsimpl.\ndestruct o.\neauto.\nsimpl; rewrite EQ, EQ1.\nauto.\nassert (CASE:    forall ls tls,    simpl_lblstmt cenv ls = OK tls ->    match select_switch_case n ls with    | None => select_switch_case n tls = None    | Some ls' =>        exists tls', select_switch_case n tls = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'    end).\ninduction ls; simpl; intros; monadInv H; simpl.\nauto.\ndestruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ, EQ1; auto.\napply IHls.\nauto.\napply IHls.\nauto.\nintros; unfold select_switch.\nspecialize (CASE _ _ H).\ndestruct (select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(cenv : compilenv) (n : Z) : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls).","conclusion":"forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)","hypotheses":"(cenv : compilenv) (n : Z)","proofString":"induction ls; simpl; intros; monadInv H.\nauto.\nsimpl.\ndestruct o.\neauto.\nsimpl; rewrite EQ, EQ1.\nauto."},{"statement":"(cenv : compilenv) (n : Z) : OK LSnil = OK (select_switch_default LSnil).","conclusion":"OK LSnil = OK (select_switch_default LSnil)","hypotheses":"(cenv : compilenv) (n : Z)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : simpl_lblstmt cenv\n  match o with\n  | Some _ => select_switch_default ls\n  | None => LScons o s ls\n  end = OK (select_switch_default (LScons o x x0)).","conclusion":"simpl_lblstmt cenv\n  match o with\n  | Some _ => select_switch_default ls\n  | None => LScons o s ls\n  end = OK (select_switch_default (LScons o x x0))","hypotheses":"(cenv : compilenv) (n : Z) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"simpl.\ndestruct o.\neauto.\nsimpl; rewrite EQ, EQ1.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : simpl_lblstmt cenv\n  match o with\n  | Some _ => select_switch_default ls\n  | None => LScons o s ls\n  end =\nOK\n  match o with\n  | Some _ => select_switch_default x0\n  | None => LScons o x x0\n  end.","conclusion":"simpl_lblstmt cenv\n  match o with\n  | Some _ => select_switch_default ls\n  | None => LScons o s ls\n  end =\nOK\n  match o with\n  | Some _ => select_switch_default x0\n  | None => LScons o x x0\n  end","hypotheses":"(cenv : compilenv) (n : Z) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"destruct o.\neauto.\nsimpl; rewrite EQ, EQ1.\nauto."},{"statement":"(cenv : compilenv) (n z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : simpl_lblstmt cenv (select_switch_default ls) = OK (select_switch_default x0).","conclusion":"simpl_lblstmt cenv (select_switch_default ls) = OK (select_switch_default x0)","hypotheses":"(cenv : compilenv) (n z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"eauto."},{"statement":"(cenv : compilenv) (n : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : simpl_lblstmt cenv (LScons None s ls) = OK (LScons None x x0).","conclusion":"simpl_lblstmt cenv (LScons None s ls) = OK (LScons None x x0)","hypotheses":"(cenv : compilenv) (n : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"simpl; rewrite EQ, EQ1.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : (do s' <- OK x; do ls1' <- OK x0; OK (LScons None s' ls1')) =\nOK (LScons None x x0).","conclusion":"(do s' <- OK x; do ls1' <- OK x0; OK (LScons None s' ls1')) =\nOK (LScons None x x0)","hypotheses":"(cenv : compilenv) (n : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch n ls) = OK (select_switch n tls).","conclusion":"forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch n ls) = OK (select_switch n tls)","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls))","proofString":"assert (CASE:    forall ls tls,    simpl_lblstmt cenv ls = OK tls ->    match select_switch_case n ls with    | None => select_switch_case n tls = None    | Some ls' =>        exists tls', select_switch_case n tls = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'    end).\ninduction ls; simpl; intros; monadInv H; simpl.\nauto.\ndestruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ, EQ1; auto.\napply IHls.\nauto.\napply IHls.\nauto.\nintros; unfold select_switch.\nspecialize (CASE _ _ H).\ndestruct (select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend.","conclusion":"forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls))","proofString":"induction ls; simpl; intros; monadInv H; simpl.\nauto.\ndestruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ, EQ1; auto.\napply IHls.\nauto.\napply IHls.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : match\n  match o with\n  | Some c =>\n      if zeq c n then Some (LScons o s ls) else select_switch_case n ls\n  | None => select_switch_case n ls\n  end\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      match o with\n      | Some c =>\n          if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n      | None => select_switch_case n x0\n      end = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'\n| None =>\n    match o with\n    | Some c =>\n        if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n    | None => select_switch_case n x0\n    end = None\nend.","conclusion":"match\n  match o with\n  | Some c =>\n      if zeq c n then Some (LScons o s ls) else select_switch_case n ls\n  | None => select_switch_case n ls\n  end\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      match o with\n      | Some c =>\n          if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n      | None => select_switch_case n x0\n      end = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'\n| None =>\n    match o with\n    | Some c =>\n        if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n    | None => select_switch_case n x0\n    end = None\nend","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"destruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ, EQ1; auto.\napply IHls.\nauto.\napply IHls.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : match\n  (if zeq z n then Some (LScons (Some z) s ls) else select_switch_case n ls)\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      (if zeq z n\n       then Some (LScons (Some z) x x0)\n       else select_switch_case n x0) = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None =>\n    (if zeq z n then Some (LScons (Some z) x x0) else select_switch_case n x0) =\n    None\nend.","conclusion":"match\n  (if zeq z n then Some (LScons (Some z) s ls) else select_switch_case n ls)\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      (if zeq z n\n       then Some (LScons (Some z) x x0)\n       else select_switch_case n x0) = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None =>\n    (if zeq z n then Some (LScons (Some z) x x0) else select_switch_case n x0) =\n    None\nend","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"destruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ, EQ1; auto.\napply IHls.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (e : z = n) : exists tls' : labeled_statements,\n  Some (LScons (Some z) x x0) = Some tls' /\\\n  simpl_lblstmt cenv (LScons (Some z) s ls) = OK tls'.","conclusion":"exists tls' : labeled_statements,\n  Some (LScons (Some z) x x0) = Some tls' /\\\n  simpl_lblstmt cenv (LScons (Some z) s ls) = OK tls'","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (e : z = n)","proofString":"econstructor; split; eauto.\nsimpl; rewrite EQ, EQ1; auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (e : z = n) : simpl_lblstmt cenv (LScons (Some z) s ls) = OK (LScons (Some z) x x0).","conclusion":"simpl_lblstmt cenv (LScons (Some z) s ls) = OK (LScons (Some z) x x0)","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (e : z = n)","proofString":"simpl; rewrite EQ, EQ1; auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (n0 : z <> n) : match select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n x0 = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n x0 = None\nend.","conclusion":"match select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n x0 = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n x0 = None\nend","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (n0 : z <> n)","proofString":"apply IHls.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (n0 : z <> n) : simpl_lblstmt cenv ls = OK x0.","conclusion":"simpl_lblstmt cenv ls = OK x0","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) (n0 : z <> n)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : match select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n x0 = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n x0 = None\nend.","conclusion":"match select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n x0 = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n x0 = None\nend","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"apply IHls.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : simpl_lblstmt cenv ls = OK x0.","conclusion":"simpl_lblstmt cenv ls = OK x0","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls)) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (CASE : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch n ls) = OK (select_switch n tls).","conclusion":"forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch n ls) = OK (select_switch n tls)","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)) (CASE : forall ls tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nmatch select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend)","proofString":"intros; unfold select_switch.\nspecialize (CASE _ _ H).\ndestruct (select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (CASE : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nmatch select_switch_case n ls0 with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls0 = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls0 = None\nend) (ls tls : labeled_statements) (H : simpl_lblstmt cenv ls = OK tls) : simpl_lblstmt cenv\n  match select_switch_case n ls with\n  | Some sl' => sl'\n  | None => select_switch_default ls\n  end =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"simpl_lblstmt cenv\n  match select_switch_case n ls with\n  | Some sl' => sl'\n  | None => select_switch_default ls\n  end =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (CASE : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nmatch select_switch_case n ls0 with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls0 = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls0 = None\nend) (ls tls : labeled_statements) (H : simpl_lblstmt cenv ls = OK tls)","proofString":"specialize (CASE _ _ H).\ndestruct (select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls : labeled_statements) (CASE : match select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (H : simpl_lblstmt cenv ls = OK tls) : simpl_lblstmt cenv\n  match select_switch_case n ls with\n  | Some sl' => sl'\n  | None => select_switch_default ls\n  end =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"simpl_lblstmt cenv\n  match select_switch_case n ls with\n  | Some sl' => sl'\n  | None => select_switch_default ls\n  end =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls : labeled_statements) (CASE : match select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\\n      simpl_lblstmt cenv ls' = OK tls'\n| None => select_switch_case n tls = None\nend) (H : simpl_lblstmt cenv ls = OK tls)","proofString":"destruct (select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls ls' : labeled_statements) (CASE : exists tls' : labeled_statements,\n  select_switch_case n tls = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls') (H : simpl_lblstmt cenv ls = OK tls) : simpl_lblstmt cenv ls' =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"simpl_lblstmt cenv ls' =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls ls' : labeled_statements) (CASE : exists tls' : labeled_statements,\n  select_switch_case n tls = Some tls' /\\ simpl_lblstmt cenv ls' = OK tls') (H : simpl_lblstmt cenv ls = OK tls)","proofString":"destruct CASE as [tls' [P Q]].\nrewrite P, Q.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls ls' tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : simpl_lblstmt cenv ls' = OK tls') (H : simpl_lblstmt cenv ls = OK tls) : simpl_lblstmt cenv ls' =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"simpl_lblstmt cenv ls' =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls ls' tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : simpl_lblstmt cenv ls' = OK tls') (H : simpl_lblstmt cenv ls = OK tls)","proofString":"rewrite P, Q.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls ls' tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : simpl_lblstmt cenv ls' = OK tls') (H : simpl_lblstmt cenv ls = OK tls) : OK tls' = OK tls'.","conclusion":"OK tls' = OK tls'","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls ls' tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : simpl_lblstmt cenv ls' = OK tls') (H : simpl_lblstmt cenv ls = OK tls)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : simpl_lblstmt cenv ls = OK tls) : simpl_lblstmt cenv (select_switch_default ls) =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"simpl_lblstmt cenv (select_switch_default ls) =\nOK\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : simpl_lblstmt cenv ls = OK tls)","proofString":"rewrite CASE.\napply DFL; auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : simpl_lblstmt cenv ls = OK tls) : simpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls).","conclusion":"simpl_lblstmt cenv (select_switch_default ls) =\nOK (select_switch_default tls)","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 tls0 : labeled_statements,\nsimpl_lblstmt cenv ls0 = OK tls0 ->\nsimpl_lblstmt cenv (select_switch_default ls0) =\nOK (select_switch_default tls0)) (ls tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : simpl_lblstmt cenv ls = OK tls)","proofString":"apply DFL; auto."},{"statement":"(cenv : compilenv) : OK Sskip = OK Sskip.","conclusion":"OK Sskip = OK Sskip","hypotheses":"(cenv : compilenv)","proofString":"auto."},{"statement":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : (do s1' <- simpl_stmt cenv s;\n do s2' <- simpl_stmt cenv (seq_of_labeled_statement ls);\n OK (Ssequence s1' s2')) = OK (Ssequence x (seq_of_labeled_statement x0)).","conclusion":"(do s1' <- simpl_stmt cenv s;\n do s2' <- simpl_stmt cenv (seq_of_labeled_statement ls);\n OK (Ssequence s1' s2')) = OK (Ssequence x (seq_of_labeled_statement x0))","hypotheses":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"rewrite EQ; simpl.\nerewrite IHls; eauto.\nsimpl.\nauto."},{"statement":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : (do s2' <- simpl_stmt cenv (seq_of_labeled_statement ls);\n OK (Ssequence x s2')) = OK (Ssequence x (seq_of_labeled_statement x0)).","conclusion":"(do s2' <- simpl_stmt cenv (seq_of_labeled_statement ls);\n OK (Ssequence x s2')) = OK (Ssequence x (seq_of_labeled_statement x0))","hypotheses":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"erewrite IHls; eauto.\nsimpl.\nauto."},{"statement":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : (do s2' <- OK (seq_of_labeled_statement x0); OK (Ssequence x s2')) =\nOK (Ssequence x (seq_of_labeled_statement x0)).","conclusion":"(do s2' <- OK (seq_of_labeled_statement x0); OK (Ssequence x s2')) =\nOK (Ssequence x (seq_of_labeled_statement x0))","hypotheses":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"simpl.\nauto."},{"statement":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0) : OK (Ssequence x (seq_of_labeled_statement x0)) =\nOK (Ssequence x (seq_of_labeled_statement x0)).","conclusion":"OK (Ssequence x (seq_of_labeled_statement x0)) =\nOK (Ssequence x (seq_of_labeled_statement x0))","hypotheses":"(cenv : compilenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall tls : labeled_statements,\nsimpl_lblstmt cenv ls = OK tls ->\nsimpl_stmt cenv (seq_of_labeled_statement ls) =\nOK (seq_of_labeled_statement tls)) (x : statement) (EQ : simpl_stmt cenv s = OK x) (x0 : labeled_statements) (EQ1 : simpl_lblstmt cenv ls = OK x0)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv.","conclusion":"forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv","hypotheses":"(cenv : compilenv) (n : Z)","proofString":"assert (DFL: forall ls,    compat_cenv (addr_taken_lblstmt ls) cenv ->    compat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv).\ninduction ls; simpl; intros.\neauto with compat.\ndestruct o; simpl; eauto with compat.\nassert (CASE: forall ls ls',    compat_cenv (addr_taken_lblstmt ls) cenv ->    select_switch_case n ls = Some ls' ->    compat_cenv (addr_taken_lblstmt ls') cenv).\ninduction ls; simpl; intros.\ndiscriminate.\ndestruct o.\ndestruct (zeq z n).\ninv H0.\nauto.\neauto with compat.\neauto with compat.\nintros.\nspecialize (CASE ls).\nunfold select_switch.\ndestruct (select_switch_case n ls) as [ls'|]; eauto."},{"statement":"(cenv : compilenv) (n : Z) : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv.","conclusion":"forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv","hypotheses":"(cenv : compilenv) (n : Z)","proofString":"induction ls; simpl; intros.\neauto with compat.\ndestruct o; simpl; eauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (H : compat_cenv VSet.empty cenv) : compat_cenv VSet.empty cenv.","conclusion":"compat_cenv VSet.empty cenv","hypotheses":"(cenv : compilenv) (n : Z) (H : compat_cenv VSet.empty cenv)","proofString":"eauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : compat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) : compat_cenv\n  (addr_taken_lblstmt\n     match o with\n     | Some _ => select_switch_default ls\n     | None => LScons o s ls\n     end) cenv.","conclusion":"compat_cenv\n  (addr_taken_lblstmt\n     match o with\n     | Some _ => select_switch_default ls\n     | None => LScons o s ls\n     end) cenv","hypotheses":"(cenv : compilenv) (n : Z) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : compat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv)","proofString":"destruct o; simpl; eauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv.","conclusion":"forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv)","proofString":"assert (CASE: forall ls ls',    compat_cenv (addr_taken_lblstmt ls) cenv ->    select_switch_case n ls = Some ls' ->    compat_cenv (addr_taken_lblstmt ls') cenv).\ninduction ls; simpl; intros.\ndiscriminate.\ndestruct o.\ndestruct (zeq z n).\ninv H0.\nauto.\neauto with compat.\neauto with compat.\nintros.\nspecialize (CASE ls).\nunfold select_switch.\ndestruct (select_switch_case n ls) as [ls'|]; eauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) : forall ls ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv.","conclusion":"forall ls ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv)","proofString":"induction ls; simpl; intros.\ndiscriminate.\ndestruct o.\ndestruct (zeq z n).\ninv H0.\nauto.\neauto with compat.\neauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) (ls' : labeled_statements) (H : compat_cenv VSet.empty cenv) (H0 : None = Some ls') : compat_cenv (addr_taken_lblstmt ls') cenv.","conclusion":"compat_cenv (addr_taken_lblstmt ls') cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) (ls' : labeled_statements) (H : compat_cenv VSet.empty cenv) (H0 : None = Some ls')","proofString":"discriminate."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (H0 : match o with\n| Some c => if zeq c n then Some (LScons o s ls) else select_switch_case n ls\n| None => select_switch_case n ls\nend = Some ls') : compat_cenv (addr_taken_lblstmt ls') cenv.","conclusion":"compat_cenv (addr_taken_lblstmt ls') cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (o : option Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (H0 : match o with\n| Some c => if zeq c n then Some (LScons o s ls) else select_switch_case n ls\n| None => select_switch_case n ls\nend = Some ls')","proofString":"destruct o.\ndestruct (zeq z n).\ninv H0.\nauto.\neauto with compat.\neauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (H0 : (if zeq z n then Some (LScons (Some z) s ls) else select_switch_case n ls) =\nSome ls') : compat_cenv (addr_taken_lblstmt ls') cenv.","conclusion":"compat_cenv (addr_taken_lblstmt ls') cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (H0 : (if zeq z n then Some (LScons (Some z) s ls) else select_switch_case n ls) =\nSome ls')","proofString":"destruct (zeq z n).\ninv H0.\nauto.\neauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (e : z = n) (H0 : Some (LScons (Some z) s ls) = Some ls') : compat_cenv (addr_taken_lblstmt ls') cenv.","conclusion":"compat_cenv (addr_taken_lblstmt ls') cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (e : z = n) (H0 : Some (LScons (Some z) s ls) = Some ls')","proofString":"inv H0.\nauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (s : statement) (ls : labeled_statements) (IHls : forall ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) : compat_cenv (addr_taken_lblstmt (LScons (Some n) s ls)) cenv.","conclusion":"compat_cenv (addr_taken_lblstmt (LScons (Some n) s ls)) cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (s : statement) (ls : labeled_statements) (IHls : forall ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv)","proofString":"auto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (n0 : z <> n) (H0 : select_switch_case n ls = Some ls') : compat_cenv (addr_taken_lblstmt ls') cenv.","conclusion":"compat_cenv (addr_taken_lblstmt ls') cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (z : Z) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (n0 : z <> n) (H0 : select_switch_case n ls = Some ls')","proofString":"eauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (H0 : select_switch_case n ls = Some ls') : compat_cenv (addr_taken_lblstmt ls') cenv.","conclusion":"compat_cenv (addr_taken_lblstmt ls') cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (s : statement) (ls : labeled_statements) (IHls : forall ls'0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls'0 ->\ncompat_cenv (addr_taken_lblstmt ls'0) cenv) (ls' : labeled_statements) (H : compat_cenv (VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls)) cenv) (H0 : select_switch_case n ls = Some ls')","proofString":"eauto with compat."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) (CASE : forall ls ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv.","conclusion":"forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls)) cenv) (CASE : forall ls ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv)","proofString":"intros.\nspecialize (CASE ls).\nunfold select_switch.\ndestruct (select_switch_case n ls) as [ls'|]; eauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (CASE : forall ls0 ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\nselect_switch_case n ls0 = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (ls : labeled_statements) (H : compat_cenv (addr_taken_lblstmt ls) cenv) : compat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv.","conclusion":"compat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (CASE : forall ls0 ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\nselect_switch_case n ls0 = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (ls : labeled_statements) (H : compat_cenv (addr_taken_lblstmt ls) cenv)","proofString":"specialize (CASE ls).\nunfold select_switch.\ndestruct (select_switch_case n ls) as [ls'|]; eauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (ls : labeled_statements) (CASE : forall ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (H : compat_cenv (addr_taken_lblstmt ls) cenv) : compat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv.","conclusion":"compat_cenv (addr_taken_lblstmt (select_switch n ls)) cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (ls : labeled_statements) (CASE : forall ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (H : compat_cenv (addr_taken_lblstmt ls) cenv)","proofString":"unfold select_switch.\ndestruct (select_switch_case n ls) as [ls'|]; eauto."},{"statement":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (ls : labeled_statements) (CASE : forall ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (H : compat_cenv (addr_taken_lblstmt ls) cenv) : compat_cenv\n  (addr_taken_lblstmt\n     match select_switch_case n ls with\n     | Some sl' => sl'\n     | None => select_switch_default ls\n     end) cenv.","conclusion":"compat_cenv\n  (addr_taken_lblstmt\n     match select_switch_case n ls with\n     | Some sl' => sl'\n     | None => select_switch_default ls\n     end) cenv","hypotheses":"(cenv : compilenv) (n : Z) (DFL : forall ls0 : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls0) cenv ->\ncompat_cenv (addr_taken_lblstmt (select_switch_default ls0)) cenv) (ls : labeled_statements) (CASE : forall ls' : labeled_statements,\ncompat_cenv (addr_taken_lblstmt ls) cenv ->\nselect_switch_case n ls = Some ls' ->\ncompat_cenv (addr_taken_lblstmt ls') cenv) (H : compat_cenv (addr_taken_lblstmt ls) cenv)","proofString":"destruct (select_switch_case n ls) as [ls'|]; eauto."},{"statement":"(s : statement) (k : cont) : find_label lbl s k = find_label lbl s k.","conclusion":"find_label lbl s k = find_label lbl s k","hypotheses":"(s : statement) (k : cont)","proofString":"auto."},{"statement":"(s : statement) (k : cont) (a : ident * type) (params : list (ident * type)) (IHparams : find_label lbl (store_params cenv params s) k = find_label lbl s k) : find_label lbl\n  (let (id, ty) := a in\n   if VSet.mem id cenv\n   then\n    if Conventions1.parameter_needs_normalization (argtype_of_type ty)\n    then\n     Ssequence (Sset id (make_cast (Etempvar id ty) ty))\n       (store_params cenv params s)\n    else store_params cenv params s\n   else\n    Ssequence (Sassign (Evar id ty) (Etempvar id ty))\n      (store_params cenv params s)) k = find_label lbl s k.","conclusion":"find_label lbl\n  (let (id, ty) := a in\n   if VSet.mem id cenv\n   then\n    if Conventions1.parameter_needs_normalization (argtype_of_type ty)\n    then\n     Ssequence (Sset id (make_cast (Etempvar id ty) ty))\n       (store_params cenv params s)\n    else store_params cenv params s\n   else\n    Ssequence (Sassign (Evar id ty) (Etempvar id ty))\n      (store_params cenv params s)) k = find_label lbl s k","hypotheses":"(s : statement) (k : cont) (a : ident * type) (params : list (ident * type)) (IHparams : find_label lbl (store_params cenv params s) k = find_label lbl s k)","proofString":"destruct a as [id ty].\ndestruct (VSet.mem id cenv); [destruct Conventions1.parameter_needs_normalization|]; auto."},{"statement":"(s : statement) (k : cont) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : find_label lbl (store_params cenv params s) k = find_label lbl s k) : find_label lbl\n  (if VSet.mem id cenv\n   then\n    if Conventions1.parameter_needs_normalization (argtype_of_type ty)\n    then\n     Ssequence (Sset id (make_cast (Etempvar id ty) ty))\n       (store_params cenv params s)\n    else store_params cenv params s\n   else\n    Ssequence (Sassign (Evar id ty) (Etempvar id ty))\n      (store_params cenv params s)) k = find_label lbl s k.","conclusion":"find_label lbl\n  (if VSet.mem id cenv\n   then\n    if Conventions1.parameter_needs_normalization (argtype_of_type ty)\n    then\n     Ssequence (Sset id (make_cast (Etempvar id ty) ty))\n       (store_params cenv params s)\n    else store_params cenv params s\n   else\n    Ssequence (Sassign (Evar id ty) (Etempvar id ty))\n      (store_params cenv params s)) k = find_label lbl s k","hypotheses":"(s : statement) (k : cont) (id : ident) (ty : type) (params : list (ident * type)) (IHparams : find_label lbl (store_params cenv params s) k = find_label lbl s k)","proofString":"destruct (VSet.mem id cenv); [destruct Conventions1.parameter_needs_normalization|]; auto."},{"statement":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl\n  (if Compopts.debug tt then fold_right add_debug_var s vars else s) k =\nfind_label lbl s k.","conclusion":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl\n  (if Compopts.debug tt then fold_right add_debug_var s vars else s) k =\nfind_label lbl s k","hypotheses":"","proofString":"destruct (Compopts.debug tt); auto.\ninduction vars; simpl; auto.\ndestruct a as [id ty]; simpl.\nauto."},{"statement":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k.","conclusion":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k","hypotheses":"","proofString":"induction vars; simpl; auto.\ndestruct a as [id ty]; simpl.\nauto."},{"statement":"(s : statement) (k : cont) (a : ident * type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k) : find_label lbl (add_debug_var a (fold_right add_debug_var s vars)) k =\nfind_label lbl s k.","conclusion":"find_label lbl (add_debug_var a (fold_right add_debug_var s vars)) k =\nfind_label lbl s k","hypotheses":"(s : statement) (k : cont) (a : ident * type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k)","proofString":"destruct a as [id ty]; simpl.\nauto."},{"statement":"(s : statement) (k : cont) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k) : find_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k.","conclusion":"find_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k","hypotheses":"(s : statement) (k : cont) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_var s vars) k = find_label lbl s k)","proofString":"auto."},{"statement":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl\n  (if Compopts.debug tt then fold_right add_debug_param s vars else s) k =\nfind_label lbl s k.","conclusion":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl\n  (if Compopts.debug tt then fold_right add_debug_param s vars else s) k =\nfind_label lbl s k","hypotheses":"","proofString":"destruct (Compopts.debug tt); auto.\ninduction vars; simpl; auto.\ndestruct a as [id ty]; simpl.\nauto."},{"statement":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k.","conclusion":"forall (s : statement) (k : cont) (vars : list (ident * type)),\nfind_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k","hypotheses":"","proofString":"induction vars; simpl; auto.\ndestruct a as [id ty]; simpl.\nauto."},{"statement":"(s : statement) (k : cont) (a : ident * type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k) : find_label lbl (add_debug_param a (fold_right add_debug_param s vars)) k =\nfind_label lbl s k.","conclusion":"find_label lbl (add_debug_param a (fold_right add_debug_param s vars)) k =\nfind_label lbl s k","hypotheses":"(s : statement) (k : cont) (a : ident * type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k)","proofString":"destruct a as [id ty]; simpl.\nauto."},{"statement":"(s : statement) (k : cont) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k) : find_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k.","conclusion":"find_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k","hypotheses":"(s : statement) (k : cont) (id : ident) (ty : type) (vars : list (ident * type)) (IHvars : find_label lbl (fold_right add_debug_param s vars) k = find_label lbl s k)","proofString":"auto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (ts : statement) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : match is_liftable_var (cenv_for f) a1 with\n| Some id => OK (Sset_debug id (typeof a1) (simpl_expr (cenv_for f) a2))\n| None =>\n    OK (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2))\nend = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf ts tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf ts tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (ts : statement) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : match is_liftable_var (cenv_for f) a1 with\n| Some id => OK (Sset_debug id (typeof a1) (simpl_expr (cenv_for f) a2))\n| None =>\n    OK (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2))\nend = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"generalize (is_liftable_var_charact (cenv_for f) a1); destruct (is_liftable_var (cenv_for f) a1) as [id|]; monadInv TRS.\nintros [ty [P Q]]; subst a1; simpl in *.\nexploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit me_vars; eauto.\ninstantiate (1 := id).\nintros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence.\nintros P.\nexploit eval_simpl_lvalue; eauto with compat.\nintros [tb [tofs [E F]]].\nexploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (id : ident) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : (exists ty : type, a1 = Evar id ty /\\ VSet.mem id (cenv_for f) = true) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id (typeof a1) (simpl_expr (cenv_for f) a2)) tk te\n       tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"(exists ty : type, a1 = Evar id ty /\\ VSet.mem id (cenv_for f) = true) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id (typeof a1) (simpl_expr (cenv_for f) a2)) tk te\n       tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (id : ident) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"intros [ty [P Q]]; subst a1; simpl in *.\nexploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit me_vars; eauto.\ninstantiate (1 := id).\nintros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true)","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit me_vars; eauto.\ninstantiate (1 := id).\nintros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv /\\\n   Val.inject j v2 tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv /\\\n   Val.inject j v2 tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true)","proofString":"intros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit me_vars; eauto.\ninstantiate (1 := id).\nintros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2)","proofString":"exploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit me_vars; eauto.\ninstantiate (1 := id).\nintros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) : (exists tv : val,\n   sem_cast tv2 (typeof a2) ty tm = Some tv /\\ Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"(exists tv : val,\n   sem_cast tv2 (typeof a2) ty tm = Some tv /\\ Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2)","proofString":"intros [tv [C D]].\nexploit me_vars; eauto.\ninstantiate (1 := id).\nintros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv)","proofString":"exploit me_vars; eauto.\ninstantiate (1 := id).\nintros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) : match_var j (cenv_for f) e m te tle id ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"match_var j (cenv_for f) e m te tle id ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv)","proofString":"intros MV.\ninv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H : eval_lvalue ge e le m (Evar id ty) loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc ofs bf v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id)","proofString":"inv H.\neconstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto.\ninv MV; congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty)) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty))","proofString":"econstructor; split.\neapply step_Sset_debug.\neauto.\nrewrite typeof_simpl_expr.\neauto.\neconstructor; eauto with compat.\neapply match_envs_assign_lifted; eauto.\neapply cast_val_is_casted; eauto.\neapply match_cont_assign_loc; eauto.\nexploit me_range; eauto.\nextlia.\ninv MV; try congruence.\ninv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty)) : val_casted v ty.","conclusion":"val_casted v ty","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty))","proofString":"eapply cast_val_is_casted; eauto."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty)) : Ple lo loc.","conclusion":"Ple lo loc","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty))","proofString":"exploit me_range; eauto.\nextlia."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty)) : Ple lo loc /\\ Plt loc hi -> Ple lo loc.","conclusion":"Ple lo loc /\\ Plt loc hi -> Ple lo loc","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H8 : e ! id = Some (loc, ty))","proofString":"extlia."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0) : Mem.inject j m' tm.","conclusion":"Mem.inject j m' tm","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0)","proofString":"inv H2; try congruence.\nunfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H3 : Mem.storev chunk0 m (Vptr loc Ptrofs.zero) v = Some m') : Mem.inject j m' tm.","conclusion":"Mem.inject j m' tm","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H3 : Mem.storev chunk0 m (Vptr loc Ptrofs.zero) v = Some m')","proofString":"unfold Mem.storev in H3.\neapply Mem.store_unmapped_inject; eauto.\ncongruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H3 : Mem.store chunk0 m loc (Ptrofs.unsigned Ptrofs.zero) v = Some m') : Mem.inject j m' tm.","conclusion":"Mem.inject j m' tm","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H3 : Mem.store chunk0 m loc (Ptrofs.unsigned Ptrofs.zero) v = Some m')","proofString":"eapply Mem.store_unmapped_inject; eauto.\ncongruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H3 : Mem.store chunk0 m loc (Ptrofs.unsigned Ptrofs.zero) v = Some m') : j loc = None.","conclusion":"j loc = None","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (H8 : e ! id = Some (loc, ty)) (b : block) (ty0 : type) (chunk : memory_chunk) (v0 tv0 : val) (ENV : e ! id = Some (b, ty0)) (TENV : te ! id = None) (LIFTED : VSet.mem id (cenv_for f) = true) (MAPPED : j b = None) (MODE : access_mode ty0 = By_value chunk) (LOAD : Mem.load chunk m b 0 = Some v0) (TLENV : tle ! id = Some tv0) (VINJ : Val.inject j v0 tv0) (chunk0 : memory_chunk) (H : access_mode ty = By_value chunk0) (H3 : Mem.store chunk0 m loc (Ptrofs.unsigned Ptrofs.zero) v = Some m')","proofString":"congruence."},{"statement":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H5 : e ! id = None) (H9 : Genv.find_symbol ge id = Some loc) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset_debug id ty (simpl_expr (cenv_for f) a2)) tk te tle tm)\n    E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (v2 v : val) (m' : mem) (id : ident) (ty : type) (H0 : eval_expr ge e le m a2 v2) (H2 : assign_loc ge ty m loc Ptrofs.zero Full v m') (H1 : sem_cast v2 (typeof a2) ty m = Some v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union VSet.empty (addr_taken_expr a2)) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (Q : VSet.mem id (cenv_for f) = true) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) ty tm = Some tv) (D : Val.inject j v tv) (MV : match_var j (cenv_for f) e m te tle id) (H5 : e ! id = None) (H9 : Genv.find_symbol ge id = Some loc)","proofString":"inv MV; congruence."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"intros P.\nexploit eval_simpl_lvalue; eauto with compat.\nintros [tb [tofs [E F]]].\nexploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend)","proofString":"exploit eval_simpl_lvalue; eauto with compat.\nintros [tb [tofs [E F]]].\nexploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) : (exists (b' : block) (ofs' : ptrofs),\n   eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) b' ofs' bf /\\\n   Val.inject j (Vptr loc ofs) (Vptr b' ofs')) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"(exists (b' : block) (ofs' : ptrofs),\n   eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) b' ofs' bf /\\\n   Val.inject j (Vptr loc ofs) (Vptr b' ofs')) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend)","proofString":"intros [tb [tofs [E F]]].\nexploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs))","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv /\\\n   Val.inject j v2 tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv /\\\n   Val.inject j v2 tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs))","proofString":"intros [tv2 [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2)","proofString":"exploit sem_cast_inject; eauto.\nintros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) : (exists tv : val,\n   sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv /\\ Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"(exists tv : val,\n   sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv /\\ Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2)","proofString":"intros [tv [C D]].\nexploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv) (D : Val.inject j v tv) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv) (D : Val.inject j v tv)","proofString":"exploit assign_loc_inject; eauto.\nintros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv) (D : Val.inject j v tv) : (exists tm' : mem,\n   assign_loc tge (typeof a1) tm tb tofs bf tv tm' /\\\n   Mem.inject j m' tm' /\\\n   (forall (b : block) (chunk : memory_chunk) (v0 : val),\n    j b = None ->\n    Mem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0)) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"(exists tm' : mem,\n   assign_loc tge (typeof a1) tm tb tofs bf tv tm' /\\\n   Mem.inject j m' tm' /\\\n   (forall (b : block) (chunk : memory_chunk) (v0 : val),\n    j b = None ->\n    Mem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0)) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv) (D : Val.inject j v tv)","proofString":"intros [tm' [X [Y Z]]].\neconstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv) (D : Val.inject j v tv) (tm' : mem) (X : assign_loc tge (typeof a1) tm tb tofs bf tv tm') (Y : Mem.inject j m' tm') (Z : forall (b : block) (chunk : memory_chunk) (v0 : val),\nj b = None ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Sassign (simpl_expr (cenv_for f) a1) (simpl_expr (cenv_for f) a2)) tk\n       te tle tm) E0 S2' /\\ match_states (State f Sskip k e le m') S2'","hypotheses":"(f : function) (a1 a2 : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (loc : block) (ofs : ptrofs) (bf : bitfield) (v2 v : val) (m' : mem) (H : eval_lvalue ge e le m a1 loc ofs bf) (H0 : eval_expr ge e le m a2 v2) (H1 : sem_cast v2 (typeof a2) (typeof a1) m = Some v) (H2 : assign_loc ge (typeof a1) m loc ofs bf v m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a1) (addr_taken_expr a2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (P : match a1 with\n| Evar id _ => VSet.mem id (cenv_for f) = false\n| _ => True\nend) (tb : block) (tofs : ptrofs) (E : eval_lvalue tge te tle tm (simpl_expr (cenv_for f) a1) tb tofs bf) (F : Val.inject j (Vptr loc ofs) (Vptr tb tofs)) (tv2 : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a2) tv2) (B : Val.inject j v2 tv2) (tv : val) (C : sem_cast tv2 (typeof a2) (typeof a1) tm = Some tv) (D : Val.inject j v tv) (tm' : mem) (X : assign_loc tge (typeof a1) tm tb tofs bf tv tm') (Y : Mem.inject j m' tm') (Z : forall (b : block) (chunk : memory_chunk) (v0 : val),\nj b = None ->\nMem.load chunk m b 0 = Some v0 -> Mem.load chunk m' b 0 = Some v0)","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neexact E.\neexact A.\nrepeat rewrite typeof_simpl_expr.\neexact C.\nrewrite typeof_simpl_expr; auto.\neexact X.\neconstructor; eauto with compat.\neapply match_envs_invariant; eauto.\neapply match_cont_invariant; eauto.\nerewrite assign_loc_nextblock; eauto.\nerewrite assign_loc_nextblock; eauto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset id (simpl_expr (cenv_for f) a)) tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e (PTree.set id v le) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset id (simpl_expr (cenv_for f) a)) tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e (PTree.set id v le) m) S2'","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x)","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tv [A B]].\neconstructor; split.\napply plus_one.\neconstructor.\neauto.\neconstructor; eauto with compat.\neapply match_envs_set_temp; eauto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset id (simpl_expr (cenv_for f) a)) tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e (PTree.set id v le) m) S2'.","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sset id (simpl_expr (cenv_for f) a)) tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e (PTree.set id v le) m) S2'","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x)","proofString":"intros [tv [A B]].\neconstructor; split.\napply plus_one.\neconstructor.\neauto.\neconstructor; eauto with compat.\neapply match_envs_set_temp; eauto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sset id (simpl_expr (cenv_for f) a)) tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e (PTree.set id v le) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sset id (simpl_expr (cenv_for f) a)) tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e (PTree.set id v le) m) S2'","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neauto.\neconstructor; eauto with compat.\neapply match_envs_set_temp; eauto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : match_envs j (cenv_for f) e (PTree.set id v le) m lo hi te\n  (PTree.set id tv tle) tlo thi.","conclusion":"match_envs j (cenv_for f) e (PTree.set id v le) m lo hi te\n  (PTree.set id tv tle) tlo thi","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (H : eval_expr ge e le m a v) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_temp (cenv_for f) id = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"eapply match_envs_set_temp; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x)","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tvf [A B]].\nexploit eval_simpl_exprlist; eauto with compat.\nintros [CASTED [tvargs [C D]]].\nexploit match_cont_find_funct; eauto.\nintros [tfd [P Q]].\neconstructor; split.\napply plus_one.\neapply step_call with (fd := tfd).\nrewrite typeof_simpl_expr.\neauto.\neauto.\neauto.\neauto.\nerewrite type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j vf tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'.","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j vf tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x)","proofString":"intros [tvf [A B]].\nexploit eval_simpl_exprlist; eauto with compat.\nintros [CASTED [tvargs [C D]]].\nexploit match_cont_find_funct; eauto.\nintros [tfd [P Q]].\neconstructor; split.\napply plus_one.\neapply step_call with (fd := tfd).\nrewrite typeof_simpl_expr.\neauto.\neauto.\neauto.\neauto.\nerewrite type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf)","proofString":"exploit eval_simpl_exprlist; eauto with compat.\nintros [CASTED [tvargs [C D]]].\nexploit match_cont_find_funct; eauto.\nintros [tfd [P Q]].\neconstructor; split.\napply plus_one.\neapply step_call with (fd := tfd).\nrewrite typeof_simpl_expr.\neauto.\neauto.\neauto.\neauto.\nerewrite type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) : val_casted_list vargs tyargs /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvl /\\\n   Val.inject_list j vargs tvl) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'.","conclusion":"val_casted_list vargs tyargs /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvl /\\\n   Val.inject_list j vargs tvl) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf)","proofString":"intros [CASTED [tvargs [C D]]].\nexploit match_cont_find_funct; eauto.\nintros [tfd [P Q]].\neconstructor; split.\napply plus_one.\neapply step_call with (fd := tfd).\nrewrite typeof_simpl_expr.\neauto.\neauto.\neauto.\neauto.\nerewrite type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs)","proofString":"exploit match_cont_find_funct; eauto.\nintros [tfd [P Q]].\neconstructor; split.\napply plus_one.\neapply step_call with (fd := tfd).\nrewrite typeof_simpl_expr.\neauto.\neauto.\neauto.\neauto.\nerewrite type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) : (exists tfd : fundef,\n   Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'.","conclusion":"(exists tfd : fundef,\n   Genv.find_funct tge tvf = Some tfd /\\ transf_fundef fd = OK tfd) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs)","proofString":"intros [tfd [P Q]].\neconstructor; split.\napply plus_one.\neapply step_call with (fd := tfd).\nrewrite typeof_simpl_expr.\neauto.\neauto.\neauto.\neauto.\nerewrite type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (tfd : fundef) (P : Genv.find_funct tge tvf = Some tfd) (Q : transf_fundef fd = OK tfd) : exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf\n       (Scall optid (simpl_expr (cenv_for f) a)\n          (simpl_exprlist (cenv_for f) al)) tk te tle tm) E0 S2' /\\\n  match_states (Callstate fd vargs (Kcall optid f e le k) m) S2'","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (tfd : fundef) (P : Genv.find_funct tge tvf = Some tfd) (Q : transf_fundef fd = OK tfd)","proofString":"econstructor; split.\napply plus_one.\neapply step_call with (fd := tfd).\nrewrite typeof_simpl_expr.\neauto.\neauto.\neauto.\neauto.\nerewrite type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (tfd : fundef) (P : Genv.find_funct tge tvf = Some tfd) (Q : transf_fundef fd = OK tfd) : forall cenv : compilenv,\nmatch_cont j cenv (Kcall optid f e le k) (Kcall optid tf te tle tk) m\n  (Mem.nextblock m) (Mem.nextblock tm).","conclusion":"forall cenv : compilenv,\nmatch_cont j cenv (Kcall optid f e le k) (Kcall optid tf te tle tk) m\n  (Mem.nextblock m) (Mem.nextblock tm)","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (tfd : fundef) (P : Genv.find_funct tge tvf = Some tfd) (Q : transf_fundef fd = OK tfd)","proofString":"intros.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (tfd : fundef) (P : Genv.find_funct tge tvf = Some tfd) (Q : transf_fundef fd = OK tfd) (cenv : compilenv) : match_cont j cenv (Kcall optid f e le k) (Kcall optid tf te tle tk) m\n  (Mem.nextblock m) (Mem.nextblock tm).","conclusion":"match_cont j cenv (Kcall optid f e le k) (Kcall optid tf te tle tk) m\n  (Mem.nextblock m) (Mem.nextblock tm)","hypotheses":"(f : function) (optid : option ident) (a : expr) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H0 : eval_expr ge e le m a vf) (H1 : eval_exprlist ge e le m al tyargs vargs) (H2 : Genv.find_funct ge vf = Some fd) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_exprlist al))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (tvf : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tvf) (B : Val.inject j vf tvf) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (tfd : fundef) (P : Genv.find_funct tge tvf = Some tfd) (Q : transf_fundef fd = OK tfd) (cenv : compilenv)","proofString":"econstructor; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x)","proofString":"exploit eval_simpl_exprlist; eauto with compat.\nintros [CASTED [tvargs [C D]]].\nexploit external_call_mem_inject; eauto.\napply match_globalenvs_preserves_globals; eauto with compat.\nintros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto.\neapply match_envs_extcall; eauto.\neapply match_cont_extcall; eauto.\ninv MENV; extlia.\ninv MENV; extlia.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) : val_casted_list vargs tyargs /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvl /\\\n   Val.inject_list j vargs tvl) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'.","conclusion":"val_casted_list vargs tyargs /\\\n(exists tvl : list val,\n   eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvl /\\\n   Val.inject_list j vargs tvl) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x)","proofString":"intros [CASTED [tvargs [C D]]].\nexploit external_call_mem_inject; eauto.\napply match_globalenvs_preserves_globals; eauto with compat.\nintros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto.\neapply match_envs_extcall; eauto.\neapply match_cont_extcall; eauto.\ninv MENV; extlia.\ninv MENV; extlia.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs)","proofString":"exploit external_call_mem_inject; eauto.\napply match_globalenvs_preserves_globals; eauto with compat.\nintros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto.\neapply match_envs_extcall; eauto.\neapply match_cont_extcall; eauto.\ninv MENV; extlia.\ninv MENV; extlia.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) : meminj_preserves_globals ge j.","conclusion":"meminj_preserves_globals ge j","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs)","proofString":"apply match_globalenvs_preserves_globals; eauto with compat."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) : (exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge tvargs tm t vres' m2' /\\\n   Val.inject f' vres vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped j) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach j m) tm m2' /\\\n   inject_incr j f' /\\ inject_separated j f' m tm) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'.","conclusion":"(exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge tvargs tm t vres' m2' /\\\n   Val.inject f' vres vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped j) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach j m) tm m2' /\\\n   inject_incr j f' /\\ inject_separated j f' m tm) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs)","proofString":"intros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto.\neapply match_envs_extcall; eauto.\neapply match_cont_extcall; eauto.\ninv MENV; extlia.\ninv MENV; extlia.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sbuiltin optid ef tyargs (simpl_exprlist (cenv_for f) al)) tk\n       te tle tm) t S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid vres le) m') S2'","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto.\neapply match_envs_extcall; eauto.\neapply match_cont_extcall; eauto.\ninv MENV; extlia.\ninv MENV; extlia.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto.\neapply Ple_trans; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"apply senv_preserved."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : Ple lo (Mem.nextblock m).","conclusion":"Ple lo (Mem.nextblock m)","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"inv MENV; extlia."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : Ple tlo (Mem.nextblock tm).","conclusion":"Ple tlo (Mem.nextblock tm)","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"inv MENV; extlia."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : Ple (Mem.nextblock m) (Mem.nextblock m').","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m')","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : Ple (Mem.nextblock tm) (Mem.nextblock tm').","conclusion":"Ple (Mem.nextblock tm) (Mem.nextblock tm')","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge e le m al tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_exprlist al) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : unit) (EQ : check_opttemp (cenv_for f) optid = OK x) (CASTED : val_casted_list vargs tyargs) (tvargs : list val) (C : eval_exprlist tge te tle tm (simpl_exprlist (cenv_for f) al) tyargs tvargs) (D : Val.inject_list j vargs tvargs) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) : exists S2' : state,\n  plus step2 tge (State tf (Ssequence x x0) tk te tle tm) E0 S2' /\\\n  match_states (State f s1 (Kseq s2 k) e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf (Ssequence x x0) tk te tle tm) E0 S2' /\\\n  match_states (State f s1 (Kseq s2 k) e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0)","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto with compat.\neconstructor; eauto with compat."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) : match_cont j (cenv_for f) (Kseq s2 k) (Kseq x0 tk) m lo tlo.","conclusion":"match_cont j (cenv_for f) (Kseq s2 k) (Kseq x0 tk) m lo tlo","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0)","proofString":"econstructor; eauto with compat."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kseq s k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (State f s k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (State f s k e le m) S2'","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kseq s k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts : statement) (tk0 : cont) (H1 : simpl_stmt (cenv_for f) s = OK ts) (H3 : match_cont j (cenv_for f) k tk0 m lo tlo) (H8 : compat_cenv (addr_taken_stmt s) (cenv_for f)) : exists S2' : state,\n  plus step2 tge (State tf Sskip (Kseq ts tk0) te tle tm) E0 S2' /\\\n  match_states (State f s k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sskip (Kseq ts tk0) te tle tm) E0 S2' /\\\n  match_states (State f s k e le m) S2'","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts : statement) (tk0 : cont) (H1 : simpl_stmt (cenv_for f) s = OK ts) (H3 : match_cont j (cenv_for f) k tk0 m lo tlo) (H8 : compat_cenv (addr_taken_stmt s) (cenv_for f))","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kseq s k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Scontinue tk te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Scontinue tk te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kseq s k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts : statement) (tk0 : cont) (H1 : simpl_stmt (cenv_for f) s = OK ts) (H3 : match_cont j (cenv_for f) k tk0 m lo tlo) (H8 : compat_cenv (addr_taken_stmt s) (cenv_for f)) : exists S2' : state,\n  plus step2 tge (State tf Scontinue (Kseq ts tk0) te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Scontinue (Kseq ts tk0) te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts : statement) (tk0 : cont) (H1 : simpl_stmt (cenv_for f) s = OK ts) (H3 : match_cont j (cenv_for f) k tk0 m lo tlo) (H8 : compat_cenv (addr_taken_stmt s) (cenv_for f))","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kseq s k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Sbreak tk te tle tm) E0 S2' /\\\n  match_states (State f Sbreak k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sbreak tk te tle tm) E0 S2' /\\\n  match_states (State f Sbreak k e le m) S2'","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kseq s k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts : statement) (tk0 : cont) (H1 : simpl_stmt (cenv_for f) s = OK ts) (H3 : match_cont j (cenv_for f) k tk0 m lo tlo) (H8 : compat_cenv (addr_taken_stmt s) (cenv_for f)) : exists S2' : state,\n  plus step2 tge (State tf Sbreak (Kseq ts tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sbreak k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sbreak (Kseq ts tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sbreak k e le m) S2'","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts : statement) (tk0 : cont) (H1 : simpl_stmt (cenv_for f) s = OK ts) (H3 : match_cont j (cenv_for f) k tk0 m lo tlo) (H8 : compat_cenv (addr_taken_stmt s) (cenv_for f))","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sifthenelse (simpl_expr (cenv_for f) a) x x0) tk te tle tm) E0\n    S2' /\\ match_states (State f (if b then s1 else s2) k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sifthenelse (simpl_expr (cenv_for f) a) x x0) tk te tle tm) E0\n    S2' /\\ match_states (State f (if b then s1 else s2) k e le m) S2'","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0)","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tv [A B]].\neconstructor; split.\napply plus_one.\napply step_ifthenelse with (v1 := tv) (b := b).\nauto.\nrewrite typeof_simpl_expr.\neapply bool_val_inject; eauto.\ndestruct b; econstructor; eauto with compat."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v1 tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sifthenelse (simpl_expr (cenv_for f) a) x x0) tk te tle tm) E0\n    S2' /\\ match_states (State f (if b then s1 else s2) k e le m) S2'.","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v1 tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sifthenelse (simpl_expr (cenv_for f) a) x x0) tk te tle tm) E0\n    S2' /\\ match_states (State f (if b then s1 else s2) k e le m) S2'","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0)","proofString":"intros [tv [A B]].\neconstructor; split.\napply plus_one.\napply step_ifthenelse with (v1 := tv) (b := b).\nauto.\nrewrite typeof_simpl_expr.\neapply bool_val_inject; eauto.\ndestruct b; econstructor; eauto with compat."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sifthenelse (simpl_expr (cenv_for f) a) x x0) tk te tle tm) E0\n    S2' /\\ match_states (State f (if b then s1 else s2) k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sifthenelse (simpl_expr (cenv_for f) a) x x0) tk te tle tm) E0\n    S2' /\\ match_states (State f (if b then s1 else s2) k e le m) S2'","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv)","proofString":"econstructor; split.\napply plus_one.\napply step_ifthenelse with (v1 := tv) (b := b).\nauto.\nrewrite typeof_simpl_expr.\neapply bool_val_inject; eauto.\ndestruct b; econstructor; eauto with compat."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv) : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv.","conclusion":"eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv)","proofString":"auto."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv) : bool_val tv (typeof (simpl_expr (cenv_for f) a)) tm = Some b.","conclusion":"bool_val tv (typeof (simpl_expr (cenv_for f) a)) tm = Some b","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv)","proofString":"rewrite typeof_simpl_expr.\neapply bool_val_inject; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv) : bool_val tv (typeof a) tm = Some b.","conclusion":"bool_val tv (typeof a) tm = Some b","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr ge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv\n  (VSet.union (addr_taken_expr a)\n     (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))) \n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v1 tv)","proofString":"eapply bool_val_inject; eauto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) : exists S2' : state,\n  plus step2 tge (State tf (Sloop x x0) tk te tle tm) E0 S2' /\\\n  match_states (State f s1 (Kloop1 s1 s2 k) e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf (Sloop x x0) tk te tle tm) E0 S2' /\\\n  match_states (State f s1 (Kloop1 s1 s2 k) e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0)","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto with compat.\neconstructor; eauto with compat."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0) : match_cont j (cenv_for f) (Kloop1 s1 s2 k) (Kloop1 x x0 tk) m lo tlo.","conclusion":"match_cont j (cenv_for f) (Kloop1 s1 s2 k) (Kloop1 x x0 tk) m lo tlo","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s1 = OK x) (x0 : statement) (EQ1 : simpl_stmt (cenv_for f) s2 = OK x0)","proofString":"econstructor; eauto with compat."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop1 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf ts tk te tle tm) E0 S2' /\\\n  match_states (State f s2 (Kloop2 s1 s2 k) e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf ts tk te tle tm) E0 S2' /\\\n  match_states (State f s2 (Kloop2 s1 s2 k) e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop1 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neconstructor.\ndestruct H; subst x; simpl in *; intuition congruence.\neconstructor; eauto with compat.\neconstructor; eauto with compat."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H3 : simpl_stmt (cenv_for f) s1 = OK ts1) (H5 : simpl_stmt (cenv_for f) s2 = OK ts2) (H10 : match_cont j (cenv_for f) k tk0 m lo tlo) (H11 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) : exists S2' : state,\n  plus step2 tge (State tf ts (Kloop1 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f s2 (Kloop2 s1 s2 k) e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf ts (Kloop1 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f s2 (Kloop2 s1 s2 k) e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H3 : simpl_stmt (cenv_for f) s1 = OK ts1) (H5 : simpl_stmt (cenv_for f) s2 = OK ts2) (H10 : match_cont j (cenv_for f) k tk0 m lo tlo) (H11 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f))","proofString":"econstructor; split.\napply plus_one.\neconstructor.\ndestruct H; subst x; simpl in *; intuition congruence.\neconstructor; eauto with compat.\neconstructor; eauto with compat."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H3 : simpl_stmt (cenv_for f) s1 = OK ts1) (H5 : simpl_stmt (cenv_for f) s2 = OK ts2) (H10 : match_cont j (cenv_for f) k tk0 m lo tlo) (H11 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) : ts = Sskip \\/ ts = Scontinue.","conclusion":"ts = Sskip \\/ ts = Scontinue","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H3 : simpl_stmt (cenv_for f) s1 = OK ts1) (H5 : simpl_stmt (cenv_for f) s2 = OK ts2) (H10 : match_cont j (cenv_for f) k tk0 m lo tlo) (H11 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f))","proofString":"destruct H; subst x; simpl in *; intuition congruence."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H3 : simpl_stmt (cenv_for f) s1 = OK ts1) (H5 : simpl_stmt (cenv_for f) s2 = OK ts2) (H10 : match_cont j (cenv_for f) k tk0 m lo tlo) (H11 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) : match_cont j (cenv_for f) (Kloop2 s1 s2 k) (Kloop2 ts1 ts2 tk0) m lo tlo.","conclusion":"match_cont j (cenv_for f) (Kloop2 s1 s2 k) (Kloop2 ts1 ts2 tk0) m lo tlo","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (x : statement) (H : x = Sskip \\/ x = Scontinue) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H3 : simpl_stmt (cenv_for f) s1 = OK ts1) (H5 : simpl_stmt (cenv_for f) s2 = OK ts2) (H10 : match_cont j (cenv_for f) k tk0 m lo tlo) (H11 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f))","proofString":"econstructor; eauto with compat."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop1 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Sbreak tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sbreak tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop1 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neapply step_break_loop1.\neconstructor; eauto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) : exists S2' : state,\n  plus step2 tge (State tf Sbreak (Kloop1 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sbreak (Kloop1 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f))","proofString":"econstructor; split.\napply plus_one.\neapply step_break_loop1.\neconstructor; eauto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop2 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (State f (Sloop s1 s2) k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (State f (Sloop s1 s2) k e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop2 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neapply step_skip_loop2.\neconstructor; eauto with compat.\nsimpl; rewrite H2; rewrite H4; auto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) : exists S2' : state,\n  plus step2 tge (State tf Sskip (Kloop2 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f (Sloop s1 s2) k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sskip (Kloop2 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f (Sloop s1 s2) k e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f))","proofString":"econstructor; split.\napply plus_one.\neapply step_skip_loop2.\neconstructor; eauto with compat.\nsimpl; rewrite H2; rewrite H4; auto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) : simpl_stmt (cenv_for f) (Sloop s1 s2) = OK (Sloop ts1 ts2).","conclusion":"simpl_stmt (cenv_for f) (Sloop s1 s2) = OK (Sloop ts1 ts2)","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f))","proofString":"simpl; rewrite H2; rewrite H4; auto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop2 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Sbreak tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sbreak tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kloop2 s1 s2 k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neapply step_break_loop2.\neconstructor; eauto."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f)) : exists S2' : state,\n  plus step2 tge (State tf Sbreak (Kloop2 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sbreak (Kloop2 ts1 ts2 tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (ts1 ts2 : statement) (tk0 : cont) (H2 : simpl_stmt (cenv_for f) s1 = OK ts1) (H4 : simpl_stmt (cenv_for f) s2 = OK ts2) (H9 : match_cont j (cenv_for f) k tk0 m lo tlo) (H10 : compat_cenv (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))\n  (cenv_for f))","proofString":"econstructor; split.\napply plus_one.\neapply step_break_loop2.\neconstructor; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf (Sreturn None) tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef (call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf (Sreturn None) tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef (call_cont k) m') S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"exploit match_envs_free_blocks; eauto.\nintros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : (exists tm' : mem,\n   Mem.free_list tm (blocks_of_env tge te) = Some tm' /\\ Mem.inject j m' tm') ->\nexists S2' : state,\n  plus step2 tge (State tf (Sreturn None) tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef (call_cont k) m') S2'.","conclusion":"(exists tm' : mem,\n   Mem.free_list tm (blocks_of_env tge te) = Some tm' /\\ Mem.inject j m' tm') ->\nexists S2' : state,\n  plus step2 tge (State tf (Sreturn None) tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef (call_cont k) m') S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"intros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') : exists S2' : state,\n  plus step2 tge (State tf (Sreturn None) tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef (call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf (Sreturn None) tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef (call_cont k) m') S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm')","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') : forall cenv : compilenv,\nmatch_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"forall cenv : compilenv,\nmatch_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm')","proofString":"intros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (cenv : compilenv) : match_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"match_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (cenv : compilenv)","proofString":"eapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tv [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv' [C D]].\nexploit match_envs_free_blocks; eauto.\nintros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\nmonadInv TRF; simpl.\neauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'.","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"intros [tv [A B]].\nexploit sem_cast_inject; eauto.\nintros [tv' [C D]].\nexploit match_envs_free_blocks; eauto.\nintros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\nmonadInv TRF; simpl.\neauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"exploit sem_cast_inject; eauto.\nintros [tv' [C D]].\nexploit match_envs_free_blocks; eauto.\nintros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\nmonadInv TRF; simpl.\neauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : (exists tv0 : val,\n   sem_cast tv (typeof a) (fn_return f) tm = Some tv0 /\\ Val.inject j v' tv0) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'.","conclusion":"(exists tv0 : val,\n   sem_cast tv (typeof a) (fn_return f) tm = Some tv0 /\\ Val.inject j v' tv0) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"intros [tv' [C D]].\nexploit match_envs_free_blocks; eauto.\nintros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\nmonadInv TRF; simpl.\neauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') : exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv')","proofString":"exploit match_envs_free_blocks; eauto.\nintros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\nmonadInv TRF; simpl.\neauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') : (exists tm' : mem,\n   Mem.free_list tm (blocks_of_env tge te) = Some tm' /\\ Mem.inject j m' tm') ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'.","conclusion":"(exists tm' : mem,\n   Mem.free_list tm (blocks_of_env tge te) = Some tm' /\\ Mem.inject j m' tm') ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv')","proofString":"intros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\nmonadInv TRF; simpl.\neauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') : exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sreturn (Some (simpl_expr (cenv_for f) a))) tk te tle tm) E0\n    S2' /\\ match_states (Returnstate v' (call_cont k) m') S2'","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm')","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\nmonadInv TRF; simpl.\neauto.\neconstructor; eauto.\nintros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') : forall cenv : compilenv,\nmatch_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"forall cenv : compilenv,\nmatch_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm')","proofString":"intros.\neapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (cenv : compilenv) : match_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"match_cont j cenv (call_cont k) (call_cont tk) m' \n  (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (v v' : val) (m' : mem) (H : eval_expr ge e le m a v) (H0 : sem_cast v (typeof a) (fn_return f) m = Some v') (H1 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_expr a) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) (tv' : val) (C : sem_cast tv (typeof a) (fn_return f) tm = Some tv') (D : Val.inject j v' tv') (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (cenv : compilenv)","proofString":"eapply match_cont_call_cont.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef k m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef k m') S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"exploit match_envs_free_blocks; eauto.\nintros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply match_cont_is_call_cont; eauto.\nmonadInv TRF; auto.\neconstructor; eauto.\nintros.\napply match_cont_change_cenv with (cenv_for f); auto.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : (exists tm' : mem,\n   Mem.free_list tm (blocks_of_env tge te) = Some tm' /\\ Mem.inject j m' tm') ->\nexists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef k m') S2'.","conclusion":"(exists tm' : mem,\n   Mem.free_list tm (blocks_of_env tge te) = Some tm' /\\ Mem.inject j m' tm') ->\nexists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef k m') S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"intros [tm' [P Q]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply match_cont_is_call_cont; eauto.\nmonadInv TRF; auto.\neconstructor; eauto.\nintros.\napply match_cont_change_cenv with (cenv_for f); auto.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') : exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef k m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Sskip tk te tle tm) E0 S2' /\\\n  match_states (Returnstate Vundef k m') S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm')","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neapply match_cont_is_call_cont; eauto.\nmonadInv TRF; auto.\neconstructor; eauto.\nintros.\napply match_cont_change_cenv with (cenv_for f); auto.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') : is_call_cont tk.","conclusion":"is_call_cont tk","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm')","proofString":"eapply match_cont_is_call_cont; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : match_states (Returnstate Vundef k m') (Returnstate Vundef tk tm').","conclusion":"match_states (Returnstate Vundef k m') (Returnstate Vundef tk tm')","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"econstructor; eauto.\nintros.\napply match_cont_change_cenv with (cenv_for f); auto.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : forall cenv : compilenv,\nmatch_cont j cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"forall cenv : compilenv,\nmatch_cont j cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"intros.\napply match_cont_change_cenv with (cenv_for f); auto.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) (cenv : compilenv) : match_cont j cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"match_cont j cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) (cenv : compilenv)","proofString":"apply match_cont_change_cenv with (cenv_for f); auto.\neapply match_cont_free_env; eauto."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) (cenv : compilenv) : match_cont j (cenv_for f) k tk m' (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"match_cont j (cenv_for f) k tk m' (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tm' : mem) (P : Mem.free_list tm (blocks_of_env tge te) = Some tm') (Q : Mem.inject j m' tm') (x : statement) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) (cenv : compilenv)","proofString":"eapply match_cont_free_env; eauto."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sswitch (simpl_expr (cenv_for f) a) x) tk te tle tm) E0 S2' /\\\n  match_states\n    (State f (seq_of_labeled_statement (select_switch n sl)) \n       (Kswitch k) e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sswitch (simpl_expr (cenv_for f) a) x) tk te tle tm) E0 S2' /\\\n  match_states\n    (State f (seq_of_labeled_statement (select_switch n sl)) \n       (Kswitch k) e le m) S2'","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x)","proofString":"exploit eval_simpl_expr; eauto with compat.\nintros [tv [A B]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\ninstantiate (1 := n).\nunfold sem_switch_arg in *;  destruct (classify_switch (typeof a)); try discriminate;  inv B; inv H0; auto.\neconstructor; eauto.\nerewrite simpl_seq_of_labeled_statement.\nreflexivity.\neapply simpl_select_switch; eauto.\neconstructor; eauto.\nrewrite addr_taken_seq_of_labeled_statement.\napply compat_cenv_select_switch.\neauto with compat."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) : (exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sswitch (simpl_expr (cenv_for f) a) x) tk te tle tm) E0 S2' /\\\n  match_states\n    (State f (seq_of_labeled_statement (select_switch n sl)) \n       (Kswitch k) e le m) S2'.","conclusion":"(exists tv : val,\n   eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv /\\\n   Val.inject j v tv) ->\nexists S2' : state,\n  plus step2 tge\n    (State tf (Sswitch (simpl_expr (cenv_for f) a) x) tk te tle tm) E0 S2' /\\\n  match_states\n    (State f (seq_of_labeled_statement (select_switch n sl)) \n       (Kswitch k) e le m) S2'","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x)","proofString":"intros [tv [A B]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\ninstantiate (1 := n).\nunfold sem_switch_arg in *;  destruct (classify_switch (typeof a)); try discriminate;  inv B; inv H0; auto.\neconstructor; eauto.\nerewrite simpl_seq_of_labeled_statement.\nreflexivity.\neapply simpl_select_switch; eauto.\neconstructor; eauto.\nrewrite addr_taken_seq_of_labeled_statement.\napply compat_cenv_select_switch.\neauto with compat."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : exists S2' : state,\n  plus step2 tge\n    (State tf (Sswitch (simpl_expr (cenv_for f) a) x) tk te tle tm) E0 S2' /\\\n  match_states\n    (State f (seq_of_labeled_statement (select_switch n sl)) \n       (Kswitch k) e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State tf (Sswitch (simpl_expr (cenv_for f) a) x) tk te tle tm) E0 S2' /\\\n  match_states\n    (State f (seq_of_labeled_statement (select_switch n sl)) \n       (Kswitch k) e le m) S2'","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\nrewrite typeof_simpl_expr.\ninstantiate (1 := n).\nunfold sem_switch_arg in *;  destruct (classify_switch (typeof a)); try discriminate;  inv B; inv H0; auto.\neconstructor; eauto.\nerewrite simpl_seq_of_labeled_statement.\nreflexivity.\neapply simpl_select_switch; eauto.\neconstructor; eauto.\nrewrite addr_taken_seq_of_labeled_statement.\napply compat_cenv_select_switch.\neauto with compat."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : sem_switch_arg tv (typeof a) = Some n.","conclusion":"sem_switch_arg tv (typeof a) = Some n","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"unfold sem_switch_arg in *;  destruct (classify_switch (typeof a)); try discriminate;  inv B; inv H0; auto."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : simpl_stmt (cenv_for f) (seq_of_labeled_statement (select_switch n sl)) =\nOK (seq_of_labeled_statement (select_switch n x)).","conclusion":"simpl_stmt (cenv_for f) (seq_of_labeled_statement (select_switch n sl)) =\nOK (seq_of_labeled_statement (select_switch n x))","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"erewrite simpl_seq_of_labeled_statement.\nreflexivity.\neapply simpl_select_switch; eauto."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : match_cont j (cenv_for f) (Kswitch k) (Kswitch tk) m lo tlo.","conclusion":"match_cont j (cenv_for f) (Kswitch k) (Kswitch tk) m lo tlo","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"econstructor; eauto."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : compat_cenv (addr_taken_stmt (seq_of_labeled_statement (select_switch n sl)))\n  (cenv_for f).","conclusion":"compat_cenv (addr_taken_stmt (seq_of_labeled_statement (select_switch n sl)))\n  (cenv_for f)","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"rewrite addr_taken_seq_of_labeled_statement.\napply compat_cenv_select_switch.\neauto with compat."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : compat_cenv (addr_taken_lblstmt (select_switch n sl)) (cenv_for f).","conclusion":"compat_cenv (addr_taken_lblstmt (select_switch n sl)) (cenv_for f)","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"apply compat_cenv_select_switch.\neauto with compat."},{"statement":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv) : compat_cenv (addr_taken_lblstmt sl) (cenv_for f).","conclusion":"compat_cenv (addr_taken_lblstmt sl) (cenv_for f)","hypotheses":"(f : function) (a : expr) (sl : labeled_statements) (k : cont) (e : env) (le : temp_env) (m : mem) (v : val) (n : Z) (H : eval_expr ge e le m a v) (H0 : sem_switch_arg v (typeof a) = Some n) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (VSet.union (addr_taken_expr a) (addr_taken_lblstmt sl))\n  (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : labeled_statements) (EQ : simpl_lblstmt (cenv_for f) sl = OK x) (tv : val) (A : eval_expr tge te tle tm (simpl_expr (cenv_for f) a) tv) (B : Val.inject j v tv)","proofString":"eauto with compat."},{"statement":"(f : function) (x : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (tf : function) (ts : statement) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kswitch k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf ts tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf ts tk te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'","hypotheses":"(f : function) (x : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (tf : function) (ts : statement) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kswitch k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neapply step_skip_break_switch.\ndestruct H; subst x; simpl in *; intuition congruence.\neconstructor; eauto with compat."},{"statement":"(f : function) (x : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tk0 : cont) (H2 : match_cont j (cenv_for f) k tk0 m lo tlo) : exists S2' : state,\n  plus step2 tge (State tf ts (Kswitch tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf ts (Kswitch tk0) te tle tm) E0 S2' /\\\n  match_states (State f Sskip k e le m) S2'","hypotheses":"(f : function) (x : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tk0 : cont) (H2 : match_cont j (cenv_for f) k tk0 m lo tlo)","proofString":"econstructor; split.\napply plus_one.\neapply step_skip_break_switch.\ndestruct H; subst x; simpl in *; intuition congruence.\neconstructor; eauto with compat."},{"statement":"(f : function) (x : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tk0 : cont) (H2 : match_cont j (cenv_for f) k tk0 m lo tlo) : ts = Sskip \\/ ts = Sbreak.","conclusion":"ts = Sskip \\/ ts = Sbreak","hypotheses":"(f : function) (x : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (tf : function) (ts : statement) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (TRS : simpl_stmt (cenv_for f) x = OK ts) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt x) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tk0 : cont) (H2 : match_cont j (cenv_for f) k tk0 m lo tlo)","proofString":"destruct H; subst x; simpl in *; intuition congruence."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kswitch k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf Scontinue tk te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Scontinue tk te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) (Kswitch k) tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neapply step_continue_switch.\neconstructor; eauto with compat."},{"statement":"(f : function) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tk0 : cont) (H1 : match_cont j (cenv_for f) k tk0 m lo tlo) : exists S2' : state,\n  plus step2 tge (State tf Scontinue (Kswitch tk0) te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf Scontinue (Kswitch tk0) te tle tm) E0 S2' /\\\n  match_states (State f Scontinue k e le m) S2'","hypotheses":"(f : function) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (tk0 : cont) (H1 : match_cont j (cenv_for f) k tk0 m lo tlo)","proofString":"econstructor; split.\napply plus_one.\neapply step_continue_switch.\neconstructor; eauto with compat."},{"statement":"(f : function) (lbl : label) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt s) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s = OK x) : exists S2' : state,\n  plus step2 tge (State tf (Slabel lbl x) tk te tle tm) E0 S2' /\\\n  match_states (State f s k e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf (Slabel lbl x) tk te tle tm) E0 S2' /\\\n  match_states (State f s k e le m) S2'","hypotheses":"(f : function) (lbl : label) (s : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv (addr_taken_stmt s) (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (x : statement) (EQ : simpl_stmt (cenv_for f) s = OK x)","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (State tf (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm))","proofString":"generalize TRF; intros TRF'.\nmonadInv TRF'.\nexploit (simpl_find_label j (cenv_for f) m lo tlo lbl (fn_body f) (call_cont k) x (call_cont tk)).\neauto.\neapply match_cont_call_cont.\neauto.\napply compat_cenv_for.\nrewrite H.\nintros [ts' [tk' [A [B [C D]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nsimpl.\nrewrite find_label_add_debug_params.\nrewrite find_label_store_params.\nrewrite find_label_add_debug_vars.\neexact A.\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (TRF' : transf_function f = OK tf) : exists S2' : state,\n  plus step2 tge (State tf (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (State tf (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tf : function) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (TRF : transf_function f = OK tf) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (TRF' : transf_function f = OK tf)","proofString":"monadInv TRF'.\nexploit (simpl_find_label j (cenv_for f) m lo tlo lbl (fn_body f) (call_cont k) x (call_cont tk)).\neauto.\neapply match_cont_call_cont.\neauto.\napply compat_cenv_for.\nrewrite H.\nintros [ts' [tk' [A [B [C D]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nsimpl.\nrewrite find_label_add_debug_params.\nrewrite find_label_store_params.\nrewrite find_label_add_debug_vars.\neexact A.\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : exists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"exploit (simpl_find_label j (cenv_for f) m lo tlo lbl (fn_body f) (call_cont k) x (call_cont tk)).\neauto.\neapply match_cont_call_cont.\neauto.\napply compat_cenv_for.\nrewrite H.\nintros [ts' [tk' [A [B [C D]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nsimpl.\nrewrite find_label_add_debug_params.\nrewrite find_label_store_params.\nrewrite find_label_add_debug_vars.\neexact A.\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : simpl_stmt (cenv_for f) (fn_body f) = OK x.","conclusion":"simpl_stmt (cenv_for f) (fn_body f) = OK x","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : match_cont j (cenv_for f) (call_cont k) (call_cont tk) m lo tlo.","conclusion":"match_cont j (cenv_for f) (call_cont k) (call_cont tk) m lo tlo","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"eapply match_cont_call_cont.\neauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : compat_cenv (addr_taken_stmt (fn_body f)) (cenv_for f).","conclusion":"compat_cenv (addr_taken_stmt (fn_body f)) (cenv_for f)","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"apply compat_cenv_for."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : match find_label lbl (fn_body f) (call_cont k) with\n| Some (s'0, k'0) =>\n    exists (ts' : statement) (tk' : cont),\n      find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n      compat_cenv (addr_taken_stmt s'0) (cenv_for f) /\\\n      simpl_stmt (cenv_for f) s'0 = OK ts' /\\\n      match_cont j (cenv_for f) k'0 tk' m lo tlo\n| None => find_label lbl x (call_cont tk) = None\nend ->\nexists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'.","conclusion":"match find_label lbl (fn_body f) (call_cont k) with\n| Some (s'0, k'0) =>\n    exists (ts' : statement) (tk' : cont),\n      find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n      compat_cenv (addr_taken_stmt s'0) (cenv_for f) /\\\n      simpl_stmt (cenv_for f) s'0 = OK ts' /\\\n      match_cont j (cenv_for f) k'0 tk' m lo tlo\n| None => find_label lbl x (call_cont tk) = None\nend ->\nexists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"rewrite H.\nintros [ts' [tk' [A [B [C D]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nsimpl.\nrewrite find_label_add_debug_params.\nrewrite find_label_store_params.\nrewrite find_label_add_debug_vars.\neexact A.\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) : (exists (ts' : statement) (tk' : cont),\n   find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n   compat_cenv (addr_taken_stmt s') (cenv_for f) /\\\n   simpl_stmt (cenv_for f) s' = OK ts' /\\\n   match_cont j (cenv_for f) k' tk' m lo tlo) ->\nexists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'.","conclusion":"(exists (ts' : statement) (tk' : cont),\n   find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n   compat_cenv (addr_taken_stmt s') (cenv_for f) /\\\n   simpl_stmt (cenv_for f) s' = OK ts' /\\\n   match_cont j (cenv_for f) k' tk' m lo tlo) ->\nexists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x)","proofString":"intros [ts' [tk' [A [B [C D]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\nsimpl.\nrewrite find_label_add_debug_params.\nrewrite find_label_store_params.\nrewrite find_label_add_debug_vars.\neexact A.\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) (ts' : statement) (tk' : cont) (A : find_label lbl x (call_cont tk) = Some (ts', tk')) (B : compat_cenv (addr_taken_stmt s') (cenv_for f)) (C : simpl_stmt (cenv_for f) s' = OK ts') (D : match_cont j (cenv_for f) k' tk' m lo tlo) : exists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (State\n       {|\n         fn_return := fn_return f;\n         fn_callconv := fn_callconv f;\n         fn_params := fn_params f;\n         fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n         fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n         fn_body :=\n           add_debug_params (fn_params f)\n             (store_params (cenv_for f) (fn_params f)\n                (add_debug_vars\n                   (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n       |} (Sgoto lbl) tk te tle tm) E0 S2' /\\\n  match_states (State f s' k' e le m) S2'","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (le : temp_env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tk : cont) (te : env) (tle : temp_env) (tm : mem) (j : meminj) (lo hi tlo thi : block) (x : statement) (TRF : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x))\n  |}) (MENV : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (MCONT : match_cont j (cenv_for f) k tk m lo tlo) (MINJ : Mem.inject j m tm) (COMPAT : compat_cenv VSet.empty (cenv_for f)) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Ple thi (Mem.nextblock tm)) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ : simpl_stmt (cenv_for f) (fn_body f) = OK x) (ts' : statement) (tk' : cont) (A : find_label lbl x (call_cont tk) = Some (ts', tk')) (B : compat_cenv (addr_taken_stmt s') (cenv_for f)) (C : simpl_stmt (cenv_for f) s' = OK ts') (D : match_cont j (cenv_for f) k' tk' m lo tlo)","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\nsimpl.\nrewrite find_label_add_debug_params.\nrewrite find_label_store_params.\nrewrite find_label_add_debug_vars.\neexact A.\neconstructor; eauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (le : temp_env) (m1 : mem) (H : function_entry1 ge f vargs m e le m1) (tfd : fundef) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (TRFD : (do tf <- transf_function f; OK (Internal tf)) = OK tfd) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) : exists S2' : state,\n  plus step2 tge (Callstate tfd tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e le m1) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Callstate tfd tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e le m1) S2'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (le : temp_env) (m1 : mem) (H : function_entry1 ge f vargs m e le m1) (tfd : fundef) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (TRFD : (do tf <- transf_function f; OK (Internal tf)) = OK tfd) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs)","proofString":"monadInv TRFD.\ninv H.\ngeneralize EQ; intro EQ'; monadInv EQ'.\nassert (list_norepet (var_names (fn_params f ++ fn_vars f))).\nunfold var_names.\nrewrite map_app.\nauto.\nexploit match_envs_alloc_variables; eauto.\ninstantiate (1 := cenv_for_gen (addr_taken_stmt f.(fn_body)) (fn_params f ++ fn_vars f)).\nintros.\neapply cenv_for_gen_by_value; eauto.\nrewrite VSF.mem_iff.\neexact H4.\nintros.\neapply cenv_for_gen_domain.\nrewrite VSF.mem_iff.\neexact H3.\nintros [j' [te [tm0 [A [B [C [D [E [F G]]]]]]]]].\nassert (K: list_forall2 val_casted vargs (map snd (fn_params f))).\napply val_casted_list_params.\nunfold type_of_function in FUNTY.\ncongruence.\nexploit store_params_correct.\neauto.\neapply list_norepet_append_left; eauto.\neexact K.\napply val_inject_list_incr with j'; eauto.\neexact B.\neexact C.\nintros.\napply (create_undef_temps_lifted id f).\nauto.\nintros.\ndestruct (create_undef_temps (fn_temps f))!id as [v|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nelim (l id id); auto.\nintros [tel [tm1 [P [Q [R [S T]]]]]].\nchange (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))    with (cenv_for f) in *.\ngeneralize (vars_and_temps_properties (cenv_for f) (fn_params f) (fn_vars f) (fn_temps f)).\nintros [X [Y Z]].\nauto.\nauto.\neconstructor; split.\neapply plus_left.\neconstructor.\neconstructor.\nexact Y.\nexact X.\nexact Z.\nsimpl.\neexact A.\nsimpl.\neexact Q.\nsimpl.\neapply star_trans.\neapply step_add_debug_params.\nauto.\neapply forall2_val_casted_inject; eauto.\neexact Q.\neapply star_trans.\neexact P.\neapply step_add_debug_vars.\nunfold remove_lifted; intros.\nrewrite List.filter_In in H3.\ndestruct H3.\napply negb_true_iff in H4.\neauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\neapply match_cont_invariant; eauto.\nintros.\ntransitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto.\napply compat_cenv_for.\nrewrite (bind_parameters_nextblock _ _ _ _ _ _ H2).\nextlia.\nrewrite T; extlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (le : temp_env) (m1 : mem) (H : function_entry1 ge f vargs m e le m1) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x : function) (EQ : transf_function f = OK x) : exists S2' : state,\n  plus step2 tge (Callstate (Internal x) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e le m1) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Callstate (Internal x) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e le m1) S2'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (le : temp_env) (m1 : mem) (H : function_entry1 ge f vargs m e le m1) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x : function) (EQ : transf_function f = OK x)","proofString":"inv H.\ngeneralize EQ; intro EQ'; monadInv EQ'.\nassert (list_norepet (var_names (fn_params f ++ fn_vars f))).\nunfold var_names.\nrewrite map_app.\nauto.\nexploit match_envs_alloc_variables; eauto.\ninstantiate (1 := cenv_for_gen (addr_taken_stmt f.(fn_body)) (fn_params f ++ fn_vars f)).\nintros.\neapply cenv_for_gen_by_value; eauto.\nrewrite VSF.mem_iff.\neexact H4.\nintros.\neapply cenv_for_gen_domain.\nrewrite VSF.mem_iff.\neexact H3.\nintros [j' [te [tm0 [A [B [C [D [E [F G]]]]]]]]].\nassert (K: list_forall2 val_casted vargs (map snd (fn_params f))).\napply val_casted_list_params.\nunfold type_of_function in FUNTY.\ncongruence.\nexploit store_params_correct.\neauto.\neapply list_norepet_append_left; eauto.\neexact K.\napply val_inject_list_incr with j'; eauto.\neexact B.\neexact C.\nintros.\napply (create_undef_temps_lifted id f).\nauto.\nintros.\ndestruct (create_undef_temps (fn_temps f))!id as [v|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nelim (l id id); auto.\nintros [tel [tm1 [P [Q [R [S T]]]]]].\nchange (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))    with (cenv_for f) in *.\ngeneralize (vars_and_temps_properties (cenv_for f) (fn_params f) (fn_vars f) (fn_temps f)).\nintros [X [Y Z]].\nauto.\nauto.\neconstructor; split.\neapply plus_left.\neconstructor.\neconstructor.\nexact Y.\nexact X.\nexact Z.\nsimpl.\neexact A.\nsimpl.\neexact Q.\nsimpl.\neapply star_trans.\neapply step_add_debug_params.\nauto.\neapply forall2_val_casted_inject; eauto.\neexact Q.\neapply star_trans.\neexact P.\neapply step_add_debug_vars.\nunfold remove_lifted; intros.\nrewrite List.filter_In in H3.\ndestruct H3.\napply negb_true_iff in H4.\neauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\neapply match_cont_invariant; eauto.\nintros.\ntransitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto.\napply compat_cenv_for.\nrewrite (bind_parameters_nextblock _ _ _ _ _ _ H2).\nextlia.\nrewrite T; extlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x : function) (EQ : transf_function f = OK x) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) : exists S2' : state,\n  plus step2 tge (Callstate (Internal x) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e (create_undef_temps (fn_temps f)) m1)\n    S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Callstate (Internal x) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e (create_undef_temps (fn_temps f)) m1)\n    S2'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x : function) (EQ : transf_function f = OK x) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1)","proofString":"generalize EQ; intro EQ'; monadInv EQ'.\nassert (list_norepet (var_names (fn_params f ++ fn_vars f))).\nunfold var_names.\nrewrite map_app.\nauto.\nexploit match_envs_alloc_variables; eauto.\ninstantiate (1 := cenv_for_gen (addr_taken_stmt f.(fn_body)) (fn_params f ++ fn_vars f)).\nintros.\neapply cenv_for_gen_by_value; eauto.\nrewrite VSF.mem_iff.\neexact H4.\nintros.\neapply cenv_for_gen_domain.\nrewrite VSF.mem_iff.\neexact H3.\nintros [j' [te [tm0 [A [B [C [D [E [F G]]]]]]]]].\nassert (K: list_forall2 val_casted vargs (map snd (fn_params f))).\napply val_casted_list_params.\nunfold type_of_function in FUNTY.\ncongruence.\nexploit store_params_correct.\neauto.\neapply list_norepet_append_left; eauto.\neexact K.\napply val_inject_list_incr with j'; eauto.\neexact B.\neexact C.\nintros.\napply (create_undef_temps_lifted id f).\nauto.\nintros.\ndestruct (create_undef_temps (fn_temps f))!id as [v|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nelim (l id id); auto.\nintros [tel [tm1 [P [Q [R [S T]]]]]].\nchange (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))    with (cenv_for f) in *.\ngeneralize (vars_and_temps_properties (cenv_for f) (fn_params f) (fn_vars f) (fn_temps f)).\nintros [X [Y Z]].\nauto.\nauto.\neconstructor; split.\neapply plus_left.\neconstructor.\neconstructor.\nexact Y.\nexact X.\nexact Z.\nsimpl.\neexact A.\nsimpl.\neexact Q.\nsimpl.\neapply star_trans.\neapply step_add_debug_params.\nauto.\neapply forall2_val_casted_inject; eauto.\neexact Q.\neapply star_trans.\neexact P.\neapply step_add_debug_vars.\nunfold remove_lifted; intros.\nrewrite List.filter_In in H3.\ndestruct H3.\napply negb_true_iff in H4.\neauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\neapply match_cont_invariant; eauto.\nintros.\ntransitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto.\napply compat_cenv_for.\nrewrite (bind_parameters_nextblock _ _ _ _ _ _ H2).\nextlia.\nrewrite T; extlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) : exists S2' : state,\n  plus step2 tge\n    (Callstate\n       (Internal\n          {|\n            fn_return := fn_return f;\n            fn_callconv := fn_callconv f;\n            fn_params := fn_params f;\n            fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n            fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n            fn_body :=\n              add_debug_params (fn_params f)\n                (store_params (cenv_for f) (fn_params f)\n                   (add_debug_vars\n                      (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n                      x0))\n          |}) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e (create_undef_temps (fn_temps f)) m1)\n    S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (Callstate\n       (Internal\n          {|\n            fn_return := fn_return f;\n            fn_callconv := fn_callconv f;\n            fn_params := fn_params f;\n            fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n            fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n            fn_body :=\n              add_debug_params (fn_params f)\n                (store_params (cenv_for f) (fn_params f)\n                   (add_debug_vars\n                      (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n                      x0))\n          |}) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e (create_undef_temps (fn_temps f)) m1)\n    S2'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0)","proofString":"assert (list_norepet (var_names (fn_params f ++ fn_vars f))).\nunfold var_names.\nrewrite map_app.\nauto.\nexploit match_envs_alloc_variables; eauto.\ninstantiate (1 := cenv_for_gen (addr_taken_stmt f.(fn_body)) (fn_params f ++ fn_vars f)).\nintros.\neapply cenv_for_gen_by_value; eauto.\nrewrite VSF.mem_iff.\neexact H4.\nintros.\neapply cenv_for_gen_domain.\nrewrite VSF.mem_iff.\neexact H3.\nintros [j' [te [tm0 [A [B [C [D [E [F G]]]]]]]]].\nassert (K: list_forall2 val_casted vargs (map snd (fn_params f))).\napply val_casted_list_params.\nunfold type_of_function in FUNTY.\ncongruence.\nexploit store_params_correct.\neauto.\neapply list_norepet_append_left; eauto.\neexact K.\napply val_inject_list_incr with j'; eauto.\neexact B.\neexact C.\nintros.\napply (create_undef_temps_lifted id f).\nauto.\nintros.\ndestruct (create_undef_temps (fn_temps f))!id as [v|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nelim (l id id); auto.\nintros [tel [tm1 [P [Q [R [S T]]]]]].\nchange (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))    with (cenv_for f) in *.\ngeneralize (vars_and_temps_properties (cenv_for f) (fn_params f) (fn_vars f) (fn_temps f)).\nintros [X [Y Z]].\nauto.\nauto.\neconstructor; split.\neapply plus_left.\neconstructor.\neconstructor.\nexact Y.\nexact X.\nexact Z.\nsimpl.\neexact A.\nsimpl.\neexact Q.\nsimpl.\neapply star_trans.\neapply step_add_debug_params.\nauto.\neapply forall2_val_casted_inject; eauto.\neexact Q.\neapply star_trans.\neexact P.\neapply step_add_debug_vars.\nunfold remove_lifted; intros.\nrewrite List.filter_In in H3.\ndestruct H3.\napply negb_true_iff in H4.\neauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\neapply match_cont_invariant; eauto.\nintros.\ntransitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto.\napply compat_cenv_for.\nrewrite (bind_parameters_nextblock _ _ _ _ _ _ H2).\nextlia.\nrewrite T; extlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) : list_norepet (var_names (fn_params f ++ fn_vars f)).","conclusion":"list_norepet (var_names (fn_params f ++ fn_vars f))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0)","proofString":"unfold var_names.\nrewrite map_app.\nauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) : list_norepet (map fst (fn_params f ++ fn_vars f)).","conclusion":"list_norepet (map fst (fn_params f ++ fn_vars f))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0)","proofString":"rewrite map_app.\nauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) : list_norepet (map fst (fn_params f) ++ map fst (fn_vars f)).","conclusion":"list_norepet (map fst (fn_params f) ++ map fst (fn_vars f))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0)","proofString":"auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) : exists S2' : state,\n  plus step2 tge\n    (Callstate\n       (Internal\n          {|\n            fn_return := fn_return f;\n            fn_callconv := fn_callconv f;\n            fn_params := fn_params f;\n            fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n            fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n            fn_body :=\n              add_debug_params (fn_params f)\n                (store_params (cenv_for f) (fn_params f)\n                   (add_debug_vars\n                      (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n                      x0))\n          |}) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e (create_undef_temps (fn_temps f)) m1)\n    S2'.","conclusion":"exists S2' : state,\n  plus step2 tge\n    (Callstate\n       (Internal\n          {|\n            fn_return := fn_return f;\n            fn_callconv := fn_callconv f;\n            fn_params := fn_params f;\n            fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n            fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n            fn_body :=\n              add_debug_params (fn_params f)\n                (store_params (cenv_for f) (fn_params f)\n                   (add_debug_vars\n                      (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n                      x0))\n          |}) tvargs tk tm) E0 S2' /\\\n  match_states (State f (fn_body f) k e (create_undef_temps (fn_temps f)) m1)\n    S2'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f)))","proofString":"exploit match_envs_alloc_variables; eauto.\ninstantiate (1 := cenv_for_gen (addr_taken_stmt f.(fn_body)) (fn_params f ++ fn_vars f)).\nintros.\neapply cenv_for_gen_by_value; eauto.\nrewrite VSF.mem_iff.\neexact H4.\nintros.\neapply cenv_for_gen_domain.\nrewrite VSF.mem_iff.\neexact H3.\nintros [j' [te [tm0 [A [B [C [D [E [F G]]]]]]]]].\nassert (K: list_forall2 val_casted vargs (map snd (fn_params f))).\napply val_casted_list_params.\nunfold type_of_function in FUNTY.\ncongruence.\nexploit store_params_correct.\neauto.\neapply list_norepet_append_left; eauto.\neexact K.\napply val_inject_list_incr with j'; eauto.\neexact B.\neexact C.\nintros.\napply (create_undef_temps_lifted id f).\nauto.\nintros.\ndestruct (create_undef_temps (fn_temps f))!id as [v|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nelim (l id id); auto.\nintros [tel [tm1 [P [Q [R [S T]]]]]].\nchange (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))    with (cenv_for f) in *.\ngeneralize (vars_and_temps_properties (cenv_for f) (fn_params f) (fn_vars f) (fn_temps f)).\nintros [X [Y Z]].\nauto.\nauto.\neconstructor; split.\neapply plus_left.\neconstructor.\neconstructor.\nexact Y.\nexact X.\nexact Z.\nsimpl.\neexact A.\nsimpl.\neexact Q.\nsimpl.\neapply star_trans.\neapply step_add_debug_params.\nauto.\neapply forall2_val_casted_inject; eauto.\neexact Q.\neapply star_trans.\neexact P.\neapply step_add_debug_vars.\nunfold remove_lifted; intros.\nrewrite List.filter_In in H3.\ndestruct H3.\napply negb_true_iff in H4.\neauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\neapply match_cont_invariant; eauto.\nintros.\ntransitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto.\napply compat_cenv_for.\nrewrite (bind_parameters_nextblock _ _ _ _ _ _ H2).\nextlia.\nrewrite T; extlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\ntrue -> exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\ntrue -> exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f)))","proofString":"intros.\neapply cenv_for_gen_by_value; eauto.\nrewrite VSF.mem_iff.\neexact H4."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (id : ident) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f)) (H4 : VSet.mem id\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\ntrue) : exists chunk : memory_chunk, access_mode ty = By_value chunk.","conclusion":"exists chunk : memory_chunk, access_mode ty = By_value chunk","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (id : ident) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f)) (H4 : VSet.mem id\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\ntrue)","proofString":"eapply cenv_for_gen_by_value; eauto.\nrewrite VSF.mem_iff.\neexact H4."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (id : VSet.elt) (H3 : VSet.mem id\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\ntrue) : In id (var_names (fn_params f ++ fn_vars f)).","conclusion":"In id (var_names (fn_params f ++ fn_vars f))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (id : VSet.elt) (H3 : VSet.mem id\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\ntrue)","proofString":"eapply cenv_for_gen_domain.\nrewrite VSF.mem_iff.\neexact H3."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : ~ In id (var_names (fn_params f))) : ~ In id (var_names (fn_params f)).","conclusion":"~ In id (var_names (fn_params f))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : ~ In id (var_names (fn_params f)))","proofString":"auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f))) : (create_undef_temps (fn_temps f)) ! id = None.","conclusion":"(create_undef_temps (fn_temps f)) ! id = None","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f)))","proofString":"destruct (create_undef_temps (fn_temps f))!id as [v|] eqn:?; auto.\nexploit create_undef_temps_inv; eauto.\nintros [P Q].\nelim (l id id); auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f))) (v : val) (Heqo : (create_undef_temps (fn_temps f)) ! id = Some v) : Some v = None.","conclusion":"Some v = None","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f))) (v : val) (Heqo : (create_undef_temps (fn_temps f)) ! id = Some v)","proofString":"exploit create_undef_temps_inv; eauto.\nintros [P Q].\nelim (l id id); auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f))) (v : val) (Heqo : (create_undef_temps (fn_temps f)) ! id = Some v) : v = Vundef /\\ In id (var_names (fn_temps f)) -> Some v = None.","conclusion":"v = Vundef /\\ In id (var_names (fn_temps f)) -> Some v = None","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f))) (v : val) (Heqo : (create_undef_temps (fn_temps f)) ! id = Some v)","proofString":"intros [P Q].\nelim (l id id); auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f))) (v : val) (Heqo : (create_undef_temps (fn_temps f)) ! id = Some v) (P : v = Vundef) (Q : In id (var_names (fn_temps f))) : Some v = None.","conclusion":"Some v = None","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted\n     (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f))\n     (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j'\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) e\n  (create_undef_temps (fn_temps f)) m0 (Mem.nextblock m) \n  (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted\n        (cenv_for_gen (addr_taken_stmt (fn_body f))\n           (fn_params f ++ fn_vars f)) (fn_params f ++ fn_vars f)\n        (fn_temps f))) (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty : type),\nIn (id0, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id0\n  (cenv_for_gen (addr_taken_stmt (fn_body f)) (fn_params f ++ fn_vars f)) =\nfalse -> exists b : block, te ! id0 = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (id : ident) (H3 : In id (var_names (fn_params f))) (v : val) (Heqo : (create_undef_temps (fn_temps f)) ! id = Some v) (P : v = Vundef) (Q : In id (var_names (fn_temps f)))","proofString":"elim (l id id); auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) : forall (id : positive) (ty : type),\nIn (id, ty) (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) ->\nexists b : block, te ! id = Some (b, ty).","conclusion":"forall (id : positive) (ty : type),\nIn (id, ty) (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) ->\nexists b : block, te ! id = Some (b, ty)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))))","proofString":"unfold remove_lifted; intros.\nrewrite List.filter_In in H3.\ndestruct H3.\napply negb_true_iff in H4.\neauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty)\n  (filter\n     (fun id_ty : VSet.elt * type => negb (VSet.mem (fst id_ty) (cenv_for f)))\n     (fn_params f ++ fn_vars f))) : exists b : block, te ! id = Some (b, ty).","conclusion":"exists b : block, te ! id = Some (b, ty)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty)\n  (filter\n     (fun id_ty : VSet.elt * type => negb (VSet.mem (fst id_ty) (cenv_for f)))\n     (fn_params f ++ fn_vars f)))","proofString":"rewrite List.filter_In in H3.\ndestruct H3.\napply negb_true_iff in H4.\neauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f) /\\\nnegb (VSet.mem (fst (id, ty)) (cenv_for f)) = true) : exists b : block, te ! id = Some (b, ty).","conclusion":"exists b : block, te ! id = Some (b, ty)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f) /\\\nnegb (VSet.mem (fst (id, ty)) (cenv_for f)) = true)","proofString":"destruct H3.\napply negb_true_iff in H4.\neauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f)) (H4 : negb (VSet.mem (fst (id, ty)) (cenv_for f)) = true) : exists b : block, te ! id = Some (b, ty).","conclusion":"exists b : block, te ! id = Some (b, ty)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f)) (H4 : negb (VSet.mem (fst (id, ty)) (cenv_for f)) = true)","proofString":"apply negb_true_iff in H4.\neauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f)) (H4 : VSet.mem (fst (id, ty)) (cenv_for f) = false) : exists b : block, te ! id = Some (b, ty).","conclusion":"exists b : block, te ! id = Some (b, ty)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b : block, te ! id0 = Some (b, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (id : positive) (ty : type) (H3 : In (id, ty) (fn_params f ++ fn_vars f)) (H4 : VSet.mem (fst (id, ty)) (cenv_for f) = false)","proofString":"eauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) : match_cont j' (cenv_for f) k tk m1 (Mem.nextblock m) (Mem.nextblock tm).","conclusion":"match_cont j' (cenv_for f) k tk m1 (Mem.nextblock m) (Mem.nextblock tm)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))))","proofString":"eapply match_cont_invariant; eauto.\nintros.\ntransitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) : forall (b : block) (chunk : memory_chunk) (v : val),\nj b = None ->\nPlt b (Mem.nextblock m) ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m1 b 0 = Some v.","conclusion":"forall (b : block) (chunk : memory_chunk) (v : val),\nj b = None ->\nPlt b (Mem.nextblock m) ->\nMem.load chunk m b 0 = Some v -> Mem.load chunk m1 b 0 = Some v","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))))","proofString":"intros.\ntransitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m1 b 0 = Some v.","conclusion":"Mem.load chunk m1 b 0 = Some v","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v)","proofString":"transitivity (Mem.load chunk m0 b 0).\neapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia.\neapply alloc_variables_load; eauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m1 b 0 = Mem.load chunk m0 b 0.","conclusion":"Mem.load chunk m1 b 0 = Mem.load chunk m0 b 0","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v)","proofString":"eapply bind_parameters_load; eauto.\nintros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) : forall (id : positive) (b' : block) (ty : type),\ne ! id = Some (b', ty) -> b <> b'.","conclusion":"forall (id : positive) (b' : block) (ty : type),\ne ! id = Some (b', ty) -> b <> b'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v)","proofString":"intros.\nexploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty)) : b <> b'.","conclusion":"b <> b'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty))","proofString":"exploit alloc_variables_range.\neexact H1.\neauto.\nunfold empty_env.\nrewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty)) : (PTree.empty (block * type)) ! id = Some (b', ty) \\/\nPle (Mem.nextblock m) b' /\\ Plt b' (Mem.nextblock m0) -> \nb <> b'.","conclusion":"(PTree.empty (block * type)) ! id = Some (b', ty) \\/\nPle (Mem.nextblock m) b' /\\ Plt b' (Mem.nextblock m0) -> \nb <> b'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty))","proofString":"rewrite PTree.gempty.\nintros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty)) : None = Some (b', ty) \\/ Ple (Mem.nextblock m) b' /\\ Plt b' (Mem.nextblock m0) ->\nb <> b'.","conclusion":"None = Some (b', ty) \\/ Ple (Mem.nextblock m) b' /\\ Plt b' (Mem.nextblock m0) ->\nb <> b'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty))","proofString":"intros [?|?].\ncongruence.\nred; intros; subst b'.\nextlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty)) (H7 : None = Some (b', ty)) : b <> b'.","conclusion":"b <> b'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty)) (H7 : None = Some (b', ty))","proofString":"congruence."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty)) (H7 : Ple (Mem.nextblock m) b' /\\ Plt b' (Mem.nextblock m0)) : b <> b'.","conclusion":"b <> b'","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b'0 : block) (delta : BinNums.Z),\nj' b0 = Some (b'0, delta) -> Mem.valid_block tm b'0 -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (b' : block) (ty : type) (H6 : e ! id = Some (b', ty)) (H7 : Ple (Mem.nextblock m) b' /\\ Plt b' (Mem.nextblock m0))","proofString":"red; intros; subst b'.\nextlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (ty : type) (H7 : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m0)) (H6 : e ! id = Some (b, ty)) : False.","conclusion":"False","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id0 : ident) (ty0 : type),\nIn (id0, ty0) (fn_params f ++ fn_vars f) ->\nVSet.mem id0 (cenv_for f) = false ->\nexists b0 : block, te ! id0 = Some (b0, ty0)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) (id : positive) (ty : type) (H7 : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m0)) (H6 : e ! id = Some (b, ty))","proofString":"extlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v) : Mem.load chunk m0 b 0 = Some v.","conclusion":"Mem.load chunk m0 b 0 = Some v","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b0 : block, Mem.valid_block m b0 -> j' b0 = j b0) (F : forall (b0 b' : block) (delta : BinNums.Z),\nj' b0 = Some (b', delta) -> Mem.valid_block tm b' -> j' b0 = j b0) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false ->\nexists b0 : block, te ! id = Some (b0, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) (b : block) (chunk : memory_chunk) (v : val) (H3 : j b = None) (H4 : Plt b (Mem.nextblock m)) (H5 : Mem.load chunk m b 0 = Some v)","proofString":"eapply alloc_variables_load; eauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) : compat_cenv (addr_taken_stmt (fn_body f)) (cenv_for f).","conclusion":"compat_cenv (addr_taken_stmt (fn_body f)) (cenv_for f)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))))","proofString":"apply compat_cenv_for."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) : Ple (Mem.nextblock m0) (Mem.nextblock m1).","conclusion":"Ple (Mem.nextblock m0) (Mem.nextblock m1)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))))","proofString":"rewrite (bind_parameters_nextblock _ _ _ _ _ _ H2).\nextlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) : Ple (Mem.nextblock m0) (Mem.nextblock m0).","conclusion":"Ple (Mem.nextblock m0) (Mem.nextblock m0)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))))","proofString":"extlia."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f)))) : Ple (Mem.nextblock tm0) (Mem.nextblock tm1).","conclusion":"Ple (Mem.nextblock tm0) (Mem.nextblock tm1)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 : mem) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs : list type) (tres : type) (cconv : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : type_of_function f = Tfunction targs tres cconv) (ANORM : val_casted_list vargs targs) (x0 : statement) (EQ : transf_function f =\nOK\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n    fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n    fn_body :=\n      add_debug_params (fn_params f)\n        (store_params (cenv_for f) (fn_params f)\n           (add_debug_vars\n              (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n  |}) (m0 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m0) (H2 : bind_parameters ge e m0 (fn_params f) vargs m1) (l : list_disjoint (var_names (fn_params f)) (var_names (fn_temps f))) (EQ0 : simpl_stmt (cenv_for f) (fn_body f) = OK x0) (H : list_norepet (var_names (fn_params f ++ fn_vars f))) (j' : meminj) (te : env) (tm0 : mem) (A : alloc_variables tge empty_env tm\n  (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) te tm0) (B : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m0\n  (Mem.nextblock m) (Mem.nextblock m0) te\n  (create_undef_temps\n     (add_lifted (cenv_for f) (fn_params f ++ fn_vars f) (fn_temps f)))\n  (Mem.nextblock tm) (Mem.nextblock tm0)) (C : Mem.inject j' m0 tm0) (D : inject_incr j j') (E : forall b : block, Mem.valid_block m b -> j' b = j b) (F : forall (b b' : block) (delta : BinNums.Z),\nj' b = Some (b', delta) -> Mem.valid_block tm b' -> j' b = j b) (G : forall (id : ident) (ty : type),\nIn (id, ty) (fn_params f ++ fn_vars f) ->\nVSet.mem id (cenv_for f) = false -> exists b : block, te ! id = Some (b, ty)) (K : list_forall2 val_casted vargs (map snd (fn_params f))) (tel : temp_env) (tm1 : mem) (P : star step2 tge\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (store_params (cenv_for f) (fn_params f)\n        (add_debug_vars\n           (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0)) tk te\n     tel tm0) E0\n  (State\n     {|\n       fn_return := fn_return f;\n       fn_callconv := fn_callconv f;\n       fn_params := fn_params f;\n       fn_vars := remove_lifted (cenv_for f) (fn_params f ++ fn_vars f);\n       fn_temps := add_lifted (cenv_for f) (fn_vars f) (fn_temps f);\n       fn_body :=\n         add_debug_params (fn_params f)\n           (store_params (cenv_for f) (fn_params f)\n              (add_debug_vars\n                 (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)) x0))\n     |}\n     (add_debug_vars (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f))\n        x0) tk te tel tm1)) (Q : bind_parameter_temps (fn_params f) tvargs\n  (create_undef_temps (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))) =\nSome tel) (R : Mem.inject j' m1 tm1) (S : match_envs j' (cenv_for f) e (create_undef_temps (fn_temps f)) m1\n  (Mem.nextblock m) (Mem.nextblock m0) te tel (Mem.nextblock tm)\n  (Mem.nextblock tm0)) (T : Mem.nextblock tm1 = Mem.nextblock tm0) (X : list_norepet (var_names (fn_params f))) (Y : list_norepet\n  (var_names (remove_lifted (cenv_for f) (fn_params f ++ fn_vars f)))) (Z : list_disjoint (var_names (fn_params f))\n  (var_names (add_lifted (cenv_for f) (fn_vars f) (fn_temps f))))","proofString":"rewrite T; extlia."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tfd : fundef) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (TRFD : OK (External ef targs tres cconv) = OK tfd) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : Tfunction targs tres cconv = Tfunction targs0 tres0 cconv0) (ANORM : val_casted_list vargs targs0) : exists S2' : state,\n  plus step2 tge (Callstate tfd tvargs tk tm) t S2' /\\\n  match_states (Returnstate vres k m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Callstate tfd tvargs tk tm) t S2' /\\\n  match_states (Returnstate vres k m') S2'","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tfd : fundef) (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (TRFD : OK (External ef targs tres cconv) = OK tfd) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : Tfunction targs tres cconv = Tfunction targs0 tres0 cconv0) (ANORM : val_casted_list vargs targs0)","proofString":"monadInv TRFD.\ninv FUNTY.\nexploit external_call_mem_inject; eauto.\napply match_globalenvs_preserves_globals.\neapply match_cont_globalenv.\neexact (MCONT VSet.empty).\nintros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\nintros.\napply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).\neapply match_cont_extcall; eauto.\nextlia.\nextlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : Tfunction targs tres cconv = Tfunction targs0 tres0 cconv0) (ANORM : val_casted_list vargs targs0) : exists S2' : state,\n  plus step2 tge (Callstate (External ef targs tres cconv) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Callstate (External ef targs tres cconv) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (FUNTY : Tfunction targs tres cconv = Tfunction targs0 tres0 cconv0) (ANORM : val_casted_list vargs targs0)","proofString":"inv FUNTY.\nexploit external_call_mem_inject; eauto.\napply match_globalenvs_preserves_globals.\neapply match_cont_globalenv.\neexact (MCONT VSet.empty).\nintros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\nintros.\napply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).\neapply match_cont_extcall; eauto.\nextlia.\nextlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) : exists S2' : state,\n  plus step2 tge (Callstate (External ef targs0 tres0 cconv0) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Callstate (External ef targs0 tres0 cconv0) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0)","proofString":"exploit external_call_mem_inject; eauto.\napply match_globalenvs_preserves_globals.\neapply match_cont_globalenv.\neexact (MCONT VSet.empty).\nintros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\nintros.\napply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).\neapply match_cont_extcall; eauto.\nextlia.\nextlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) : meminj_preserves_globals ge j.","conclusion":"meminj_preserves_globals ge j","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0)","proofString":"apply match_globalenvs_preserves_globals.\neapply match_cont_globalenv.\neexact (MCONT VSet.empty)."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) : exists bound : block, match_globalenvs j bound.","conclusion":"exists bound : block, match_globalenvs j bound","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0)","proofString":"eapply match_cont_globalenv.\neexact (MCONT VSet.empty)."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) : (exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge tvargs tm t vres' m2' /\\\n   Val.inject f' vres vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped j) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach j m) tm m2' /\\\n   inject_incr j f' /\\ inject_separated j f' m tm) ->\nexists S2' : state,\n  plus step2 tge (Callstate (External ef targs0 tres0 cconv0) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'.","conclusion":"(exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge tvargs tm t vres' m2' /\\\n   Val.inject f' vres vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped j) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach j m) tm m2' /\\\n   inject_incr j f' /\\ inject_separated j f' m tm) ->\nexists S2' : state,\n  plus step2 tge (Callstate (External ef targs0 tres0 cconv0) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0)","proofString":"intros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\nintros.\napply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).\neapply match_cont_extcall; eauto.\nextlia.\nextlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : exists S2' : state,\n  plus step2 tge (Callstate (External ef targs0 tres0 cconv0) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Callstate (External ef targs0 tres0 cconv0) tvargs tk tm) t\n    S2' /\\ match_states (Returnstate vres k m') S2'","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\nintros.\napply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).\neapply match_cont_extcall; eauto.\nextlia.\nextlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"apply senv_preserved."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) : forall cenv : compilenv,\nmatch_cont j' cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"forall cenv : compilenv,\nmatch_cont j' cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm)","proofString":"intros.\napply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).\neapply match_cont_extcall; eauto.\nextlia.\nextlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv) : match_cont j' cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm').","conclusion":"match_cont j' cenv k tk m' (Mem.nextblock m') (Mem.nextblock tm')","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv)","proofString":"apply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).\neapply match_cont_extcall; eauto.\nextlia.\nextlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv) : match_cont j' cenv k tk m' (Mem.nextblock m) (Mem.nextblock tm).","conclusion":"match_cont j' cenv k tk m' (Mem.nextblock m) (Mem.nextblock tm)","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv)","proofString":"eapply match_cont_extcall; eauto.\nextlia.\nextlia."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv) : Ple (Mem.nextblock m) (Mem.nextblock m).","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m)","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv)","proofString":"extlia."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv) : Ple (Mem.nextblock tm) (Mem.nextblock tm).","conclusion":"Ple (Mem.nextblock tm) (Mem.nextblock tm)","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv)","proofString":"extlia."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv) : Ple (Mem.nextblock m) (Mem.nextblock m').","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m')","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv)","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv) : Ple (Mem.nextblock tm) (Mem.nextblock tm').","conclusion":"Ple (Mem.nextblock tm) (Mem.nextblock tm')","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tvargs : list val) (tk : cont) (tm : Mem.mem') (j : meminj) (targs0 : list type) (tres0 : type) (cconv0 : calling_convention) (MCONT : forall cenv0 : compilenv,\nmatch_cont j cenv0 k tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (AINJ : Val.inject_list j vargs tvargs) (ANORM : val_casted_list vargs targs0) (j' : meminj) (tvres : val) (tm' : mem) (P : external_call ef ge tvargs tm t tvres tm') (Q : Val.inject j' vres tvres) (R : Mem.inject j' m' tm') (S : Mem.unchanged_on (loc_unmapped j) m m') (T : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (U : inject_incr j j') (V : inject_separated j j' m tm) (cenv : compilenv)","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv (Kcall optid f e le k) tk m (Mem.nextblock m)\n  (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv) : exists S2' : state,\n  plus step2 tge (Returnstate tv tk tm) E0 S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid v le) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Returnstate tv tk tm) E0 S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid v le) m) S2'","hypotheses":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv (Kcall optid f e le k) tk m (Mem.nextblock m)\n  (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv)","proofString":"specialize (MCONT (cenv_for f)).\ninv MCONT.\neconstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto."},{"statement":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : match_cont j (cenv_for f) (Kcall optid f e le k) tk m \n  (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv) : exists S2' : state,\n  plus step2 tge (Returnstate tv tk tm) E0 S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid v le) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Returnstate tv tk tm) E0 S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid v le) m) S2'","hypotheses":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : match_cont j (cenv_for f) (Kcall optid f e le k) tk m \n  (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv)","proofString":"inv MCONT.\neconstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto."},{"statement":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv) (tfn : function) (te : env) (tle : temp_env) (tk0 : cont) (hi thi lo tlo : block) (x : unit) (H4 : transf_function f = OK tfn) (H6 : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (H11 : match_cont j (cenv_for f) k tk0 m lo tlo) (H12 : check_opttemp (cenv_for f) optid = OK x) (H13 : Ple hi (Mem.nextblock m)) (H14 : Ple thi (Mem.nextblock tm)) : exists S2' : state,\n  plus step2 tge (Returnstate tv (Kcall optid tfn te tle tk0) tm) E0 S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid v le) m) S2'.","conclusion":"exists S2' : state,\n  plus step2 tge (Returnstate tv (Kcall optid tfn te tle tk0) tm) E0 S2' /\\\n  match_states (State f Sskip k e (set_opttemp optid v le) m) S2'","hypotheses":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv) (tfn : function) (te : env) (tle : temp_env) (tk0 : cont) (hi thi lo tlo : block) (x : unit) (H4 : transf_function f = OK tfn) (H6 : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (H11 : match_cont j (cenv_for f) k tk0 m lo tlo) (H12 : check_opttemp (cenv_for f) optid = OK x) (H13 : Ple hi (Mem.nextblock m)) (H14 : Ple thi (Mem.nextblock tm))","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto with compat.\neapply match_envs_set_opttemp; eauto."},{"statement":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv) (tfn : function) (te : env) (tle : temp_env) (tk0 : cont) (hi thi lo tlo : block) (x : unit) (H4 : transf_function f = OK tfn) (H6 : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (H11 : match_cont j (cenv_for f) k tk0 m lo tlo) (H12 : check_opttemp (cenv_for f) optid = OK x) (H13 : Ple hi (Mem.nextblock m)) (H14 : Ple thi (Mem.nextblock tm)) : match_envs j (cenv_for f) e (set_opttemp optid v le) m lo hi te\n  (set_opttemp optid tv tle) tlo thi.","conclusion":"match_envs j (cenv_for f) e (set_opttemp optid v le) m lo hi te\n  (set_opttemp optid tv tle) tlo thi","hypotheses":"(v : val) (optid : option ident) (f : function) (e : env) (le : temp_env) (k : cont) (m : mem) (tv : val) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j v tv) (tfn : function) (te : env) (tle : temp_env) (tk0 : cont) (hi thi lo tlo : block) (x : unit) (H4 : transf_function f = OK tfn) (H6 : match_envs j (cenv_for f) e le m lo hi te tle tlo thi) (H11 : match_cont j (cenv_for f) k tk0 m lo tlo) (H12 : check_opttemp (cenv_for f) optid = OK x) (H13 : Ple hi (Mem.nextblock m)) (H14 : Ple thi (Mem.nextblock tm))","proofString":"eapply match_envs_set_opttemp; eauto."},{"statement":"(S : state) (H : initial_state prog S) : exists R : state, initial_state tprog R /\\ match_states S R.","conclusion":"exists R : state, initial_state tprog R /\\ match_states S R","hypotheses":"(S : state) (H : initial_state prog S)","proofString":"inv H.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\neconstructor; split.\neconstructor.\neapply (Genv.init_mem_transf_partial (proj1 TRANSF)).\neauto.\nreplace (prog_main tprog) with (prog_main prog).\ninstantiate (1 := b).\nrewrite <- H1.\napply symbols_preserved.\ngeneralize (match_program_main (proj1 TRANSF)).\nsimpl; auto.\neauto.\nrewrite <- H3; apply type_of_fundef_preserved; auto.\neconstructor; eauto.\nintros.\ninstantiate (1 := Mem.flat_inj (Mem.nextblock m0)).\neconstructor.\ninstantiate (1 := Mem.nextblock m0).\nconstructor; intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nunfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); inv H.\nauto.\neapply Genv.find_symbol_not_fresh; eauto.\neapply Genv.find_funct_ptr_not_fresh; eauto.\neapply Genv.find_var_info_not_fresh; eauto.\nextlia.\nextlia.\neapply Genv.initmem_inject; eauto.\nconstructor."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"generalize (match_program_main (proj1 TRANSF)).\nsimpl; auto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : AST.prog_main tprog = AST.prog_main prog -> prog_main prog = prog_main tprog.","conclusion":"AST.prog_main tprog = AST.prog_main prog -> prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"simpl; auto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) : match_cont (Mem.flat_inj (Mem.nextblock m0)) cenv Kstop Kstop m0\n  (Mem.nextblock m0) (Mem.nextblock m0).","conclusion":"match_cont (Mem.flat_inj (Mem.nextblock m0)) cenv Kstop Kstop m0\n  (Mem.nextblock m0) (Mem.nextblock m0)","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv)","proofString":"econstructor.\ninstantiate (1 := Mem.nextblock m0).\nconstructor; intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nunfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); inv H.\nauto.\neapply Genv.find_symbol_not_fresh; eauto.\neapply Genv.find_funct_ptr_not_fresh; eauto.\neapply Genv.find_var_info_not_fresh; eauto.\nextlia.\nextlia."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) : match_globalenvs (Mem.flat_inj (Mem.nextblock m0)) (Mem.nextblock m0).","conclusion":"match_globalenvs (Mem.flat_inj (Mem.nextblock m0)) (Mem.nextblock m0)","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv)","proofString":"constructor; intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nunfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); inv H.\nauto.\neapply Genv.find_symbol_not_fresh; eauto.\neapply Genv.find_funct_ptr_not_fresh; eauto.\neapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : positive) (H : Plt b0 (Mem.nextblock m0)) : Mem.flat_inj (Mem.nextblock m0) b0 = Some (b0, 0).","conclusion":"Mem.flat_inj (Mem.nextblock m0) b0 = Some (b0, 0)","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : positive) (H : Plt b0 (Mem.nextblock m0))","proofString":"unfold Mem.flat_inj.\napply pred_dec_true; auto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : positive) (H : Plt b0 (Mem.nextblock m0)) : (if plt b0 (Mem.nextblock m0) then Some (b0, 0) else None) = Some (b0, 0).","conclusion":"(if plt b0 (Mem.nextblock m0) then Some (b0, 0) else None) = Some (b0, 0)","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : positive) (H : Plt b0 (Mem.nextblock m0))","proofString":"apply pred_dec_true; auto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b1 b2 : block) (delta : Z) (H : Mem.flat_inj (Mem.nextblock m0) b1 = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b1 b2 : block) (delta : Z) (H : Mem.flat_inj (Mem.nextblock m0) b1 = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0))","proofString":"unfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); inv H.\nauto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b1 b2 : block) (delta : Z) (H : (if plt b1 (Mem.nextblock m0) then Some (b1, 0) else None) = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b1 b2 : block) (delta : Z) (H : (if plt b1 (Mem.nextblock m0) then Some (b1, 0) else None) = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0))","proofString":"destruct (plt b1 (Mem.nextblock m0)); inv H.\nauto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b2 : block) (p H4 : Plt b2 (Mem.nextblock m0)) : b2 = b2.","conclusion":"b2 = b2","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b2 : block) (p H4 : Plt b2 (Mem.nextblock m0))","proofString":"auto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0)","proofString":"eapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : block) (fd : fundef) (H : Genv.find_funct_ptr ge b0 = Some fd) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : block) (fd : fundef) (H : Genv.find_funct_ptr ge b0 = Some fd)","proofString":"eapply Genv.find_funct_ptr_not_fresh; eauto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : block) (gv : globvar type) (H : Genv.find_var_info ge b0 = Some gv) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (cenv : compilenv) (b0 : block) (gv : globvar type) (H : Genv.find_var_info ge b0 = Some gv)","proofString":"eapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : val_casted_list nil nil.","conclusion":"val_casted_list nil nil","hypotheses":"(b : block) (f : Ctypes.fundef function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"constructor."},{"statement":"(S R : state) (r : int) (H : match_states S R) (H0 : final_state S r) : final_state R r.","conclusion":"final_state R r","hypotheses":"(S R : state) (r : int) (H : match_states S R) (H0 : final_state S r)","proofString":"inv H0.\ninv H.\nspecialize (MCONT VSet.empty).\ninv MCONT.\ninv RINJ.\nconstructor."},{"statement":"(R : state) (r : int) (m : mem) (H : match_states (Returnstate (Vint r) Kstop m) R) : final_state R r.","conclusion":"final_state R r","hypotheses":"(R : state) (r : int) (m : mem) (H : match_states (Returnstate (Vint r) Kstop m) R)","proofString":"inv H.\nspecialize (MCONT VSet.empty).\ninv MCONT.\ninv RINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv Kstop tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j (Vint r) tv) : final_state (Returnstate tv tk tm) r.","conclusion":"final_state (Returnstate tv tk tm) r","hypotheses":"(r : int) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : forall cenv : compilenv,\nmatch_cont j cenv Kstop tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j (Vint r) tv)","proofString":"specialize (MCONT VSet.empty).\ninv MCONT.\ninv RINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : match_cont j VSet.empty Kstop tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j (Vint r) tv) : final_state (Returnstate tv tk tm) r.","conclusion":"final_state (Returnstate tv tk tm) r","hypotheses":"(r : int) (m : mem) (tv : val) (tk : cont) (tm : Mem.mem') (j : meminj) (MCONT : match_cont j VSet.empty Kstop tk m (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j (Vint r) tv)","proofString":"inv MCONT.\ninv RINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j (Vint r) tv) (hi : block) (H : match_globalenvs j hi) (H0 : Ple hi (Mem.nextblock m)) (H1 : Ple hi (Mem.nextblock tm)) : final_state (Returnstate tv Kstop tm) r.","conclusion":"final_state (Returnstate tv Kstop tm) r","hypotheses":"(r : int) (m : mem) (tv : val) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (RINJ : Val.inject j (Vint r) tv) (hi : block) (H : match_globalenvs j hi) (H0 : Ple hi (Mem.nextblock m)) (H1 : Ple hi (Mem.nextblock tm))","proofString":"inv RINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (hi : block) (H : match_globalenvs j hi) (H0 : Ple hi (Mem.nextblock m)) (H1 : Ple hi (Mem.nextblock tm)) : final_state (Returnstate (Vint r) Kstop tm) r.","conclusion":"final_state (Returnstate (Vint r) Kstop tm) r","hypotheses":"(r : int) (m : mem) (tm : Mem.mem') (j : meminj) (MINJ : Mem.inject j m tm) (hi : block) (H : match_globalenvs j hi) (H0 : Ple hi (Mem.nextblock m)) (H1 : Ple hi (Mem.nextblock tm))","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics2 tprog)) id =\nSenv.public_symbol (symbolenv (semantics1 prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics2 tprog)) id =\nSenv.public_symbol (symbolenv (semantics1 prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}