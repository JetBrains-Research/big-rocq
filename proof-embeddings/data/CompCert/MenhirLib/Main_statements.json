{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/MenhirLib/Main.v","fileSamples":[{"statement":"(safe : safe_validator () = true) (init : initstate) (log_n_steps : nat) (word : list token) (buffer_end : buffer) (H : complete_validator () = true) (tree : parse_tree (NT (start_nt init)) word) : match parse safe init log_n_steps (word ++ buffer_end) with\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size tree\n| Parsed_pr sem_res buffer_end_res =>\n    sem_res = pt_sem tree /\\\n    buffer_end_res = buffer_end /\\ pt_size tree <= 2 ^ log_n_steps\nend.","proofString":"now apply Complete.parse_complete, Complete.Valid.complete_is_validator."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) : pt_sem tree1 = pt_sem tree2.","proofString":"pose (buf_end := cofix buf_end := (tok :: buf_end)%buf).\nassert (Hcomp1 := parse_complete Hsafe init (pt_size tree1) word buf_end                                   Hcomp tree1).\nassert (Hcomp2 := parse_complete Hsafe init (pt_size tree1) word buf_end                                   Hcomp tree2).\ndestruct parse.\ndestruct Hcomp1.\nexfalso.\neapply PeanoNat.Nat.lt_irrefl.\netransitivity; [|apply Hcomp1].\neapply Nat.pow_gt_lin_r.\nconstructor.\ndestruct Hcomp1 as [-> _], Hcomp2 as [-> _].\nreflexivity."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) : pt_sem tree1 = pt_sem tree2.","proofString":"assert (Hcomp1 := parse_complete Hsafe init (pt_size tree1) word buf_end                                   Hcomp tree1).\nassert (Hcomp2 := parse_complete Hsafe init (pt_size tree1) word buf_end                                   Hcomp tree2).\ndestruct parse.\ndestruct Hcomp1.\nexfalso.\neapply PeanoNat.Nat.lt_irrefl.\netransitivity; [|apply Hcomp1].\neapply Nat.pow_gt_lin_r.\nconstructor.\ndestruct Hcomp1 as [-> _], Hcomp2 as [-> _].\nreflexivity."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (Hcomp1 : match parse Hsafe init (pt_size tree1) (word ++ buf_end) with\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ pt_size tree1 < pt_size tree1\n| Parsed_pr sem_res buffer_end_res =>\n    sem_res = pt_sem tree1 /\\\n    buffer_end_res = buf_end /\\ pt_size tree1 <= 2 ^ pt_size tree1\nend) : pt_sem tree1 = pt_sem tree2.","proofString":"assert (Hcomp2 := parse_complete Hsafe init (pt_size tree1) word buf_end                                   Hcomp tree2).\ndestruct parse.\ndestruct Hcomp1.\nexfalso.\neapply PeanoNat.Nat.lt_irrefl.\netransitivity; [|apply Hcomp1].\neapply Nat.pow_gt_lin_r.\nconstructor.\ndestruct Hcomp1 as [-> _], Hcomp2 as [-> _].\nreflexivity."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (Hcomp1 : match parse Hsafe init (pt_size tree1) (word ++ buf_end) with\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ pt_size tree1 < pt_size tree1\n| Parsed_pr sem_res buffer_end_res =>\n    sem_res = pt_sem tree1 /\\\n    buffer_end_res = buf_end /\\ pt_size tree1 <= 2 ^ pt_size tree1\nend) (Hcomp2 : match parse Hsafe init (pt_size tree1) (word ++ buf_end) with\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ pt_size tree1 < pt_size tree2\n| Parsed_pr sem_res buffer_end_res =>\n    sem_res = pt_sem tree2 /\\\n    buffer_end_res = buf_end /\\ pt_size tree2 <= 2 ^ pt_size tree1\nend) : pt_sem tree1 = pt_sem tree2.","proofString":"destruct parse.\ndestruct Hcomp1.\nexfalso.\neapply PeanoNat.Nat.lt_irrefl.\netransitivity; [|apply Hcomp1].\neapply Nat.pow_gt_lin_r.\nconstructor.\ndestruct Hcomp1 as [-> _], Hcomp2 as [-> _].\nreflexivity."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (s : state) (t : token) (Hcomp1 Hcomp2 : False) : pt_sem tree1 = pt_sem tree2.","proofString":"destruct Hcomp1."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (Hcomp1 : 2 ^ pt_size tree1 < pt_size tree1) (Hcomp2 : 2 ^ pt_size tree1 < pt_size tree2) : pt_sem tree1 = pt_sem tree2.","proofString":"exfalso.\neapply PeanoNat.Nat.lt_irrefl.\netransitivity; [|apply Hcomp1].\neapply Nat.pow_gt_lin_r.\nconstructor."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (Hcomp1 : 2 ^ pt_size tree1 < pt_size tree1) (Hcomp2 : 2 ^ pt_size tree1 < pt_size tree2) : False.","proofString":"eapply PeanoNat.Nat.lt_irrefl.\netransitivity; [|apply Hcomp1].\neapply Nat.pow_gt_lin_r.\nconstructor."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (Hcomp1 : 2 ^ pt_size tree1 < pt_size tree1) (Hcomp2 : 2 ^ pt_size tree1 < pt_size tree2) : pt_size tree1 < 2 ^ pt_size tree1.","proofString":"eapply Nat.pow_gt_lin_r.\nconstructor."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (Hcomp1 : 2 ^ pt_size tree1 < pt_size tree1) (Hcomp2 : 2 ^ pt_size tree1 < pt_size tree2) : 1 < 2.","proofString":"constructor."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (s : symbol_semantic_type (NT (start_nt init))) (b : buffer) (Hcomp1 : s = pt_sem tree1 /\\ b = buf_end /\\ pt_size tree1 <= 2 ^ pt_size tree1) (Hcomp2 : s = pt_sem tree2 /\\ b = buf_end /\\ pt_size tree2 <= 2 ^ pt_size tree1) : pt_sem tree1 = pt_sem tree2.","proofString":"destruct Hcomp1 as [-> _], Hcomp2 as [-> _].\nreflexivity."},{"statement":"(Hsafe : safe_validator () = true) (Hcomp : complete_validator () = true) (tok : token) (init : initstate) (word : list token) (tree1 tree2 : parse_tree (NT (start_nt init)) word) (buf_end : buffer) (b : buffer) : pt_sem tree2 = pt_sem tree2.","proofString":"reflexivity."}]}