{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/imm/ImmFair.v","fileSamples":[{"statement":"(SCpL : sc_per_loc G) : fsupp (co G)＊.","conclusion":"fsupp (co G)＊","hypotheses":"(SCpL : sc_per_loc G)","proofString":"apply fsupp_ct_rt.\nrewrite ct_of_trans; [| by apply WF].\napply FAIR."},{"statement":"(SCpL : sc_per_loc G) : fsupp (co G)⁺.","conclusion":"fsupp (co G)⁺","hypotheses":"(SCpL : sc_per_loc G)","proofString":"rewrite ct_of_trans; [| by apply WF].\napply FAIR."},{"statement":"(SCpL : sc_per_loc G) : fsupp (co G).","conclusion":"fsupp (co G)","hypotheses":"(SCpL : sc_per_loc G)","proofString":"apply FAIR."},{"statement":"(SCpL : sc_per_loc G) : (rf G ⨾ sb G ∩ same_loc (lab G))⁺ ⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"(rf G ⨾ sb G ∩ same_loc (lab G))⁺ ⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G)","proofString":"rewrite ctEE.\napply inclusion_bunion_l.\nintros i _.\ninduction i.\nsimpl.\napply seq_mori; basic_solver.\nrewrite pow_S_end.\nrewrite IHi.\narewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\nrewrite wf_rfD; basic_solver.\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) : (⋃n, (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S n))\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"(⋃n, (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S n))\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G)","proofString":"apply inclusion_bunion_l.\nintros i _.\ninduction i.\nsimpl.\napply seq_mori; basic_solver.\nrewrite pow_S_end.\nrewrite IHi.\narewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\nrewrite wf_rfD; basic_solver.\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) : forall x : nat,\nTrue ->\n(rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S x)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"forall x : nat,\nTrue ->\n(rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S x)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G)","proofString":"intros i _.\ninduction i.\nsimpl.\napply seq_mori; basic_solver.\nrewrite pow_S_end.\nrewrite IHi.\narewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\nrewrite wf_rfD; basic_solver.\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"(rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G) (i : nat)","proofString":"induction i.\nsimpl.\napply seq_mori; basic_solver.\nrewrite pow_S_end.\nrewrite IHi.\narewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\nrewrite wf_rfD; basic_solver.\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ 1\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"(rf G ⨾ sb G ∩ same_loc (lab G)) ^^ 1\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G)","proofString":"simpl.\napply seq_mori; basic_solver."},{"statement":"(SCpL : sc_per_loc G) : ⦗fun _ : actid => True⦘ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"⦗fun _ : actid => True⦘ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G)","proofString":"apply seq_mori; basic_solver."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S (S i))\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"(rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S (S i))\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"rewrite pow_S_end.\nrewrite IHi.\narewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\nrewrite wf_rfD; basic_solver.\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i) ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"(rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i) ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"rewrite IHi.\narewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\nrewrite wf_rfD; basic_solver.\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : ((co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"((co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"arewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\nrewrite wf_rfD; basic_solver.\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : rf G ≡ ⦗W⦘ ⨾ rf G.","conclusion":"rf G ≡ ⦗W⦘ ⨾ rf G","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"rewrite wf_rfD; basic_solver."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : (co G)＊\n⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G).","conclusion":"(co G)＊\n⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"hahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ (co G)＊.","conclusion":"(co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ (co G)＊","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"etransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ (co G)⁺.","conclusion":"(co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ (co G)⁺","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"rewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ (co G)＊ ⨾ co G.","conclusion":"(co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ (co G)＊ ⨾ co G","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"hahn_frame_l.\napply rf_sb_loc_w_in_co; auto."},{"statement":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G)) : rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ co G.","conclusion":"rf G ⨾ sb G ∩ same_loc (lab G) ⨾ ⦗W⦘ ⊆ co G","hypotheses":"(SCpL : sc_per_loc G) (i : nat) (IHi : (rf G ⨾ sb G ∩ same_loc (lab G)) ^^ (S i)\n⊆ (co G)＊ ⨾ rf G ⨾ sb G ∩ same_loc (lab G))","proofString":"apply rf_sb_loc_w_in_co; auto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s) : ⦗s⦘ ⨾ r⁺ ⊆ (⦗s⦘ ⨾ r)⁺.","conclusion":"⦗s⦘ ⨾ r⁺ ⊆ (⦗s⦘ ⨾ r)⁺","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s)","proofString":"erewrite domb_rewrite with (r := r) at 1; eauto.\nrewrite ct_rotl.\nrewrite <- seqA.\nseq_rewrite <- ct_begin.\nrewrite inclusion_seq_eqv_r.\nbasic_solver."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s) : ⦗s⦘ ⨾ (r ⨾ ⦗s⦘)⁺ ⊆ (⦗s⦘ ⨾ r)⁺.","conclusion":"⦗s⦘ ⨾ (r ⨾ ⦗s⦘)⁺ ⊆ (⦗s⦘ ⨾ r)⁺","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s)","proofString":"rewrite ct_rotl.\nrewrite <- seqA.\nseq_rewrite <- ct_begin.\nrewrite inclusion_seq_eqv_r.\nbasic_solver."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s) : ⦗s⦘ ⨾ r ⨾ (⦗s⦘ ⨾ r)＊ ⨾ ⦗s⦘ ⊆ (⦗s⦘ ⨾ r)⁺.","conclusion":"⦗s⦘ ⨾ r ⨾ (⦗s⦘ ⨾ r)＊ ⨾ ⦗s⦘ ⊆ (⦗s⦘ ⨾ r)⁺","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s)","proofString":"rewrite <- seqA.\nseq_rewrite <- ct_begin.\nrewrite inclusion_seq_eqv_r.\nbasic_solver."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s) : (⦗s⦘ ⨾ r) ⨾ (⦗s⦘ ⨾ r)＊ ⨾ ⦗s⦘ ⊆ (⦗s⦘ ⨾ r)⁺.","conclusion":"(⦗s⦘ ⨾ r) ⨾ (⦗s⦘ ⨾ r)＊ ⨾ ⦗s⦘ ⊆ (⦗s⦘ ⨾ r)⁺","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s)","proofString":"seq_rewrite <- ct_begin.\nrewrite inclusion_seq_eqv_r.\nbasic_solver."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s) : (⦗s⦘ ⨾ r)⁺ ⨾ ⦗s⦘ ⊆ (⦗s⦘ ⨾ r)⁺.","conclusion":"(⦗s⦘ ⨾ r)⁺ ⨾ ⦗s⦘ ⊆ (⦗s⦘ ⨾ r)⁺","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s)","proofString":"rewrite inclusion_seq_eqv_r.\nbasic_solver."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s) : (⦗s⦘ ⨾ r)⁺ ⊆ (⦗s⦘ ⨾ r)⁺.","conclusion":"(⦗s⦘ ⨾ r)⁺ ⊆ (⦗s⦘ ⨾ r)⁺","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (DOMB_S : domb r s)","proofString":"basic_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) : Basics.flip inclusion (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar G sc)⁺)\n  sc.","conclusion":"Basics.flip inclusion (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar G sc)⁺)\n  sc","hypotheses":"(IMM_FAIR : imm_s_fair G sc)","proofString":"red.\nrewrite <- ct_step.\nunfold ar.\ndo 2 rewrite <- inclusion_union_r1.\napply doma_helper.\ninversion WFSC.\nrewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) : sc ⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar G sc)⁺.","conclusion":"sc ⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar G sc)⁺","hypotheses":"(IMM_FAIR : imm_s_fair G sc)","proofString":"rewrite <- ct_step.\nunfold ar.\ndo 2 rewrite <- inclusion_union_r1.\napply doma_helper.\ninversion WFSC.\nrewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) : sc ⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ar G sc.","conclusion":"sc ⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ar G sc","hypotheses":"(IMM_FAIR : imm_s_fair G sc)","proofString":"unfold ar.\ndo 2 rewrite <- inclusion_union_r1.\napply doma_helper.\ninversion WFSC.\nrewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) : sc\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ (sc ∪ rfe G ∪ imm_s_ppo.ar_int G).","conclusion":"sc\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ (sc ∪ rfe G ∪ imm_s_ppo.ar_int G)","hypotheses":"(IMM_FAIR : imm_s_fair G sc)","proofString":"do 2 rewrite <- inclusion_union_r1.\napply doma_helper.\ninversion WFSC.\nrewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) : sc ⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc.","conclusion":"sc ⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc","hypotheses":"(IMM_FAIR : imm_s_fair G sc)","proofString":"apply doma_helper.\ninversion WFSC.\nrewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) : doma sc (set_compl (fun a : actid => is_init a)).","conclusion":"doma sc (set_compl (fun a : actid => is_init a))","hypotheses":"(IMM_FAIR : imm_s_fair G sc)","proofString":"inversion WFSC.\nrewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc) : doma sc (set_compl (fun a : actid => is_init a)).","conclusion":"doma sc (set_compl (fun a : actid => is_init a))","hypotheses":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc)","proofString":"rewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc) : doma\n  (⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n   ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘)\n  (set_compl (fun a : actid => is_init a)).","conclusion":"doma\n  (⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n   ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘)\n  (set_compl (fun a : actid => is_init a))","hypotheses":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc)","proofString":"red.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc) : forall x y : actid,\n(⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) x y ->\nset_compl (fun a : actid => is_init a) x.","conclusion":"forall x y : actid,\n(⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) x y ->\nset_compl (fun a : actid => is_init a) x","hypotheses":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc)","proofString":"intros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc) (x y : actid) (REL : (F ∩₁ (fun a : actid => is_sc (lab G) a)) x /\\\nsc x y /\\ (F ∩₁ (fun a : actid => is_sc (lab G) a)) y) : set_compl (fun a : actid => is_init a) x.","conclusion":"set_compl (fun a : actid => is_init a) x","hypotheses":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc) (x y : actid) (REL : (F ∩₁ (fun a : actid => is_sc (lab G) a)) x /\\\nsc x y /\\ (F ∩₁ (fun a : actid => is_sc (lab G) a)) y)","proofString":"eapply read_or_fence_is_not_init; eauto.\ntype_solver."},{"statement":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc) (x y : actid) (REL : (F ∩₁ (fun a : actid => is_sc (lab G) a)) x /\\\nsc x y /\\ (F ∩₁ (fun a : actid => is_sc (lab G) a)) y) : is_r (lab G) x \\/ is_f (lab G) x.","conclusion":"is_r (lab G) x \\/ is_f (lab G) x","hypotheses":"(IMM_FAIR : imm_s_fair G sc) (wf_scE : sc ≡ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘) (wf_scD : sc\n≡ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc ⨾ ⦗F ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc) (wf_sc_total : is_total (E ∩₁ F ∩₁ (fun a : actid => is_sc (lab G) a)) sc) (sc_irr : irreflexive sc) (x y : actid) (REL : (F ∩₁ (fun a : actid => is_sc (lab G) a)) x /\\\nsc x y /\\ (F ∩₁ (fun a : actid => is_sc (lab G) a)) y)","proofString":"type_solver."},{"statement":"(G : execution) (sc : relation actid) (WF : Wf G) (WFSC : wf_sc G sc) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar G sc)⁺\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar G sc)⁺\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full","hypotheses":"(G : execution) (sc : relation actid) (WF : Wf G) (WFSC : wf_sc G sc) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a)))","proofString":"rewrite ct_begin, wf_arE; auto.\nbasic_solver."},{"statement":"(G : execution) (sc : relation actid) (WF : Wf G) (WFSC : wf_sc G sc) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (⦗acts_set G⦘ ⨾ ar G sc ⨾ ⦗acts_set G⦘)\n  ⨾ (⦗acts_set G⦘ ⨾ ar G sc ⨾ ⦗acts_set G⦘)＊\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (⦗acts_set G⦘ ⨾ ar G sc ⨾ ⦗acts_set G⦘)\n  ⨾ (⦗acts_set G⦘ ⨾ ar G sc ⨾ ⦗acts_set G⦘)＊\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full","hypotheses":"(G : execution) (sc : relation actid) (WF : Wf G) (WFSC : wf_sc G sc) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a)))","proofString":"basic_solver."},{"statement":"(G : execution) (WF : Wf G) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (imm.ar G)⁺\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (imm.ar G)⁺\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full","hypotheses":"(G : execution) (WF : Wf G) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a)))","proofString":"rewrite ct_begin, imm.wf_arE; auto.\nbasic_solver."},{"statement":"(G : execution) (WF : Wf G) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (⦗acts_set G⦘ ⨾ imm.ar G ⨾ ⦗acts_set G⦘)\n  ⨾ (⦗acts_set G⦘ ⨾ imm.ar G ⨾ ⦗acts_set G⦘)＊\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (⦗acts_set G⦘ ⨾ imm.ar G ⨾ ⦗acts_set G⦘)\n  ⨾ (⦗acts_set G⦘ ⨾ imm.ar G ⨾ ⦗acts_set G⦘)＊\n⊆ (acts_set G \\₁ (fun a : actid => is_init a)) × set_full","hypotheses":"(G : execution) (WF : Wf G) (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a)))","proofString":"basic_solver."}]}