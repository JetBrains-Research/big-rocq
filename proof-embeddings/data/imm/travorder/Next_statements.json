{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/travorder/Next.v","fileSamples":[{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) : ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘ ⊆ ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘.","proofString":"unfolder; ins; desc; splits; eauto; eexists; splits; eauto; subst.\nassert (~ is_init a) as NA.\nintros H; apply NEXT, IC.\nsplit; auto.\napply NEXT.\nassert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) : sb y a.","proofString":"assert (~ is_init a) as NA.\nintros H; apply NEXT, IC.\nsplit; auto.\napply NEXT.\nassert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) : ~ is_init a.","proofString":"intros H; apply NEXT, IC.\nsplit; auto.\napply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a) : (Init ∩₁ E) a.","proofString":"split; auto.\napply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a) : E a.","proofString":"apply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) : sb y a.","proofString":"assert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) : E y.","proofString":"by apply CE."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) : sb y a.","proofString":"assert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) : E a.","proofString":"by apply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","proofString":"desf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","proofString":"symmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid a = tid y) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","proofString":"eapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y \\/ sb y a) : sb y a.","proofString":"desf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y) : sb y a.","proofString":"exfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y) : False.","proofString":"red in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : False.","proofString":"apply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : C a.","proofString":"apply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : dom_cond sb C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : C a.","proofString":"apply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) : ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘ ⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘.","proofString":"rewrite sb_tid_init'.\nunfold same_tid; unfolder; ins; desf; splits; eauto.\napply NEXT; basic_solver 10.\napply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) : ⦗dom_rel ((sb ∩ same_tid ∪ ⦗Init⦘ ⨾ sb) ⨾ ⦗eq a⦘)⦘\n⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘.","proofString":"unfold same_tid; unfolder; ins; desf; splits; eauto.\napply NEXT; basic_solver 10.\napply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (y : actid) (H2 : tid y = tid y0) (H0 : sb y y0) : C y.","proofString":"apply NEXT; basic_solver 10."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : C z.","proofString":"apply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : (Init ∩₁ E) z.","proofString":"split; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : E z.","proofString":"apply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : (⦗E⦘ ⨾ sb) z y0) : E z.","proofString":"apply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : E z /\\ sb z y0) : E z.","proofString":"desf."},{"statement":"(a : actid) (T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (NEXT : next (covered T) a) : covered T ⊆₁ dom_cond sb (covered T).","proofString":"apply dom_rel_to_cond.\neapply dom_sb_covered; eauto."},{"statement":"(a : actid) (T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (NEXT : next (covered T) a) : dom_rel (sb ⨾ ⦗covered T⦘) ⊆₁ covered T.","proofString":"eapply dom_sb_covered; eauto."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : False.","proofString":"apply NEXT.\neapply init_covered; eauto.\nsplit; auto.\napply NEXT."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : covered T e.","proofString":"eapply init_covered; eauto.\nsplit; auto.\napply NEXT."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : (Init ∩₁ E) e.","proofString":"split; auto.\napply NEXT."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : E e.","proofString":"apply NEXT."}]}