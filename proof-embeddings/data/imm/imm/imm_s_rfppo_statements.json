{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/imm/imm_s_rfppo.v","fileSamples":[{"statement":"(sc ∪ rfe ∪ ar_int) ⨾ rf ⨾ ppo ∩ same_loc ⊆ (sc ∪ rfe ∪ ar_int)⁺.","proofString":"rewrite unionA, seq_union_l.\nunionL.\nrewrite wf_scD with (sc:=sc) at 1; [|by apply IMMCON].\nrewrite (dom_l (wf_rfD WF)).\ntype_solver.\nrewrite ar_int_rfe_rf_ppo_loc_in_ar_int_rfe_ct.\napply clos_trans_mori.\neauto with hahn."},{"statement":"sc ⨾ rf ⨾ ppo ∩ same_loc ∪ (rfe ∪ ar_int) ⨾ rf ⨾ ppo ∩ same_loc\n⊆ (sc ∪ (rfe ∪ ar_int))⁺.","proofString":"unionL.\nrewrite wf_scD with (sc:=sc) at 1; [|by apply IMMCON].\nrewrite (dom_l (wf_rfD WF)).\ntype_solver.\nrewrite ar_int_rfe_rf_ppo_loc_in_ar_int_rfe_ct.\napply clos_trans_mori.\neauto with hahn."},{"statement":"sc ⨾ rf ⨾ ppo ∩ same_loc ⊆ (sc ∪ (rfe ∪ ar_int))⁺.","proofString":"rewrite wf_scD with (sc:=sc) at 1; [|by apply IMMCON].\nrewrite (dom_l (wf_rfD WF)).\ntype_solver."},{"statement":"(⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ rf ⨾ ppo ∩ same_loc ⊆ (sc ∪ (rfe ∪ ar_int))⁺.","proofString":"rewrite (dom_l (wf_rfD WF)).\ntype_solver."},{"statement":"(⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ (⦗W⦘ ⨾ rf) ⨾ ppo ∩ same_loc\n⊆ (sc ∪ (rfe ∪ ar_int))⁺.","proofString":"type_solver."},{"statement":"(rfe ∪ ar_int) ⨾ rf ⨾ ppo ∩ same_loc ⊆ (sc ∪ (rfe ∪ ar_int))⁺.","proofString":"rewrite ar_int_rfe_rf_ppo_loc_in_ar_int_rfe_ct.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(rfe ∪ ar_int)⁺ ⊆ (sc ∪ (rfe ∪ ar_int))⁺.","proofString":"apply clos_trans_mori.\neauto with hahn."},{"statement":"rfe ∪ ar_int ⊆ sc ∪ (rfe ∪ ar_int).","proofString":"eauto with hahn."},{"statement":"(ar＊ ⨾ ar) ⨾ rf ⨾ ppo ∩ same_loc ⊆ ar⁺.","proofString":"rewrite !seqA.\nrewrite ar_rf_ppo_loc_in_ar_ct.\napply rt_ct."},{"statement":"ar＊ ⨾ ar ⨾ rf ⨾ ppo ∩ same_loc ⊆ ar⁺.","proofString":"rewrite ar_rf_ppo_loc_in_ar_ct.\napply rt_ct."},{"statement":"ar＊ ⨾ ar⁺ ⊆ ar⁺.","proofString":"apply rt_ct."},{"statement":"ar⁺ ⨾ rf ⨾ ppo ∩ same_loc ⊆ rf ⨾ ppo ∩ same_loc \\/\nar⁺ ⨾ rf ⨾ ppo ∩ same_loc ⊆ ar⁺.","proofString":"right.\napply ar_ct_rf_ppo_loc_in_ar_ct."},{"statement":"ar⁺ ⨾ rf ⨾ ppo ∩ same_loc ⊆ ar⁺.","proofString":"apply ar_ct_rf_ppo_loc_in_ar_ct."},{"statement":"irreflexive (ar⁺)⁺.","proofString":"rewrite ct_of_ct.\napply IMMCON."},{"statement":"irreflexive ar⁺.","proofString":"apply IMMCON."},{"statement":"coherence G.","proofString":"by apply IMMCON."},{"statement":"acyclic co.","proofString":"by apply co_acyclic."},{"statement":"ar⁺ ⨾ (rf ⨾ ppo ∩ same_loc)⁺ ⊆ ar⁺.","proofString":"by apply ar_ct_rf_ppo_loc_ct_in_ar_ct."},{"statement":"⦗set_compl Init⦘ ⨾ ⦗fun _ : actid => True⦘\n∪ ⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ ⦗set_compl Init⦘ ⨾ ⦗fun _ : actid => True⦘ ⨾ ⦗set_compl Init⦘\n  ∪ ⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗set_compl Init⦘.","proofString":"apply union_mori.\nclear; basic_solver.\nrewrite !ct_end.\nhahn_frame_l.\nhahn_frame_l.\ntransitivity ((ar ∪ rf ⨾ ppo ∩ same_loc) ;; <|is_init ∪₁ set_compl is_init|>).\nrewrite <- set_full_split.\nclear; basic_solver.\nrewrite id_union, seq_union_r.\nrewrite no_ar_rf_ppo_loc_to_init; auto.\nnow unionL."},{"statement":"⦗set_compl Init⦘ ⨾ ⦗fun _ : actid => True⦘\n⊆ ⦗set_compl Init⦘ ⨾ ⦗fun _ : actid => True⦘ ⨾ ⦗set_compl Init⦘.","proofString":"clear; basic_solver."},{"statement":"⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ ⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗set_compl Init⦘.","proofString":"rewrite !ct_end.\nhahn_frame_l.\nhahn_frame_l.\ntransitivity ((ar ∪ rf ⨾ ppo ∩ same_loc) ;; <|is_init ∪₁ set_compl is_init|>).\nrewrite <- set_full_split.\nclear; basic_solver.\nrewrite id_union, seq_union_r.\nrewrite no_ar_rf_ppo_loc_to_init; auto.\nnow unionL."},{"statement":"⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)\n⊆ ⦗set_compl Init⦘\n  ⨾ ((ar ∪ rf ⨾ ppo ∩ same_loc)＊ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc))\n    ⨾ ⦗set_compl Init⦘.","proofString":"hahn_frame_l.\nhahn_frame_l.\ntransitivity ((ar ∪ rf ⨾ ppo ∩ same_loc) ;; <|is_init ∪₁ set_compl is_init|>).\nrewrite <- set_full_split.\nclear; basic_solver.\nrewrite id_union, seq_union_r.\nrewrite no_ar_rf_ppo_loc_to_init; auto.\nnow unionL."},{"statement":"(ar ∪ rf ⨾ ppo ∩ same_loc)＊ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)＊ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl Init⦘.","proofString":"hahn_frame_l.\ntransitivity ((ar ∪ rf ⨾ ppo ∩ same_loc) ;; <|is_init ∪₁ set_compl is_init|>).\nrewrite <- set_full_split.\nclear; basic_solver.\nrewrite id_union, seq_union_r.\nrewrite no_ar_rf_ppo_loc_to_init; auto.\nnow unionL."},{"statement":"ar ∪ rf ⨾ ppo ∩ same_loc ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl Init⦘.","proofString":"transitivity ((ar ∪ rf ⨾ ppo ∩ same_loc) ;; <|is_init ∪₁ set_compl is_init|>).\nrewrite <- set_full_split.\nclear; basic_solver.\nrewrite id_union, seq_union_r.\nrewrite no_ar_rf_ppo_loc_to_init; auto.\nnow unionL."},{"statement":"ar ∪ rf ⨾ ppo ∩ same_loc\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init ∪₁ set_compl Init⦘.","proofString":"rewrite <- set_full_split.\nclear; basic_solver."},{"statement":"ar ∪ rf ⨾ ppo ∩ same_loc ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗⊤₁⦘.","proofString":"clear; basic_solver."},{"statement":"(ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init ∪₁ set_compl Init⦘\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl Init⦘.","proofString":"rewrite id_union, seq_union_r.\nrewrite no_ar_rf_ppo_loc_to_init; auto.\nnow unionL."},{"statement":"(ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘\n∪ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl Init⦘\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl Init⦘.","proofString":"rewrite no_ar_rf_ppo_loc_to_init; auto.\nnow unionL."},{"statement":"∅₂ ∪ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl Init⦘\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl Init⦘.","proofString":"now unionL."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) : ar ⨾ (rf ⨾ ppo ∩ same_loc)＊ ⊆ ar⁺.","proofString":"rewrite rtE, seq_union_r, seq_id_r.\nrewrite ar_rf_ppo_loc_ct_in_ar_ct.\neauto with hahn."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) : ar ∪ ar ⨾ (rf ⨾ ppo ∩ same_loc)⁺ ⊆ ar⁺.","proofString":"rewrite ar_rf_ppo_loc_ct_in_ar_ct.\neauto with hahn."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) : ar ∪ ar⁺ ⊆ ar⁺.","proofString":"eauto with hahn."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) : coherence G.","proofString":"by apply IMMCON."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) : fsupp co⁺.","proofString":"rewrite ct_of_trans; [apply FAIR| apply WF]."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (AA : fsupp (rf ⨾ ppo ∩ same_loc)⁺) : fsupp (⦗set_compl Init⦘ ⨾ (rf ⨾ ppo ∩ same_loc)⁺).","proofString":"apply fsupp_seq; auto.\napply fsupp_eqv."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (AA : fsupp (rf ⨾ ppo ∩ same_loc)⁺) : fsupp ⦗set_compl Init⦘.","proofString":"apply fsupp_eqv."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (AA : fsupp (rf ⨾ ppo ∩ same_loc)⁺) : domb (rf ⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘) ∩ same_loc) (set_compl Init).","proofString":"basic_solver."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (AA : fsupp (rf ⨾ ppo ∩ same_loc)⁺) : fsupp (⦗set_compl Init⦘ ⨾ (rf ⨾ ppo ∩ same_loc)＊ ⨾ ⦗set_compl Init⦘ ⨾ ar⁺).","proofString":"apply fsupp_seq; [by apply fsupp_eqv|].\napply fsupp_seq; auto.\nnow apply fsupp_ct_rt."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (AA : fsupp (rf ⨾ ppo ∩ same_loc)⁺) : fsupp ((rf ⨾ ppo ∩ same_loc)＊ ⨾ ⦗set_compl Init⦘ ⨾ ar⁺).","proofString":"apply fsupp_seq; auto.\nnow apply fsupp_ct_rt."},{"statement":"(FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (AA : fsupp (rf ⨾ ppo ∩ same_loc)⁺) : fsupp (rf ⨾ ppo ∩ same_loc)＊.","proofString":"now apply fsupp_ct_rt."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) : ⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"basic_solver 10."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) : transitive (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","proofString":"red.\nins.\napply seq_eqv_l.\napply seq_eqv_l in H, H0.\ndesc.\nsplit; auto.\neapply transitive_ct; eauto."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) : forall x y z : actid,\n(⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) x y ->\n(⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) y z ->\n(⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) x z.","proofString":"ins.\napply seq_eqv_l.\napply seq_eqv_l in H, H0.\ndesc.\nsplit; auto.\neapply transitive_ct; eauto."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) (x y z : actid) (H : (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) x y) (H0 : (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) y z) : (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) x z.","proofString":"apply seq_eqv_l.\napply seq_eqv_l in H, H0.\ndesc.\nsplit; auto.\neapply transitive_ct; eauto."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) (x y z : actid) (H : (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) x y) (H0 : (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺) y z) : set_compl Init x /\\ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ x z.","proofString":"apply seq_eqv_l in H, H0.\ndesc.\nsplit; auto.\neapply transitive_ct; eauto."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) (x y z : actid) (H : set_compl Init x /\\ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ x y) (H0 : set_compl Init y /\\ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ y z) : set_compl Init x /\\ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ x z.","proofString":"desc.\nsplit; auto.\neapply transitive_ct; eauto."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) (x y z : actid) (H : set_compl Init x) (H2 : (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ x y) (H0 : set_compl Init y) (H1 : (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ y z) : set_compl Init x /\\ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ x z.","proofString":"split; auto.\neapply transitive_ct; eauto."},{"statement":"(FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)) (x y z : actid) (H : set_compl Init x) (H2 : (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ x y) (H0 : set_compl Init y) (H1 : (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ y z) : (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ x z.","proofString":"eapply transitive_ct; eauto."},{"statement":"(NOSC : E ∩₁ F ∩₁ Sc ⊆₁ ∅) (FSUPP : fsupp (⦗set_compl Init⦘ ⨾ (sb ∪ rf)⁺)) : fsupp (⦗set_compl Init⦘ ⨾ ((sb ∪ rf)⁺)⁺).","proofString":"now rewrite ct_of_ct."},{"statement":"(FAIR : mem_fair G) (IMM_CONS : imm_consistent G sc) (IMM_FAIR : imm_s_fair G sc) : acyclic (ar ∪ rf ⨾ ppo ∩ same_loc).","proofString":"by apply ar_rf_ppo_loc_acyclic."},{"statement":"(FAIR : mem_fair G) (IMM_CONS : imm_consistent G sc) (IMM_FAIR : imm_s_fair G sc) : (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ≡ ∅₂.","proofString":"by apply no_ar_rf_ppo_loc_to_init."},{"statement":"(FAIR : mem_fair G) (IMM_CONS : imm_consistent G sc) (IMM_FAIR : imm_s_fair G sc) : ppo ⊆ sb.","proofString":"by apply imm_s_ppo.ppo_in_sb."},{"statement":"(FAIR : mem_fair G) (IMM_CONS : imm_consistent G sc) (IMM_FAIR : imm_s_fair G sc) : ar ⨾ (rf ⨾ ppo ∩ same_loc)⁺ ⊆ ar⁺.","proofString":"by apply ar_rf_ppo_loc_ct_in_ar_ct."},{"statement":"(FAIR : mem_fair G) (IMM_CONS : imm_consistent G sc) (IMM_FAIR : imm_s_fair G sc) : sc_per_loc G.","proofString":"cdes IMM_CONS.\nby apply imm_s_hb.coherence_sc_per_loc."},{"statement":"(FAIR : mem_fair G) (IMM_CONS : imm_consistent G sc) (IMM_FAIR : imm_s_fair G sc) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) : sc_per_loc G.","proofString":"by apply imm_s_hb.coherence_sc_per_loc."}]}