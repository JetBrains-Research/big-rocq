[{"statement":"Lemma tls_set_alt T a e:\n  (event ↑₁ (T ∩₁ action ↓₁ eq a)) e <-> T (mkTL a e).","proof":"unfolder.\nsplit; ins; desc; eauto.\ndestruct y; ins; by subst.\n"},{"statement":"Lemma propagated_alt G T: \n  propagated G T ≡₁ ⋃₁ t ∈ threads_set G \\₁ eq tid_init, propagated_thread T t.","proof":"unfold propagated_thread, propagated, is_ta_propagate_to_G.\nbasic_solver 10.\n"},{"statement":"Lemma covered_single e:\n  covered (eq (mkTL ta_cover e)) ≡₁ eq e.","proof":"unfold covered.\nrewrite set_inter_absorb_r; basic_solver.\n"},{"statement":"Lemma reserved_ta_reserve s :\n  reserved (eq ta_reserve <*> s) ≡₁ s.","proof":"unfold reserved.\nunfolder; split; ins; desf.\n{\ndestruct y; ins.\ndesf.\n}\neexists (_, _).\nsplits; ins; eauto.\n"},{"statement":"Lemma reserved_eq_ta_reserve e :\n  reserved (eq (mkTL ta_reserve e)) ≡₁ eq e.","proof":"unfold reserved.\nunfolder; split; ins; desf.\neexists (_, _).\nsplits; ins; eauto.\n"},{"statement":"Lemma reserved_eq_ta_propagate tid e :\n  reserved (eq (mkTL (ta_propagate tid) e)) ≡₁ ∅.","proof":"unfold reserved.\nunfolder; split; ins; desf.\n"},{"statement":"Lemma reserved_ta_propagate tid s :\n  reserved (eq (ta_propagate tid) <*> s) ≡₁ ∅.","proof":"unfold reserved.\nunfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\n"},{"statement":"Lemma issued_ta_reserve s :\n  issued (eq ta_reserve <*> s) ≡₁ ∅.","proof":"unfold issued.\nunfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\n"},{"statement":"Lemma issued_ta_issue s :\n  issued (eq ta_issue <*> s) ≡₁ s.","proof":"unfold issued.\nunfolder; split; ins; desf.\n{\ndestruct y; ins.\ndesf.\n}\neexists (_, _).\nsplits; ins; eauto.\n"},{"statement":"Lemma issued_ta_cover s :\n  issued (eq ta_cover <*> s) ≡₁ ∅.","proof":"unfold issued.\nunfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\n"},{"statement":"Lemma issued_is_ta_propagate_to_G G s :\n  issued (is_ta_propagate_to_G G <*> s) ≡₁ ∅.","proof":"unfold issued, is_ta_propagate_to_G.\nunfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\n"},{"statement":"Lemma covered_ta_reserve s :\n  covered (eq ta_reserve <*> s) ≡₁ ∅.","proof":"unfold covered.\nunfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\n"},{"statement":"Lemma covered_action_ta_reserve : covered (action ↓₁ eq ta_reserve) ≡₁ ∅.","proof":"unfold covered.\nunfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\n"},{"statement":"Lemma issued_eq_ta_cover w : issued (eq (ta_cover, w)) ≡₁ ∅.","proof":"unfold issued.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma issued_eq_ta_issue w : issued (eq (ta_issue, w)) ≡₁ eq w.","proof":"unfold issued.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma issued_eq_ta_propagate tid e :\n  issued (eq (mkTL (ta_propagate tid) e)) ≡₁ ∅.","proof":"unfold issued.\nunfolder; split; ins; desf.\n"},{"statement":"Lemma covered_eq_ta_propagate tid e :\n  covered (eq (mkTL (ta_propagate tid) e)) ≡₁ ∅.","proof":"unfold covered.\nunfolder; split; ins; desf.\n"},{"statement":"Lemma covered_eq_ta_issue w : covered (eq (ta_issue, w)) ≡₁ ∅.","proof":"unfold covered.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma covered_eq_ta_reserve w : covered (eq (ta_reserve, w)) ≡₁ ∅.","proof":"unfold covered.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma issued_eq_ta_reserve w : issued (eq (ta_reserve, w)) ≡₁ ∅.","proof":"unfold issued.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma reserved_eq_ta_issue w : reserved (eq (ta_issue, w)) ≡₁ ∅.","proof":"unfold reserved.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma reserved_eq_ta_cover w : reserved (eq (ta_cover, w)) ≡₁ ∅.","proof":"unfold reserved.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma tls_set_inter_helper T1 T2 (a: trav_action):\n  event ↑₁ ((T1 ∩₁ T2) ∩₁ action ↓₁ eq a) ≡₁\n  event ↑₁ (T1 ∩₁ action ↓₁ eq a) ∩₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a).","proof":"split; try basic_solver 10.\nunfolder.\nins.\ndesc.\ndestruct y, y0; ins; subst.\neauto.\n"},{"statement":"Lemma tls_set_minus_helper T1 T2 (a: trav_action):\n  event ↑₁ ((T1 \\₁ T2) ∩₁ action ↓₁ eq a) ≡₁\n  event ↑₁ (T1 ∩₁ action ↓₁ eq a) \\₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a).","proof":"split; try basic_solver 10.\nunfolder.\nins.\ndesc.\ndestruct y; ins; subst.\nsplits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone.\n"},{"statement":"Lemma covered_events (A: actid -> Prop): covered (event ↓₁ A) ⊆₁ A.","proof":"unfold covered.\nbasic_solver.\n"},{"statement":"Lemma issued_events (A: actid -> Prop): issued (event ↓₁ A) ⊆₁ A.","proof":"unfold issued.\nbasic_solver.\n"},{"statement":"Lemma reserved_events (A: actid -> Prop): reserved (event ↓₁ A) ⊆₁ A.","proof":"unfold reserved.\nbasic_solver.\n"},{"statement":"Lemma propagated_events G (A: actid -> Prop): propagated G (event ↓₁ A) ⊆₁ A.","proof":"unfold propagated.\nbasic_solver.\n"},{"statement":"Lemma covered_union T1 T2: covered (T1 ∪₁ T2) ≡₁ covered T1 ∪₁ covered T2.","proof":"unfold covered.\nbasic_solver 10.\n"},{"statement":"Lemma covered_inter T1 T2: covered (T1 ∩₁ T2) ≡₁ covered T1 ∩₁ covered T2.","proof":"apply tls_set_inter_helper.\n"},{"statement":"Lemma covered_minus T1 T2: covered (T1 \\₁ T2) ≡₁ covered T1 \\₁ covered T2.","proof":"apply tls_set_minus_helper.\n"},{"statement":"Lemma issued_union T1 T2: issued (T1 ∪₁ T2) ≡₁ issued T1 ∪₁ issued T2.","proof":"unfold issued.\nbasic_solver 10.\n"},{"statement":"Lemma issued_inter T1 T2: issued (T1 ∩₁ T2) ≡₁ issued T1 ∩₁ issued T2.","proof":"apply tls_set_inter_helper.\n"},{"statement":"Lemma issued_minus T1 T2: issued (T1 \\₁ T2) ≡₁ issued T1 \\₁ issued T2.","proof":"apply tls_set_minus_helper.\n"},{"statement":"Lemma reserved_union T1 T2: reserved (T1 ∪₁ T2) ≡₁ reserved T1 ∪₁ reserved T2.","proof":"unfold reserved.\nbasic_solver 10.\n"},{"statement":"Lemma reserved_inter T1 T2: reserved (T1 ∩₁ T2) ≡₁ reserved T1 ∩₁ reserved T2.","proof":"apply tls_set_inter_helper.\n"},{"statement":"Lemma reserved_minus T1 T2: reserved (T1 \\₁ T2) ≡₁ reserved T1 \\₁ reserved T2.","proof":"apply tls_set_minus_helper.\n"},{"statement":"Lemma propagated_union G T1 T2:\n  propagated G (T1 ∪₁ T2) ≡₁ propagated G T1 ∪₁ propagated G T2.","proof":"unfold propagated.\nbasic_solver 10.\n"},{"statement":"Lemma covered_singleton e:\n  covered (eq (mkTL ta_cover e)) ≡₁ eq e.","proof":"unfold covered.\nsplit; basic_solver.\n"},{"statement":"Lemma issued_singleton e:\n  issued (eq (mkTL ta_issue e)) ≡₁ eq e.","proof":"unfold issued.\nsplit; basic_solver.\n"},{"statement":"Lemma reserved_singleton e:\n  reserved (eq (mkTL ta_reserve e)) ≡₁ eq e.","proof":"unfold reserved.\nsplit; basic_solver.\n"},{"statement":"Lemma covered_noncover_empty S\n      (NONCOVER: set_disjoint S (action ↓₁ eq ta_cover)):\n  covered S ≡₁ ∅.","proof":"unfold covered.\nsplit; basic_solver.\n"},{"statement":"Lemma issued_nonissue_empty S\n      (NONISSUE: set_disjoint S (action ↓₁ eq ta_issue)):\n  issued S ≡₁ ∅.","proof":"unfold issued.\nsplit; basic_solver.\n"},{"statement":"Lemma reserved_nonreserve_empty S\n      (NONISSUE: set_disjoint S (action ↓₁ eq ta_reserve)):\n  reserved S ≡₁ ∅.","proof":"unfold reserved.\nsplit; basic_solver.\n"},{"statement":"Lemma propagated_nonpropagated_empty G S\n      (NONPROP: set_disjoint S (action ↓₁ is_ta_propagate_to_G G)):\n  propagated G S ≡₁ ∅.","proof":"unfold propagated.\nsplit; basic_solver.\n"},{"statement":"Lemma covered_only_cover M\n      (COV: M ⊆₁ action ↓₁ eq ta_cover):\n  covered M ≡₁ event ↑₁ M.","proof":"unfold covered.\nsplit; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize COV.\nbasic_solver.\n"},{"statement":"Lemma issued_only_issue M\n      (ISS: M ⊆₁ action ↓₁ eq ta_issue):\n  issued M ≡₁ event ↑₁ M.","proof":"unfold issued.\nsplit; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize ISS.\nbasic_solver.\n"},{"statement":"Lemma reserved_only_reserve M\n      (RES: M ⊆₁ action ↓₁ eq ta_reserve):\n  reserved M ≡₁ event ↑₁ M.","proof":"unfold reserved.\nsplit; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize RES.\nbasic_solver.\n"},{"statement":"Lemma propagated_only_propagate G (M: trav_label -> Prop)\n      (PROP: M ⊆₁ action ↓₁ is_ta_propagate_to_G G):\n  propagated G M ≡₁ event ↑₁ M.","proof":"unfold propagated.\nsplit; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize PROP.\nbasic_solver.\n"},{"statement":"Lemma test T e:\n  reserved (T ∪₁ eq (mkTL ta_issue e) ∪₁ eq (mkTL ta_reserve e)) ≡₁\n  reserved T ∪₁ eq e.","proof":"simplify_tls_events.\nbasic_solver.\n"},{"statement":"Lemma issuedW :\n    issued T ⊆₁ W.","proof":"unfold issued.\nrewrite tlsc_I_in_W; eauto.\nbasic_solver.\n"},{"statement":"Lemma propagatedEW : propagated G T ⊆₁ E ∩₁ W.","proof":"clear -WF TLSCOH.\nunfold propagated.\nunfolder.\nins.\ndesf.\nunfold is_ta_propagate_to_G in *.\nunfolder in *.\ndesf.\nsplit; [eapply tlsc_P_in_E|eapply tlsc_P_in_W].\nall: eauto.\nall: basic_solver.\n"},{"statement":"Lemma propagatedE : propagated G T ⊆₁ E.","proof":"rewrite propagatedEW.\nbasic_solver 1.\n"},{"statement":"Lemma propagatedW : propagated G T ⊆₁ W.","proof":"rewrite propagatedEW.\nbasic_solver 1.\n"},{"statement":"Lemma issuedE :\n    issued T ⊆₁ E.","proof":"unfold issued.\nrewrite (tlsc_E WF TLSCOH).\nbasic_solver.\n"},{"statement":"Lemma coveredE:\n    covered T ⊆₁ E.","proof":"unfold covered.\nrewrite (tlsc_E WF TLSCOH).\nbasic_solver.\n"},{"statement":"Lemma w_covered_issued :\n    W ∩₁ covered T ⊆₁ issued T.","proof":"unfold covered.\nunfolder.\nins.\ndesc.\nforward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto.\n"},{"statement":"Lemma IPROP_in_iord_simpl : IPROP G ⊆ iord_simpl G sc.","proof":"unfold iord_simpl.\neauto with hahn.\n"},{"statement":"Lemma init_issued : is_init ∩₁ E ⊆₁ issued T.","proof":"unfolder; ins; desf.\nred.\nexists (mkTL ta_issue x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver.\n"},{"statement":"Lemma init_covered : is_init ∩₁ E ⊆₁ covered T.","proof":"unfolder; ins; desf.\nred.\nexists (mkTL ta_cover x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver.\n"},{"statement":"Lemma init_propagated_thread t (Gt: (threads_set G \\₁ eq tid_init) t):\n    is_init ∩₁ E ⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq (ta_propagate t)).","proof":"unfolder; ins; desf.\nexists (mkTL (ta_propagate t) x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto.\n"},{"statement":"Lemma propagated_in_issued : propagated G T ⊆₁ issued T.","proof":"rewrite AuxRel2.set_split_complete with (s' := propagated G T) (s := fun x => is_init x = true).\nunionL.\n{\nrewrite propagatedE.\nrewrite <- init_issued.\nclear; basic_solver 1.\n}\narewrite (propagated G T ⊆₁ propagated G T ∩₁ (E ∩₁ W)).\n{\napply set_subset_inter_r.\nsplits; auto.\napply propagatedEW.\n}\nrewrite <- set_minusE.\nrewrite <- set_inter_minus_r.\nintros x [HH BB].\ndestruct HH as [[t e] HH]; desf; ins.\ndestruct HH as [HH AA].\nunfolder in AA; ins.\nexists (ta_issue, e); ins.\nsplits; auto.\nsplit.\n2: basic_solver 1.\neapply IORDCOH.\nred.\nexists (t, e).\napply seq_eqv_r.\nsplit; auto.\ndo 2 red.\nsplits.\nall: try now red; ins; generalize BB; clear; basic_solver 10.\napply IPROP_in_iord_simpl.\nred.\nunfolder; ins.\nsplits; eauto.\neexists; splits; eauto.\ngeneralize BB; clear; basic_solver 10.\n"},{"statement":"Lemma covered_in_coverable: \n    covered T ⊆₁ coverable G sc T.","proof":"unfold covered, coverable.\napply set_subset_inter_r.\nsplit; [apply coveredE|].\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond.\n"},{"statement":"Lemma issued_in_issuable:\n    issued T ⊆₁ issuable G sc T.","proof":"unfold issued, issuable.\nrepeat (apply set_subset_inter_r; split); auto using issuedE, issuedW.\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond.\n"},{"statement":"Lemma issuableE:\n    issuable G sc T ⊆₁ acts_set G.","proof":"unfold issuable.\nbasic_solver.\n"},{"statement":"Lemma issuableW:\n    issuable G sc T ⊆₁ is_w (lab G).","proof":"unfold issuable.\nbasic_solver.\n"},{"statement":"Lemma w_coverable_issued :\n    W ∩₁ coverable G sc T ⊆₁ issued T.","proof":"rewrite AuxRel2.set_split_complete with (s' := _ ∩₁ _) (s := is_init).\napply set_subset_union_l.\nsplit.\n{\nrewrite <- init_issued.\nunfold coverable.\nbasic_solver.\n}\nrewrite <- dom_eqv with (d := _ ∩₁ _).\nrewrite id_inter, seq_eqvC.\nunfold coverable, issued.\nrewrite !id_inter, <- !seqA.\neapply dom_rel_iord_ext_parts.\n3: by apply init_issued.\n2: basic_solver.\ntransitivity (RF G); [| unfold iord_simpl; basic_solver 10].\nunfold RF.\nhahn_frame.\nbasic_solver 10.\n"},{"statement":"Lemma issued_EW :\n    issued T ⊆₁ E ∩₁ W.","proof":"unfold issued.\napply set_subset_inter_r.\nsplit.\n{\napply issuedE; auto.\n}\napply issuedW; auto.\n"},{"statement":"Lemma coverable_iord_dom_cond G sc T e (COV: coverable G sc T e):\n  dom_cond (iord G sc) T (mkTL ta_cover e).","proof":"red in COV.\napply proj2 in COV as [[a e_] [[AA [=]] [=]]].\nby subst.\n"},{"statement":"Lemma issuable_iord_dom_cond G sc T e (ISS: issuable G sc T e):\n  dom_cond (iord G sc) T (mkTL ta_issue e).","proof":"red in ISS.\napply proj2 in ISS as [[a e_] [[AA [=]] [=]]].\nby subst.\n"},{"statement":"Lemma set_pair_empty_l (A B: Type) (S: A -> Prop):\n  S <*> (∅: B -> Prop) ≡₁ ∅.","proof":"rewrite set_pair_alt.\nbasic_solver.\n"},{"statement":"Lemma set_pair_empty_r (A B: Type) (S: B -> Prop):\n  (∅: A -> Prop) <*> S ≡₁ ∅.","proof":"rewrite set_pair_alt.\nbasic_solver.\n"},{"statement":"Lemma set_minus_empty (A : Type) (s : A -> Prop) : s \\₁ ∅ ≡₁ s.","proof":"basic_solver.\n"}]