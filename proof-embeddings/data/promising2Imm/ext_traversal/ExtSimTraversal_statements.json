{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/ext_traversal/ExtSimTraversal.v","fileSamples":[{"statement":"(rmw ⨾ rfi)＊ ⨾ ⦗fun _ : actid => True⦘ ⨾ sb ⊆ sb.","proofString":"rewrite seq_id_l.\narewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF).\narewrite (sb ⨾ sb ⊆ sb).\ngeneralize (@sb_trans G).\nclear.\nbasic_solver 10.\nrewrite <- ct_end.\napply ct_of_trans.\napply sb_trans."},{"statement":"(rmw ⨾ rfi)＊ ⨾ sb ⊆ sb.","proofString":"arewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF).\narewrite (sb ⨾ sb ⊆ sb).\ngeneralize (@sb_trans G).\nclear.\nbasic_solver 10.\nrewrite <- ct_end.\napply ct_of_trans.\napply sb_trans."},{"statement":"(rmw ⨾ sb)＊ ⨾ sb ⊆ sb.","proofString":"rewrite (rmw_in_sb WF).\narewrite (sb ⨾ sb ⊆ sb).\ngeneralize (@sb_trans G).\nclear.\nbasic_solver 10.\nrewrite <- ct_end.\napply ct_of_trans.\napply sb_trans."},{"statement":"(sb ⨾ sb)＊ ⨾ sb ⊆ sb.","proofString":"arewrite (sb ⨾ sb ⊆ sb).\ngeneralize (@sb_trans G).\nclear.\nbasic_solver 10.\nrewrite <- ct_end.\napply ct_of_trans.\napply sb_trans."},{"statement":"sb ⨾ sb ⊆ sb.","proofString":"generalize (@sb_trans G).\nclear.\nbasic_solver 10."},{"statement":"transitive sb -> sb ⨾ sb ⊆ sb.","proofString":"clear.\nbasic_solver 10."},{"statement":"transitive sb -> sb ⨾ sb ⊆ sb.","proofString":"basic_solver 10."},{"statement":"sb＊ ⨾ sb ⊆ sb.","proofString":"rewrite <- ct_end.\napply ct_of_trans.\napply sb_trans."},{"statement":"sb⁺ ⊆ sb.","proofString":"apply ct_of_trans.\napply sb_trans."},{"statement":"transitive sb.","proofString":"apply sb_trans."},{"statement":"(w : actid) : dom_rel\n  ((detour ∪ rfe)\n   ⨾ rmw ⨾ ⦗reserved T ∪₁ eq w ∪₁ dom_sb_S_rfrmw G T rfi (eq w)⦘)\n≡₁ dom_rel ((detour ∪ rfe) ⨾ rmw ⨾ ⦗reserved T ∪₁ eq w⦘).","proofString":"rewrite id_union.\nrewrite !seq_union_r.\nrewrite dom_union.\nby rewrite DRFE_EMP1, set_union_empty_r."},{"statement":"(w : actid) : dom_rel\n  ((detour ∪ rfe)\n   ⨾ rmw ⨾ (⦗reserved T ∪₁ eq w⦘ ∪ ⦗dom_sb_S_rfrmw G T rfi (eq w)⦘))\n≡₁ dom_rel ((detour ∪ rfe) ⨾ rmw ⨾ ⦗reserved T ∪₁ eq w⦘).","proofString":"rewrite !seq_union_r.\nrewrite dom_union.\nby rewrite DRFE_EMP1, set_union_empty_r."},{"statement":"(w : actid) : dom_rel\n  ((detour ∪ rfe) ⨾ rmw ⨾ ⦗reserved T ∪₁ eq w⦘\n   ∪ (detour ∪ rfe) ⨾ rmw ⨾ ⦗dom_sb_S_rfrmw G T rfi (eq w)⦘)\n≡₁ dom_rel ((detour ∪ rfe) ⨾ rmw ⨾ ⦗reserved T ∪₁ eq w⦘).","proofString":"rewrite dom_union.\nby rewrite DRFE_EMP1, set_union_empty_r."},{"statement":"(w : actid) : dom_rel ((detour ∪ rfe) ⨾ rmw ⨾ ⦗reserved T ∪₁ eq w⦘)\n∪₁ dom_rel ((detour ∪ rfe) ⨾ rmw ⨾ ⦗dom_sb_S_rfrmw G T rfi (eq w)⦘)\n≡₁ dom_rel ((detour ∪ rfe) ⨾ rmw ⨾ ⦗reserved T ∪₁ eq w⦘).","proofString":"by rewrite DRFE_EMP1, set_union_empty_r."},{"statement":"(w : actid) (EW : E w) : reserved T ∪₁ eq w ∪₁ dom_sb_S_rfrmw G T rfi (eq w) ⊆₁ E.","proofString":"rewrite (dom_sb_S_rfrmwE WF).\nerewrite rcoh_S_in_E; eauto.\ngeneralize EW.\nclear.\nbasic_solver."},{"statement":"(w : actid) (EW : E w) : reserved T ∪₁ eq w ∪₁ E ⊆₁ E.","proofString":"erewrite rcoh_S_in_E; eauto.\ngeneralize EW.\nclear.\nbasic_solver."},{"statement":"(w : actid) (EW : E w) : E ∪₁ eq w ∪₁ E ⊆₁ E.","proofString":"generalize EW.\nclear.\nbasic_solver."},{"statement":"(w : actid) (EW : E w) : E w -> E ∪₁ eq w ∪₁ E ⊆₁ E.","proofString":"clear.\nbasic_solver."},{"statement":"(w : actid) : E w -> E ∪₁ eq w ∪₁ E ⊆₁ E.","proofString":"basic_solver."},{"statement":"(e : actid) (TS_RES : ext_itrav_step G sc (mkTL ta_reserve e) T T') : exists T'' : trav_label -> Prop, ext_sim_trav_step T T''.","proofString":"inversion TS_RES.\neexists.\neexists.\neapply ext_reserve_trav_step.\neconstructor; eauto."},{"statement":"(e : actid) (TS_RES : ext_itrav_step G sc (mkTL ta_reserve e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_reserve e)) (ets_issue_W_ex : W_ex (event (mkTL ta_reserve e)) ->\naction (mkTL ta_reserve e) = ta_issue ->\nT (ta_reserve, event (mkTL ta_reserve e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_reserve e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve e) T) : exists T'' : trav_label -> Prop, ext_sim_trav_step T T''.","proofString":"eexists.\neexists.\neapply ext_reserve_trav_step.\neconstructor; eauto."},{"statement":"(t : thread_id) (e : actid) (TS_PROP : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') : exists T'' : trav_label -> Prop, ext_sim_trav_step T T''.","proofString":"inversion TS_PROP.\neexists.\neexists.\neapply ext_propagation_trav_step.\neconstructor; eauto."},{"statement":"(t : thread_id) (e : actid) (TS_PROP : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL (ta_propagate t) e)) (ets_issue_W_ex : W_ex (event (mkTL (ta_propagate t) e)) ->\naction (mkTL (ta_propagate t) e) = ta_issue ->\nT (ta_reserve, event (mkTL (ta_propagate t) e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T) : exists T'' : trav_label -> Prop, ext_sim_trav_step T T''.","proofString":"eexists.\neexists.\neapply ext_propagation_trav_step.\neconstructor; eauto."}]}