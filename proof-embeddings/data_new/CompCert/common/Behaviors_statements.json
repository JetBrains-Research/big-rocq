{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Behaviors.v","fileSamples":[{"statement":"(t1 t2 : trace) (beh : program_behavior) : behavior_app (t1 ** t2) beh = behavior_app t1 (behavior_app t2 beh).","conclusion":"behavior_app (t1 ** t2) beh = behavior_app t1 (behavior_app t2 beh)","hypotheses":"(t1 t2 : trace) (beh : program_behavior)","proofString":"destruct beh; simpl; f_equal; traceEq."},{"statement":"(beh1 beh2 beh3 : program_behavior) (H : behavior_improves beh1 beh2) (H0 : behavior_improves beh2 beh3) : behavior_improves beh1 beh3.","conclusion":"behavior_improves beh1 beh3","hypotheses":"(beh1 beh2 beh3 : program_behavior) (H : behavior_improves beh1 beh2) (H0 : behavior_improves beh2 beh3)","proofString":"red.\ndestruct H; destruct H0; subst; auto.\ndestruct H as [t1 [EQ1 [beh2' EQ1']]].\ndestruct H0 as [t2 [EQ2 [beh3' EQ2']]].\nsubst.\ndestruct beh2'; simpl in EQ2; try discriminate.\ninv EQ2.\nright.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(beh1 beh2 beh3 : program_behavior) (H : behavior_improves beh1 beh2) (H0 : behavior_improves beh2 beh3) : beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3).","conclusion":"beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3)","hypotheses":"(beh1 beh2 beh3 : program_behavior) (H : behavior_improves beh1 beh2) (H0 : behavior_improves beh2 beh3)","proofString":"destruct H; destruct H0; subst; auto.\ndestruct H as [t1 [EQ1 [beh2' EQ1']]].\ndestruct H0 as [t2 [EQ2 [beh3' EQ2']]].\nsubst.\ndestruct beh2'; simpl in EQ2; try discriminate.\ninv EQ2.\nright.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(beh1 beh2 beh3 : program_behavior) (H : exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh2) (H0 : exists t : trace, beh2 = Goes_wrong t /\\ behavior_prefix t beh3) : beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3).","conclusion":"beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3)","hypotheses":"(beh1 beh2 beh3 : program_behavior) (H : exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh2) (H0 : exists t : trace, beh2 = Goes_wrong t /\\ behavior_prefix t beh3)","proofString":"destruct H as [t1 [EQ1 [beh2' EQ1']]].\ndestruct H0 as [t2 [EQ2 [beh3' EQ2']]].\nsubst.\ndestruct beh2'; simpl in EQ2; try discriminate.\ninv EQ2.\nright.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(beh1 beh2 beh3 : program_behavior) (t1 : trace) (EQ1 : beh1 = Goes_wrong t1) (beh2' : program_behavior) (EQ1' : beh2 = behavior_app t1 beh2') (H0 : exists t : trace, beh2 = Goes_wrong t /\\ behavior_prefix t beh3) : beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3).","conclusion":"beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3)","hypotheses":"(beh1 beh2 beh3 : program_behavior) (t1 : trace) (EQ1 : beh1 = Goes_wrong t1) (beh2' : program_behavior) (EQ1' : beh2 = behavior_app t1 beh2') (H0 : exists t : trace, beh2 = Goes_wrong t /\\ behavior_prefix t beh3)","proofString":"destruct H0 as [t2 [EQ2 [beh3' EQ2']]].\nsubst.\ndestruct beh2'; simpl in EQ2; try discriminate.\ninv EQ2.\nright.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(beh1 beh2 beh3 : program_behavior) (t1 : trace) (EQ1 : beh1 = Goes_wrong t1) (beh2' : program_behavior) (EQ1' : beh2 = behavior_app t1 beh2') (t2 : trace) (EQ2 : beh2 = Goes_wrong t2) (beh3' : program_behavior) (EQ2' : beh3 = behavior_app t2 beh3') : beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3).","conclusion":"beh1 = beh3 \\/\n(exists t : trace, beh1 = Goes_wrong t /\\ behavior_prefix t beh3)","hypotheses":"(beh1 beh2 beh3 : program_behavior) (t1 : trace) (EQ1 : beh1 = Goes_wrong t1) (beh2' : program_behavior) (EQ1' : beh2 = behavior_app t1 beh2') (t2 : trace) (EQ2 : beh2 = Goes_wrong t2) (beh3' : program_behavior) (EQ2' : beh3 = behavior_app t2 beh3')","proofString":"subst.\ndestruct beh2'; simpl in EQ2; try discriminate.\ninv EQ2.\nright.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(t1 : trace) (beh2' : program_behavior) (t2 : trace) (EQ2 : behavior_app t1 beh2' = Goes_wrong t2) (beh3' : program_behavior) : Goes_wrong t1 = behavior_app t2 beh3' \\/\n(exists t : trace,\n   Goes_wrong t1 = Goes_wrong t /\\ behavior_prefix t (behavior_app t2 beh3')).","conclusion":"Goes_wrong t1 = behavior_app t2 beh3' \\/\n(exists t : trace,\n   Goes_wrong t1 = Goes_wrong t /\\ behavior_prefix t (behavior_app t2 beh3'))","hypotheses":"(t1 : trace) (beh2' : program_behavior) (t2 : trace) (EQ2 : behavior_app t1 beh2' = Goes_wrong t2) (beh3' : program_behavior)","proofString":"destruct beh2'; simpl in EQ2; try discriminate.\ninv EQ2.\nright.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(t1 t t2 : trace) (EQ2 : Goes_wrong (t1 ** t) = Goes_wrong t2) (beh3' : program_behavior) : Goes_wrong t1 = behavior_app t2 beh3' \\/\n(exists t0 : trace,\n   Goes_wrong t1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t2 beh3')).","conclusion":"Goes_wrong t1 = behavior_app t2 beh3' \\/\n(exists t0 : trace,\n   Goes_wrong t1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t2 beh3'))","hypotheses":"(t1 t t2 : trace) (EQ2 : Goes_wrong (t1 ** t) = Goes_wrong t2) (beh3' : program_behavior)","proofString":"inv EQ2.\nright.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(t1 t : trace) (beh3' : program_behavior) : Goes_wrong t1 = behavior_app (t1 ** t) beh3' \\/\n(exists t0 : trace,\n   Goes_wrong t1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app (t1 ** t) beh3')).","conclusion":"Goes_wrong t1 = behavior_app (t1 ** t) beh3' \\/\n(exists t0 : trace,\n   Goes_wrong t1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app (t1 ** t) beh3'))","hypotheses":"(t1 t : trace) (beh3' : program_behavior)","proofString":"right.\nexists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(t1 t : trace) (beh3' : program_behavior) : exists t0 : trace,\n  Goes_wrong t1 = Goes_wrong t0 /\\\n  behavior_prefix t0 (behavior_app (t1 ** t) beh3').","conclusion":"exists t0 : trace,\n  Goes_wrong t1 = Goes_wrong t0 /\\\n  behavior_prefix t0 (behavior_app (t1 ** t) beh3')","hypotheses":"(t1 t : trace) (beh3' : program_behavior)","proofString":"exists t1; split; auto.\nexists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(t1 t : trace) (beh3' : program_behavior) : behavior_prefix t1 (behavior_app (t1 ** t) beh3').","conclusion":"behavior_prefix t1 (behavior_app (t1 ** t) beh3')","hypotheses":"(t1 t : trace) (beh3' : program_behavior)","proofString":"exists (behavior_app t beh3').\napply behavior_app_assoc."},{"statement":"(t1 t : trace) (beh3' : program_behavior) : behavior_app (t1 ** t) beh3' = behavior_app t1 (behavior_app t beh3').","conclusion":"behavior_app (t1 ** t) beh3' = behavior_app t1 (behavior_app t beh3')","hypotheses":"(t1 t : trace) (beh3' : program_behavior)","proofString":"apply behavior_app_assoc."},{"statement":"(beh : program_behavior) : behavior_improves (Goes_wrong E0) beh.","conclusion":"behavior_improves (Goes_wrong E0) beh","hypotheses":"(beh : program_behavior)","proofString":"right.\nexists E0; split; auto.\nexists beh.\nrewrite behavior_app_E0; auto."},{"statement":"(beh : program_behavior) : exists t : trace, Goes_wrong E0 = Goes_wrong t /\\ behavior_prefix t beh.","conclusion":"exists t : trace, Goes_wrong E0 = Goes_wrong t /\\ behavior_prefix t beh","hypotheses":"(beh : program_behavior)","proofString":"exists E0; split; auto.\nexists beh.\nrewrite behavior_app_E0; auto."},{"statement":"(beh : program_behavior) : behavior_prefix E0 beh.","conclusion":"behavior_prefix E0 beh","hypotheses":"(beh : program_behavior)","proofString":"exists beh.\nrewrite behavior_app_E0; auto."},{"statement":"(beh : program_behavior) : beh = behavior_app E0 beh.","conclusion":"beh = behavior_app E0 beh","hypotheses":"(beh : program_behavior)","proofString":"rewrite behavior_app_E0; auto."},{"statement":"(t : trace) (beh1 beh2 : program_behavior) (H : behavior_improves beh1 beh2) : behavior_improves (behavior_app t beh1) (behavior_app t beh2).","conclusion":"behavior_improves (behavior_app t beh1) (behavior_app t beh2)","hypotheses":"(t : trace) (beh1 beh2 : program_behavior) (H : behavior_improves beh1 beh2)","proofString":"red; destruct H.\nleft; congruence.\ndestruct H as [t' [A [beh' B]]].\nsubst.\nright; exists (t ** t'); split; auto.\nexists beh'.\nrewrite behavior_app_assoc; auto."},{"statement":"(t : trace) (beh1 beh2 : program_behavior) (H : beh1 = beh2) : behavior_app t beh1 = behavior_app t beh2 \\/\n(exists t0 : trace,\n   behavior_app t beh1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t beh2)).","conclusion":"behavior_app t beh1 = behavior_app t beh2 \\/\n(exists t0 : trace,\n   behavior_app t beh1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t beh2))","hypotheses":"(t : trace) (beh1 beh2 : program_behavior) (H : beh1 = beh2)","proofString":"left; congruence."},{"statement":"(t : trace) (beh1 beh2 : program_behavior) (H : exists t0 : trace, beh1 = Goes_wrong t0 /\\ behavior_prefix t0 beh2) : behavior_app t beh1 = behavior_app t beh2 \\/\n(exists t0 : trace,\n   behavior_app t beh1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t beh2)).","conclusion":"behavior_app t beh1 = behavior_app t beh2 \\/\n(exists t0 : trace,\n   behavior_app t beh1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t beh2))","hypotheses":"(t : trace) (beh1 beh2 : program_behavior) (H : exists t0 : trace, beh1 = Goes_wrong t0 /\\ behavior_prefix t0 beh2)","proofString":"destruct H as [t' [A [beh' B]]].\nsubst.\nright; exists (t ** t'); split; auto.\nexists beh'.\nrewrite behavior_app_assoc; auto."},{"statement":"(t : trace) (beh1 beh2 : program_behavior) (t' : trace) (A : beh1 = Goes_wrong t') (beh' : program_behavior) (B : beh2 = behavior_app t' beh') : behavior_app t beh1 = behavior_app t beh2 \\/\n(exists t0 : trace,\n   behavior_app t beh1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t beh2)).","conclusion":"behavior_app t beh1 = behavior_app t beh2 \\/\n(exists t0 : trace,\n   behavior_app t beh1 = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t beh2))","hypotheses":"(t : trace) (beh1 beh2 : program_behavior) (t' : trace) (A : beh1 = Goes_wrong t') (beh' : program_behavior) (B : beh2 = behavior_app t' beh')","proofString":"subst.\nright; exists (t ** t'); split; auto.\nexists beh'.\nrewrite behavior_app_assoc; auto."},{"statement":"(t t' : trace) (beh' : program_behavior) : behavior_app t (Goes_wrong t') = behavior_app t (behavior_app t' beh') \\/\n(exists t0 : trace,\n   behavior_app t (Goes_wrong t') = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t (behavior_app t' beh'))).","conclusion":"behavior_app t (Goes_wrong t') = behavior_app t (behavior_app t' beh') \\/\n(exists t0 : trace,\n   behavior_app t (Goes_wrong t') = Goes_wrong t0 /\\\n   behavior_prefix t0 (behavior_app t (behavior_app t' beh')))","hypotheses":"(t t' : trace) (beh' : program_behavior)","proofString":"right; exists (t ** t'); split; auto.\nexists beh'.\nrewrite behavior_app_assoc; auto."},{"statement":"(t t' : trace) (beh' : program_behavior) : behavior_prefix (t ** t') (behavior_app t (behavior_app t' beh')).","conclusion":"behavior_prefix (t ** t') (behavior_app t (behavior_app t' beh'))","hypotheses":"(t t' : trace) (beh' : program_behavior)","proofString":"exists beh'.\nrewrite behavior_app_assoc; auto."},{"statement":"(t t' : trace) (beh' : program_behavior) : behavior_app t (behavior_app t' beh') = behavior_app (t ** t') beh'.","conclusion":"behavior_app t (behavior_app t' beh') = behavior_app (t ** t') beh'","hypotheses":"(t t' : trace) (beh' : program_behavior)","proofString":"rewrite behavior_app_assoc; auto."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (beh : program_behavior) (H : Star L s1 t s2) (H0 : state_behaves s2 beh) : state_behaves s1 (behavior_app t beh).","conclusion":"state_behaves s1 (behavior_app t beh)","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (beh : program_behavior) (H : Star L s1 t s2) (H0 : state_behaves s2 beh)","proofString":"inv H0; simpl; econstructor; eauto; try (eapply star_trans; eauto).\neapply star_forever_reactive; eauto."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : Star L s1 t s2) (T : traceinf) (H1 : Forever_reactive L s2 T) : Forever_reactive L s1 (t *** T).","conclusion":"Forever_reactive L s1 (t *** T)","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : Star L s1 t s2) (T : traceinf) (H1 : Forever_reactive L s2 T)","proofString":"eapply star_forever_reactive; eauto."},{"statement":"(s1 : state L) (t1 : trace) (H : Star L s0 t1 s1) : {s2 : state L & {t2 : trace | Star L s1 t2 s2 /\\ t2 <> E0}}.","conclusion":"{s2 : state L & {t2 : trace | Star L s1 t2 s2 /\\ t2 <> E0}}","hypotheses":"(s1 : state L) (t1 : trace) (H : Star L s0 t1 s1)","proofString":"destruct (constructive_indefinite_description _ (reacts H)) as [s2 A].\ndestruct (constructive_indefinite_description _ A) as [t2 [B C]].\nexists s2; exists t2; auto."},{"statement":"(s1 : state L) (t1 : trace) (H : Star L s0 t1 s1) (s2 : state L) (A : exists t2 : trace, Star L s1 t2 s2 /\\ t2 <> E0) : {s3 : state L & {t2 : trace | Star L s1 t2 s3 /\\ t2 <> E0}}.","conclusion":"{s3 : state L & {t2 : trace | Star L s1 t2 s3 /\\ t2 <> E0}}","hypotheses":"(s1 : state L) (t1 : trace) (H : Star L s0 t1 s1) (s2 : state L) (A : exists t2 : trace, Star L s1 t2 s2 /\\ t2 <> E0)","proofString":"destruct (constructive_indefinite_description _ A) as [t2 [B C]].\nexists s2; exists t2; auto."},{"statement":"(s1 : state L) (t1 : trace) (H : Star L s0 t1 s1) (s2 : state L) (A : exists t0 : trace, Star L s1 t0 s2 /\\ t0 <> E0) (t2 : trace) (B : Star L s1 t2 s2) (C : t2 <> E0) : {s3 : state L & {t0 : trace | Star L s1 t0 s3 /\\ t0 <> E0}}.","conclusion":"{s3 : state L & {t0 : trace | Star L s1 t0 s3 /\\ t0 <> E0}}","hypotheses":"(s1 : state L) (t1 : trace) (H : Star L s0 t1 s1) (s2 : state L) (A : exists t0 : trace, Star L s1 t0 s2 /\\ t0 <> E0) (t2 : trace) (B : Star L s1 t2 s2) (C : t2 <> E0)","proofString":"exists s2; exists t2; auto."},{"statement":"(COINDHYP : forall (s2 : state L) (t0 : trace) (ST0 : Star L s0 t0 s2),\nForever_reactive L s2 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) : Forever_reactive L s1 (traceinf_of_traceinf' (build_traceinf' ST)).","conclusion":"Forever_reactive L s1 (traceinf_of_traceinf' (build_traceinf' ST))","hypotheses":"(COINDHYP : forall (s2 : state L) (t0 : trace) (ST0 : Star L s0 t0 s2),\nForever_reactive L s2 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1)","proofString":"rewrite (unroll_traceinf' (build_traceinf' ST)).\nsimpl.\ndestruct (reacts' ST) as [s2 [t2 [A B]]].\nrewrite traceinf_traceinf'_app.\neconstructor.\neexact A.\nauto.\napply COINDHYP."},{"statement":"(COINDHYP : forall (s2 : state L) (t0 : trace) (ST0 : Star L s0 t0 s2),\nForever_reactive L s2 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) : Forever_reactive L s1\n  (traceinf_of_traceinf'\n     match build_traceinf' ST with\n     | Econsinf' t T' NE => Econsinf' t T' NE\n     end).","conclusion":"Forever_reactive L s1\n  (traceinf_of_traceinf'\n     match build_traceinf' ST with\n     | Econsinf' t T' NE => Econsinf' t T' NE\n     end)","hypotheses":"(COINDHYP : forall (s2 : state L) (t0 : trace) (ST0 : Star L s0 t0 s2),\nForever_reactive L s2 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1)","proofString":"simpl.\ndestruct (reacts' ST) as [s2 [t2 [A B]]].\nrewrite traceinf_traceinf'_app.\neconstructor.\neexact A.\nauto.\napply COINDHYP."},{"statement":"(COINDHYP : forall (s2 : state L) (t0 : trace) (ST0 : Star L s0 t0 s2),\nForever_reactive L s2 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) : Forever_reactive L s1\n  (traceinf_of_traceinf'\n     match\n       (let (s2, s) := reacts' ST in\n        let (t2, a) := s in\n        match a with\n        | conj A B =>\n            Econsinf' t2 (build_traceinf' (star_trans ST A eq_refl)) B\n        end)\n     with\n     | Econsinf' t T' NE => Econsinf' t T' NE\n     end).","conclusion":"Forever_reactive L s1\n  (traceinf_of_traceinf'\n     match\n       (let (s2, s) := reacts' ST in\n        let (t2, a) := s in\n        match a with\n        | conj A B =>\n            Econsinf' t2 (build_traceinf' (star_trans ST A eq_refl)) B\n        end)\n     with\n     | Econsinf' t T' NE => Econsinf' t T' NE\n     end)","hypotheses":"(COINDHYP : forall (s2 : state L) (t0 : trace) (ST0 : Star L s0 t0 s2),\nForever_reactive L s2 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1)","proofString":"destruct (reacts' ST) as [s2 [t2 [A B]]].\nrewrite traceinf_traceinf'_app.\neconstructor.\neexact A.\nauto.\napply COINDHYP."},{"statement":"(COINDHYP : forall (s3 : state L) (t0 : trace) (ST0 : Star L s0 t0 s3),\nForever_reactive L s3 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) (s2 : state L) (t2 : trace) (A : Star L s1 t2 s2) (B : t2 <> E0) : Forever_reactive L s1\n  (traceinf_of_traceinf'\n     (Econsinf' t2 (build_traceinf' (star_trans ST A eq_refl)) B)).","conclusion":"Forever_reactive L s1\n  (traceinf_of_traceinf'\n     (Econsinf' t2 (build_traceinf' (star_trans ST A eq_refl)) B))","hypotheses":"(COINDHYP : forall (s3 : state L) (t0 : trace) (ST0 : Star L s0 t0 s3),\nForever_reactive L s3 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) (s2 : state L) (t2 : trace) (A : Star L s1 t2 s2) (B : t2 <> E0)","proofString":"rewrite traceinf_traceinf'_app.\neconstructor.\neexact A.\nauto.\napply COINDHYP."},{"statement":"(COINDHYP : forall (s3 : state L) (t0 : trace) (ST0 : Star L s0 t0 s3),\nForever_reactive L s3 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) (s2 : state L) (t2 : trace) (A : Star L s1 t2 s2) (B : t2 <> E0) : Forever_reactive L s1\n  (t2 *** traceinf_of_traceinf' (build_traceinf' (star_trans ST A eq_refl))).","conclusion":"Forever_reactive L s1\n  (t2 *** traceinf_of_traceinf' (build_traceinf' (star_trans ST A eq_refl)))","hypotheses":"(COINDHYP : forall (s3 : state L) (t0 : trace) (ST0 : Star L s0 t0 s3),\nForever_reactive L s3 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) (s2 : state L) (t2 : trace) (A : Star L s1 t2 s2) (B : t2 <> E0)","proofString":"econstructor.\neexact A.\nauto.\napply COINDHYP."},{"statement":"(COINDHYP : forall (s3 : state L) (t0 : trace) (ST0 : Star L s0 t0 s3),\nForever_reactive L s3 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) (s2 : state L) (t2 : trace) (A : Star L s1 t2 s2) (B : t2 <> E0) : t2 <> E0.","conclusion":"t2 <> E0","hypotheses":"(COINDHYP : forall (s3 : state L) (t0 : trace) (ST0 : Star L s0 t0 s3),\nForever_reactive L s3 (traceinf_of_traceinf' (build_traceinf' ST0))) (s1 : state L) (t1 : trace) (ST : Star L s0 t1 s1) (s2 : state L) (t2 : trace) (A : Star L s1 t2 s2) (B : t2 <> E0)","proofString":"auto."},{"statement":"Forever_reactive L s0\n  (traceinf_of_traceinf'\n     (build_traceinf' (star_refl (step L) (globalenv L) s0))).","conclusion":"Forever_reactive L s0\n  (traceinf_of_traceinf'\n     (build_traceinf' (star_refl (step L) (globalenv L) s0)))","hypotheses":"","proofString":"apply reacts_forever_reactive_rec."},{"statement":"(COINDHYP : forall s1 : state L,\n(forall (s2 : state L) (t1 : trace),\n Star L s1 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) ->\nForever_silent L s1) (s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists s2 : state L, Step L s1 E0 s2) : Forever_silent L s0.","conclusion":"Forever_silent L s0","hypotheses":"(COINDHYP : forall s1 : state L,\n(forall (s2 : state L) (t1 : trace),\n Star L s1 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) ->\nForever_silent L s1) (s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists s2 : state L, Step L s1 E0 s2)","proofString":"destruct (H s0 E0) as [s1 ST].\nconstructor.\neconstructor.\neexact ST.\napply COINDHYP.\nintros.\neapply H.\neapply star_left; eauto."},{"statement":"(COINDHYP : forall s1 : state L,\n(forall (s2 : state L) (t1 : trace),\n Star L s1 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) ->\nForever_silent L s1) (s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists s2 : state L, Step L s1 E0 s2) : Star L s0 E0 s0.","conclusion":"Star L s0 E0 s0","hypotheses":"(COINDHYP : forall s1 : state L,\n(forall (s2 : state L) (t1 : trace),\n Star L s1 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) ->\nForever_silent L s1) (s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists s2 : state L, Step L s1 E0 s2)","proofString":"constructor."},{"statement":"(COINDHYP : forall s2 : state L,\n(forall (s3 : state L) (t1 : trace),\n Star L s2 t1 s3 -> exists s4 : state L, Step L s3 E0 s4) ->\nForever_silent L s2) (s0 : state L) (H : forall (s2 : state L) (t1 : trace),\nStar L s0 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) (s1 : state L) (ST : Step L s0 E0 s1) : Forever_silent L s0.","conclusion":"Forever_silent L s0","hypotheses":"(COINDHYP : forall s2 : state L,\n(forall (s3 : state L) (t1 : trace),\n Star L s2 t1 s3 -> exists s4 : state L, Step L s3 E0 s4) ->\nForever_silent L s2) (s0 : state L) (H : forall (s2 : state L) (t1 : trace),\nStar L s0 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) (s1 : state L) (ST : Step L s0 E0 s1)","proofString":"econstructor.\neexact ST.\napply COINDHYP.\nintros.\neapply H.\neapply star_left; eauto."},{"statement":"(COINDHYP : forall s2 : state L,\n(forall (s3 : state L) (t1 : trace),\n Star L s2 t1 s3 -> exists s4 : state L, Step L s3 E0 s4) ->\nForever_silent L s2) (s0 : state L) (H : forall (s2 : state L) (t1 : trace),\nStar L s0 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) (s1 : state L) (ST : Step L s0 E0 s1) : forall (s2 : state L) (t1 : trace),\nStar L s1 t1 s2 -> exists s3 : state L, Step L s2 E0 s3.","conclusion":"forall (s2 : state L) (t1 : trace),\nStar L s1 t1 s2 -> exists s3 : state L, Step L s2 E0 s3","hypotheses":"(COINDHYP : forall s2 : state L,\n(forall (s3 : state L) (t1 : trace),\n Star L s2 t1 s3 -> exists s4 : state L, Step L s3 E0 s4) ->\nForever_silent L s2) (s0 : state L) (H : forall (s2 : state L) (t1 : trace),\nStar L s0 t1 s2 -> exists s3 : state L, Step L s2 E0 s3) (s1 : state L) (ST : Step L s0 E0 s1)","proofString":"intros.\neapply H.\neapply star_left; eauto."},{"statement":"(COINDHYP : forall s3 : state L,\n(forall (s4 : state L) (t2 : trace),\n Star L s3 t2 s4 -> exists s5 : state L, Step L s4 E0 s5) ->\nForever_silent L s3) (s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists s4 : state L, Step L s3 E0 s4) (s1 : state L) (ST : Step L s0 E0 s1) (s2 : state L) (t1 : trace) (H0 : Star L s1 t1 s2) : exists s3 : state L, Step L s2 E0 s3.","conclusion":"exists s3 : state L, Step L s2 E0 s3","hypotheses":"(COINDHYP : forall s3 : state L,\n(forall (s4 : state L) (t2 : trace),\n Star L s3 t2 s4 -> exists s5 : state L, Step L s4 E0 s5) ->\nForever_silent L s3) (s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists s4 : state L, Step L s3 E0 s4) (s1 : state L) (ST : Step L s0 E0 s1) (s2 : state L) (t1 : trace) (H0 : Star L s1 t1 s2)","proofString":"eapply H.\neapply star_left; eauto."},{"statement":"(s0 : state L) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 : state L)","proofString":"destruct (classic (forall s1 t1, Star L s0 t1 s1 -> exists s2, exists t2, Step L s1 t2 s2)).\ndestruct (classic (exists s1, exists t1, Star L s0 t1 s1 /\\                       (forall s2 t2, Star L s1 t2 s2 ->                        exists s3, Step L s2 E0 s3))).\ndestruct H0 as [s1 [t1 [A B]]].\nexists (Diverges t1); econstructor; eauto.\napply diverges_forever_silent; auto.\ndestruct (@reacts_forever_reactive s0) as [T FR].\nintros.\ngeneralize (not_ex_all_not _ _ H0 s1).\nintro A; clear H0.\ngeneralize (not_ex_all_not _ _ A t1).\nintro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto.\nexists (Reacts T); econstructor; eauto.\ndestruct (not_all_ex_not _ _ H) as [s1 A]; clear H.\ndestruct (not_all_ex_not _ _ A) as [t1 B]; clear A.\ndestruct (imply_to_and _ _ B) as [C D]; clear B.\ndestruct (classic (exists r, final_state L s1 r)) as [[r FINAL] | NOTFINAL].\nexists (Terminates t1 r); econstructor; eauto.\nexists (Goes_wrong t1); econstructor; eauto.\nred.\nintros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)","proofString":"destruct (classic (exists s1, exists t1, Star L s0 t1 s1 /\\                       (forall s2 t2, Star L s1 t2 s2 ->                        exists s3, Step L s2 E0 s3))).\ndestruct H0 as [s1 [t1 [A B]]].\nexists (Diverges t1); econstructor; eauto.\napply diverges_forever_silent; auto.\ndestruct (@reacts_forever_reactive s0) as [T FR].\nintros.\ngeneralize (not_ex_all_not _ _ H0 s1).\nintro A; clear H0.\ngeneralize (not_ex_all_not _ _ A t1).\nintro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto.\nexists (Reacts T); econstructor; eauto."},{"statement":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : exists (s1 : state L) (t1 : trace),\n  Star L s0 t1 s1 /\\\n  (forall (s2 : state L) (t2 : trace),\n   Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : exists (s1 : state L) (t1 : trace),\n  Star L s0 t1 s1 /\\\n  (forall (s2 : state L) (t2 : trace),\n   Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))","proofString":"destruct H0 as [s1 [t1 [A B]]].\nexists (Diverges t1); econstructor; eauto.\napply diverges_forever_silent; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (A : Star L s0 t1 s1) (B : forall (s2 : state L) (t2 : trace),\nStar L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (A : Star L s0 t1 s1) (B : forall (s2 : state L) (t2 : trace),\nStar L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)","proofString":"exists (Diverges t1); econstructor; eauto.\napply diverges_forever_silent; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (A : Star L s0 t1 s1) (B : forall (s2 : state L) (t2 : trace),\nStar L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3) : Forever_silent L s1.","conclusion":"Forever_silent L s1","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (A : Star L s0 t1 s1) (B : forall (s2 : state L) (t2 : trace),\nStar L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)","proofString":"apply diverges_forever_silent; auto."},{"statement":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : ~\n(exists (s1 : state L) (t1 : trace),\n   Star L s0 t1 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : ~\n(exists (s1 : state L) (t1 : trace),\n   Star L s0 t1 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)))","proofString":"destruct (@reacts_forever_reactive s0) as [T FR].\nintros.\ngeneralize (not_ex_all_not _ _ H0 s1).\nintro A; clear H0.\ngeneralize (not_ex_all_not _ _ A t1).\nintro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto.\nexists (Reacts T); econstructor; eauto."},{"statement":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : ~\n(exists (s1 : state L) (t1 : trace),\n   Star L s0 t1 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 ->\nexists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 ->\nexists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : ~\n(exists (s1 : state L) (t1 : trace),\n   Star L s0 t1 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)))","proofString":"intros.\ngeneralize (not_ex_all_not _ _ H0 s1).\nintro A; clear H0.\ngeneralize (not_ex_all_not _ _ A t1).\nintro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (H0 : ~\n(exists (s2 : state L) (t0 : trace),\n   Star L s0 t0 s2 /\\\n   (forall (s3 : state L) (t2 : trace),\n    Star L s2 t2 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) : exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (H0 : ~\n(exists (s2 : state L) (t0 : trace),\n   Star L s0 t0 s2 /\\\n   (forall (s3 : state L) (t2 : trace),\n    Star L s2 t2 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1)","proofString":"generalize (not_ex_all_not _ _ H0 s1).\nintro A; clear H0.\ngeneralize (not_ex_all_not _ _ A t1).\nintro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (H0 : ~\n(exists (s2 : state L) (t0 : trace),\n   Star L s0 t0 s2 /\\\n   (forall (s3 : state L) (t2 : trace),\n    Star L s2 t2 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) : ~\n(exists t2 : trace,\n   Star L s0 t2 s1 /\\\n   (forall (s2 : state L) (t3 : trace),\n    Star L s1 t3 s2 -> exists s3 : state L, Step L s2 E0 s3)) ->\nexists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"~\n(exists t2 : trace,\n   Star L s0 t2 s1 /\\\n   (forall (s2 : state L) (t3 : trace),\n    Star L s1 t3 s2 -> exists s3 : state L, Step L s2 E0 s3)) ->\nexists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (H0 : ~\n(exists (s2 : state L) (t0 : trace),\n   Star L s0 t0 s2 /\\\n   (forall (s3 : state L) (t2 : trace),\n    Star L s2 t2 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1)","proofString":"intro A; clear H0.\ngeneralize (not_ex_all_not _ _ A t1).\nintro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (A : ~\n(exists t0 : trace,\n   Star L s0 t0 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) : exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (A : ~\n(exists t0 : trace,\n   Star L s0 t0 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)))","proofString":"generalize (not_ex_all_not _ _ A t1).\nintro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (A : ~\n(exists t0 : trace,\n   Star L s0 t0 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) : ~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)) ->\nexists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)) ->\nexists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (A : ~\n(exists t0 : trace,\n   Star L s0 t0 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)))","proofString":"intro B; clear A.\ndestruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) : exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)))","proofString":"destruct (not_and_or _ _ B).\ncontradiction.\ndestruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) (H0 : ~ Star L s0 t1 s1) : exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) (H0 : ~ Star L s0 t1 s1)","proofString":"contradiction."},{"statement":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) (H0 : ~\n(forall (s2 : state L) (t2 : trace),\n Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)) : exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0.","conclusion":"exists (s2 : state L) (t2 : trace), Star L s1 t2 s2 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s2 : state L) (t0 : trace),\nStar L s0 t0 s2 -> exists (s3 : state L) (t2 : trace), Step L s2 t2 s3) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s2 : state L) (t2 : trace),\n  Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) (H0 : ~\n(forall (s2 : state L) (t2 : trace),\n Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))","proofString":"destruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.\ndestruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t2 : trace), Step L s3 t2 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t2 : trace),\n  Star L s1 t2 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (C : ~\n(forall t2 : trace, Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)) : exists (s3 : state L) (t2 : trace), Star L s1 t2 s3 /\\ t2 <> E0.","conclusion":"exists (s3 : state L) (t2 : trace), Star L s1 t2 s3 /\\ t2 <> E0","hypotheses":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t2 : trace), Step L s3 t2 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t2 : trace),\n  Star L s1 t2 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (C : ~\n(forall t2 : trace, Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))","proofString":"destruct (not_all_ex_not _ _ C) as [t2 D]; clear C.\ndestruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t3 : trace), Step L s3 t3 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t0 : trace),\n  Star L s1 t0 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (t2 : trace) (D : ~ (Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3)) : exists (s3 : state L) (t0 : trace), Star L s1 t0 s3 /\\ t0 <> E0.","conclusion":"exists (s3 : state L) (t0 : trace), Star L s1 t0 s3 /\\ t0 <> E0","hypotheses":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t3 : trace), Step L s3 t3 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t0 : trace),\n  Star L s1 t0 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (t2 : trace) (D : ~ (Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))","proofString":"destruct (imply_to_and _ _ D) as [E F]; clear D.\ndestruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t3 : trace), Step L s3 t3 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t0 : trace),\n  Star L s1 t0 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s3 : state L, Step L s2 E0 s3)) : exists (s3 : state L) (t0 : trace), Star L s1 t0 s3 /\\ t0 <> E0.","conclusion":"exists (s3 : state L) (t0 : trace), Star L s1 t0 s3 /\\ t0 <> E0","hypotheses":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t3 : trace), Step L s3 t3 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t0 : trace),\n  Star L s1 t0 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s3 : state L, Step L s2 E0 s3))","proofString":"destruct (H s2 (t1 ** t2)) as [s3 [t3 G]].\neapply star_trans; eauto.\nexists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t3 : trace), Step L s3 t3 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t0 : trace),\n  Star L s1 t0 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s3 : state L, Step L s2 E0 s3)) : Star L s0 (t1 ** t2) s2.","conclusion":"Star L s0 (t1 ** t2) s2","hypotheses":"(s0 : state L) (H : forall (s3 : state L) (t0 : trace),\nStar L s0 t0 s3 -> exists (s4 : state L) (t3 : trace), Step L s3 t3 s4) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s3 : state L) (t0 : trace),\n  Star L s1 t0 s3 -> exists s4 : state L, Step L s3 E0 s4))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s3 : state L, Step L s2 E0 s3))","proofString":"eapply star_trans; eauto."},{"statement":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3) : exists (s4 : state L) (t0 : trace), Star L s1 t0 s4 /\\ t0 <> E0.","conclusion":"exists (s4 : state L) (t0 : trace), Star L s1 t0 s4 /\\ t0 <> E0","hypotheses":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3)","proofString":"exists s3; exists (t2 ** t3); split.\neapply star_right; eauto.\nred; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3) : Star L s1 (t2 ** t3) s3.","conclusion":"Star L s1 (t2 ** t3) s3","hypotheses":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3)","proofString":"eapply star_right; eauto."},{"statement":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3) : t2 ** t3 <> E0.","conclusion":"t2 ** t3 <> E0","hypotheses":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3)","proofString":"red; intros.\ndestruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3) (H0 : t2 ** t3 = E0) : False.","conclusion":"False","hypotheses":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3) (H0 : t2 ** t3 = E0)","proofString":"destruct (app_eq_nil t2 t3 H0).\nsubst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3) (H0 : t2 ** t3 = E0) (H2 : t2 = nil) (H3 : t3 = nil) : False.","conclusion":"False","hypotheses":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t4 : trace), Step L s4 t4 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t0 : trace),\n  Star L s1 t0 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (t2 : trace) (E : Star L s1 t2 s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (t3 : trace) (G : Step L s2 t3 s3) (H0 : t2 ** t3 = E0) (H2 : t2 = nil) (H3 : t3 = nil)","proofString":"subst.\nelim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t2 : trace), Step L s4 t2 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t2 : trace),\n  Star L s1 t2 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (E : Star L s1 nil s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (H0 : nil ** nil = E0) (G : Step L s2 nil s3) : False.","conclusion":"False","hypotheses":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t2 : trace), Step L s4 t2 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t2 : trace),\n  Star L s1 t2 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (E : Star L s1 nil s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (H0 : nil ** nil = E0) (G : Step L s2 nil s3)","proofString":"elim F.\nexists s3; auto."},{"statement":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t2 : trace), Step L s4 t2 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t2 : trace),\n  Star L s1 t2 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (E : Star L s1 nil s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (H0 : nil ** nil = E0) (G : Step L s2 nil s3) : exists s4 : state L, Step L s2 E0 s4.","conclusion":"exists s4 : state L, Step L s2 E0 s4","hypotheses":"(s0 : state L) (H : forall (s4 : state L) (t0 : trace),\nStar L s0 t0 s4 -> exists (s5 : state L) (t2 : trace), Step L s4 t2 s5) (s1 : state L) (t1 : trace) (H1 : Star L s0 t1 s1) (B : ~\n(Star L s0 t1 s1 /\\\n (forall (s4 : state L) (t2 : trace),\n  Star L s1 t2 s4 -> exists s5 : state L, Step L s4 E0 s5))) (s2 : state L) (E : Star L s1 nil s2) (F : ~ (exists s4 : state L, Step L s2 E0 s4)) (s3 : state L) (H0 : nil ** nil = E0) (G : Step L s2 nil s3)","proofString":"exists s3; auto."},{"statement":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : ~\n(exists (s1 : state L) (t1 : trace),\n   Star L s0 t1 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) (T : traceinf) (FR : Forever_reactive L s0 T) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 : state L) (H : forall (s1 : state L) (t1 : trace),\nStar L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2) (H0 : ~\n(exists (s1 : state L) (t1 : trace),\n   Star L s0 t1 s1 /\\\n   (forall (s2 : state L) (t2 : trace),\n    Star L s1 t2 s2 -> exists s3 : state L, Step L s2 E0 s3))) (T : traceinf) (FR : Forever_reactive L s0 T)","proofString":"exists (Reacts T); econstructor; eauto."},{"statement":"(s0 : state L) (H : ~\n(forall (s1 : state L) (t1 : trace),\n Star L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 : state L) (H : ~\n(forall (s1 : state L) (t1 : trace),\n Star L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2))","proofString":"destruct (not_all_ex_not _ _ H) as [s1 A]; clear H.\ndestruct (not_all_ex_not _ _ A) as [t1 B]; clear A.\ndestruct (imply_to_and _ _ B) as [C D]; clear B.\ndestruct (classic (exists r, final_state L s1 r)) as [[r FINAL] | NOTFINAL].\nexists (Terminates t1 r); econstructor; eauto.\nexists (Goes_wrong t1); econstructor; eauto.\nred.\nintros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (A : ~\n(forall t1 : trace,\n Star L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 s1 : state L) (A : ~\n(forall t1 : trace,\n Star L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2))","proofString":"destruct (not_all_ex_not _ _ A) as [t1 B]; clear A.\ndestruct (imply_to_and _ _ B) as [C D]; clear B.\ndestruct (classic (exists r, final_state L s1 r)) as [[r FINAL] | NOTFINAL].\nexists (Terminates t1 r); econstructor; eauto.\nexists (Goes_wrong t1); econstructor; eauto.\nred.\nintros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (B : ~ (Star L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 s1 : state L) (t1 : trace) (B : ~ (Star L s0 t1 s1 -> exists (s2 : state L) (t2 : trace), Step L s1 t2 s2))","proofString":"destruct (imply_to_and _ _ B) as [C D]; clear B.\ndestruct (classic (exists r, final_state L s1 r)) as [[r FINAL] | NOTFINAL].\nexists (Terminates t1 r); econstructor; eauto.\nexists (Goes_wrong t1); econstructor; eauto.\nred.\nintros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2))","proofString":"destruct (classic (exists r, final_state L s1 r)) as [[r FINAL] | NOTFINAL].\nexists (Terminates t1 r); econstructor; eauto.\nexists (Goes_wrong t1); econstructor; eauto.\nred.\nintros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (r : int) (FINAL : final_state L s1 r) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (r : int) (FINAL : final_state L s1 r)","proofString":"exists (Terminates t1 r); econstructor; eauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) : exists beh : program_behavior, state_behaves s0 beh.","conclusion":"exists beh : program_behavior, state_behaves s0 beh","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r))","proofString":"exists (Goes_wrong t1); econstructor; eauto.\nred.\nintros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) : Nostep L s1.","conclusion":"Nostep L s1","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r))","proofString":"red.\nintros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) : forall (t : trace) (s' : state L), ~ Step L s1 t s'.","conclusion":"forall (t : trace) (s' : state L), ~ Step L s1 t s'","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r))","proofString":"intros.\ngeneralize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) (t : trace) (s' : state L) : ~ Step L s1 t s'.","conclusion":"~ Step L s1 t s'","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) (t : trace) (s' : state L)","proofString":"generalize (not_ex_all_not _ _ D s'); intros.\ngeneralize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) (t : trace) (s' : state L) (H : ~ (exists t2 : trace, Step L s1 t2 s')) : ~ Step L s1 t s'.","conclusion":"~ Step L s1 t s'","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) (t : trace) (s' : state L) (H : ~ (exists t2 : trace, Step L s1 t2 s'))","proofString":"generalize (not_ex_all_not _ _ H t); intros.\nauto."},{"statement":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) (t : trace) (s' : state L) (H : ~ (exists t2 : trace, Step L s1 t2 s')) (H0 : ~ Step L s1 t s') : ~ Step L s1 t s'.","conclusion":"~ Step L s1 t s'","hypotheses":"(s0 s1 : state L) (t1 : trace) (C : Star L s0 t1 s1) (D : ~ (exists (s2 : state L) (t2 : trace), Step L s1 t2 s2)) (NOTFINAL : ~ (exists r : int, final_state L s1 r)) (t : trace) (s' : state L) (H : ~ (exists t2 : trace, Step L s1 t2 s')) (H0 : ~ Step L s1 t s')","proofString":"auto."},{"statement":"(s0 : state L) (INIT : initial_state L s0) : exists beh : program_behavior, program_behaves beh.","conclusion":"exists beh : program_behavior, program_behaves beh","hypotheses":"(s0 : state L) (INIT : initial_state L s0)","proofString":"destruct (state_behaves_exists s0) as [beh SB].\nexists beh; econstructor; eauto."},{"statement":"(s0 : state L) (INIT : initial_state L s0) (beh : program_behavior) (SB : state_behaves s0 beh) : exists beh0 : program_behavior, program_behaves beh0.","conclusion":"exists beh0 : program_behavior, program_behaves beh0","hypotheses":"(s0 : state L) (INIT : initial_state L s0) (beh : program_behavior) (SB : state_behaves s0 beh)","proofString":"exists beh; econstructor; eauto."},{"statement":"(NOTINIT : ~ (exists s : state L, initial_state L s)) : exists beh : program_behavior, program_behaves beh.","conclusion":"exists beh : program_behavior, program_behaves beh","hypotheses":"(NOTINIT : ~ (exists s : state L, initial_state L s))","proofString":"exists (Goes_wrong E0).\napply program_goes_initially_wrong.\nintros.\neapply not_ex_all_not; eauto."},{"statement":"(NOTINIT : ~ (exists s : state L, initial_state L s)) : program_behaves (Goes_wrong E0).","conclusion":"program_behaves (Goes_wrong E0)","hypotheses":"(NOTINIT : ~ (exists s : state L, initial_state L s))","proofString":"apply program_goes_initially_wrong.\nintros.\neapply not_ex_all_not; eauto."},{"statement":"(NOTINIT : ~ (exists s : state L, initial_state L s)) : forall s : state L, ~ initial_state L s.","conclusion":"forall s : state L, ~ initial_state L s","hypotheses":"(NOTINIT : ~ (exists s : state L, initial_state L s))","proofString":"intros.\neapply not_ex_all_not; eauto."},{"statement":"(NOTINIT : ~ (exists s0 : state L, initial_state L s0)) (s : state L) : ~ initial_state L s.","conclusion":"~ initial_state L s","hypotheses":"(NOTINIT : ~ (exists s0 : state L, initial_state L s0)) (s : state L)","proofString":"eapply not_ex_all_not; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh1 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L1 s1 beh1) : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh1 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L1 s1 beh1)","proofString":"inv H0.\nexploit simulation_star; eauto.\nintros [i' [s2' [A B]]].\nexists (Terminates t r); split.\neconstructor; eauto.\neapply fsim_match_final_states; eauto.\napply behavior_improves_refl.\nexploit simulation_star; eauto.\nintros [i' [s2' [A B]]].\nexists (Diverges t); split.\neconstructor; eauto.\neapply simulation_forever_silent; eauto.\napply behavior_improves_refl.\nexists (Reacts T); split.\neconstructor.\neapply simulation_forever_reactive; eauto.\napply behavior_improves_refl.\nexploit simulation_star; eauto.\nintros [i' [s2' [A B]]].\ndestruct (state_behaves_exists L2 s2') as [beh' SB].\nexists (behavior_app t beh'); split.\neapply state_behaves_app; eauto.\nreplace (Goes_wrong t) with (behavior_app t (Goes_wrong E0)).\napply behavior_improves_app.\napply behavior_improves_bot.\nsimpl.\ndecEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Terminates t r) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Terminates t r) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r)","proofString":"exploit simulation_star; eauto.\nintros [i' [s2' [A B]]].\nexists (Terminates t r); split.\neconstructor; eauto.\neapply fsim_match_final_states; eauto.\napply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) : (exists (i' : index) (s2' : state L2),\n   Star L2 s2 t s2' /\\ match_states i' s' s2') ->\nexists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Terminates t r) beh2.","conclusion":"(exists (i' : index) (s2' : state L2),\n   Star L2 s2 t s2' /\\ match_states i' s' s2') ->\nexists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Terminates t r) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r)","proofString":"intros [i' [s2' [A B]]].\nexists (Terminates t r); split.\neconstructor; eauto.\neapply fsim_match_final_states; eauto.\napply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Terminates t r) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Terminates t r) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"exists (Terminates t r); split.\neconstructor; eauto.\neapply fsim_match_final_states; eauto.\napply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : state_behaves L2 s2 (Terminates t r).","conclusion":"state_behaves L2 s2 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"econstructor; eauto.\neapply fsim_match_final_states; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : final_state L2 s2' r.","conclusion":"final_state L2 s2' r","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"eapply fsim_match_final_states; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : behavior_improves (Terminates t r) (Terminates t r).","conclusion":"behavior_improves (Terminates t r) (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (r : int) (H1 : Star L1 s1 t s') (H2 : final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"apply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Diverges t) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Diverges t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s')","proofString":"exploit simulation_star; eauto.\nintros [i' [s2' [A B]]].\nexists (Diverges t); split.\neconstructor; eauto.\neapply simulation_forever_silent; eauto.\napply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') : (exists (i' : index) (s2' : state L2),\n   Star L2 s2 t s2' /\\ match_states i' s' s2') ->\nexists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Diverges t) beh2.","conclusion":"(exists (i' : index) (s2' : state L2),\n   Star L2 s2 t s2' /\\ match_states i' s' s2') ->\nexists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Diverges t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s')","proofString":"intros [i' [s2' [A B]]].\nexists (Diverges t); split.\neconstructor; eauto.\neapply simulation_forever_silent; eauto.\napply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Diverges t) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Diverges t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"exists (Diverges t); split.\neconstructor; eauto.\neapply simulation_forever_silent; eauto.\napply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : state_behaves L2 s2 (Diverges t).","conclusion":"state_behaves L2 s2 (Diverges t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"econstructor; eauto.\neapply simulation_forever_silent; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : Forever_silent L2 s2'.","conclusion":"Forever_silent L2 s2'","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"eapply simulation_forever_silent; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : behavior_improves (Diverges t) (Diverges t).","conclusion":"behavior_improves (Diverges t) (Diverges t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Forever_silent L1 s') (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"apply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T) : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Reacts T) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Reacts T) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T)","proofString":"exists (Reacts T); split.\neconstructor.\neapply simulation_forever_reactive; eauto.\napply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T) : state_behaves L2 s2 (Reacts T).","conclusion":"state_behaves L2 s2 (Reacts T)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T)","proofString":"econstructor.\neapply simulation_forever_reactive; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T) : Forever_reactive L2 s2 T.","conclusion":"Forever_reactive L2 s2 T","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T)","proofString":"eapply simulation_forever_reactive; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T) : behavior_improves (Reacts T) (Reacts T).","conclusion":"behavior_improves (Reacts T) (Reacts T)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : Forever_reactive L1 s1 T)","proofString":"apply behavior_improves_refl."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r)","proofString":"exploit simulation_star; eauto.\nintros [i' [s2' [A B]]].\ndestruct (state_behaves_exists L2 s2') as [beh' SB].\nexists (behavior_app t beh'); split.\neapply state_behaves_app; eauto.\nreplace (Goes_wrong t) with (behavior_app t (Goes_wrong E0)).\napply behavior_improves_app.\napply behavior_improves_bot.\nsimpl.\ndecEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) : (exists (i' : index) (s2' : state L2),\n   Star L2 s2 t s2' /\\ match_states i' s' s2') ->\nexists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2.","conclusion":"(exists (i' : index) (s2' : state L2),\n   Star L2 s2 t s2' /\\ match_states i' s' s2') ->\nexists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r)","proofString":"intros [i' [s2' [A B]]].\ndestruct (state_behaves_exists L2 s2') as [beh' SB].\nexists (behavior_app t beh'); split.\neapply state_behaves_app; eauto.\nreplace (Goes_wrong t) with (behavior_app t (Goes_wrong E0)).\napply behavior_improves_app.\napply behavior_improves_bot.\nsimpl.\ndecEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2')","proofString":"destruct (state_behaves_exists L2 s2') as [beh' SB].\nexists (behavior_app t beh'); split.\neapply state_behaves_app; eauto.\nreplace (Goes_wrong t) with (behavior_app t (Goes_wrong E0)).\napply behavior_improves_app.\napply behavior_improves_bot.\nsimpl.\ndecEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2.","conclusion":"exists beh2 : program_behavior,\n  state_behaves L2 s2 beh2 /\\ behavior_improves (Goes_wrong t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"exists (behavior_app t beh'); split.\neapply state_behaves_app; eauto.\nreplace (Goes_wrong t) with (behavior_app t (Goes_wrong E0)).\napply behavior_improves_app.\napply behavior_improves_bot.\nsimpl.\ndecEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : state_behaves L2 s2 (behavior_app t beh').","conclusion":"state_behaves L2 s2 (behavior_app t beh')","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"eapply state_behaves_app; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : behavior_improves (Goes_wrong t) (behavior_app t beh').","conclusion":"behavior_improves (Goes_wrong t) (behavior_app t beh')","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"replace (Goes_wrong t) with (behavior_app t (Goes_wrong E0)).\napply behavior_improves_app.\napply behavior_improves_bot.\nsimpl.\ndecEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : behavior_improves (behavior_app t (Goes_wrong E0)) (behavior_app t beh').","conclusion":"behavior_improves (behavior_app t (Goes_wrong E0)) (behavior_app t beh')","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"apply behavior_improves_app.\napply behavior_improves_bot."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : behavior_improves (Goes_wrong E0) beh'.","conclusion":"behavior_improves (Goes_wrong E0) beh'","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"apply behavior_improves_bot."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : behavior_app t (Goes_wrong E0) = Goes_wrong t.","conclusion":"behavior_app t (Goes_wrong E0) = Goes_wrong t","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"simpl.\ndecEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : Goes_wrong (t ** E0) = Goes_wrong t.","conclusion":"Goes_wrong (t ** E0) = Goes_wrong t","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"decEq.\ntraceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh') : t ** E0 = t.","conclusion":"t ** E0 = t","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (s' : state L1) (H1 : Star L1 s1 t s') (H2 : Nostep L1 s') (H3 : forall r : int, ~ final_state L1 s' r) (i' : index) (s2' : state L2) (A : Star L2 s2 t s2') (B : match_states i' s' s2') (beh' : program_behavior) (SB : state_behaves L2 s2' beh')","proofString":"traceEq."},{"statement":"(L1 L2 : semantics) (FS : forward_simulation L1 L2) : forall beh1 : program_behavior,\nprogram_behaves L1 beh1 ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"forall beh1 : program_behavior,\nprogram_behaves L1 beh1 ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (FS : forward_simulation L1 L2)","proofString":"destruct FS as [init order match_states S].\nintros.\ninv H.\nexploit (fsim_match_initial_states S); eauto.\nintros [i [s' [INIT MATCH]]].\nexploit forward_simulation_state_behaves; eauto.\nintros [beh2 [A B]].\nexists beh2; split; auto.\neconstructor; eauto.\ndestruct (classic (exists s', initial_state L2 s')).\ndestruct H as [s' INIT].\ndestruct (state_behaves_exists L2 s') as [beh' SB].\nexists beh'; split.\neconstructor; eauto.\napply behavior_improves_bot.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim H; exists s; auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) : forall beh1 : program_behavior,\nprogram_behaves L1 beh1 ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"forall beh1 : program_behavior,\nprogram_behaves L1 beh1 ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states)","proofString":"intros.\ninv H.\nexploit (fsim_match_initial_states S); eauto.\nintros [i [s' [INIT MATCH]]].\nexploit forward_simulation_state_behaves; eauto.\nintros [beh2 [A B]].\nexists beh2; split; auto.\neconstructor; eauto.\ndestruct (classic (exists s', initial_state L2 s')).\ndestruct H as [s' INIT].\ndestruct (state_behaves_exists L2 s') as [beh' SB].\nexists beh'; split.\neconstructor; eauto.\napply behavior_improves_bot.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim H; exists s; auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (H : program_behaves L1 beh1) : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (H : program_behaves L1 beh1)","proofString":"inv H.\nexploit (fsim_match_initial_states S); eauto.\nintros [i [s' [INIT MATCH]]].\nexploit forward_simulation_state_behaves; eauto.\nintros [beh2 [A B]].\nexists beh2; split; auto.\neconstructor; eauto.\ndestruct (classic (exists s', initial_state L2 s')).\ndestruct H as [s' INIT].\ndestruct (state_behaves_exists L2 s') as [beh' SB].\nexists beh'; split.\neconstructor; eauto.\napply behavior_improves_bot.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim H; exists s; auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1)","proofString":"exploit (fsim_match_initial_states S); eauto.\nintros [i [s' [INIT MATCH]]].\nexploit forward_simulation_state_behaves; eauto.\nintros [beh2 [A B]].\nexists beh2; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) : (exists (i : init) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s s2) ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"(exists (i : init) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s s2) ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1)","proofString":"intros [i [s' [INIT MATCH]]].\nexploit forward_simulation_state_behaves; eauto.\nintros [beh2 [A B]].\nexists beh2; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s') : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s')","proofString":"exploit forward_simulation_state_behaves; eauto.\nintros [beh2 [A B]].\nexists beh2; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s') : (exists beh2 : program_behavior,\n   state_behaves L2 s' beh2 /\\ behavior_improves beh1 beh2) ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2.","conclusion":"(exists beh2 : program_behavior,\n   state_behaves L2 s' beh2 /\\ behavior_improves beh1 beh2) ->\nexists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s')","proofString":"intros [beh2 [A B]].\nexists beh2; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s') (beh2 : program_behavior) (A : state_behaves L2 s' beh2) (B : behavior_improves beh1 beh2) : exists beh0 : program_behavior,\n  program_behaves L2 beh0 /\\ behavior_improves beh1 beh0.","conclusion":"exists beh0 : program_behavior,\n  program_behaves L2 beh0 /\\ behavior_improves beh1 beh0","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s') (beh2 : program_behavior) (A : state_behaves L2 s' beh2) (B : behavior_improves beh1 beh2)","proofString":"exists beh2; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s') (beh2 : program_behavior) (A : state_behaves L2 s' beh2) (B : behavior_improves beh1 beh2) : program_behaves L2 beh2.","conclusion":"program_behaves L2 beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (beh1 : program_behavior) (s : state L1) (H0 : initial_state L1 s) (H1 : state_behaves L1 s beh1) (i : init) (s' : state L2) (INIT : initial_state L2 s') (MATCH : match_states i s s') (beh2 : program_behavior) (A : state_behaves L2 s' beh2) (B : behavior_improves beh1 beh2)","proofString":"econstructor; eauto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s)","proofString":"destruct (classic (exists s', initial_state L2 s')).\ndestruct H as [s' INIT].\ndestruct (state_behaves_exists L2 s') as [beh' SB].\nexists beh'; split.\neconstructor; eauto.\napply behavior_improves_bot.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim H; exists s; auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : exists s' : state L2, initial_state L2 s') : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : exists s' : state L2, initial_state L2 s')","proofString":"destruct H as [s' INIT].\ndestruct (state_behaves_exists L2 s') as [beh' SB].\nexists beh'; split.\neconstructor; eauto.\napply behavior_improves_bot."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s') : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s')","proofString":"destruct (state_behaves_exists L2 s') as [beh' SB].\nexists beh'; split.\neconstructor; eauto.\napply behavior_improves_bot."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s') (beh' : program_behavior) (SB : state_behaves L2 s' beh') : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s') (beh' : program_behavior) (SB : state_behaves L2 s' beh')","proofString":"exists beh'; split.\neconstructor; eauto.\napply behavior_improves_bot."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s') (beh' : program_behavior) (SB : state_behaves L2 s' beh') : program_behaves L2 beh'.","conclusion":"program_behaves L2 beh'","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s') (beh' : program_behavior) (SB : state_behaves L2 s' beh')","proofString":"econstructor; eauto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s') (beh' : program_behavior) (SB : state_behaves L2 s' beh') : behavior_improves (Goes_wrong E0) beh'.","conclusion":"behavior_improves (Goes_wrong E0) beh'","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (s' : state L2) (INIT : initial_state L2 s') (beh' : program_behavior) (SB : state_behaves L2 s' beh')","proofString":"apply behavior_improves_bot."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s')) : exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2.","conclusion":"exists beh2 : program_behavior,\n  program_behaves L2 beh2 /\\ behavior_improves (Goes_wrong E0) beh2","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s'))","proofString":"exists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim H; exists s; auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s')) : program_behaves L2 (Goes_wrong E0).","conclusion":"program_behaves L2 (Goes_wrong E0)","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s'))","proofString":"apply program_goes_initially_wrong.\nintros; red; intros.\nelim H; exists s; auto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s')) : forall s : state L2, ~ initial_state L2 s.","conclusion":"forall s : state L2, ~ initial_state L2 s","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s'))","proofString":"intros; red; intros.\nelim H; exists s; auto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s0 : state L1, ~ initial_state L1 s0) (H : ~ (exists s' : state L2, initial_state L2 s')) (s : state L2) (H1 : initial_state L2 s) : False.","conclusion":"False","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s0 : state L1, ~ initial_state L1 s0) (H : ~ (exists s' : state L2, initial_state L2 s')) (s : state L2) (H1 : initial_state L2 s)","proofString":"elim H; exists s; auto."},{"statement":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s')) : behavior_improves (Goes_wrong E0) (Goes_wrong E0).","conclusion":"behavior_improves (Goes_wrong E0) (Goes_wrong E0)","hypotheses":"(L1 L2 : semantics) (init : Type) (order : init -> init -> Prop) (match_states : init -> state L1 -> state L2 -> Prop) (S : fsim_properties L1 L2 init order match_states) (H0 : forall s : state L1, ~ initial_state L1 s) (H : ~ (exists s' : state L2, initial_state L2 s'))","proofString":"apply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) : program_behaves L2 beh.","conclusion":"program_behaves L2 beh","hypotheses":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh)","proofString":"exploit forward_simulation_behavior_improves; eauto.\nintros [beh' [A B]].\ndestruct B.\ncongruence.\ndestruct H2 as [t [C D]].\nsubst.\ncontradiction."},{"statement":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) : (exists beh2 : program_behavior,\n   program_behaves L2 beh2 /\\ behavior_improves beh beh2) ->\nprogram_behaves L2 beh.","conclusion":"(exists beh2 : program_behavior,\n   program_behaves L2 beh2 /\\ behavior_improves beh beh2) ->\nprogram_behaves L2 beh","hypotheses":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh)","proofString":"intros [beh' [A B]].\ndestruct B.\ncongruence.\ndestruct H2 as [t [C D]].\nsubst.\ncontradiction."},{"statement":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (B : behavior_improves beh beh') : program_behaves L2 beh.","conclusion":"program_behaves L2 beh","hypotheses":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (B : behavior_improves beh beh')","proofString":"destruct B.\ncongruence.\ndestruct H2 as [t [C D]].\nsubst.\ncontradiction."},{"statement":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (H2 : beh = beh') : program_behaves L2 beh.","conclusion":"program_behaves L2 beh","hypotheses":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (H2 : beh = beh')","proofString":"congruence."},{"statement":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (H2 : exists t : trace, beh = Goes_wrong t /\\ behavior_prefix t beh') : program_behaves L2 beh.","conclusion":"program_behaves L2 beh","hypotheses":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (H2 : exists t : trace, beh = Goes_wrong t /\\ behavior_prefix t beh')","proofString":"destruct H2 as [t [C D]].\nsubst.\ncontradiction."},{"statement":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (t : trace) (C : beh = Goes_wrong t) (D : behavior_prefix t beh') : program_behaves L2 beh.","conclusion":"program_behaves L2 beh","hypotheses":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (beh : program_behavior) (H0 : program_behaves L1 beh) (H1 : not_wrong beh) (beh' : program_behavior) (A : program_behaves L2 beh') (t : trace) (C : beh = Goes_wrong t) (D : behavior_prefix t beh')","proofString":"subst.\ncontradiction."},{"statement":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (t : trace) (H1 : not_wrong (Goes_wrong t)) (H0 : program_behaves L1 (Goes_wrong t)) (beh' : program_behavior) (A : program_behaves L2 beh') (D : behavior_prefix t beh') : program_behaves L2 (Goes_wrong t).","conclusion":"program_behaves L2 (Goes_wrong t)","hypotheses":"(L1 L2 : semantics) (H : forward_simulation L1 L2) (t : trace) (H1 : not_wrong (Goes_wrong t)) (H0 : program_behaves L1 (Goes_wrong t)) (beh' : program_behavior) (A : program_behaves L2 beh') (D : behavior_prefix t beh')","proofString":"contradiction."},{"statement":"(s : state L1) (b : program_behavior) (H : safe_along_behavior s b) (s' : state L1) (H0 : Star L1 s E0 s') : (exists r : int, final_state L1 s' r) \\/\n(exists (t : trace) (s'' : state L1), Step L1 s' t s'').","conclusion":"(exists r : int, final_state L1 s' r) \\/\n(exists (t : trace) (s'' : state L1), Step L1 s' t s'')","hypotheses":"(s : state L1) (b : program_behavior) (H : safe_along_behavior s b) (s' : state L1) (H0 : Star L1 s E0 s')","proofString":"eapply H; eauto.\nsymmetry; apply behavior_app_E0."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (H : safe_along_behavior s b) (H0 : Star L1 s t1 s') (H1 : b = behavior_app t1 b2) (t0 : trace) (s'0 : state L1) (b0 : program_behavior) (H2 : Star L1 s' t0 s'0) (H3 : b2 = behavior_app t0 b0) : (exists r : int, final_state L1 s'0 r) \\/\n(exists (t2 : trace) (s'' : state L1), Step L1 s'0 t2 s'').","conclusion":"(exists r : int, final_state L1 s'0 r) \\/\n(exists (t2 : trace) (s'' : state L1), Step L1 s'0 t2 s'')","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (H : safe_along_behavior s b) (H0 : Star L1 s t1 s') (H1 : b = behavior_app t1 b2) (t0 : trace) (s'0 : state L1) (b0 : program_behavior) (H2 : Star L1 s' t0 s'0) (H3 : b2 = behavior_app t0 b0)","proofString":"eapply H.\neapply star_trans; eauto.\nsubst.\nrewrite behavior_app_assoc.\neauto."},{"statement":"(s : state L1) (b : program_behavior) (H : ~ safe_along_behavior s b) : exists (t : trace) (s' : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r).","conclusion":"exists (t : trace) (s' : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r)","hypotheses":"(s : state L1) (b : program_behavior) (H : ~ safe_along_behavior s b)","proofString":"destruct (not_all_ex_not _ _ H) as [t1 A]; clear H.\ndestruct (not_all_ex_not _ _ A) as [s' B]; clear A.\ndestruct (not_all_ex_not _ _ B) as [b2 C]; clear B.\ndestruct (imply_to_and _ _ C) as [D E]; clear C.\ndestruct (imply_to_and _ _ E) as [F G]; clear E.\ndestruct (not_or_and _ _ G) as [P Q]; clear G.\nexists t1; exists s'.\nsplit.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (A : ~\n(forall (s' : state L1) (b2 : program_behavior),\n Star L1 s t1 s' ->\n b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))) : exists (t : trace) (s' : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r).","conclusion":"exists (t : trace) (s' : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (A : ~\n(forall (s' : state L1) (b2 : program_behavior),\n Star L1 s t1 s' ->\n b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')))","proofString":"destruct (not_all_ex_not _ _ A) as [s' B]; clear A.\ndestruct (not_all_ex_not _ _ B) as [b2 C]; clear B.\ndestruct (imply_to_and _ _ C) as [D E]; clear C.\ndestruct (imply_to_and _ _ E) as [F G]; clear E.\ndestruct (not_or_and _ _ G) as [P Q]; clear G.\nexists t1; exists s'.\nsplit.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (B : ~\n(forall b2 : program_behavior,\n Star L1 s t1 s' ->\n b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))) : exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r).","conclusion":"exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (B : ~\n(forall b2 : program_behavior,\n Star L1 s t1 s' ->\n b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')))","proofString":"destruct (not_all_ex_not _ _ B) as [b2 C]; clear B.\ndestruct (imply_to_and _ _ C) as [D E]; clear C.\ndestruct (imply_to_and _ _ E) as [F G]; clear E.\ndestruct (not_or_and _ _ G) as [P Q]; clear G.\nexists t1; exists s'.\nsplit.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (C : ~\n(Star L1 s t1 s' ->\n b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))) : exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r).","conclusion":"exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (C : ~\n(Star L1 s t1 s' ->\n b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')))","proofString":"destruct (imply_to_and _ _ C) as [D E]; clear C.\ndestruct (imply_to_and _ _ E) as [F G]; clear E.\ndestruct (not_or_and _ _ G) as [P Q]; clear G.\nexists t1; exists s'.\nsplit.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (E : ~\n(b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))) : exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r).","conclusion":"exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (E : ~\n(b = behavior_app t1 b2 ->\n (exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')))","proofString":"destruct (imply_to_and _ _ E) as [F G]; clear E.\ndestruct (not_or_and _ _ G) as [P Q]; clear G.\nexists t1; exists s'.\nsplit.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (G : ~\n((exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))) : exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r).","conclusion":"exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (G : ~\n((exists r : int, final_state L1 s' r) \\/\n (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')))","proofString":"destruct (not_or_and _ _ G) as [P Q]; clear G.\nexists t1; exists s'.\nsplit.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r).","conclusion":"exists (t : trace) (s'0 : state L1),\n  behavior_prefix t b /\\\n  Star L1 s t s'0 /\\\n  Nostep L1 s'0 /\\ (forall r : int, ~ final_state L1 s'0 r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"exists t1; exists s'.\nsplit.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : behavior_prefix t1 b /\\\nStar L1 s t1 s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r).","conclusion":"behavior_prefix t1 b /\\\nStar L1 s t1 s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"split.\nexists b2; auto.\nsplit.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : behavior_prefix t1 b.","conclusion":"behavior_prefix t1 b","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"exists b2; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : Star L1 s t1 s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r).","conclusion":"Star L1 s t1 s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"split.\nauto.\nsplit.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : Star L1 s t1 s'.","conclusion":"Star L1 s t1 s'","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r).","conclusion":"Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r)","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"split.\nred; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto.\nintros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : Nostep L1 s'.","conclusion":"Nostep L1 s'","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"red; intros; red; intros.\nelim Q.\nexists t; exists s'0; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (t : trace) (s'0 : state L1) (H : Step L1 s' t s'0) : False.","conclusion":"False","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (t : trace) (s'0 : state L1) (H : Step L1 s' t s'0)","proofString":"elim Q.\nexists t; exists s'0; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (t : trace) (s'0 : state L1) (H : Step L1 s' t s'0) : exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''.","conclusion":"exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (t : trace) (s'0 : state L1) (H : Step L1 s' t s'0)","proofString":"exists t; exists s'0; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) : forall r : int, ~ final_state L1 s' r.","conclusion":"forall r : int, ~ final_state L1 s' r","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r : int, final_state L1 s' r)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s''))","proofString":"intros; red; intros.\nelim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r0 : int, final_state L1 s' r0)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (r : int) (H : final_state L1 s' r) : False.","conclusion":"False","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r0 : int, final_state L1 s' r0)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (r : int) (H : final_state L1 s' r)","proofString":"elim P.\nexists r; auto."},{"statement":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r0 : int, final_state L1 s' r0)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (r : int) (H : final_state L1 s' r) : exists r0 : int, final_state L1 s' r0.","conclusion":"exists r0 : int, final_state L1 s' r0","hypotheses":"(s : state L1) (b : program_behavior) (t1 : trace) (s' : state L1) (b2 : program_behavior) (D : Star L1 s t1 s') (F : b = behavior_app t1 b2) (P : ~ (exists r0 : int, final_state L1 s' r0)) (Q : ~ (exists (t2 : trace) (s'' : state L1), Step L1 s' t2 s'')) (r : int) (H : final_state L1 s' r)","proofString":"exists r; auto."},{"statement":"(s : state L2) (i : index) (s1 : state L1) (b : program_behavior) (H : match_states i s1 s) (H0 : safe_along_behavior s1 (behavior_app E0 b)) : exists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s.","conclusion":"exists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s","hypotheses":"(s : state L2) (i : index) (s1 : state L1) (b : program_behavior) (H : match_states i s1 s) (H0 : safe_along_behavior s1 (behavior_app E0 b))","proofString":"exists i; exists s1; split; auto.\napply star_refl."},{"statement":"(s : state L2) (i : index) (s1 : state L1) (b : program_behavior) (H : match_states i s1 s) (H0 : safe_along_behavior s1 (behavior_app E0 b)) : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(s : state L2) (i : index) (s1 : state L1) (b : program_behavior) (H : match_states i s1 s) (H0 : safe_along_behavior s1 (behavior_app E0 b))","proofString":"apply star_refl."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 t2 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) : exists (i' : index) (s1' : state L1),\n  Star L1 s0 t s1' /\\ match_states i' s1' s3.","conclusion":"exists (i' : index) (s1' : state L1),\n  Star L1 s0 t s1' /\\ match_states i' s1' s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 t2 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b))","proofString":"exploit (bsim_simulation S); eauto.\neapply safe_along_safe; eauto.\nintros [i' [s1' [A B]]].\nassert (Star L1 s0 t1 s1').\nintuition.\napply plus_star; auto.\nexploit IHstar; eauto.\neapply star_safe_along; eauto.\nsubst t; apply behavior_app_assoc.\nintros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 t2 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) : safe L1 s0.","conclusion":"safe L1 s0","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 t2 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b))","proofString":"eapply safe_along_safe; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 t2 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) : (exists (i' : index) (s1' : state L1),\n   (Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) /\\\n   match_states i' s1' s2) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s0 t s1' /\\ match_states i' s1' s3.","conclusion":"(exists (i' : index) (s1' : state L1),\n   (Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) /\\\n   match_states i' s1' s2) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s0 t s1' /\\ match_states i' s1' s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 t2 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b))","proofString":"intros [i' [s1' [A B]]].\nassert (Star L1 s0 t1 s1').\nintuition.\napply plus_star; auto.\nexploit IHstar; eauto.\neapply star_safe_along; eauto.\nsubst t; apply behavior_app_assoc.\nintros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) : exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3.","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2)","proofString":"assert (Star L1 s0 t1 s1').\nintuition.\napply plus_star; auto.\nexploit IHstar; eauto.\neapply star_safe_along; eauto.\nsubst t; apply behavior_app_assoc.\nintros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) : Star L1 s0 t1 s1'.","conclusion":"Star L1 s0 t1 s1'","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2)","proofString":"intuition.\napply plus_star; auto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (B : match_states i' s1' s2) (H4 : Plus L1 s0 t1 s1') : Star L1 s0 t1 s1'.","conclusion":"Star L1 s0 t1 s1'","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (B : match_states i' s1' s2) (H4 : Plus L1 s0 t1 s1')","proofString":"apply plus_star; auto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1') : exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3.","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1')","proofString":"exploit IHstar; eauto.\neapply star_safe_along; eauto.\nsubst t; apply behavior_app_assoc.\nintros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1') : (exists (i'0 : index) (s1'0 : state L1),\n   Star L1 s1' t2 s1'0 /\\ match_states i'0 s1'0 s3) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3.","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Star L1 s1' t2 s1'0 /\\ match_states i'0 s1'0 s3) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1')","proofString":"intros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1') (i'' : index) (s2'' : state L1) (C : Star L1 s1' t2 s2'') (D : match_states i'' s2'' s3) : exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3.","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 t s1'0 /\\ match_states i'0 s1'0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1') (i'' : index) (s2'' : state L1) (C : Star L1 s1' t2 s2'') (D : match_states i'' s2'' s3)","proofString":"exists i''; exists s2''; split; auto.\neapply star_trans; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1') (i'' : index) (s2'' : state L1) (C : Star L1 s1' t2 s2'') (D : match_states i'' s2'' s3) : Star L1 s0 t s2''.","conclusion":"Star L1 s0 t s2''","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L1) (b0 : program_behavior),\nmatch_states i0 s4 s2 ->\nsafe_along_behavior s4 (behavior_app t2 b0) ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 t2 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (b : program_behavior) (H2 : match_states i s0 s1) (H3 : safe_along_behavior s0 (behavior_app t b)) (i' : index) (s1' : state L1) (A : Plus L1 s0 t1 s1' \\/ Star L1 s0 t1 s1' /\\ order i' i) (B : match_states i' s1' s2) (H4 : Star L1 s0 t1 s1') (i'' : index) (s2'' : state L1) (C : Star L1 s1' t2 s2'') (D : match_states i'' s2'' s3)","proofString":"eapply star_trans; eauto."},{"statement":"forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L2 s2 ->\nmatch_states i s1 s2 ->\nsafe L1 s1 -> forever_silent_N (step L1) order (globalenv L1) i s1.","conclusion":"forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L2 s2 ->\nmatch_states i s1 s2 ->\nsafe L1 s1 -> forever_silent_N (step L1) order (globalenv L1) i s1","hypotheses":"","proofString":"cofix COINDHYP; intros.\ninv H.\ndestruct (bsim_simulation S _ _ _ H2 _ H0 H1) as [i' [s2' [A B]]].\ndestruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto.\napply plus_star; auto.\neapply forever_silent_N_star; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L2 s3 ->\nmatch_states i0 s0 s3 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H : Forever_silent L2 s2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) : forever_silent_N (step L1) order (globalenv L1) i s1.","conclusion":"forever_silent_N (step L1) order (globalenv L1) i s1","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L2 s3 ->\nmatch_states i0 s0 s3 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H : Forever_silent L2 s2) (H0 : match_states i s1 s2) (H1 : safe L1 s1)","proofString":"inv H.\ndestruct (bsim_simulation S _ _ _ H2 _ H0 H1) as [i' [s2' [A B]]].\ndestruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto.\napply plus_star; auto.\neapply forever_silent_N_star; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) : forever_silent_N (step L1) order (globalenv L1) i s1.","conclusion":"forever_silent_N (step L1) order (globalenv L1) i s1","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3)","proofString":"destruct (bsim_simulation S _ _ _ H2 _ H0 H1) as [i' [s2' [A B]]].\ndestruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto.\napply plus_star; auto.\neapply forever_silent_N_star; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (A : Plus L1 s1 E0 s2' \\/ Star L1 s1 E0 s2' /\\ order i' i) (B : match_states i' s2' s3) : forever_silent_N (step L1) order (globalenv L1) i s1.","conclusion":"forever_silent_N (step L1) order (globalenv L1) i s1","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (A : Plus L1 s1 E0 s2' \\/ Star L1 s1 E0 s2' /\\ order i' i) (B : match_states i' s2' s3)","proofString":"destruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto.\napply plus_star; auto.\neapply forever_silent_N_star; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Plus L1 s1 E0 s2') (B : match_states i' s2' s3) : forever_silent_N (step L1) order (globalenv L1) i s1.","conclusion":"forever_silent_N (step L1) order (globalenv L1) i s1","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Plus L1 s1 E0 s2') (B : match_states i' s2' s3)","proofString":"eapply forever_silent_N_plus; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto.\napply plus_star; auto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Plus L1 s1 E0 s2') (B : match_states i' s2' s3) : safe L1 s2'.","conclusion":"safe L1 s2'","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Plus L1 s1 E0 s2') (B : match_states i' s2' s3)","proofString":"eapply star_safe; eauto.\napply plus_star; auto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Plus L1 s1 E0 s2') (B : match_states i' s2' s3) : Star L1 s1 E0 s2'.","conclusion":"Star L1 s1 E0 s2'","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Plus L1 s1 E0 s2') (B : match_states i' s2' s3)","proofString":"apply plus_star; auto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Star L1 s1 E0 s2') (D : order i' i) (B : match_states i' s2' s3) : forever_silent_N (step L1) order (globalenv L1) i s1.","conclusion":"forever_silent_N (step L1) order (globalenv L1) i s1","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Star L1 s1 E0 s2') (D : order i' i) (B : match_states i' s2' s3)","proofString":"eapply forever_silent_N_star; eauto.\neapply COINDHYP; eauto.\neapply star_safe; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Star L1 s1 E0 s2') (D : order i' i) (B : match_states i' s2' s3) : forever_silent_N (step L1) order (globalenv L1) i' s2'.","conclusion":"forever_silent_N (step L1) order (globalenv L1) i' s2'","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Star L1 s1 E0 s2') (D : order i' i) (B : match_states i' s2' s3)","proofString":"eapply COINDHYP; eauto.\neapply star_safe; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Star L1 s1 E0 s2') (D : order i' i) (B : match_states i' s2' s3) : safe L1 s2'.","conclusion":"safe L1 s2'","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L2 s4 ->\nmatch_states i0 s0 s4 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (H1 : safe L1 s1) (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H3 : Forever_silent L2 s3) (i' : index) (s2' : state L1) (C : Star L1 s1 E0 s2') (D : order i' i) (B : match_states i' s2' s3)","proofString":"eapply star_safe; eauto."},{"statement":"(H : forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L2 s2 ->\nmatch_states i s1 s2 ->\nsafe L1 s1 -> forever_silent_N (step L1) order (globalenv L1) i s1) : forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L2 s2 ->\nmatch_states i s1 s2 -> safe L1 s1 -> Forever_silent L1 s1.","conclusion":"forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L2 s2 ->\nmatch_states i s1 s2 -> safe L1 s1 -> Forever_silent L1 s1","hypotheses":"(H : forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L2 s2 ->\nmatch_states i s1 s2 ->\nsafe L1 s1 -> forever_silent_N (step L1) order (globalenv L1) i s1)","proofString":"intros.\neapply forever_silent_N_forever; eauto.\neapply bsim_order_wf; eauto."},{"statement":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L2 s3 ->\nmatch_states i0 s0 s3 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L2 s2) (H1 : match_states i s1 s2) (H2 : safe L1 s1) : Forever_silent L1 s1.","conclusion":"Forever_silent L1 s1","hypotheses":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L2 s3 ->\nmatch_states i0 s0 s3 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L2 s2) (H1 : match_states i s1 s2) (H2 : safe L1 s1)","proofString":"eapply forever_silent_N_forever; eauto.\neapply bsim_order_wf; eauto."},{"statement":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L2 s3 ->\nmatch_states i0 s0 s3 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L2 s2) (H1 : match_states i s1 s2) (H2 : safe L1 s1) : well_founded order.","conclusion":"well_founded order","hypotheses":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L2 s3 ->\nmatch_states i0 s0 s3 ->\nsafe L1 s0 -> forever_silent_N (step L1) order (globalenv L1) i0 s0) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L2 s2) (H1 : match_states i s1 s2) (H2 : safe L1 s1)","proofString":"eapply bsim_order_wf; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2) (T0 : traceinf),\nForever_reactive L2 s3 T0 ->\nmatch_states i0 s0 s3 ->\nsafe_along_behavior s0 (Reacts T0) -> Forever_reactive L1 s0 T0) (i : index) (s1 : state L1) (s2 : state L2) (T : traceinf) (H : Forever_reactive L2 s2 T) (H0 : match_states i s1 s2) (H1 : safe_along_behavior s1 (Reacts T)) : Forever_reactive L1 s1 T.","conclusion":"Forever_reactive L1 s1 T","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2) (T0 : traceinf),\nForever_reactive L2 s3 T0 ->\nmatch_states i0 s0 s3 ->\nsafe_along_behavior s0 (Reacts T0) -> Forever_reactive L1 s0 T0) (i : index) (s1 : state L1) (s2 : state L2) (T : traceinf) (H : Forever_reactive L2 s2 T) (H0 : match_states i s1 s2) (H1 : safe_along_behavior s1 (Reacts T))","proofString":"inv H.\ndestruct (backward_simulation_star H2 (Reacts T0) H0) as [i' [s1' [A B]]]; eauto.\neconstructor; eauto.\neapply COINDHYP; eauto.\neapply star_safe_along; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0) : Forever_reactive L1 s1 (t *** T0).","conclusion":"Forever_reactive L1 s1 (t *** T0)","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0)","proofString":"destruct (backward_simulation_star H2 (Reacts T0) H0) as [i' [s1' [A B]]]; eauto.\neconstructor; eauto.\neapply COINDHYP; eauto.\neapply star_safe_along; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s3) : Forever_reactive L1 s1 (t *** T0).","conclusion":"Forever_reactive L1 s1 (t *** T0)","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s3)","proofString":"econstructor; eauto.\neapply COINDHYP; eauto.\neapply star_safe_along; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s3) : Forever_reactive L1 s1' T0.","conclusion":"Forever_reactive L1 s1' T0","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s3)","proofString":"eapply COINDHYP; eauto.\neapply star_safe_along; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s3) : safe_along_behavior s1' (Reacts T0).","conclusion":"safe_along_behavior s1' (Reacts T0)","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L2 s4 T ->\nmatch_states i0 s0 s4 ->\nsafe_along_behavior s0 (Reacts T) -> Forever_reactive L1 s0 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (t : trace) (T0 : traceinf) (H1 : safe_along_behavior s1 (Reacts (t *** T0))) (s3 : state L2) (H2 : Star L2 s2 t s3) (H3 : t <> E0) (H4 : Forever_reactive L2 s3 T0) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s3)","proofString":"eapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) : exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2)","proofString":"destruct (classic (safe_along_behavior s1 beh2)).\nexists beh2; split; [idtac|apply behavior_improves_refl].\ninv H0.\nassert (Terminates t r = behavior_app t (Terminates E0 r)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto.\nassert (Diverges t = behavior_app t (Diverges E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\neconstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\neconstructor.\neapply backward_simulation_forever_reactive; eauto.\nassert (Goes_wrong t = behavior_app t (Goes_wrong E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2).\nexploit not_safe_along_behavior; eauto.\nintros [t [s1' [PREF [STEPS [NOSTEP NOFIN]]]]].\nexists (Goes_wrong t); split.\neconstructor; eauto.\nright.\nexists t; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : safe_along_behavior s1 beh2) : exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : safe_along_behavior s1 beh2)","proofString":"exists beh2; split; [idtac|apply behavior_improves_refl].\ninv H0.\nassert (Terminates t r = behavior_app t (Terminates E0 r)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto.\nassert (Diverges t = behavior_app t (Diverges E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\neconstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\neconstructor.\neapply backward_simulation_forever_reactive; eauto.\nassert (Goes_wrong t = behavior_app t (Goes_wrong E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : safe_along_behavior s1 beh2) : state_behaves L1 s1 beh2.","conclusion":"state_behaves L1 s1 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : safe_along_behavior s1 beh2)","proofString":"inv H0.\nassert (Terminates t r = behavior_app t (Terminates E0 r)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto.\nassert (Diverges t = behavior_app t (Diverges E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\neconstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\neconstructor.\neapply backward_simulation_forever_reactive; eauto.\nassert (Goes_wrong t = behavior_app t (Goes_wrong E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) : state_behaves L1 s1 (Terminates t r).","conclusion":"state_behaves L1 s1 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r)","proofString":"assert (Terminates t r = behavior_app t (Terminates E0 r)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) : Terminates t r = behavior_app t (Terminates E0 r).","conclusion":"Terminates t r = behavior_app t (Terminates E0 r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r)","proofString":"simpl.\nrewrite E0_right; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) : Terminates t r = Terminates (t ** E0) r.","conclusion":"Terminates t r = Terminates (t ** E0) r","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r)","proofString":"rewrite E0_right; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) : state_behaves L1 s1 (Terminates t r).","conclusion":"state_behaves L1 s1 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (Terminates t r)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r))","proofString":"rewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) : state_behaves L1 s1 (Terminates t r).","conclusion":"state_behaves L1 s1 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r))","proofString":"exploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) : (exists (i' : index) (s1' : state L1),\n   Star L1 s1 t s1' /\\ match_states i' s1' s') ->\nstate_behaves L1 s1 (Terminates t r).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Star L1 s1 t s1' /\\ match_states i' s1' s') ->\nstate_behaves L1 s1 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r))","proofString":"intros [i' [s1' [A B]]].\nexploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : state_behaves L1 s1 (Terminates t r).","conclusion":"state_behaves L1 s1 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"exploit (bsim_match_final_states S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"eapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : (exists s1'0 : state L1, Star L1 s1' E0 s1'0 /\\ final_state L1 s1'0 r) ->\nstate_behaves L1 s1 (Terminates t r).","conclusion":"(exists s1'0 : state L1, Star L1 s1' E0 s1'0 /\\ final_state L1 s1'0 r) ->\nstate_behaves L1 s1 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"intros [s1'' [C D]].\neconstructor.\neapply star_trans; eauto.\ntraceEq.\nauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : final_state L1 s1'' r) : state_behaves L1 s1 (Terminates t r).","conclusion":"state_behaves L1 s1 (Terminates t r)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : final_state L1 s1'' r)","proofString":"econstructor.\neapply star_trans; eauto.\ntraceEq.\nauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : final_state L1 s1'' r) : t = t ** E0.","conclusion":"t = t ** E0","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (r : int) (H1 : safe_along_behavior s1 (behavior_app t (Terminates E0 r))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : final_state L2 s' r) (H0 : Terminates t r = behavior_app t (Terminates E0 r)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : final_state L1 s1'' r)","proofString":"traceEq."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') : state_behaves L1 s1 (Diverges t).","conclusion":"state_behaves L1 s1 (Diverges t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s')","proofString":"assert (Diverges t = behavior_app t (Diverges E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\neconstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') : Diverges t = behavior_app t (Diverges E0).","conclusion":"Diverges t = behavior_app t (Diverges E0)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s')","proofString":"simpl.\nrewrite E0_right; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') : Diverges t = Diverges (t ** E0).","conclusion":"Diverges t = Diverges (t ** E0)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s')","proofString":"rewrite E0_right; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0)) : state_behaves L1 s1 (Diverges t).","conclusion":"state_behaves L1 s1 (Diverges t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Diverges t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0))","proofString":"rewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\neconstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0)) : state_behaves L1 s1 (Diverges t).","conclusion":"state_behaves L1 s1 (Diverges t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0))","proofString":"exploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\neconstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0)) : (exists (i' : index) (s1' : state L1),\n   Star L1 s1 t s1' /\\ match_states i' s1' s') ->\nstate_behaves L1 s1 (Diverges t).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Star L1 s1 t s1' /\\ match_states i' s1' s') ->\nstate_behaves L1 s1 (Diverges t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0))","proofString":"intros [i' [s1' [A B]]].\neconstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : state_behaves L1 s1 (Diverges t).","conclusion":"state_behaves L1 s1 (Diverges t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"econstructor.\neauto.\neapply backward_simulation_forever_silent; eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Diverges E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Forever_silent L2 s') (H0 : Diverges t = behavior_app t (Diverges E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"eapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : safe_along_behavior s1 (Reacts T)) (H2 : Forever_reactive L2 s2 T) : state_behaves L1 s1 (Reacts T).","conclusion":"state_behaves L1 s1 (Reacts T)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : safe_along_behavior s1 (Reacts T)) (H2 : Forever_reactive L2 s2 T)","proofString":"econstructor.\neapply backward_simulation_forever_reactive; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : safe_along_behavior s1 (Reacts T)) (H2 : Forever_reactive L2 s2 T) : Forever_reactive L1 s1 T.","conclusion":"Forever_reactive L1 s1 T","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (T : traceinf) (H1 : safe_along_behavior s1 (Reacts T)) (H2 : Forever_reactive L2 s2 T)","proofString":"eapply backward_simulation_forever_reactive; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) : state_behaves L1 s1 (Goes_wrong t).","conclusion":"state_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r)","proofString":"assert (Goes_wrong t = behavior_app t (Goes_wrong E0)).\nsimpl.\nrewrite E0_right; auto.\nrewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) : Goes_wrong t = behavior_app t (Goes_wrong E0).","conclusion":"Goes_wrong t = behavior_app t (Goes_wrong E0)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r)","proofString":"simpl.\nrewrite E0_right; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) : Goes_wrong t = Goes_wrong (t ** E0).","conclusion":"Goes_wrong t = Goes_wrong (t ** E0)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r)","proofString":"rewrite E0_right; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) : state_behaves L1 s1 (Goes_wrong t).","conclusion":"state_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (Goes_wrong t)) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0))","proofString":"rewrite H0 in H1.\nexploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) : state_behaves L1 s1 (Goes_wrong t).","conclusion":"state_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0))","proofString":"exploit backward_simulation_star; eauto.\nintros [i' [s1' [A B]]].\nexploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) : (exists (i' : index) (s1' : state L1),\n   Star L1 s1 t s1' /\\ match_states i' s1' s') ->\nstate_behaves L1 s1 (Goes_wrong t).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Star L1 s1 t s1' /\\ match_states i' s1' s') ->\nstate_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0))","proofString":"intros [i' [s1' [A B]]].\nexploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : state_behaves L1 s1 (Goes_wrong t).","conclusion":"state_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"exploit (bsim_progress S); eauto.\neapply safe_along_safe.\neapply star_safe_along; eauto.\nintros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"eapply safe_along_safe.\neapply star_safe_along; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') : (exists r : int, final_state L2 s' r) \\/\n(exists (t0 : trace) (s2' : state L2), Step L2 s' t0 s2') ->\nstate_behaves L1 s1 (Goes_wrong t).","conclusion":"(exists r : int, final_state L2 s' r) \\/\n(exists (t0 : trace) (s2' : state L2), Step L2 s' t0 s2') ->\nstate_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s')","proofString":"intros [[r FIN] | [t' [s2' STEP2]]].\nelim (H4 _ FIN).\nelim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r0 : int, ~ final_state L2 s' r0) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (r : int) (FIN : final_state L2 s' r) : state_behaves L1 s1 (Goes_wrong t).","conclusion":"state_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r0 : int, ~ final_state L2 s' r0) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (r : int) (FIN : final_state L2 s' r)","proofString":"elim (H4 _ FIN)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (t' : trace) (s2' : state L2) (STEP2 : Step L2 s' t' s2') : state_behaves L1 s1 (Goes_wrong t).","conclusion":"state_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (t : trace) (H1 : safe_along_behavior s1 (behavior_app t (Goes_wrong E0))) (s' : state L2) (H2 : Star L2 s2 t s') (H3 : Nostep L2 s') (H4 : forall r : int, ~ final_state L2 s' r) (H0 : Goes_wrong t = behavior_app t (Goes_wrong E0)) (i' : index) (s1' : state L1) (A : Star L1 s1 t s1') (B : match_states i' s1' s') (t' : trace) (s2' : state L2) (STEP2 : Step L2 s' t' s2')","proofString":"elim (H3 _ _ STEP2)."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) : exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2)","proofString":"exploit not_safe_along_behavior; eauto.\nintros [t [s1' [PREF [STEPS [NOSTEP NOFIN]]]]].\nexists (Goes_wrong t); split.\neconstructor; eauto.\nright.\nexists t; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) : (exists (t : trace) (s' : state L1),\n   behavior_prefix t beh2 /\\\n   Star L1 s1 t s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r)) ->\nexists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"(exists (t : trace) (s' : state L1),\n   behavior_prefix t beh2 /\\\n   Star L1 s1 t s' /\\ Nostep L1 s' /\\ (forall r : int, ~ final_state L1 s' r)) ->\nexists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2)","proofString":"intros [t [s1' [PREF [STEPS [NOSTEP NOFIN]]]]].\nexists (Goes_wrong t); split.\neconstructor; eauto.\nright.\nexists t; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r) : exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  state_behaves L1 s1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r)","proofString":"exists (Goes_wrong t); split.\neconstructor; eauto.\nright.\nexists t; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r) : state_behaves L1 s1 (Goes_wrong t).","conclusion":"state_behaves L1 s1 (Goes_wrong t)","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r)","proofString":"econstructor; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r) : behavior_improves (Goes_wrong t) beh2.","conclusion":"behavior_improves (Goes_wrong t) beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r)","proofString":"right.\nexists t; auto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r) : exists t0 : trace, Goes_wrong t = Goes_wrong t0 /\\ behavior_prefix t0 beh2.","conclusion":"exists t0 : trace, Goes_wrong t = Goes_wrong t0 /\\ behavior_prefix t0 beh2","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (beh2 : program_behavior) (H : match_states i s1 s2) (H0 : state_behaves L2 s2 beh2) (H1 : ~ safe_along_behavior s1 beh2) (t : trace) (s1' : state L1) (PREF : behavior_prefix t beh2) (STEPS : Star L1 s1 t s1') (NOSTEP : Nostep L1 s1') (NOFIN : forall r : int, ~ final_state L1 s1' r)","proofString":"exists t; auto."},{"statement":"(L1 L2 : semantics) (S : backward_simulation L1 L2) (beh2 : program_behavior) (H : program_behaves L2 beh2) : exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (S : backward_simulation L1 L2) (beh2 : program_behavior) (H : program_behaves L2 beh2)","proofString":"destruct S as [index order match_states S].\ninv H.\ndestruct (classic (exists s1, initial_state L1 s1)) as [[s1 INIT] | NOINIT].\nexploit (bsim_match_initial_states S); eauto.\nintros [i [s1' [INIT1' MATCH]]].\nexploit backward_simulation_state_behaves; eauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\neconstructor; eauto.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim NOINIT; exists s0; auto.\napply behavior_improves_bot.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nexploit (bsim_initial_states_exist S); eauto.\nintros [s2 INIT2].\nelim (H0 s2); auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (H : program_behaves L2 beh2) : exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (H : program_behaves L2 beh2)","proofString":"inv H.\ndestruct (classic (exists s1, initial_state L1 s1)) as [[s1 INIT] | NOINIT].\nexploit (bsim_match_initial_states S); eauto.\nintros [i [s1' [INIT1' MATCH]]].\nexploit backward_simulation_state_behaves; eauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\neconstructor; eauto.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim NOINIT; exists s0; auto.\napply behavior_improves_bot.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nexploit (bsim_initial_states_exist S); eauto.\nintros [s2 INIT2].\nelim (H0 s2); auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) : exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2)","proofString":"destruct (classic (exists s1, initial_state L1 s1)) as [[s1 INIT] | NOINIT].\nexploit (bsim_match_initial_states S); eauto.\nintros [i [s1' [INIT1' MATCH]]].\nexploit backward_simulation_state_behaves; eauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\neconstructor; eauto.\nexists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim NOINIT; exists s0; auto.\napply behavior_improves_bot."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) : exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1)","proofString":"exploit (bsim_match_initial_states S); eauto.\nintros [i [s1' [INIT1' MATCH]]].\nexploit backward_simulation_state_behaves; eauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) : (exists (i : index) (s1' : state L1),\n   initial_state L1 s1' /\\ match_states i s1' s) ->\nexists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"(exists (i : index) (s1' : state L1),\n   initial_state L1 s1' /\\ match_states i s1' s) ->\nexists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1)","proofString":"intros [i [s1' [INIT1' MATCH]]].\nexploit backward_simulation_state_behaves; eauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s) : exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s)","proofString":"exploit backward_simulation_state_behaves; eauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s) : (exists beh1 : program_behavior,\n   state_behaves L1 s1' beh1 /\\ behavior_improves beh1 beh2) ->\nexists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"(exists beh1 : program_behavior,\n   state_behaves L1 s1' beh1 /\\ behavior_improves beh1 beh2) ->\nexists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s)","proofString":"intros [beh1 [A B]].\nexists beh1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s) (beh1 : program_behavior) (A : state_behaves L1 s1' beh1) (B : behavior_improves beh1 beh2) : exists beh0 : program_behavior,\n  program_behaves L1 beh0 /\\ behavior_improves beh0 beh2.","conclusion":"exists beh0 : program_behavior,\n  program_behaves L1 beh0 /\\ behavior_improves beh0 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s) (beh1 : program_behavior) (A : state_behaves L1 s1' beh1) (B : behavior_improves beh1 beh2)","proofString":"exists beh1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s) (beh1 : program_behavior) (A : state_behaves L1 s1' beh1) (B : behavior_improves beh1 beh2) : program_behaves L1 beh1.","conclusion":"program_behaves L1 beh1","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (s1 : state L1) (INIT : initial_state L1 s1) (i : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (MATCH : match_states i s1' s) (beh1 : program_behavior) (A : state_behaves L1 s1' beh1) (B : behavior_improves beh1 beh2)","proofString":"econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1)) : exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2.","conclusion":"exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1))","proofString":"exists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim NOINIT; exists s0; auto.\napply behavior_improves_bot."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1)) : program_behaves L1 (Goes_wrong E0).","conclusion":"program_behaves L1 (Goes_wrong E0)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1))","proofString":"apply program_goes_initially_wrong.\nintros; red; intros.\nelim NOINIT; exists s0; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1)) : forall s0 : state L1, ~ initial_state L1 s0.","conclusion":"forall s0 : state L1, ~ initial_state L1 s0","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1))","proofString":"intros; red; intros.\nelim NOINIT; exists s0; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1)) (s0 : state L1) (H : initial_state L1 s0) : False.","conclusion":"False","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1)) (s0 : state L1) (H : initial_state L1 s0)","proofString":"elim NOINIT; exists s0; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1)) : behavior_improves (Goes_wrong E0) beh2.","conclusion":"behavior_improves (Goes_wrong E0) beh2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (beh2 : program_behavior) (s : state L2) (H0 : initial_state L2 s) (H1 : state_behaves L2 s beh2) (NOINIT : ~ (exists s1 : state L1, initial_state L1 s1))","proofString":"apply behavior_improves_bot."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s) : exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 (Goes_wrong E0).","conclusion":"exists beh1 : program_behavior,\n  program_behaves L1 beh1 /\\ behavior_improves beh1 (Goes_wrong E0)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s)","proofString":"exists (Goes_wrong E0); split.\napply program_goes_initially_wrong.\nintros; red; intros.\nexploit (bsim_initial_states_exist S); eauto.\nintros [s2 INIT2].\nelim (H0 s2); auto.\napply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s) : program_behaves L1 (Goes_wrong E0).","conclusion":"program_behaves L1 (Goes_wrong E0)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s)","proofString":"apply program_goes_initially_wrong.\nintros; red; intros.\nexploit (bsim_initial_states_exist S); eauto.\nintros [s2 INIT2].\nelim (H0 s2); auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s) : forall s : state L1, ~ initial_state L1 s.","conclusion":"forall s : state L1, ~ initial_state L1 s","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s)","proofString":"intros; red; intros.\nexploit (bsim_initial_states_exist S); eauto.\nintros [s2 INIT2].\nelim (H0 s2); auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s0 : state L2, ~ initial_state L2 s0) (s : state L1) (H : initial_state L1 s) : False.","conclusion":"False","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s0 : state L2, ~ initial_state L2 s0) (s : state L1) (H : initial_state L1 s)","proofString":"exploit (bsim_initial_states_exist S); eauto.\nintros [s2 INIT2].\nelim (H0 s2); auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s0 : state L2, ~ initial_state L2 s0) (s : state L1) (H : initial_state L1 s) : (exists s2 : state L2, initial_state L2 s2) -> False.","conclusion":"(exists s2 : state L2, initial_state L2 s2) -> False","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s0 : state L2, ~ initial_state L2 s0) (s : state L1) (H : initial_state L1 s)","proofString":"intros [s2 INIT2].\nelim (H0 s2); auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s0 : state L2, ~ initial_state L2 s0) (s : state L1) (H : initial_state L1 s) (s2 : state L2) (INIT2 : initial_state L2 s2) : False.","conclusion":"False","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s0 : state L2, ~ initial_state L2 s0) (s : state L1) (H : initial_state L1 s) (s2 : state L2) (INIT2 : initial_state L2 s2)","proofString":"elim (H0 s2); auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s) : behavior_improves (Goes_wrong E0) (Goes_wrong E0).","conclusion":"behavior_improves (Goes_wrong E0) (Goes_wrong E0)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (S : bsim_properties L1 L2 index order match_states) (H0 : forall s : state L2, ~ initial_state L2 s)","proofString":"apply behavior_improves_refl."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) : program_behaves L1 beh.","conclusion":"program_behaves L1 beh","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh)","proofString":"exploit backward_simulation_behavior_improves; eauto.\nintros [beh' [A B]].\ndestruct B.\ncongruence.\ndestruct H2 as [t [C D]].\nsubst.\nelim (H0 (Goes_wrong t)).\nauto."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) : (exists beh1 : program_behavior,\n   program_behaves L1 beh1 /\\ behavior_improves beh1 beh) ->\nprogram_behaves L1 beh.","conclusion":"(exists beh1 : program_behavior,\n   program_behaves L1 beh1 /\\ behavior_improves beh1 beh) ->\nprogram_behaves L1 beh","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh)","proofString":"intros [beh' [A B]].\ndestruct B.\ncongruence.\ndestruct H2 as [t [C D]].\nsubst.\nelim (H0 (Goes_wrong t)).\nauto."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (B : behavior_improves beh' beh) : program_behaves L1 beh.","conclusion":"program_behaves L1 beh","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (B : behavior_improves beh' beh)","proofString":"destruct B.\ncongruence.\ndestruct H2 as [t [C D]].\nsubst.\nelim (H0 (Goes_wrong t)).\nauto."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (H2 : beh' = beh) : program_behaves L1 beh.","conclusion":"program_behaves L1 beh","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (H2 : beh' = beh)","proofString":"congruence."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (H2 : exists t : trace, beh' = Goes_wrong t /\\ behavior_prefix t beh) : program_behaves L1 beh.","conclusion":"program_behaves L1 beh","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (H2 : exists t : trace, beh' = Goes_wrong t /\\ behavior_prefix t beh)","proofString":"destruct H2 as [t [C D]].\nsubst.\nelim (H0 (Goes_wrong t)).\nauto."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (t : trace) (C : beh' = Goes_wrong t) (D : behavior_prefix t beh) : program_behaves L1 beh.","conclusion":"program_behaves L1 beh","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (beh' : program_behavior) (A : program_behaves L1 beh') (t : trace) (C : beh' = Goes_wrong t) (D : behavior_prefix t beh)","proofString":"subst.\nelim (H0 (Goes_wrong t)).\nauto."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (t : trace) (A : program_behaves L1 (Goes_wrong t)) (D : behavior_prefix t beh) : program_behaves L1 beh.","conclusion":"program_behaves L1 beh","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (t : trace) (A : program_behaves L1 (Goes_wrong t)) (D : behavior_prefix t beh)","proofString":"elim (H0 (Goes_wrong t)).\nauto."},{"statement":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (t : trace) (A : program_behaves L1 (Goes_wrong t)) (D : behavior_prefix t beh) : program_behaves L1 (Goes_wrong t).","conclusion":"program_behaves L1 (Goes_wrong t)","hypotheses":"(L1 L2 : semantics) (H : backward_simulation L1 L2) (H0 : forall beh0 : program_behavior, program_behaves L1 beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves L2 beh) (t : trace) (A : program_behaves L1 (Goes_wrong t)) (D : behavior_prefix t beh)","proofString":"auto."},{"statement":"(s : state L) (H : output_trace nil) : Star (atomic L) (nil, s) nil (E0, s).","conclusion":"Star (atomic L) (nil, s) nil (E0, s)","hypotheses":"(s : state L) (H : output_trace nil)","proofString":"apply star_refl."},{"statement":"(s : state L) (a : event) (t : list event) (IHt : output_trace t -> Star (atomic L) (t, s) t (E0, s)) (H : output_trace (a :: t)) : Star (atomic L) (a :: t, s) (a :: t) (E0, s).","conclusion":"Star (atomic L) (a :: t, s) (a :: t) (E0, s)","hypotheses":"(s : state L) (a : event) (t : list event) (IHt : output_trace t -> Star (atomic L) (t, s) t (E0, s)) (H : output_trace (a :: t))","proofString":"simpl in H; destruct H.\neapply star_left; eauto.\nsimpl.\napply atomic_step_continue; auto.\nsimpl; auto.\nauto."},{"statement":"(s : state L) (a : event) (t : list event) (IHt : output_trace t -> Star (atomic L) (t, s) t (E0, s)) (H : output_event a) (H0 : output_trace t) : Star (atomic L) (a :: t, s) (a :: t) (E0, s).","conclusion":"Star (atomic L) (a :: t, s) (a :: t) (E0, s)","hypotheses":"(s : state L) (a : event) (t : list event) (IHt : output_trace t -> Star (atomic L) (t, s) t (E0, s)) (H : output_event a) (H0 : output_trace t)","proofString":"eapply star_left; eauto.\nsimpl.\napply atomic_step_continue; auto.\nsimpl; auto.\nauto."},{"statement":"(s : state L) (a : event) (t : list event) (IHt : output_trace t -> Star (atomic L) (t, s) t (E0, s)) (H : output_event a) (H0 : output_trace t) : output_trace (a :: t).","conclusion":"output_trace (a :: t)","hypotheses":"(s : state L) (a : event) (t : list event) (IHt : output_trace t -> Star (atomic L) (t, s) t (E0, s)) (H : output_event a) (H0 : output_trace t)","proofString":"simpl; auto."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : Step L s1 t s2) : Plus (atomic L) (E0, s1) t (E0, s2).","conclusion":"Plus (atomic L) (E0, s1) t (E0, s2)","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : Step L s1 t s2)","proofString":"destruct t.\napply plus_one.\nsimpl; apply atomic_step_silent; auto.\nexploit Lwb; eauto.\nsimpl; intros.\neapply plus_left.\neapply atomic_step_start; eauto.\neapply atomic_finish; eauto.\nauto."},{"statement":"(s1 s2 : state L) (H : Step L s1 nil s2) : Plus (atomic L) (E0, s1) nil (E0, s2).","conclusion":"Plus (atomic L) (E0, s1) nil (E0, s2)","hypotheses":"(s1 s2 : state L) (H : Step L s1 nil s2)","proofString":"apply plus_one.\nsimpl; apply atomic_step_silent; auto."},{"statement":"(s1 s2 : state L) (H : Step L s1 nil s2) : Step (atomic L) (E0, s1) nil (E0, s2).","conclusion":"Step (atomic L) (E0, s1) nil (E0, s2)","hypotheses":"(s1 s2 : state L) (H : Step L s1 nil s2)","proofString":"simpl; apply atomic_step_silent; auto."},{"statement":"(s1 : state L) (e : event) (t : list event) (s2 : state L) (H : Step L s1 (e :: t) s2) : Plus (atomic L) (E0, s1) (e :: t) (E0, s2).","conclusion":"Plus (atomic L) (E0, s1) (e :: t) (E0, s2)","hypotheses":"(s1 : state L) (e : event) (t : list event) (s2 : state L) (H : Step L s1 (e :: t) s2)","proofString":"exploit Lwb; eauto.\nsimpl; intros.\neapply plus_left.\neapply atomic_step_start; eauto.\neapply atomic_finish; eauto.\nauto."},{"statement":"(s1 : state L) (e : event) (t : list event) (s2 : state L) (H : Step L s1 (e :: t) s2) : match e :: t with\n| nil => True\n| _ :: t' => output_trace t'\nend -> Plus (atomic L) (E0, s1) (e :: t) (E0, s2).","conclusion":"match e :: t with\n| nil => True\n| _ :: t' => output_trace t'\nend -> Plus (atomic L) (E0, s1) (e :: t) (E0, s2)","hypotheses":"(s1 : state L) (e : event) (t : list event) (s2 : state L) (H : Step L s1 (e :: t) s2)","proofString":"simpl; intros.\neapply plus_left.\neapply atomic_step_start; eauto.\neapply atomic_finish; eauto.\nauto."},{"statement":"(s1 : state L) (e : event) (t : list event) (s2 : state L) (H : Step L s1 (e :: t) s2) (H0 : output_trace t) : plus (atomic_step L) (globalenv L) (E0, s1) (e :: t) (E0, s2).","conclusion":"plus (atomic_step L) (globalenv L) (E0, s1) (e :: t) (E0, s2)","hypotheses":"(s1 : state L) (e : event) (t : list event) (s2 : state L) (H : Step L s1 (e :: t) s2) (H0 : output_trace t)","proofString":"eapply plus_left.\neapply atomic_step_start; eauto.\neapply atomic_finish; eauto.\nauto."},{"statement":"(s : state L) : Star (atomic L) (E0, s) E0 (E0, s).","conclusion":"Star (atomic L) (E0, s) E0 (E0, s)","hypotheses":"(s : state L)","proofString":"apply star_refl."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : Star (atomic L) (E0, s2) t2 (E0, s3)) : Star (atomic L) (E0, s1) t (E0, s3).","conclusion":"Star (atomic L) (E0, s1) t (E0, s3)","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : Star (atomic L) (E0, s2) t2 (E0, s3))","proofString":"eapply star_trans with (s2 := (E0,s2)).\napply plus_star.\neapply step_atomic_plus; eauto.\neauto.\nauto."},{"statement":"(ms : state L -> state (atomic L) -> Prop) (id : AST.ident) : Senv.public_symbol (symbolenv (atomic L)) id =\nSenv.public_symbol (symbolenv L) id.","conclusion":"Senv.public_symbol (symbolenv (atomic L)) id =\nSenv.public_symbol (symbolenv L) id","hypotheses":"(ms : state L -> state (atomic L) -> Prop) (id : AST.ident)","proofString":"auto."},{"statement":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (H : initial_state L s1) : initial_state (atomic L) (E0, s1).","conclusion":"initial_state (atomic L) (E0, s1)","hypotheses":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (H : initial_state L s1)","proofString":"simpl; auto."},{"statement":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (s2 : state (atomic L)) (r : int) (H : s2 = (E0, s1)) (H0 : final_state L s1 r) : final_state (atomic L) s2 r.","conclusion":"final_state (atomic L) s2 r","hypotheses":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (s2 : state (atomic L)) (r : int) (H : s2 = (E0, s1)) (H0 : final_state L s1 r)","proofString":"subst s2.\nsimpl; auto."},{"statement":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (r : int) (H0 : final_state L s1 r) : final_state (atomic L) (E0, s1) r.","conclusion":"final_state (atomic L) (E0, s1) r","hypotheses":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (r : int) (H0 : final_state L s1 r)","proofString":"simpl; auto."},{"statement":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (t : trace) (s1' : state L) (H : Step L s1 t s1') : Plus (atomic L) (E0, s1) t (E0, s1').","conclusion":"Plus (atomic L) (E0, s1) t (E0, s1')","hypotheses":"(ms : state L -> state (atomic L) -> Prop) (s1 : state L) (t : trace) (s1' : state L) (H : Step L s1 t s1')","proofString":"apply step_atomic_plus; auto."},{"statement":"(s : state (atomic L)) : exists t' : trace, Star L (snd s) t' (snd s) /\\ fst s ** t' = E0 ** fst s.","conclusion":"exists t' : trace, Star L (snd s) t' (snd s) /\\ fst s ** t' = E0 ** fst s","hypotheses":"(s : state (atomic L))","proofString":"exists E0; split.\napply star_refl.\ntraceEq."},{"statement":"(s : state (atomic L)) : Star L (snd s) E0 (snd s).","conclusion":"Star L (snd s) E0 (snd s)","hypotheses":"(s : state (atomic L))","proofString":"apply star_refl."},{"statement":"(s : state (atomic L)) : fst s ** E0 = E0 ** fst s.","conclusion":"fst s ** E0 = E0 ** fst s","hypotheses":"(s : state (atomic L))","proofString":"traceEq."},{"statement":"(s1 : state (atomic L)) (t1 : trace) (s2 : state (atomic L)) (t2 : trace) (s3 : state (atomic L)) (t : trace) (H : Step (atomic L) s1 t1 s2) (H0 : Star (atomic L) s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : exists t' : trace, Star L (snd s2) t' (snd s3) /\\ fst s2 ** t' = t2 ** fst s3) : exists t' : trace, Star L (snd s1) t' (snd s3) /\\ fst s1 ** t' = t ** fst s3.","conclusion":"exists t' : trace, Star L (snd s1) t' (snd s3) /\\ fst s1 ** t' = t ** fst s3","hypotheses":"(s1 : state (atomic L)) (t1 : trace) (s2 : state (atomic L)) (t2 : trace) (s3 : state (atomic L)) (t : trace) (H : Step (atomic L) s1 t1 s2) (H0 : Star (atomic L) s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : exists t' : trace, Star L (snd s2) t' (snd s3) /\\ fst s2 ** t' = t2 ** fst s3)","proofString":"destruct IHstar as [t' [A B]].\nsimpl in H; inv H; simpl in *.\nexists t'; split.\neapply star_left; eauto.\nauto.\nexists (ev :: t0 ** t'); split.\neapply star_left; eauto.\nrewrite B; auto.\nexists t'; split.\nauto.\nrewrite B; auto."},{"statement":"(s1 : state (atomic L)) (t1 : trace) (s2 : state (atomic L)) (t2 : trace) (s3 : state (atomic L)) (t : trace) (H : Step (atomic L) s1 t1 s2) (H0 : Star (atomic L) s2 t2 s3) (H1 : t = t1 ** t2) (t' : trace) (A : Star L (snd s2) t' (snd s3)) (B : fst s2 ** t' = t2 ** fst s3) : exists t'0 : trace,\n  Star L (snd s1) t'0 (snd s3) /\\ fst s1 ** t'0 = t ** fst s3.","conclusion":"exists t'0 : trace,\n  Star L (snd s1) t'0 (snd s3) /\\ fst s1 ** t'0 = t ** fst s3","hypotheses":"(s1 : state (atomic L)) (t1 : trace) (s2 : state (atomic L)) (t2 : trace) (s3 : state (atomic L)) (t : trace) (H : Step (atomic L) s1 t1 s2) (H0 : Star (atomic L) s2 t2 s3) (H1 : t = t1 ** t2) (t' : trace) (A : Star L (snd s2) t' (snd s3)) (B : fst s2 ** t' = t2 ** fst s3)","proofString":"simpl in H; inv H; simpl in *.\nexists t'; split.\neapply star_left; eauto.\nauto.\nexists (ev :: t0 ** t'); split.\neapply star_left; eauto.\nrewrite B; auto.\nexists t'; split.\nauto.\nrewrite B; auto."},{"statement":"(t2 : trace) (s3 : trace * state L) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (t' : trace) (B : t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (H2 : Step L s E0 s') : exists t'0 : trace, Star L s t'0 (snd s3) /\\ t'0 = t2 ** fst s3.","conclusion":"exists t'0 : trace, Star L s t'0 (snd s3) /\\ t'0 = t2 ** fst s3","hypotheses":"(t2 : trace) (s3 : trace * state L) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (t' : trace) (B : t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (H2 : Step L s E0 s')","proofString":"exists t'; split.\neapply star_left; eauto.\nauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (t' : trace) (B : t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (H2 : Step L s E0 s') : Star L s t' (snd s3).","conclusion":"Star L s t' (snd s3)","hypotheses":"(t2 : trace) (s3 : trace * state L) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (t' : trace) (B : t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (H2 : Step L s E0 s')","proofString":"eapply star_left; eauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (t' : trace) (B : t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (H2 : Step L s E0 s') : t' = t2 ** fst s3.","conclusion":"t' = t2 ** fst s3","hypotheses":"(t2 : trace) (s3 : trace * state L) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (t' : trace) (B : t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (H2 : Step L s E0 s')","proofString":"auto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (ev : event) (H2 : Step L s (ev :: t0) s') : exists t'0 : trace, Star L s t'0 (snd s3) /\\ t'0 = ev :: t2 ** fst s3.","conclusion":"exists t'0 : trace, Star L s t'0 (snd s3) /\\ t'0 = ev :: t2 ** fst s3","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (ev : event) (H2 : Step L s (ev :: t0) s')","proofString":"exists (ev :: t0 ** t'); split.\neapply star_left; eauto.\nrewrite B; auto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (ev : event) (H2 : Step L s (ev :: t0) s') : Star L s (ev :: t0 ** t') (snd s3).","conclusion":"Star L s (ev :: t0 ** t') (snd s3)","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (ev : event) (H2 : Step L s (ev :: t0) s')","proofString":"eapply star_left; eauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (ev : event) (H2 : Step L s (ev :: t0) s') : ev :: t0 ** t' = ev :: t2 ** fst s3.","conclusion":"ev :: t0 ** t' = ev :: t2 ** fst s3","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s' t' (snd s3)) (s : state L) (ev : event) (H2 : Step L s (ev :: t0) s')","proofString":"rewrite B; auto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s t' (snd s3)) (ev : event) (H2 : output_event ev /\\ output_trace t0) : exists t'0 : trace,\n  Star L s t'0 (snd s3) /\\ ev :: t0 ** t'0 = ev :: t2 ** fst s3.","conclusion":"exists t'0 : trace,\n  Star L s t'0 (snd s3) /\\ ev :: t0 ** t'0 = ev :: t2 ** fst s3","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s t' (snd s3)) (ev : event) (H2 : output_event ev /\\ output_trace t0)","proofString":"exists t'; split.\nauto.\nrewrite B; auto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s t' (snd s3)) (ev : event) (H2 : output_event ev /\\ output_trace t0) : Star L s t' (snd s3).","conclusion":"Star L s t' (snd s3)","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s t' (snd s3)) (ev : event) (H2 : output_event ev /\\ output_trace t0)","proofString":"auto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s t' (snd s3)) (ev : event) (H2 : output_event ev /\\ output_trace t0) : ev :: t0 ** t' = ev :: t2 ** fst s3.","conclusion":"ev :: t0 ** t' = ev :: t2 ** fst s3","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (t' : trace) (B : t0 ** t' = t2 ** fst s3) (A : Star L s t' (snd s3)) (ev : event) (H2 : output_event ev /\\ output_trace t0)","proofString":"rewrite B; auto."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : Star (atomic L) (E0, s1) t (E0, s2)) : Star L s1 t s2.","conclusion":"Star L s1 t s2","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : Star (atomic L) (E0, s1) t (E0, s2))","proofString":"exploit atomic_star_star_gen; eauto.\nintros [t' [A B]].\nsimpl in *.\nreplace t with t'.\nauto.\nsubst; traceEq."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : Star (atomic L) (E0, s1) t (E0, s2)) : (exists t' : trace,\n   Star L (snd (E0, s1)) t' (snd (E0, s2)) /\\\n   fst (E0, s1) ** t' = t ** fst (E0, s2)) -> Star L s1 t s2.","conclusion":"(exists t' : trace,\n   Star L (snd (E0, s1)) t' (snd (E0, s2)) /\\\n   fst (E0, s1) ** t' = t ** fst (E0, s2)) -> Star L s1 t s2","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : Star (atomic L) (E0, s1) t (E0, s2))","proofString":"intros [t' [A B]].\nsimpl in *.\nreplace t with t'.\nauto.\nsubst; traceEq."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : Star (atomic L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L (snd (E0, s1)) t' (snd (E0, s2))) (B : fst (E0, s1) ** t' = t ** fst (E0, s2)) : Star L s1 t s2.","conclusion":"Star L s1 t s2","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : Star (atomic L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L (snd (E0, s1)) t' (snd (E0, s2))) (B : fst (E0, s1) ** t' = t ** fst (E0, s2))","proofString":"simpl in *.\nreplace t with t'.\nauto.\nsubst; traceEq."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : star (atomic_step L) (globalenv L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L s1 t' s2) (B : t' = t ** E0) : Star L s1 t s2.","conclusion":"Star L s1 t s2","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : star (atomic_step L) (globalenv L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L s1 t' s2) (B : t' = t ** E0)","proofString":"replace t with t'.\nauto.\nsubst; traceEq."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : star (atomic_step L) (globalenv L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L s1 t' s2) (B : t' = t ** E0) : Star L s1 t' s2.","conclusion":"Star L s1 t' s2","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : star (atomic_step L) (globalenv L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L s1 t' s2) (B : t' = t ** E0)","proofString":"auto."},{"statement":"(s1 : state L) (t : trace) (s2 : state L) (H : star (atomic_step L) (globalenv L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L s1 t' s2) (B : t' = t ** E0) : t' = t.","conclusion":"t' = t","hypotheses":"(s1 : state L) (t : trace) (s2 : state L) (H : star (atomic_step L) (globalenv L) (E0, s1) t (E0, s2)) (t' : trace) (A : Star L s1 t' s2) (B : t' = t ** E0)","proofString":"subst; traceEq."},{"statement":"(COINDHYP : forall s0 : state (atomic L),\nForever_silent (atomic L) s0 -> Forever_silent L (snd s0)) (s : state (atomic L)) (H : Forever_silent (atomic L) s) : Forever_silent L (snd s).","conclusion":"Forever_silent L (snd s)","hypotheses":"(COINDHYP : forall s0 : state (atomic L),\nForever_silent (atomic L) s0 -> Forever_silent L (snd s0)) (s : state (atomic L)) (H : Forever_silent (atomic L) s)","proofString":"inv H.\ninv H0.\napply forever_silent_intro with (snd (E0, s')).\nauto.\napply COINDHYP; auto."},{"statement":"(COINDHYP : forall s0 : state (atomic L),\nForever_silent (atomic L) s0 -> Forever_silent L (snd s0)) (s s2 : state (atomic L)) (H0 : Step (atomic L) s E0 s2) (H1 : Forever_silent (atomic L) s2) : Forever_silent L (snd s).","conclusion":"Forever_silent L (snd s)","hypotheses":"(COINDHYP : forall s0 : state (atomic L),\nForever_silent (atomic L) s0 -> Forever_silent L (snd s0)) (s s2 : state (atomic L)) (H0 : Step (atomic L) s E0 s2) (H1 : Forever_silent (atomic L) s2)","proofString":"inv H0.\napply forever_silent_intro with (snd (E0, s')).\nauto.\napply COINDHYP; auto."},{"statement":"(COINDHYP : forall s : state (atomic L),\nForever_silent (atomic L) s -> Forever_silent L (snd s)) (s' : state L) (H1 : Forever_silent (atomic L) (E0, s')) (s0 : state L) (H : Step L s0 E0 s') : Forever_silent L (snd (E0, s0)).","conclusion":"Forever_silent L (snd (E0, s0))","hypotheses":"(COINDHYP : forall s : state (atomic L),\nForever_silent (atomic L) s -> Forever_silent L (snd s)) (s' : state L) (H1 : Forever_silent (atomic L) (E0, s')) (s0 : state L) (H : Step L s0 E0 s')","proofString":"apply forever_silent_intro with (snd (E0, s')).\nauto.\napply COINDHYP; auto."},{"statement":"(COINDHYP : forall s : state (atomic L),\nForever_silent (atomic L) s -> Forever_silent L (snd s)) (s' : state L) (H1 : Forever_silent (atomic L) (E0, s')) (s0 : state L) (H : Step L s0 E0 s') : Step L (snd (E0, s0)) E0 (snd (E0, s')).","conclusion":"Step L (snd (E0, s0)) E0 (snd (E0, s'))","hypotheses":"(COINDHYP : forall s : state (atomic L),\nForever_silent (atomic L) s -> Forever_silent L (snd s)) (s' : state L) (H1 : Forever_silent (atomic L) (E0, s')) (s0 : state L) (H : Step L s0 E0 s')","proofString":"auto."},{"statement":"(COINDHYP : forall s : state (atomic L),\nForever_silent (atomic L) s -> Forever_silent L (snd s)) (s' : state L) (H1 : Forever_silent (atomic L) (E0, s')) (s0 : state L) (H : Step L s0 E0 s') : Forever_silent L (snd (E0, s')).","conclusion":"Forever_silent L (snd (E0, s'))","hypotheses":"(COINDHYP : forall s : state (atomic L),\nForever_silent (atomic L) s -> Forever_silent L (snd s)) (s' : state L) (H1 : Forever_silent (atomic L) (E0, s')) (s0 : state L) (H : Step L s0 E0 s')","proofString":"apply COINDHYP; auto."},{"statement":"forall (ts1 : state (atomic L)) (t : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t ts2 -> output_trace (fst ts1) -> output_trace (fst ts2).","conclusion":"forall (ts1 : state (atomic L)) (t : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t ts2 -> output_trace (fst ts1) -> output_trace (fst ts2)","hypotheses":"","proofString":"induction 1; intros.\nauto.\ninv H; simpl in *.\napply IHstar.\nauto.\napply IHstar.\nexploit Lwb; eauto.\ndestruct H2.\napply IHstar.\nauto."},{"statement":"(s : state (atomic L)) (H : output_trace (fst s)) : output_trace (fst s).","conclusion":"output_trace (fst s)","hypotheses":"(s : state (atomic L)) (H : output_trace (fst s))","proofString":"auto."},{"statement":"(s1 : state (atomic L)) (t1 : trace) (s2 : state (atomic L)) (t2 : trace) (s3 : state (atomic L)) (t : trace) (H : Step (atomic L) s1 t1 s2) (H0 : Star (atomic L) s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : output_trace (fst s2) -> output_trace (fst s3)) (H2 : output_trace (fst s1)) : output_trace (fst s3).","conclusion":"output_trace (fst s3)","hypotheses":"(s1 : state (atomic L)) (t1 : trace) (s2 : state (atomic L)) (t2 : trace) (s3 : state (atomic L)) (t : trace) (H : Step (atomic L) s1 t1 s2) (H0 : Star (atomic L) s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : output_trace (fst s2) -> output_trace (fst s3)) (H2 : output_trace (fst s1))","proofString":"inv H; simpl in *.\napply IHstar.\nauto.\napply IHstar.\nexploit Lwb; eauto.\ndestruct H2.\napply IHstar.\nauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (s' : state L) (IHstar : True -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (s : state L) (H2 : True) (H3 : Step L s E0 s') : output_trace (fst s3).","conclusion":"output_trace (fst s3)","hypotheses":"(t2 : trace) (s3 : trace * state L) (s' : state L) (IHstar : True -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (s : state L) (H2 : True) (H3 : Step L s E0 s')","proofString":"apply IHstar.\nauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (s' : state L) (IHstar : True -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (s : state L) (H2 : True) (H3 : Step L s E0 s') : True.","conclusion":"True","hypotheses":"(t2 : trace) (s3 : trace * state L) (s' : state L) (IHstar : True -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (E0, s') t2 s3) (s : state L) (H2 : True) (H3 : Step L s E0 s')","proofString":"auto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (s : state L) (H2 : True) (ev : event) (H3 : Step L s (ev :: t0) s') : output_trace (fst s3).","conclusion":"output_trace (fst s3)","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (s : state L) (H2 : True) (ev : event) (H3 : Step L s (ev :: t0) s')","proofString":"apply IHstar.\nexploit Lwb; eauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (s : state L) (H2 : True) (ev : event) (H3 : Step L s (ev :: t0) s') : output_trace t0.","conclusion":"output_trace t0","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s' : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s') t2 s3) (s : state L) (H2 : True) (ev : event) (H3 : Step L s (ev :: t0) s')","proofString":"exploit Lwb; eauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (ev : event) (H2 H3 : output_event ev /\\ output_trace t0) : output_trace (fst s3).","conclusion":"output_trace (fst s3)","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (ev : event) (H2 H3 : output_event ev /\\ output_trace t0)","proofString":"destruct H2.\napply IHstar.\nauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (ev : event) (H : output_event ev) (H1 : output_trace t0) (H3 : output_event ev /\\ output_trace t0) : output_trace (fst s3).","conclusion":"output_trace (fst s3)","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (ev : event) (H : output_event ev) (H1 : output_trace t0) (H3 : output_event ev /\\ output_trace t0)","proofString":"apply IHstar.\nauto."},{"statement":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (ev : event) (H : output_event ev) (H1 : output_trace t0) (H3 : output_event ev /\\ output_trace t0) : output_trace t0.","conclusion":"output_trace t0","hypotheses":"(t2 : trace) (s3 : trace * state L) (t0 : list event) (s : state L) (IHstar : output_trace t0 -> output_trace (fst s3)) (H0 : star (atomic_step L) (globalenv L) (t0, s) t2 s3) (ev : event) (H : output_event ev) (H1 : output_trace t0) (H3 : output_event ev /\\ output_trace t0)","proofString":"auto."},{"statement":"(H : forall (ts1 : state (atomic L)) (t : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t ts2 -> output_trace (fst ts1) -> output_trace (fst ts2)) : forall (s : state L) (t t' : trace) (s' : state L),\nStar (atomic L) (E0, s) t (t', s') -> output_trace t'.","conclusion":"forall (s : state L) (t t' : trace) (s' : state L),\nStar (atomic L) (E0, s) t (t', s') -> output_trace t'","hypotheses":"(H : forall (ts1 : state (atomic L)) (t : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t ts2 -> output_trace (fst ts1) -> output_trace (fst ts2))","proofString":"intros.\nchange t' with (fst (t',s')).\neapply H; eauto.\nsimpl; auto."},{"statement":"(H : forall (ts1 : state (atomic L)) (t0 : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t0 ts2 ->\noutput_trace (fst ts1) -> output_trace (fst ts2)) (s : state L) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) : output_trace t'.","conclusion":"output_trace t'","hypotheses":"(H : forall (ts1 : state (atomic L)) (t0 : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t0 ts2 ->\noutput_trace (fst ts1) -> output_trace (fst ts2)) (s : state L) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s'))","proofString":"change t' with (fst (t',s')).\neapply H; eauto.\nsimpl; auto."},{"statement":"(H : forall (ts1 : state (atomic L)) (t0 : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t0 ts2 ->\noutput_trace (fst ts1) -> output_trace (fst ts2)) (s : state L) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) : output_trace (fst (t', s')).","conclusion":"output_trace (fst (t', s'))","hypotheses":"(H : forall (ts1 : state (atomic L)) (t0 : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t0 ts2 ->\noutput_trace (fst ts1) -> output_trace (fst ts2)) (s : state L) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s'))","proofString":"eapply H; eauto.\nsimpl; auto."},{"statement":"(H : forall (ts1 : state (atomic L)) (t0 : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t0 ts2 ->\noutput_trace (fst ts1) -> output_trace (fst ts2)) (s : state L) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) : output_trace (fst (E0, s)).","conclusion":"output_trace (fst (E0, s))","hypotheses":"(H : forall (ts1 : state (atomic L)) (t0 : trace) (ts2 : state (atomic L)),\nStar (atomic L) ts1 t0 ts2 ->\noutput_trace (fst ts1) -> output_trace (fst ts2)) (s : state L) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s'))","proofString":"simpl; auto."},{"statement":"forall (t : trace) (s : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s) T' /\\ T = t *** T'.","conclusion":"forall (t : trace) (s : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s) T' /\\ T = t *** T'","hypotheses":"","proofString":"induction t; intros.\nexists T; auto.\ninv H.\ninv H0.\ncongruence.\nsimpl in H; inv H.\ndestruct (IHt s (t2***T0)) as [T' [A B]].\neapply star_forever_reactive; eauto.\nexists T'; split; auto.\nsimpl.\ncongruence."},{"statement":"(s : state L) (T : traceinf) (H : Forever_reactive (atomic L) (nil, s) T) : exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ T = nil *** T'.","conclusion":"exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ T = nil *** T'","hypotheses":"(s : state L) (T : traceinf) (H : Forever_reactive (atomic L) (nil, s) T)","proofString":"exists T; auto."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T0 : traceinf),\nForever_reactive (atomic L) (t, s0) T0 ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T0 = t *** T') (s : state L) (T : traceinf) (H : Forever_reactive (atomic L) (a :: t, s) T) : exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ T = (a :: t) *** T'.","conclusion":"exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ T = (a :: t) *** T'","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T0 : traceinf),\nForever_reactive (atomic L) (t, s0) T0 ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T0 = t *** T') (s : state L) (T : traceinf) (H : Forever_reactive (atomic L) (a :: t, s) T)","proofString":"inv H.\ninv H0.\ncongruence.\nsimpl in H; inv H.\ndestruct (IHt s (t2***T0)) as [T' [A B]].\neapply star_forever_reactive; eauto.\nexists T'; split; auto.\nsimpl.\ncongruence."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (t0 : trace) (T0 : traceinf) (H0 : Star (atomic L) (a :: t, s) t0 s2) (H1 : t0 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) : exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ t0 *** T0 = (a :: t) *** T'.","conclusion":"exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ t0 *** T0 = (a :: t) *** T'","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (t0 : trace) (T0 : traceinf) (H0 : Star (atomic L) (a :: t, s) t0 s2) (H1 : t0 <> E0) (H2 : Forever_reactive (atomic L) s2 T0)","proofString":"inv H0.\ncongruence.\nsimpl in H; inv H.\ndestruct (IHt s (t2***T0)) as [T' [A B]].\neapply star_forever_reactive; eauto.\nexists T'; split; auto.\nsimpl.\ncongruence."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (T0 : traceinf) (H1 : E0 <> E0) (H2 : Forever_reactive (atomic L) (a :: t, s) T0) : exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ E0 *** T0 = (a :: t) *** T'.","conclusion":"exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\ E0 *** T0 = (a :: t) *** T'","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (T0 : traceinf) (H1 : E0 <> E0) (H2 : Forever_reactive (atomic L) (a :: t, s) T0)","proofString":"congruence."},{"statement":"(a : event) (t : list event) (IHt : forall (s1 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s1) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s1) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t1 t2 : trace) (H1 : t1 ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (s0 : state (atomic L)) (H : Step (atomic L) (a :: t, s) t1 s0) (H3 : Star (atomic L) s0 t2 s2) : exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\\n  (t1 ** t2) *** T0 = (a :: t) *** T'.","conclusion":"exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\\n  (t1 ** t2) *** T0 = (a :: t) *** T'","hypotheses":"(a : event) (t : list event) (IHt : forall (s1 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s1) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s1) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t1 t2 : trace) (H1 : t1 ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (s0 : state (atomic L)) (H : Step (atomic L) (a :: t, s) t1 s0) (H3 : Star (atomic L) s0 t2 s2)","proofString":"simpl in H; inv H.\ndestruct (IHt s (t2***T0)) as [T' [A B]].\neapply star_forever_reactive; eauto.\nexists T'; split; auto.\nsimpl.\ncongruence."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) : exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\\n  ((a :: nil) ** t2) *** T0 = (a :: t) *** T'.","conclusion":"exists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s) T' /\\\n  ((a :: nil) ** t2) *** T0 = (a :: t) *** T'","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t))","proofString":"destruct (IHt s (t2***T0)) as [T' [A B]].\neapply star_forever_reactive; eauto.\nexists T'; split; auto.\nsimpl.\ncongruence."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) : Forever_reactive (atomic L) (t, s) (t2 *** T0).","conclusion":"Forever_reactive (atomic L) (t, s) (t2 *** T0)","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s0) T' /\\ T = t *** T') (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t))","proofString":"eapply star_forever_reactive; eauto."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t *** T'0) (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s) T') (B : t2 *** T0 = t *** T') : exists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s) T'0 /\\\n  ((a :: nil) ** t2) *** T0 = (a :: t) *** T'0.","conclusion":"exists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s) T'0 /\\\n  ((a :: nil) ** t2) *** T0 = (a :: t) *** T'0","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t *** T'0) (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s) T') (B : t2 *** T0 = t *** T')","proofString":"exists T'; split; auto.\nsimpl.\ncongruence."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t *** T'0) (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s) T') (B : t2 *** T0 = t *** T') : ((a :: nil) ** t2) *** T0 = (a :: t) *** T'.","conclusion":"((a :: nil) ** t2) *** T0 = (a :: t) *** T'","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t *** T'0) (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s) T') (B : t2 *** T0 = t *** T')","proofString":"simpl.\ncongruence."},{"statement":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t *** T'0) (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s) T') (B : t2 *** T0 = t *** T') : Econsinf a (t2 *** T0) = Econsinf a (t *** T').","conclusion":"Econsinf a (t2 *** T0) = Econsinf a (t *** T')","hypotheses":"(a : event) (t : list event) (IHt : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t *** T'0) (s : state L) (s2 : state (atomic L)) (T0 : traceinf) (t2 : trace) (H1 : (a :: nil) ** t2 <> E0) (H2 : Forever_reactive (atomic L) s2 T0) (H3 : Star (atomic L) (t, s) t2 s2) (H8 : output_trace (a :: t)) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s) T') (B : t2 *** T0 = t *** T')","proofString":"congruence."},{"statement":"(H : forall (t : trace) (s : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s) T' /\\ T = t *** T') : forall (s : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s) T -> Forever_reactive L s T.","conclusion":"forall (s : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s) T -> Forever_reactive L s T","hypotheses":"(H : forall (t : trace) (s : state L) (T : traceinf),\nForever_reactive (atomic L) (t, s) T ->\nexists T' : traceinf, Forever_reactive (atomic L) (E0, s) T' /\\ T = t *** T')","proofString":"cofix COINDHYP; intros.\ninv H0.\ndestruct s2 as [t2 s2].\ndestruct (H _ _ _ H3) as [T' [A B]].\nassert (Star (atomic L) (E0, s) (t**t2) (E0, s2)).\neapply star_trans.\neauto.\napply atomic_finish.\neapply star_atomic_output_trace; eauto.\nauto.\nreplace (t *** T0) with ((t ** t2) *** T').\napply forever_reactive_intro with s2.\napply atomic_star_star; auto.\ndestruct t; simpl in *; unfold E0 in *; congruence.\napply COINDHYP.\nauto.\nsubst T0; traceEq."},{"statement":"(H : forall (t : trace) (s0 : state L) (T0 : traceinf),\nForever_reactive (atomic L) (t, s0) T0 ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T0 = t *** T') (COINDHYP : forall (s0 : state L) (T0 : traceinf),\nForever_reactive (atomic L) (E0, s0) T0 -> Forever_reactive L s0 T0) (s : state L) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T) : Forever_reactive L s T.","conclusion":"Forever_reactive L s T","hypotheses":"(H : forall (t : trace) (s0 : state L) (T0 : traceinf),\nForever_reactive (atomic L) (t, s0) T0 ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T0 = t *** T') (COINDHYP : forall (s0 : state L) (T0 : traceinf),\nForever_reactive (atomic L) (E0, s0) T0 -> Forever_reactive L s0 T0) (s : state L) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T)","proofString":"inv H0.\ndestruct s2 as [t2 s2].\ndestruct (H _ _ _ H3) as [T' [A B]].\nassert (Star (atomic L) (E0, s) (t**t2) (E0, s2)).\neapply star_trans.\neauto.\napply atomic_finish.\neapply star_atomic_output_trace; eauto.\nauto.\nreplace (t *** T0) with ((t ** t2) *** T').\napply forever_reactive_intro with s2.\napply atomic_star_star; auto.\ndestruct t; simpl in *; unfold E0 in *; congruence.\napply COINDHYP.\nauto.\nsubst T0; traceEq."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T = t0 *** T') (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (s2 : state (atomic L)) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t s2) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) s2 T0) : Forever_reactive L s (t *** T0).","conclusion":"Forever_reactive L s (t *** T0)","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T = t0 *** T') (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (s2 : state (atomic L)) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t s2) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) s2 T0)","proofString":"destruct s2 as [t2 s2].\ndestruct (H _ _ _ H3) as [T' [A B]].\nassert (Star (atomic L) (E0, s) (t**t2) (E0, s2)).\neapply star_trans.\neauto.\napply atomic_finish.\neapply star_atomic_output_trace; eauto.\nauto.\nreplace (t *** T0) with ((t ** t2) *** T').\napply forever_reactive_intro with s2.\napply atomic_star_star; auto.\ndestruct t; simpl in *; unfold E0 in *; congruence.\napply COINDHYP.\nauto.\nsubst T0; traceEq."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T = t0 *** T') (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) : Forever_reactive L s (t *** T0).","conclusion":"Forever_reactive L s (t *** T0)","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T' : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T' /\\ T = t0 *** T') (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0)","proofString":"destruct (H _ _ _ H3) as [T' [A B]].\nassert (Star (atomic L) (E0, s) (t**t2) (E0, s2)).\neapply star_trans.\neauto.\napply atomic_finish.\neapply star_atomic_output_trace; eauto.\nauto.\nreplace (t *** T0) with ((t ** t2) *** T').\napply forever_reactive_intro with s2.\napply atomic_star_star; auto.\ndestruct t; simpl in *; unfold E0 in *; congruence.\napply COINDHYP.\nauto.\nsubst T0; traceEq."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') : Forever_reactive L s (t *** T0).","conclusion":"Forever_reactive L s (t *** T0)","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T')","proofString":"assert (Star (atomic L) (E0, s) (t**t2) (E0, s2)).\neapply star_trans.\neauto.\napply atomic_finish.\neapply star_atomic_output_trace; eauto.\nauto.\nreplace (t *** T0) with ((t ** t2) *** T').\napply forever_reactive_intro with s2.\napply atomic_star_star; auto.\ndestruct t; simpl in *; unfold E0 in *; congruence.\napply COINDHYP.\nauto.\nsubst T0; traceEq."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') : Star (atomic L) (E0, s) (t ** t2) (E0, s2).","conclusion":"Star (atomic L) (E0, s) (t ** t2) (E0, s2)","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T')","proofString":"eapply star_trans.\neauto.\napply atomic_finish.\neapply star_atomic_output_trace; eauto.\nauto."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') : output_trace t2.","conclusion":"output_trace t2","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T')","proofString":"eapply star_atomic_output_trace; eauto."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2)) : Forever_reactive L s (t *** T0).","conclusion":"Forever_reactive L s (t *** T0)","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2))","proofString":"replace (t *** T0) with ((t ** t2) *** T').\napply forever_reactive_intro with s2.\napply atomic_star_star; auto.\ndestruct t; simpl in *; unfold E0 in *; congruence.\napply COINDHYP.\nauto.\nsubst T0; traceEq."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2)) : Forever_reactive L s ((t ** t2) *** T').","conclusion":"Forever_reactive L s ((t ** t2) *** T')","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2))","proofString":"apply forever_reactive_intro with s2.\napply atomic_star_star; auto.\ndestruct t; simpl in *; unfold E0 in *; congruence.\napply COINDHYP.\nauto."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2)) : Star L s (t ** t2) s2.","conclusion":"Star L s (t ** t2) s2","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2))","proofString":"apply atomic_star_star; auto."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2)) : t ** t2 <> E0.","conclusion":"t ** t2 <> E0","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2))","proofString":"destruct t; simpl in *; unfold E0 in *; congruence."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2)) : Forever_reactive L s2 T'.","conclusion":"Forever_reactive L s2 T'","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2))","proofString":"apply COINDHYP.\nauto."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2)) : Forever_reactive (atomic L) (E0, s2) T'.","conclusion":"Forever_reactive (atomic L) (E0, s2) T'","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2))","proofString":"auto."},{"statement":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2)) : (t ** t2) *** T' = t *** T0.","conclusion":"(t ** t2) *** T' = t *** T0","hypotheses":"(H : forall (t0 : trace) (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (t0, s0) T ->\nexists T'0 : traceinf,\n  Forever_reactive (atomic L) (E0, s0) T'0 /\\ T = t0 *** T'0) (COINDHYP : forall (s0 : state L) (T : traceinf),\nForever_reactive (atomic L) (E0, s0) T -> Forever_reactive L s0 T) (s : state L) (t2 : trace) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star (atomic L) (E0, s) t (t2, s2)) (H2 : t <> E0) (H3 : Forever_reactive (atomic L) (t2, s2) T0) (T' : traceinf) (A : Forever_reactive (atomic L) (E0, s2) T') (B : T0 = t2 *** T') (H0 : Star (atomic L) (E0, s) (t ** t2) (E0, s2))","proofString":"subst T0; traceEq."},{"statement":"(beh : program_behavior) (H : program_behaves L beh) : program_behaves (atomic L) beh.","conclusion":"program_behaves (atomic L) beh","hypotheses":"(beh : program_behavior) (H : program_behaves L beh)","proofString":"exploit forward_simulation_behavior_improves.\neapply atomic_forward_simulation.\neauto.\nintros [beh2 [A B]].\nred in B.\ndestruct B as [EQ | [t [C D]]].\ncongruence.\nsubst beh.\ninv H.\ninv H1.\napply program_runs with (E0,s).\nsimpl; auto.\napply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto.\napply program_goes_initially_wrong.\nintros; red; intros.\nsimpl in H; destruct H.\neelim H1; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (B : behavior_improves beh beh2) : program_behaves (atomic L) beh.","conclusion":"program_behaves (atomic L) beh","hypotheses":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (B : behavior_improves beh beh2)","proofString":"red in B.\ndestruct B as [EQ | [t [C D]]].\ncongruence.\nsubst beh.\ninv H.\ninv H1.\napply program_runs with (E0,s).\nsimpl; auto.\napply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto.\napply program_goes_initially_wrong.\nintros; red; intros.\nsimpl in H; destruct H.\neelim H1; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (B : beh = beh2 \\/\n(exists t : trace, beh = Goes_wrong t /\\ behavior_prefix t beh2)) : program_behaves (atomic L) beh.","conclusion":"program_behaves (atomic L) beh","hypotheses":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (B : beh = beh2 \\/\n(exists t : trace, beh = Goes_wrong t /\\ behavior_prefix t beh2))","proofString":"destruct B as [EQ | [t [C D]]].\ncongruence.\nsubst beh.\ninv H.\ninv H1.\napply program_runs with (E0,s).\nsimpl; auto.\napply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto.\napply program_goes_initially_wrong.\nintros; red; intros.\nsimpl in H; destruct H.\neelim H1; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (EQ : beh = beh2) : program_behaves (atomic L) beh.","conclusion":"program_behaves (atomic L) beh","hypotheses":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (EQ : beh = beh2)","proofString":"congruence."},{"statement":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (t : trace) (C : beh = Goes_wrong t) (D : behavior_prefix t beh2) : program_behaves (atomic L) beh.","conclusion":"program_behaves (atomic L) beh","hypotheses":"(beh : program_behavior) (H : program_behaves L beh) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (t : trace) (C : beh = Goes_wrong t) (D : behavior_prefix t beh2)","proofString":"subst beh.\ninv H.\ninv H1.\napply program_runs with (E0,s).\nsimpl; auto.\napply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto.\napply program_goes_initially_wrong.\nintros; red; intros.\nsimpl in H; destruct H.\neelim H1; eauto."},{"statement":"(t : trace) (H : program_behaves L (Goes_wrong t)) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) : program_behaves (atomic L) (Goes_wrong t).","conclusion":"program_behaves (atomic L) (Goes_wrong t)","hypotheses":"(t : trace) (H : program_behaves L (Goes_wrong t)) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2)","proofString":"inv H.\ninv H1.\napply program_runs with (E0,s).\nsimpl; auto.\napply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto.\napply program_goes_initially_wrong.\nintros; red; intros.\nsimpl in H; destruct H.\neelim H1; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (H1 : state_behaves L s (Goes_wrong t)) : program_behaves (atomic L) (Goes_wrong t).","conclusion":"program_behaves (atomic L) (Goes_wrong t)","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (H1 : state_behaves L s (Goes_wrong t))","proofString":"inv H1.\napply program_runs with (E0,s).\nsimpl; auto.\napply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) : program_behaves (atomic L) (Goes_wrong t).","conclusion":"program_behaves (atomic L) (Goes_wrong t)","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r)","proofString":"apply program_runs with (E0,s).\nsimpl; auto.\napply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) : initial_state (atomic L) (E0, s).","conclusion":"initial_state (atomic L) (E0, s)","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r)","proofString":"simpl; auto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) : state_behaves (atomic L) (E0, s) (Goes_wrong t).","conclusion":"state_behaves (atomic L) (E0, s) (Goes_wrong t)","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r)","proofString":"apply state_goes_wrong with (E0,s').\napply star_atomic_star; auto.\nred; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto.\nintros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) : Star (atomic L) (E0, s) t (E0, s').","conclusion":"Star (atomic L) (E0, s) t (E0, s')","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r)","proofString":"apply star_atomic_star; auto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) : Nostep (atomic L) (E0, s').","conclusion":"Nostep (atomic L) (E0, s')","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r)","proofString":"red; intros; red; intros.\ninv H.\neelim H3; eauto.\neelim H3; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) (t0 : trace) (s'0 : state (atomic L)) (H : Step (atomic L) (E0, s') t0 s'0) : False.","conclusion":"False","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) (t0 : trace) (s'0 : state (atomic L)) (H : Step (atomic L) (E0, s') t0 s'0)","proofString":"inv H.\neelim H3; eauto.\neelim H3; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) (s'1 : state L) (H5 : Step L s' E0 s'1) : False.","conclusion":"False","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) (s'1 : state L) (H5 : Step L s' E0 s'1)","proofString":"eelim H3; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) (ev : event) (t1 : list event) (s'1 : state L) (H5 : Step L s' (ev :: t1) s'1) : False.","conclusion":"False","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) (ev : event) (t1 : list event) (s'1 : state L) (H5 : Step L s' (ev :: t1) s'1)","proofString":"eelim H3; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r) : forall r : int, ~ final_state (atomic L) (E0, s') r.","conclusion":"forall r : int, ~ final_state (atomic L) (E0, s') r","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r : int, ~ final_state L s' r)","proofString":"intros; red; intros.\nsimpl in H.\ndestruct H.\neelim H4; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r0 : int, ~ final_state L s' r0) (r : int) (H : final_state (atomic L) (E0, s') r) : False.","conclusion":"False","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r0 : int, ~ final_state L s' r0) (r : int) (H : final_state (atomic L) (E0, s') r)","proofString":"simpl in H.\ndestruct H.\neelim H4; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r0 : int, ~ final_state L s' r0) (r : int) (H : final_state L s' r /\\ E0 = E0) : False.","conclusion":"False","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r0 : int, ~ final_state L s' r0) (r : int) (H : final_state L s' r /\\ E0 = E0)","proofString":"destruct H.\neelim H4; eauto."},{"statement":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r0 : int, ~ final_state L s' r0) (r : int) (H : final_state L s' r) (H1 : E0 = E0) : False.","conclusion":"False","hypotheses":"(t : trace) (beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix t beh2) (s : state L) (H0 : initial_state L s) (s' : state L) (H2 : Star L s t s') (H3 : Nostep L s') (H4 : forall r0 : int, ~ final_state L s' r0) (r : int) (H : final_state L s' r) (H1 : E0 = E0)","proofString":"eelim H4; eauto."},{"statement":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s : state L, ~ initial_state L s) : program_behaves (atomic L) (Goes_wrong E0).","conclusion":"program_behaves (atomic L) (Goes_wrong E0)","hypotheses":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s : state L, ~ initial_state L s)","proofString":"apply program_goes_initially_wrong.\nintros; red; intros.\nsimpl in H; destruct H.\neelim H1; eauto."},{"statement":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s : state L, ~ initial_state L s) : forall s : state (atomic L), ~ initial_state (atomic L) s.","conclusion":"forall s : state (atomic L), ~ initial_state (atomic L) s","hypotheses":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s : state L, ~ initial_state L s)","proofString":"intros; red; intros.\nsimpl in H; destruct H.\neelim H1; eauto."},{"statement":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s0 : state L, ~ initial_state L s0) (s : state (atomic L)) (H : initial_state (atomic L) s) : False.","conclusion":"False","hypotheses":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s0 : state L, ~ initial_state L s0) (s : state (atomic L)) (H : initial_state (atomic L) s)","proofString":"simpl in H; destruct H.\neelim H1; eauto."},{"statement":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s0 : state L, ~ initial_state L s0) (s : state (atomic L)) (H : initial_state L (snd s)) (H0 : fst s = E0) : False.","conclusion":"False","hypotheses":"(beh2 : program_behavior) (A : program_behaves (atomic L) beh2) (D : behavior_prefix E0 beh2) (H1 : forall s0 : state L, ~ initial_state L s0) (s : state (atomic L)) (H : initial_state L (snd s)) (H0 : fst s = E0)","proofString":"eelim H1; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves (atomic L) beh) : program_behaves L beh.","conclusion":"program_behaves L beh","hypotheses":"(beh : program_behavior) (H : program_behaves (atomic L) beh)","proofString":"inv H.\ndestruct s as [t s].\nsimpl in H0.\ndestruct H0; subst t.\napply program_runs with s; auto.\ninv H1.\ndestruct s' as [t' s'].\nsimpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto.\neconstructor.\napply atomic_forever_reactive_forever_reactive.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto.\napply program_goes_initially_wrong.\nintros; red; intros.\nelim (H0 (E0,s)); simpl; auto."},{"statement":"(beh : program_behavior) (s : state (atomic L)) (H0 : initial_state (atomic L) s) (H1 : state_behaves (atomic L) s beh) : program_behaves L beh.","conclusion":"program_behaves L beh","hypotheses":"(beh : program_behavior) (s : state (atomic L)) (H0 : initial_state (atomic L) s) (H1 : state_behaves (atomic L) s beh)","proofString":"destruct s as [t s].\nsimpl in H0.\ndestruct H0; subst t.\napply program_runs with s; auto.\ninv H1.\ndestruct s' as [t' s'].\nsimpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto.\neconstructor.\napply atomic_forever_reactive_forever_reactive.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(beh : program_behavior) (t : trace) (s : state L) (H0 : initial_state (atomic L) (t, s)) (H1 : state_behaves (atomic L) (t, s) beh) : program_behaves L beh.","conclusion":"program_behaves L beh","hypotheses":"(beh : program_behavior) (t : trace) (s : state L) (H0 : initial_state (atomic L) (t, s)) (H1 : state_behaves (atomic L) (t, s) beh)","proofString":"simpl in H0.\ndestruct H0; subst t.\napply program_runs with s; auto.\ninv H1.\ndestruct s' as [t' s'].\nsimpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto.\neconstructor.\napply atomic_forever_reactive_forever_reactive.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(beh : program_behavior) (t : trace) (s : state L) (H0 : initial_state L s /\\ t = E0) (H1 : state_behaves (atomic L) (t, s) beh) : program_behaves L beh.","conclusion":"program_behaves L beh","hypotheses":"(beh : program_behavior) (t : trace) (s : state L) (H0 : initial_state L s /\\ t = E0) (H1 : state_behaves (atomic L) (t, s) beh)","proofString":"destruct H0; subst t.\napply program_runs with s; auto.\ninv H1.\ndestruct s' as [t' s'].\nsimpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto.\neconstructor.\napply atomic_forever_reactive_forever_reactive.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(beh : program_behavior) (s : state L) (H : initial_state L s) (H1 : state_behaves (atomic L) (E0, s) beh) : program_behaves L beh.","conclusion":"program_behaves L beh","hypotheses":"(beh : program_behavior) (s : state L) (H : initial_state L s) (H1 : state_behaves (atomic L) (E0, s) beh)","proofString":"apply program_runs with s; auto.\ninv H1.\ndestruct s' as [t' s'].\nsimpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto.\neconstructor.\napply atomic_forever_reactive_forever_reactive.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(beh : program_behavior) (s : state L) (H : initial_state L s) (H1 : state_behaves (atomic L) (E0, s) beh) : state_behaves L s beh.","conclusion":"state_behaves L s beh","hypotheses":"(beh : program_behavior) (s : state L) (H : initial_state L s) (H1 : state_behaves (atomic L) (E0, s) beh)","proofString":"inv H1.\ndestruct s' as [t' s'].\nsimpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto.\neconstructor.\napply atomic_forever_reactive_forever_reactive.\nauto.\ndestruct s' as [t' s'].\nassert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state (atomic L)) (r : int) (H0 : Star (atomic L) (E0, s) t s') (H2 : final_state (atomic L) s' r) : state_behaves L s (Terminates t r).","conclusion":"state_behaves L s (Terminates t r)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state (atomic L)) (r : int) (H0 : Star (atomic L) (E0, s) t s') (H2 : final_state (atomic L) s' r)","proofString":"destruct s' as [t' s'].\nsimpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (r : int) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : final_state (atomic L) (t', s') r) : state_behaves L s (Terminates t r).","conclusion":"state_behaves L s (Terminates t r)","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (r : int) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : final_state (atomic L) (t', s') r)","proofString":"simpl in H2; destruct H2; subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (r : int) (H0 : Star (atomic L) (E0, s) t (E0, s')) (H1 : final_state L s' r) : state_behaves L s (Terminates t r).","conclusion":"state_behaves L s (Terminates t r)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (r : int) (H0 : Star (atomic L) (E0, s) t (E0, s')) (H1 : final_state L s' r)","proofString":"econstructor.\neapply atomic_star_star; eauto.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state (atomic L)) (H0 : Star (atomic L) (E0, s) t s') (H2 : Forever_silent (atomic L) s') : state_behaves L s (Diverges t).","conclusion":"state_behaves L s (Diverges t)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state (atomic L)) (H0 : Star (atomic L) (E0, s) t s') (H2 : Forever_silent (atomic L) s')","proofString":"destruct s' as [t' s'].\nassert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Forever_silent (atomic L) (t', s')) : state_behaves L s (Diverges t).","conclusion":"state_behaves L s (Diverges t)","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Forever_silent (atomic L) (t', s'))","proofString":"assert (t' = E0).\ninv H2.\ninv H1; auto.\nsubst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Forever_silent (atomic L) (t', s')) : t' = E0.","conclusion":"t' = E0","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Forever_silent (atomic L) (t', s'))","proofString":"inv H2.\ninv H1; auto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (s2 : state (atomic L)) (H1 : Step (atomic L) (t', s') E0 s2) (H3 : Forever_silent (atomic L) s2) : t' = E0.","conclusion":"t' = E0","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (s2 : state (atomic L)) (H1 : Step (atomic L) (t', s') E0 s2) (H3 : Forever_silent (atomic L) s2)","proofString":"inv H1; auto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Forever_silent (atomic L) (t', s')) (H1 : t' = E0) : state_behaves L s (Diverges t).","conclusion":"state_behaves L s (Diverges t)","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Forever_silent (atomic L) (t', s')) (H1 : t' = E0)","proofString":"subst t'.\neconstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H2 : Forever_silent (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) : state_behaves L s (Diverges t).","conclusion":"state_behaves L s (Diverges t)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H2 : Forever_silent (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s'))","proofString":"econstructor.\neapply atomic_star_star; eauto.\nchange s' with (snd (E0,s')).\napply atomic_forever_silent_forever_silent.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H2 : Forever_silent (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) : Forever_silent L (snd (E0, s')).","conclusion":"Forever_silent L (snd (E0, s'))","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H2 : Forever_silent (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s'))","proofString":"apply atomic_forever_silent_forever_silent.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H2 : Forever_silent (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) : Forever_silent (atomic L) (E0, s').","conclusion":"Forever_silent (atomic L) (E0, s')","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H2 : Forever_silent (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s'))","proofString":"auto."},{"statement":"(s : state L) (H : initial_state L s) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T) : state_behaves L s (Reacts T).","conclusion":"state_behaves L s (Reacts T)","hypotheses":"(s : state L) (H : initial_state L s) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T)","proofString":"econstructor.\napply atomic_forever_reactive_forever_reactive.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T) : Forever_reactive L s T.","conclusion":"Forever_reactive L s T","hypotheses":"(s : state L) (H : initial_state L s) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T)","proofString":"apply atomic_forever_reactive_forever_reactive.\nauto."},{"statement":"(s : state L) (H : initial_state L s) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T) : Forever_reactive (atomic L) (E0, s) T.","conclusion":"Forever_reactive (atomic L) (E0, s) T","hypotheses":"(s : state L) (H : initial_state L s) (T : traceinf) (H0 : Forever_reactive (atomic L) (E0, s) T)","proofString":"auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state (atomic L)) (H0 : Star (atomic L) (E0, s) t s') (H2 : Nostep (atomic L) s') (H3 : forall r : int, ~ final_state (atomic L) s' r) : state_behaves L s (Goes_wrong t).","conclusion":"state_behaves L s (Goes_wrong t)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state (atomic L)) (H0 : Star (atomic L) (E0, s) t s') (H2 : Nostep (atomic L) s') (H3 : forall r : int, ~ final_state (atomic L) s' r)","proofString":"destruct s' as [t' s'].\nassert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Nostep (atomic L) (t', s')) (H3 : forall r : int, ~ final_state (atomic L) (t', s') r) : state_behaves L s (Goes_wrong t).","conclusion":"state_behaves L s (Goes_wrong t)","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Nostep (atomic L) (t', s')) (H3 : forall r : int, ~ final_state (atomic L) (t', s') r)","proofString":"assert (t' = E0).\ndestruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto.\nsubst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Nostep (atomic L) (t', s')) (H3 : forall r : int, ~ final_state (atomic L) (t', s') r) : t' = E0.","conclusion":"t' = E0","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Nostep (atomic L) (t', s')) (H3 : forall r : int, ~ final_state (atomic L) (t', s') r)","proofString":"destruct t'; auto.\neelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (e : event) (t' : list event) (s' : state L) (H0 : Star (atomic L) (E0, s) t (e :: t', s')) (H2 : Nostep (atomic L) (e :: t', s')) (H3 : forall r : int, ~ final_state (atomic L) (e :: t', s') r) : e :: t' = E0.","conclusion":"e :: t' = E0","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (e : event) (t' : list event) (s' : state L) (H0 : Star (atomic L) (E0, s) t (e :: t', s')) (H2 : Nostep (atomic L) (e :: t', s')) (H3 : forall r : int, ~ final_state (atomic L) (e :: t', s') r)","proofString":"eelim H2.\nsimpl.\napply atomic_step_continue.\neapply star_atomic_output_trace; eauto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (e : event) (t' : list event) (s' : state L) (H0 : Star (atomic L) (E0, s) t (e :: t', s')) (H2 : Nostep (atomic L) (e :: t', s')) (H3 : forall r : int, ~ final_state (atomic L) (e :: t', s') r) : output_trace (e :: t').","conclusion":"output_trace (e :: t')","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (e : event) (t' : list event) (s' : state L) (H0 : Star (atomic L) (E0, s) t (e :: t', s')) (H2 : Nostep (atomic L) (e :: t', s')) (H3 : forall r : int, ~ final_state (atomic L) (e :: t', s') r)","proofString":"eapply star_atomic_output_trace; eauto."},{"statement":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Nostep (atomic L) (t', s')) (H3 : forall r : int, ~ final_state (atomic L) (t', s') r) (H1 : t' = E0) : state_behaves L s (Goes_wrong t).","conclusion":"state_behaves L s (Goes_wrong t)","hypotheses":"(s : state L) (H : initial_state L s) (t t' : trace) (s' : state L) (H0 : Star (atomic L) (E0, s) t (t', s')) (H2 : Nostep (atomic L) (t', s')) (H3 : forall r : int, ~ final_state (atomic L) (t', s') r) (H1 : t' = E0)","proofString":"subst t'.\neconstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) : state_behaves L s (Goes_wrong t).","conclusion":"state_behaves L s (Goes_wrong t)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s'))","proofString":"econstructor.\napply atomic_star_star; eauto.\nred; intros; red; intros.\ndestruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto.\nintros; red; intros.\nelim (H3 r).\nsimpl; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (t0 : trace) (s'0 : state L) (H1 : Step L s' t0 s'0) : False.","conclusion":"False","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (t0 : trace) (s'0 : state L) (H1 : Step L s' t0 s'0)","proofString":"destruct t0.\nelim (H2 E0 (E0,s'0)).\nconstructor; auto.\nelim (H2 (e::nil) (t0,s'0)).\nconstructor; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (s'0 : state L) (H1 : Step L s' nil s'0) : False.","conclusion":"False","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (s'0 : state L) (H1 : Step L s' nil s'0)","proofString":"elim (H2 E0 (E0,s'0)).\nconstructor; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (s'0 : state L) (H1 : Step L s' nil s'0) : Step (atomic L) (E0, s') E0 (E0, s'0).","conclusion":"Step (atomic L) (E0, s') E0 (E0, s'0)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (s'0 : state L) (H1 : Step L s' nil s'0)","proofString":"constructor; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (e : event) (t0 : list event) (s'0 : state L) (H1 : Step L s' (e :: t0) s'0) : False.","conclusion":"False","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (e : event) (t0 : list event) (s'0 : state L) (H1 : Step L s' (e :: t0) s'0)","proofString":"elim (H2 (e::nil) (t0,s'0)).\nconstructor; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (e : event) (t0 : list event) (s'0 : state L) (H1 : Step L s' (e :: t0) s'0) : Step (atomic L) (E0, s') (e :: nil) (t0, s'0).","conclusion":"Step (atomic L) (E0, s') (e :: nil) (t0, s'0)","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r : int, ~ final_state (atomic L) (E0, s') r) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (e : event) (t0 : list event) (s'0 : state L) (H1 : Step L s' (e :: t0) s'0)","proofString":"constructor; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r0 : int, ~ final_state (atomic L) (E0, s') r0) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (r : int) (H1 : final_state L s' r) : False.","conclusion":"False","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r0 : int, ~ final_state (atomic L) (E0, s') r0) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (r : int) (H1 : final_state L s' r)","proofString":"elim (H3 r).\nsimpl; auto."},{"statement":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r0 : int, ~ final_state (atomic L) (E0, s') r0) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (r : int) (H1 : final_state L s' r) : final_state (atomic L) (E0, s') r.","conclusion":"final_state (atomic L) (E0, s') r","hypotheses":"(s : state L) (H : initial_state L s) (t : trace) (s' : state L) (H3 : forall r0 : int, ~ final_state (atomic L) (E0, s') r0) (H2 : Nostep (atomic L) (E0, s')) (H0 : Star (atomic L) (E0, s) t (E0, s')) (r : int) (H1 : final_state L s' r)","proofString":"simpl; auto."},{"statement":"(H0 : forall s : state (atomic L), ~ initial_state (atomic L) s) : program_behaves L (Goes_wrong E0).","conclusion":"program_behaves L (Goes_wrong E0)","hypotheses":"(H0 : forall s : state (atomic L), ~ initial_state (atomic L) s)","proofString":"apply program_goes_initially_wrong.\nintros; red; intros.\nelim (H0 (E0,s)); simpl; auto."},{"statement":"(H0 : forall s : state (atomic L), ~ initial_state (atomic L) s) : forall s : state L, ~ initial_state L s.","conclusion":"forall s : state L, ~ initial_state L s","hypotheses":"(H0 : forall s : state (atomic L), ~ initial_state (atomic L) s)","proofString":"intros; red; intros.\nelim (H0 (E0,s)); simpl; auto."},{"statement":"(H0 : forall s0 : state (atomic L), ~ initial_state (atomic L) s0) (s : state L) (H : initial_state L s) : False.","conclusion":"False","hypotheses":"(H0 : forall s0 : state (atomic L), ~ initial_state (atomic L) s0) (s : state L) (H : initial_state L s)","proofString":"elim (H0 (E0,s)); simpl; auto."},{"statement":"(S S3 : tstate) (H : tsteps S S3) : tsteps S S3.","conclusion":"tsteps S S3","hypotheses":"(S S3 : tstate) (H : tsteps S S3)","proofString":"auto."},{"statement":"(t : trace) (S1 S2 S3 : tstate) (H : tstep t S1 S2) (H0 : tsteps S2 S3) (IHtsteps : forall S4 : tstate, tsteps S3 S4 -> tsteps S2 S4) (S0 : tstate) (H1 : tsteps S3 S0) : tsteps S1 S0.","conclusion":"tsteps S1 S0","hypotheses":"(t : trace) (S1 S2 S3 : tstate) (H : tstep t S1 S2) (H0 : tsteps S2 S3) (IHtsteps : forall S4 : tstate, tsteps S3 S4 -> tsteps S2 S4) (S0 : tstate) (H1 : tsteps S3 S0)","proofString":"econstructor; eauto."},{"statement":"(S : tstate) : treactive S \\/ (exists S' : tstate, tsteps S S' /\\ tsilent S').","conclusion":"treactive S \\/ (exists S' : tstate, tsteps S S' /\\ tsilent S')","hypotheses":"(S : tstate)","proofString":"destruct (classic (exists S', tsteps S S' /\\ tsilent S')).\nauto.\nleft.\nred; intros.\ngeneralize (not_ex_all_not _ _ H S1).\nintros.\ndestruct (not_and_or _ _ H1).\ncontradiction.\nunfold tsilent in H2.\ngeneralize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : exists S' : tstate, tsteps S S' /\\ tsilent S') : treactive S \\/ (exists S' : tstate, tsteps S S' /\\ tsilent S').","conclusion":"treactive S \\/ (exists S' : tstate, tsteps S S' /\\ tsilent S')","hypotheses":"(S : tstate) (H : exists S' : tstate, tsteps S S' /\\ tsilent S')","proofString":"auto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) : treactive S \\/ (exists S' : tstate, tsteps S S' /\\ tsilent S').","conclusion":"treactive S \\/ (exists S' : tstate, tsteps S S' /\\ tsilent S')","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S'))","proofString":"left.\nred; intros.\ngeneralize (not_ex_all_not _ _ H S1).\nintros.\ndestruct (not_and_or _ _ H1).\ncontradiction.\nunfold tsilent in H2.\ngeneralize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) : treactive S.","conclusion":"treactive S","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S'))","proofString":"red; intros.\ngeneralize (not_ex_all_not _ _ H S1).\nintros.\ndestruct (not_and_or _ _ H1).\ncontradiction.\nunfold tsilent in H2.\ngeneralize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) : exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1)","proofString":"generalize (not_ex_all_not _ _ H S1).\nintros.\ndestruct (not_and_or _ _ H1).\ncontradiction.\nunfold tsilent in H2.\ngeneralize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) : ~ (tsteps S S1 /\\ tsilent S1) ->\nexists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"~ (tsteps S S1 /\\ tsilent S1) ->\nexists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1)","proofString":"intros.\ndestruct (not_and_or _ _ H1).\ncontradiction.\nunfold tsilent in H2.\ngeneralize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) : exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1))","proofString":"destruct (not_and_or _ _ H1).\ncontradiction.\nunfold tsilent in H2.\ngeneralize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~ tsteps S S1) : exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~ tsteps S S1)","proofString":"contradiction."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~ tsilent S1) : exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~ tsilent S1)","proofString":"unfold tsilent in H2.\ngeneralize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S2 : tstate),\n tsteps S1 S0 -> tstep t S0 S2 -> t = E0)) : exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"exists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S2 : tstate),\n tsteps S1 S0 -> tstep t S0 S2 -> t = E0))","proofString":"generalize (not_all_ex_not _ _ H2).\nintros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S2 : tstate),\n tsteps S1 S0 -> tstep t S0 S2 -> t = E0)) : (exists n : tstate,\n   ~\n   (forall (t : trace) (S2 : tstate), tsteps S1 n -> tstep t n S2 -> t = E0)) ->\nexists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"(exists n : tstate,\n   ~\n   (forall (t : trace) (S2 : tstate), tsteps S1 n -> tstep t n S2 -> t = E0)) ->\nexists (S2 S3 : tstate) (t : trace), tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S2 : tstate),\n tsteps S1 S0 -> tstep t S0 S2 -> t = E0))","proofString":"intros [S2 A].\ngeneralize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t S0 S3 -> t = E0)) (S2 : tstate) (A : ~ (forall (t : trace) (S0 : tstate), tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) : exists (S0 S3 : tstate) (t : trace), tsteps S1 S0 /\\ tstep t S0 S3 /\\ t <> E0.","conclusion":"exists (S0 S3 : tstate) (t : trace), tsteps S1 S0 /\\ tstep t S0 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t S0 S3 -> t = E0)) (S2 : tstate) (A : ~ (forall (t : trace) (S0 : tstate), tsteps S1 S2 -> tstep t S2 S0 -> t = E0))","proofString":"generalize (not_all_ex_not _ _ A).\nintros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t S0 S3 -> t = E0)) (S2 : tstate) (A : ~ (forall (t : trace) (S0 : tstate), tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) : (exists n : trace,\n   ~ (forall S3 : tstate, tsteps S1 S2 -> tstep n S2 S3 -> n = E0)) ->\nexists (S0 S3 : tstate) (t : trace), tsteps S1 S0 /\\ tstep t S0 S3 /\\ t <> E0.","conclusion":"(exists n : trace,\n   ~ (forall S3 : tstate, tsteps S1 S2 -> tstep n S2 S3 -> n = E0)) ->\nexists (S0 S3 : tstate) (t : trace), tsteps S1 S0 /\\ tstep t S0 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t S0 S3 -> t = E0)) (S2 : tstate) (A : ~ (forall (t : trace) (S0 : tstate), tsteps S1 S2 -> tstep t S2 S0 -> t = E0))","proofString":"intros [t B].\ngeneralize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S3 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) : exists (S0 S3 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S3 /\\ t0 <> E0.","conclusion":"exists (S0 S3 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S3 /\\ t0 <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S3 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0))","proofString":"generalize (not_all_ex_not _ _ B).\nintros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S3 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) : (exists n : tstate, ~ (tsteps S1 S2 -> tstep t S2 n -> t = E0)) ->\nexists (S0 S3 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S3 /\\ t0 <> E0.","conclusion":"(exists n : tstate, ~ (tsteps S1 S2 -> tstep t S2 n -> t = E0)) ->\nexists (S0 S3 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S3 /\\ t0 <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S3 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S3 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0))","proofString":"intros [S3 C].\ngeneralize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) : exists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0.","conclusion":"exists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0))","proofString":"generalize (imply_to_and _ _ C).\nintros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) : tsteps S1 S2 /\\ ~ (tstep t S2 S3 -> t = E0) ->\nexists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0.","conclusion":"tsteps S1 S2 /\\ ~ (tstep t S2 S3 -> t = E0) ->\nexists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0))","proofString":"intros [D F].\ngeneralize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0)) : exists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0.","conclusion":"exists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0))","proofString":"generalize (imply_to_and _ _ F).\nintros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0)) : tstep t S2 S3 /\\ t <> E0 ->\nexists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0.","conclusion":"tstep t S2 S3 /\\ t <> E0 ->\nexists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0))","proofString":"intros [G J].\nexists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0)) (G : tstep t S2 S3) (J : t <> E0) : exists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0.","conclusion":"exists (S0 S4 : tstate) (t0 : trace),\n  tsteps S1 S0 /\\ tstep t0 S0 S4 /\\ t0 <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0)) (G : tstep t S2 S3) (J : t <> E0)","proofString":"exists S2; exists S3; exists t.\nauto."},{"statement":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0)) (G : tstep t S2 S3) (J : t <> E0) : tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0.","conclusion":"tsteps S1 S2 /\\ tstep t S2 S3 /\\ t <> E0","hypotheses":"(S : tstate) (H : ~ (exists S' : tstate, tsteps S S' /\\ tsilent S')) (S1 : tstate) (H0 : tsteps S S1) (H1 : ~ (tsteps S S1 /\\ tsilent S1)) (H2 : ~\n(forall (S0 : tstate) (t0 : trace) (S4 : tstate),\n tsteps S1 S0 -> tstep t0 S0 S4 -> t0 = E0)) (S2 : tstate) (A : ~\n(forall (t0 : trace) (S0 : tstate), tsteps S1 S2 -> tstep t0 S2 S0 -> t0 = E0)) (t : trace) (B : ~ (forall S0 : tstate, tsteps S1 S2 -> tstep t S2 S0 -> t = E0)) (S3 : tstate) (C : ~ (tsteps S1 S2 -> tstep t S2 S3 -> t = E0)) (D : tsteps S1 S2) (F : ~ (tstep t S2 S3 -> t = E0)) (G : tstep t S2 S3) (J : t <> E0)","proofString":"auto."},{"statement":"(S : tstate) : exists t : trace,\n  star step ge (state_of_tstate S) t (state_of_tstate S) /\\\n  traceinf_of_tstate S = t *** traceinf_of_tstate S.","conclusion":"exists t : trace,\n  star step ge (state_of_tstate S) t (state_of_tstate S) /\\\n  traceinf_of_tstate S = t *** traceinf_of_tstate S","hypotheses":"(S : tstate)","proofString":"exists E0; split.\napply star_refl.\nauto."},{"statement":"(S : tstate) : star step ge (state_of_tstate S) E0 (state_of_tstate S).","conclusion":"star step ge (state_of_tstate S) E0 (state_of_tstate S)","hypotheses":"(S : tstate)","proofString":"apply star_refl."},{"statement":"(S : tstate) : traceinf_of_tstate S = E0 *** traceinf_of_tstate S.","conclusion":"traceinf_of_tstate S = E0 *** traceinf_of_tstate S","hypotheses":"(S : tstate)","proofString":"auto."},{"statement":"(t : trace) (S1 S2 S3 : tstate) (H : tstep t S1 S2) (H0 : tsteps S2 S3) (IHtsteps : exists t0 : trace,\n  star step ge (state_of_tstate S2) t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate S2 = t0 *** traceinf_of_tstate S3) : exists t0 : trace,\n  star step ge (state_of_tstate S1) t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate S1 = t0 *** traceinf_of_tstate S3.","conclusion":"exists t0 : trace,\n  star step ge (state_of_tstate S1) t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate S1 = t0 *** traceinf_of_tstate S3","hypotheses":"(t : trace) (S1 S2 S3 : tstate) (H : tstep t S1 S2) (H0 : tsteps S2 S3) (IHtsteps : exists t0 : trace,\n  star step ge (state_of_tstate S2) t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate S2 = t0 *** traceinf_of_tstate S3)","proofString":"inv H.\ndestruct IHtsteps as [t' [A B]].\nexists (t ** t'); split.\nsimpl; eapply star_left; eauto.\nsimpl in *.\nsubst T.\ntraceEq."},{"statement":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (IHtsteps : exists t0 : trace,\n  star step ge (state_of_tstate (ST s2 T F)) t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate (ST s2 T F) = t0 *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2) : exists t0 : trace,\n  star step ge (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)))\n    t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)) =\n  t0 *** traceinf_of_tstate S3.","conclusion":"exists t0 : trace,\n  star step ge (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)))\n    t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)) =\n  t0 *** traceinf_of_tstate S3","hypotheses":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (IHtsteps : exists t0 : trace,\n  star step ge (state_of_tstate (ST s2 T F)) t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate (ST s2 T F) = t0 *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2)","proofString":"destruct IHtsteps as [t' [A B]].\nexists (t ** t'); split.\nsimpl; eapply star_left; eauto.\nsimpl in *.\nsubst T.\ntraceEq."},{"statement":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge (state_of_tstate (ST s2 T F)) t' (state_of_tstate S3)) (B : traceinf_of_tstate (ST s2 T F) = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2) : exists t0 : trace,\n  star step ge (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)))\n    t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)) =\n  t0 *** traceinf_of_tstate S3.","conclusion":"exists t0 : trace,\n  star step ge (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)))\n    t0 (state_of_tstate S3) /\\\n  traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)) =\n  t0 *** traceinf_of_tstate S3","hypotheses":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge (state_of_tstate (ST s2 T F)) t' (state_of_tstate S3)) (B : traceinf_of_tstate (ST s2 T F) = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2)","proofString":"exists (t ** t'); split.\nsimpl; eapply star_left; eauto.\nsimpl in *.\nsubst T.\ntraceEq."},{"statement":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge (state_of_tstate (ST s2 T F)) t' (state_of_tstate S3)) (B : traceinf_of_tstate (ST s2 T F) = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2) : star step ge (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)))\n  (t ** t') (state_of_tstate S3).","conclusion":"star step ge (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)))\n  (t ** t') (state_of_tstate S3)","hypotheses":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge (state_of_tstate (ST s2 T F)) t' (state_of_tstate S3)) (B : traceinf_of_tstate (ST s2 T F) = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2)","proofString":"simpl; eapply star_left; eauto."},{"statement":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge (state_of_tstate (ST s2 T F)) t' (state_of_tstate S3)) (B : traceinf_of_tstate (ST s2 T F) = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2) : traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)) =\n(t ** t') *** traceinf_of_tstate S3.","conclusion":"traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S F)) =\n(t ** t') *** traceinf_of_tstate S3","hypotheses":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge (state_of_tstate (ST s2 T F)) t' (state_of_tstate S3)) (B : traceinf_of_tstate (ST s2 T F) = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2)","proofString":"simpl in *.\nsubst T.\ntraceEq."},{"statement":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge s2 t' (state_of_tstate S3)) (B : T = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2) : t *** T = (t ** t') *** traceinf_of_tstate S3.","conclusion":"t *** T = (t ** t') *** traceinf_of_tstate S3","hypotheses":"(t : trace) (S3 : tstate) (T : traceinf) (s2 : state) (F : forever step ge s2 T) (t' : trace) (A : star step ge s2 t' (state_of_tstate S3)) (B : T = t' *** traceinf_of_tstate S3) (H0 : tsteps (ST s2 T F) S3) (s1 : state) (S : step ge s1 t s2)","proofString":"subst T.\ntraceEq."},{"statement":"(t : trace) (S3 : tstate) (s2 : state) (t' : trace) (F : forever step ge s2 (t' *** traceinf_of_tstate S3)) (A : star step ge s2 t' (state_of_tstate S3)) (H0 : tsteps (ST s2 (t' *** traceinf_of_tstate S3) F) S3) (s1 : state) (S : step ge s1 t s2) : t *** t' *** traceinf_of_tstate S3 = (t ** t') *** traceinf_of_tstate S3.","conclusion":"t *** t' *** traceinf_of_tstate S3 = (t ** t') *** traceinf_of_tstate S3","hypotheses":"(t : trace) (S3 : tstate) (s2 : state) (t' : trace) (F : forever step ge s2 (t' *** traceinf_of_tstate S3)) (A : star step ge s2 t' (state_of_tstate S3)) (H0 : tsteps (ST s2 (t' *** traceinf_of_tstate S3) F) S3) (s1 : state) (S : step ge s1 t s2)","proofString":"traceEq."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) : tsilent S -> forever_silent step ge (state_of_tstate S).","conclusion":"tsilent S -> forever_silent step ge (state_of_tstate S)","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate)","proofString":"case S.\nintros until f.\nsimpl.\ncase f.\nintros.\nassert (tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0))                  (ST s2 T0 f0)).\nconstructor.\nassert (t = E0).\nred in H.\neapply H; eauto.\napply tsteps_refl.\napply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) : forall (s : state) (T : traceinf) (f : forever step ge s T),\ntsilent (ST s T f) -> forever_silent step ge (state_of_tstate (ST s T f)).","conclusion":"forall (s : state) (T : traceinf) (f : forever step ge s T),\ntsilent (ST s T f) -> forever_silent step ge (state_of_tstate (ST s T f))","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate)","proofString":"intros until f.\nsimpl.\ncase f.\nintros.\nassert (tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0))                  (ST s2 T0 f0)).\nconstructor.\nassert (t = E0).\nred in H.\neapply H; eauto.\napply tsteps_refl.\napply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) : tsilent (ST s T f) -> forever_silent step ge (state_of_tstate (ST s T f)).","conclusion":"tsilent (ST s T f) -> forever_silent step ge (state_of_tstate (ST s T f))","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T)","proofString":"simpl.\ncase f.\nintros.\nassert (tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0))                  (ST s2 T0 f0)).\nconstructor.\nassert (t = E0).\nred in H.\neapply H; eauto.\napply tsteps_refl.\napply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) : tsilent (ST s T f) -> forever_silent step ge s.","conclusion":"tsilent (ST s T f) -> forever_silent step ge s","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T)","proofString":"case f.\nintros.\nassert (tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0))                  (ST s2 T0 f0)).\nconstructor.\nassert (t = E0).\nred in H.\neapply H; eauto.\napply tsteps_refl.\napply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) : forall (s1 : state) (t : trace) (s2 : state) (T0 : traceinf)\n  (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0),\ntsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) ->\nforever_silent step ge s1.","conclusion":"forall (s1 : state) (t : trace) (s2 : state) (T0 : traceinf)\n  (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0),\ntsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) ->\nforever_silent step ge s1","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T)","proofString":"intros.\nassert (tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0))                  (ST s2 T0 f0)).\nconstructor.\nassert (t = E0).\nred in H.\neapply H; eauto.\napply tsteps_refl.\napply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) : forever_silent step ge s1.","conclusion":"forever_silent step ge s1","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0)))","proofString":"assert (tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0))                  (ST s2 T0 f0)).\nconstructor.\nassert (t = E0).\nred in H.\neapply H; eauto.\napply tsteps_refl.\napply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0).","conclusion":"tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0)))","proofString":"constructor."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) : forever_silent step ge s1.","conclusion":"forever_silent step ge s1","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0))","proofString":"assert (t = E0).\nred in H.\neapply H; eauto.\napply tsteps_refl.\napply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) : t = E0.","conclusion":"t = E0","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0))","proofString":"red in H.\neapply H; eauto.\napply tsteps_refl."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : forall (S1 : tstate) (t0 : trace) (S2 : tstate),\ntsteps (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) S1 ->\ntstep t0 S1 S2 -> t0 = E0) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) : t = E0.","conclusion":"t = E0","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : forall (S1 : tstate) (t0 : trace) (S2 : tstate),\ntsteps (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) S1 ->\ntstep t0 S1 S2 -> t0 = E0) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0))","proofString":"eapply H; eauto.\napply tsteps_refl."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : forall (S1 : tstate) (t0 : trace) (S2 : tstate),\ntsteps (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) S1 ->\ntstep t0 S1 S2 -> t0 = E0) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) : tsteps (ST s1 (t *** T0) (forever_intro s1 t s0 f0))\n  (ST s1 (t *** T0) (forever_intro s1 t s0 f0)).","conclusion":"tsteps (ST s1 (t *** T0) (forever_intro s1 t s0 f0))\n  (ST s1 (t *** T0) (forever_intro s1 t s0 f0))","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : forall (S1 : tstate) (t0 : trace) (S2 : tstate),\ntsteps (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) S1 ->\ntstep t0 S1 S2 -> t0 = E0) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0))","proofString":"apply tsteps_refl."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0) : forever_silent step ge s1.","conclusion":"forever_silent step ge s1","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0)","proofString":"apply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).\nrewrite <- H1.\nassumption.\napply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0) : step ge s1 E0 (state_of_tstate (ST s2 T0 f0)).","conclusion":"step ge s1 E0 (state_of_tstate (ST s2 T0 f0))","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0)","proofString":"rewrite <- H1.\nassumption."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0) : step ge s1 t (state_of_tstate (ST s2 T0 f0)).","conclusion":"step ge s1 t (state_of_tstate (ST s2 T0 f0))","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0)","proofString":"assumption."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0) : forever_silent step ge (state_of_tstate (ST s2 T0 f0)).","conclusion":"forever_silent step ge (state_of_tstate (ST s2 T0 f0))","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0)","proofString":"apply COINDHYP.\nred; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0) : tsilent (ST s2 T0 f0).","conclusion":"tsilent (ST s2 T0 f0)","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0)","proofString":"red; intros.\neapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0) (S1 : tstate) (t0 : trace) (S2 : tstate) (H2 : tsteps (ST s2 T0 f0) S1) (H3 : tstep t0 S1 S2) : t0 = E0.","conclusion":"t0 = E0","hypotheses":"(COINDHYP : forall S0 : tstate, tsilent S0 -> forever_silent step ge (state_of_tstate S0)) (S : tstate) (s : state) (T : traceinf) (f : forever step ge s T) (s1 : state) (t : trace) (s2 : state) (T0 : traceinf) (s0 : step ge s1 t s2) (f0 : forever step ge s2 T0) (H : tsilent (ST s1 (t *** T0) (forever_intro s1 t s0 f0))) (H0 : tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0)) (ST s2 T0 f0)) (H1 : t = E0) (S1 : tstate) (t0 : trace) (S2 : tstate) (H2 : tsteps (ST s2 T0 f0) S1) (H3 : tstep t0 S1 S2)","proofString":"eapply H.\neapply tsteps_left; eauto.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S) : forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S).","conclusion":"forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S)","hypotheses":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S)","proofString":"destruct (H S) as [S1 [S2 [t [A [B C]]]]].\napply tsteps_refl.\ndestruct (tsteps_star _ _ A) as [t' [P Q]].\ninv B.\nsimpl in *.\nrewrite Q.\nrewrite <- Eappinf_assoc.\napply forever_reactive_intro with s2.\neapply star_right; eauto.\nred; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction.\nchange (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S) : tsteps S S.","conclusion":"tsteps S S","hypotheses":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S)","proofString":"apply tsteps_refl."},{"statement":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S) (S1 S2 : tstate) (t : trace) (A : tsteps S S1) (B : tstep t S1 S2) (C : t <> E0) : forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S).","conclusion":"forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S)","hypotheses":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S) (S1 S2 : tstate) (t : trace) (A : tsteps S S1) (B : tstep t S1 S2) (C : t <> E0)","proofString":"destruct (tsteps_star _ _ A) as [t' [P Q]].\ninv B.\nsimpl in *.\nrewrite Q.\nrewrite <- Eappinf_assoc.\napply forever_reactive_intro with s2.\neapply star_right; eauto.\nred; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction.\nchange (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S) (S1 S2 : tstate) (t : trace) (A : tsteps S S1) (B : tstep t S1 S2) (C : t <> E0) (t' : trace) (P : star step ge (state_of_tstate S) t' (state_of_tstate S1)) (Q : traceinf_of_tstate S = t' *** traceinf_of_tstate S1) : forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S).","conclusion":"forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S)","hypotheses":"(COINDHYP : forall S0 : tstate,\ntreactive S0 ->\nforever_reactive step ge (state_of_tstate S0) (traceinf_of_tstate S0)) (S : tstate) (H : treactive S) (S1 S2 : tstate) (t : trace) (A : tsteps S S1) (B : tstep t S1 S2) (C : t <> E0) (t' : trace) (P : star step ge (state_of_tstate S) t' (state_of_tstate S1)) (Q : traceinf_of_tstate S = t' *** traceinf_of_tstate S1)","proofString":"inv B.\nsimpl in *.\nrewrite Q.\nrewrite <- Eappinf_assoc.\napply forever_reactive_intro with s2.\neapply star_right; eauto.\nred; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction.\nchange (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S =\nt' *** traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S0 F))) (P : star step ge (state_of_tstate S) t'\n  (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S0 F)))) : forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S).","conclusion":"forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S)","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S =\nt' *** traceinf_of_tstate (ST s1 (t *** T) (forever_intro s1 t S0 F))) (P : star step ge (state_of_tstate S) t'\n  (state_of_tstate (ST s1 (t *** T) (forever_intro s1 t S0 F))))","proofString":"simpl in *.\nrewrite Q.\nrewrite <- Eappinf_assoc.\napply forever_reactive_intro with s2.\neapply star_right; eauto.\nred; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction.\nchange (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S).","conclusion":"forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S)","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"rewrite Q.\nrewrite <- Eappinf_assoc.\napply forever_reactive_intro with s2.\neapply star_right; eauto.\nred; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction.\nchange (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : forever_reactive step ge (state_of_tstate S) (t' *** t *** T).","conclusion":"forever_reactive step ge (state_of_tstate S) (t' *** t *** T)","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"rewrite <- Eappinf_assoc.\napply forever_reactive_intro with s2.\neapply star_right; eauto.\nred; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction.\nchange (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : forever_reactive step ge (state_of_tstate S) ((t' ** t) *** T).","conclusion":"forever_reactive step ge (state_of_tstate S) ((t' ** t) *** T)","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"apply forever_reactive_intro with s2.\neapply star_right; eauto.\nred; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction.\nchange (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : star step ge (state_of_tstate S) (t' ** t) s2.","conclusion":"star step ge (state_of_tstate S) (t' ** t) s2","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"eapply star_right; eauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : t' ** t <> E0.","conclusion":"t' ** t <> E0","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"red; intros.\ndestruct (Eapp_E0_inv _ _ H0).\ncontradiction."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (H0 : t' ** t = E0) : False.","conclusion":"False","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (H0 : t' ** t = E0)","proofString":"destruct (Eapp_E0_inv _ _ H0).\ncontradiction."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (H0 : t' ** t = E0) (H1 : t' = E0) (H2 : t = E0) : False.","conclusion":"False","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (H0 : t' ** t = E0) (H1 : t' = E0) (H2 : t = E0)","proofString":"contradiction."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : forever_reactive step ge s2 T.","conclusion":"forever_reactive step ge s2 T","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"change (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).\napply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : forever_reactive step ge (state_of_tstate (ST s2 T F))\n  (traceinf_of_tstate (ST s2 T F)).","conclusion":"forever_reactive step ge (state_of_tstate (ST s2 T F))\n  (traceinf_of_tstate (ST s2 T F))","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"apply COINDHYP.\nred; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) : treactive (ST s2 T F).","conclusion":"treactive (ST s2 T F)","hypotheses":"(COINDHYP : forall S1 : tstate,\ntreactive S1 ->\nforever_reactive step ge (state_of_tstate S1) (traceinf_of_tstate S1)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1)","proofString":"red; intros.\napply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S2 : tstate,\ntreactive S2 ->\nforever_reactive step ge (state_of_tstate S2) (traceinf_of_tstate S2)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (S1 : tstate) (H0 : tsteps (ST s2 T F) S1) : exists (S2 S3 : tstate) (t0 : trace),\n  tsteps S1 S2 /\\ tstep t0 S2 S3 /\\ t0 <> E0.","conclusion":"exists (S2 S3 : tstate) (t0 : trace),\n  tsteps S1 S2 /\\ tstep t0 S2 S3 /\\ t0 <> E0","hypotheses":"(COINDHYP : forall S2 : tstate,\ntreactive S2 ->\nforever_reactive step ge (state_of_tstate S2) (traceinf_of_tstate S2)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (S1 : tstate) (H0 : tsteps (ST s2 T F) S1)","proofString":"apply H.\neapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(COINDHYP : forall S2 : tstate,\ntreactive S2 ->\nforever_reactive step ge (state_of_tstate S2) (traceinf_of_tstate S2)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (S1 : tstate) (H0 : tsteps (ST s2 T F) S1) : tsteps S S1.","conclusion":"tsteps S S1","hypotheses":"(COINDHYP : forall S2 : tstate,\ntreactive S2 ->\nforever_reactive step ge (state_of_tstate S2) (traceinf_of_tstate S2)) (S : tstate) (H : treactive S) (t : trace) (s1 : state) (T : traceinf) (s2 : state) (S0 : step ge s1 t s2) (F : forever step ge s2 T) (A : tsteps S (ST s1 (t *** T) (forever_intro s1 t S0 F))) (C : t <> E0) (t' : trace) (Q : traceinf_of_tstate S = t' *** t *** T) (P : star step ge (state_of_tstate S) t' s1) (S1 : tstate) (H0 : tsteps (ST s2 T F) S1)","proofString":"eapply tsteps_trans.\neauto.\neapply tsteps_left.\nconstructor.\neauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) : forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T').","conclusion":"forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T)","proofString":"destruct (treactive_or_tsilent (ST s T H)).\nleft.\nchange (forever_reactive step ge (state_of_tstate (ST s T H)) (traceinf_of_tstate (ST s T H))).\napply treactive_forever_reactive.\nauto.\ndestruct H0 as [S' [A B]].\nexploit tsteps_star; eauto.\nintros [t [C D]].\nsimpl in *.\nright.\nexists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').\nsplit.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H)) : forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T').","conclusion":"forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H))","proofString":"left.\nchange (forever_reactive step ge (state_of_tstate (ST s T H)) (traceinf_of_tstate (ST s T H))).\napply treactive_forever_reactive.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H)) : forever_reactive step ge s T.","conclusion":"forever_reactive step ge s T","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H))","proofString":"change (forever_reactive step ge (state_of_tstate (ST s T H)) (traceinf_of_tstate (ST s T H))).\napply treactive_forever_reactive.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H)) : forever_reactive step ge (state_of_tstate (ST s T H))\n  (traceinf_of_tstate (ST s T H)).","conclusion":"forever_reactive step ge (state_of_tstate (ST s T H))\n  (traceinf_of_tstate (ST s T H))","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H))","proofString":"apply treactive_forever_reactive.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H)) : treactive (ST s T H).","conclusion":"treactive (ST s T H)","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : treactive (ST s T H))","proofString":"auto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : exists S' : tstate, tsteps (ST s T H) S' /\\ tsilent S') : forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T').","conclusion":"forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (H0 : exists S' : tstate, tsteps (ST s T H) S' /\\ tsilent S')","proofString":"destruct H0 as [S' [A B]].\nexploit tsteps_star; eauto.\nintros [t [C D]].\nsimpl in *.\nright.\nexists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').\nsplit.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') : forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T').","conclusion":"forever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S')","proofString":"exploit tsteps_star; eauto.\nintros [t [C D]].\nsimpl in *.\nright.\nexists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').\nsplit.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') : (exists t : trace,\n   star step ge (state_of_tstate (ST s T H)) t (state_of_tstate S') /\\\n   traceinf_of_tstate (ST s T H) = t *** traceinf_of_tstate S') ->\nforever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T').","conclusion":"(exists t : trace,\n   star step ge (state_of_tstate (ST s T H)) t (state_of_tstate S') /\\\n   traceinf_of_tstate (ST s T H) = t *** traceinf_of_tstate S') ->\nforever_reactive step ge s T \\/\n(exists (t : trace) (s' : state) (T' : traceinf),\n   star step ge s t s' /\\ forever_silent step ge s' /\\ T = t *** T')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S')","proofString":"intros [t [C D]].\nsimpl in *.\nright.\nexists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').\nsplit.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge (state_of_tstate (ST s T H)) t (state_of_tstate S')) (D : traceinf_of_tstate (ST s T H) = t *** traceinf_of_tstate S') : forever_reactive step ge s T \\/\n(exists (t0 : trace) (s' : state) (T' : traceinf),\n   star step ge s t0 s' /\\ forever_silent step ge s' /\\ T = t0 *** T').","conclusion":"forever_reactive step ge s T \\/\n(exists (t0 : trace) (s' : state) (T' : traceinf),\n   star step ge s t0 s' /\\ forever_silent step ge s' /\\ T = t0 *** T')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge (state_of_tstate (ST s T H)) t (state_of_tstate S')) (D : traceinf_of_tstate (ST s T H) = t *** traceinf_of_tstate S')","proofString":"simpl in *.\nright.\nexists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').\nsplit.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : forever_reactive step ge s T \\/\n(exists (t0 : trace) (s' : state) (T' : traceinf),\n   star step ge s t0 s' /\\ forever_silent step ge s' /\\ T = t0 *** T').","conclusion":"forever_reactive step ge s T \\/\n(exists (t0 : trace) (s' : state) (T' : traceinf),\n   star step ge s t0 s' /\\ forever_silent step ge s' /\\ T = t0 *** T')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"right.\nexists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').\nsplit.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : exists (t0 : trace) (s' : state) (T' : traceinf),\n  star step ge s t0 s' /\\ forever_silent step ge s' /\\ T = t0 *** T'.","conclusion":"exists (t0 : trace) (s' : state) (T' : traceinf),\n  star step ge s t0 s' /\\ forever_silent step ge s' /\\ T = t0 *** T'","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"exists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').\nsplit.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : star step ge s t (state_of_tstate S') /\\\nforever_silent step ge (state_of_tstate S') /\\\nT = t *** traceinf_of_tstate S'.","conclusion":"star step ge s t (state_of_tstate S') /\\\nforever_silent step ge (state_of_tstate S') /\\\nT = t *** traceinf_of_tstate S'","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"split.\nauto.\nsplit.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : star step ge s t (state_of_tstate S').","conclusion":"star step ge s t (state_of_tstate S')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"auto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : forever_silent step ge (state_of_tstate S') /\\\nT = t *** traceinf_of_tstate S'.","conclusion":"forever_silent step ge (state_of_tstate S') /\\\nT = t *** traceinf_of_tstate S'","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"split.\napply tsilent_forever_silent.\nauto.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : forever_silent step ge (state_of_tstate S').","conclusion":"forever_silent step ge (state_of_tstate S')","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"apply tsilent_forever_silent.\nauto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : tsilent S'.","conclusion":"tsilent S'","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"auto."},{"statement":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S') : T = t *** traceinf_of_tstate S'.","conclusion":"T = t *** traceinf_of_tstate S'","hypotheses":"(s : state) (T : traceinf) (H : forever step ge s T) (S' : tstate) (A : tsteps (ST s T H) S') (B : tsilent S') (t : trace) (C : star step ge s t (state_of_tstate S')) (D : T = t *** traceinf_of_tstate S')","proofString":"auto."},{"statement":"(t : trace) (r : int) (H : bigstep_terminates B t r) : program_behaves L (Terminates t r).","conclusion":"program_behaves L (Terminates t r)","hypotheses":"(t : trace) (r : int) (H : bigstep_terminates B t r)","proofString":"exploit (bigstep_terminates_sound sound); eauto.\nintros [s1 [s2 [P [Q R]]]].\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(t : trace) (r : int) (H : bigstep_terminates B t r) : (exists s1 s2 : state L,\n   initial_state L s1 /\\ Star L s1 t s2 /\\ final_state L s2 r) ->\nprogram_behaves L (Terminates t r).","conclusion":"(exists s1 s2 : state L,\n   initial_state L s1 /\\ Star L s1 t s2 /\\ final_state L s2 r) ->\nprogram_behaves L (Terminates t r)","hypotheses":"(t : trace) (r : int) (H : bigstep_terminates B t r)","proofString":"intros [s1 [s2 [P [Q R]]]].\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(t : trace) (r : int) (H : bigstep_terminates B t r) (s1 s2 : state L) (P : initial_state L s1) (Q : Star L s1 t s2) (R : final_state L s2 r) : program_behaves L (Terminates t r).","conclusion":"program_behaves L (Terminates t r)","hypotheses":"(t : trace) (r : int) (H : bigstep_terminates B t r) (s1 s2 : state L) (P : initial_state L s1) (Q : Star L s1 t s2) (R : final_state L s2 r)","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(t : trace) (r : int) (H : bigstep_terminates B t r) (s1 s2 : state L) (P : initial_state L s1) (Q : Star L s1 t s2) (R : final_state L s2 r) : state_behaves L s1 (Terminates t r).","conclusion":"state_behaves L s1 (Terminates t r)","hypotheses":"(t : trace) (r : int) (H : bigstep_terminates B t r) (s1 s2 : state L) (P : initial_state L s1) (Q : Star L s1 t s2) (R : final_state L s2 r)","proofString":"econstructor; eauto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) : program_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T).","conclusion":"program_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T)","proofString":"exploit (bigstep_diverges_sound sound); eauto.\nintros [s1 [P Q]].\nexploit forever_silent_or_reactive; eauto.\nintros [X | [t [s' [T' [X [Y Z]]]]]].\nleft.\neconstructor; eauto.\nconstructor; auto.\nright.\nexists t; split.\neconstructor; eauto.\neconstructor; eauto.\nexists T'; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) : (exists s1 : state L,\n   initial_state L s1 /\\ forever (step L) (globalenv L) s1 T) ->\nprogram_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T).","conclusion":"(exists s1 : state L,\n   initial_state L s1 /\\ forever (step L) (globalenv L) s1 T) ->\nprogram_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T)","proofString":"intros [s1 [P Q]].\nexploit forever_silent_or_reactive; eauto.\nintros [X | [t [s' [T' [X [Y Z]]]]]].\nleft.\neconstructor; eauto.\nconstructor; auto.\nright.\nexists t; split.\neconstructor; eauto.\neconstructor; eauto.\nexists T'; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) : program_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T).","conclusion":"program_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T)","proofString":"exploit forever_silent_or_reactive; eauto.\nintros [X | [t [s' [T' [X [Y Z]]]]]].\nleft.\neconstructor; eauto.\nconstructor; auto.\nright.\nexists t; split.\neconstructor; eauto.\neconstructor; eauto.\nexists T'; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) : Forever_reactive L s1 T \\/\n(exists (t : trace) (s' : state L) (T' : traceinf),\n   Star L s1 t s' /\\ Forever_silent L s' /\\ T = t *** T') ->\nprogram_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T).","conclusion":"Forever_reactive L s1 T \\/\n(exists (t : trace) (s' : state L) (T' : traceinf),\n   Star L s1 t s' /\\ Forever_silent L s' /\\ T = t *** T') ->\nprogram_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T)","proofString":"intros [X | [t [s' [T' [X [Y Z]]]]]].\nleft.\neconstructor; eauto.\nconstructor; auto.\nright.\nexists t; split.\neconstructor; eauto.\neconstructor; eauto.\nexists T'; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (X : Forever_reactive L s1 T) : program_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T).","conclusion":"program_behaves L (Reacts T) \\/\n(exists t : trace, program_behaves L (Diverges t) /\\ traceinf_prefix t T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (X : Forever_reactive L s1 T)","proofString":"left.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (X : Forever_reactive L s1 T) : program_behaves L (Reacts T).","conclusion":"program_behaves L (Reacts T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (X : Forever_reactive L s1 T)","proofString":"econstructor; eauto.\nconstructor; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (X : Forever_reactive L s1 T) : state_behaves L s1 (Reacts T).","conclusion":"state_behaves L s1 (Reacts T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (X : Forever_reactive L s1 T)","proofString":"constructor; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T') : program_behaves L (Reacts T) \\/\n(exists t0 : trace, program_behaves L (Diverges t0) /\\ traceinf_prefix t0 T).","conclusion":"program_behaves L (Reacts T) \\/\n(exists t0 : trace, program_behaves L (Diverges t0) /\\ traceinf_prefix t0 T)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T')","proofString":"right.\nexists t; split.\neconstructor; eauto.\neconstructor; eauto.\nexists T'; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T') : exists t0 : trace, program_behaves L (Diverges t0) /\\ traceinf_prefix t0 T.","conclusion":"exists t0 : trace, program_behaves L (Diverges t0) /\\ traceinf_prefix t0 T","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T')","proofString":"exists t; split.\neconstructor; eauto.\neconstructor; eauto.\nexists T'; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T') : program_behaves L (Diverges t).","conclusion":"program_behaves L (Diverges t)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T')","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T') : state_behaves L s1 (Diverges t).","conclusion":"state_behaves L s1 (Diverges t)","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T')","proofString":"econstructor; eauto."},{"statement":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T') : traceinf_prefix t T.","conclusion":"traceinf_prefix t T","hypotheses":"(T : traceinf) (H : bigstep_diverges B T) (s1 : state L) (P : initial_state L s1) (Q : forever (step L) (globalenv L) s1 T) (t : trace) (s' : state L) (T' : traceinf) (X : Star L s1 t s') (Y : Forever_silent L s') (Z : T = t *** T')","proofString":"exists T'; auto."}]}