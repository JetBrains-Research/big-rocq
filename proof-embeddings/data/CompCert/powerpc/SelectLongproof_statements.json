{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/powerpc/SelectLongproof.v","fileSamples":[{"statement":"(le : letenv) (n : int64) : eval_expr ge sp e m le (Eop (Olongconst n) Enil) (Vlong n).","proofString":"EvalOp."},{"statement":"(v : val) (a : expr) (n : int64) (le : letenv) (H : match is_longconst_match a with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) (H0 : eval_expr ge sp e m le a v) : v = Vlong n.","proofString":"eapply SplitLongproof.is_longconst_sound; eauto."},{"statement":"(v : val) (n : int64) (le : letenv) (H0 : eval_expr ge sp e m le (Eop (Olongconst n) Enil) v) (H : match is_longconst_match (Eop (Olongconst n) Enil) with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) : v = Vlong n.","proofString":"InvEval.\nauto."},{"statement":"(n : int64) (le : letenv) (H : match is_longconst_match (Eop (Olongconst n) Enil) with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) : Vlong n = Vlong n.","proofString":"auto."},{"statement":"(le : letenv) (x : val) (n : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n) Enil) x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.not n)) Enil) v /\\\n  Val.lessdef (Val.notl x) v.","proofString":"InvEval.\neconstructor; split.\napply eval_longconst.\nauto."},{"statement":"(le : letenv) (n : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.not n)) Enil) v /\\\n  Val.lessdef (Val.notl (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nauto."},{"statement":"(le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (H : Val.andl v1 (Vlong n2) = Vundef) : eval_expr ge sp e m le (andlimm_base (Int64.and Int64.zero n2) t2)\n  (Vlong Int64.zero).","proofString":"apply eval_longconst."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\ Val.lessdef (Val.andl x y) v.","proofString":"InvEval.\nrewrite Val.andl_commut.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl (Vlong n1) y) v.","proofString":"rewrite Val.andl_commut.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl y (Vlong n1)) v.","proofString":"apply eval_andlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\ Val.lessdef (Val.andl x y) v.","proofString":"InvEval.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\\n  Val.lessdef (Val.andl x (Vlong n2)) v.","proofString":"apply eval_andlimm; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      if Int64.eq n Int64.mone\n      then Eop (Olongconst Int64.mone) Enil\n      else\n       match orlimm_match a with\n       | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n       | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n       | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\neconstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto.\ndestruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"exists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : Val.lessdef (Val.orl x (Vlong n)) x.","proofString":"subst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.orl x (Vlong Int64.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.or i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone\n     then Eop (Olongconst Int64.mone) Enil\n     else\n      match orlimm_match a with\n      | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n      | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n      | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone.\neconstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto.\ndestruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Val.orl x (Vlong Int64.mone)) (Vlong Int64.mone).","proofString":"destruct x; simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Vlong (Int64.or i Int64.mone)) (Vlong Int64.mone).","proofString":"rewrite Int64.or_mone; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le\n    match orlimm_match a with\n    | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n    | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n    | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"destruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.or n n2)) Enil) v /\\\n  Val.lessdef (Val.orl (Vlong n2) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : Val.lessdef (Vlong (Int64.or n2 n)) (Vlong (Int64.or n n2)).","proofString":"rewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : eval_operation ge sp (Oorlimm (Int64.or n n2)) (v1 :: nil) m =\nSome (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)).","proofString":"simpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.orl v1 (Vlong (Int64.or n n2))) =\nSome (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)).","proofString":"rewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.orl v1 (Vlong (Int64.or n n2))) =\nSome (Val.orl v1 (Val.orl (Vlong n2) (Vlong n))).","proofString":"rewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) : forall (v : val) (n1 n2 : int) (m1 m2 : int64),\nn1 = n2 ->\nVal.lessdef (Val.orl (Val.rolml v n1 m1) (Val.rolml v n2 m2))\n  (Val.rolml v n1 (Int64.or m1 m2)).","proofString":"intros.\ndestruct v; simpl; auto.\nunfold Int64.rolm.\nrewrite Int64.and_or_distrib.\nrewrite H1.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v0 : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v0 /\\\n  Val.lessdef (Val.orl x y) v0) (v : val) (n1 n2 : int) (m1 m2 : int64) (H1 : n1 = n2) : Val.lessdef (Val.orl (Val.rolml v n1 m1) (Val.rolml v n2 m2))\n  (Val.rolml v n1 (Int64.or m1 m2)).","proofString":"destruct v; simpl; auto.\nunfold Int64.rolm.\nrewrite Int64.and_or_distrib.\nrewrite H1.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (m1 m2 : int64) (H1 : n1 = n2) : Val.lessdef\n  (Vlong\n     (Int64.or (Int64.rolm i (Int64.repr (Int.unsigned n1)) m1)\n        (Int64.rolm i (Int64.repr (Int.unsigned n2)) m2)))\n  (Vlong (Int64.rolm i (Int64.repr (Int.unsigned n1)) (Int64.or m1 m2))).","proofString":"unfold Int64.rolm.\nrewrite Int64.and_or_distrib.\nrewrite H1.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (m1 m2 : int64) (H1 : n1 = n2) : Val.lessdef\n  (Vlong\n     (Int64.or (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n1))) m1)\n        (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n2))) m2)))\n  (Vlong\n     (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n1))) (Int64.or m1 m2))).","proofString":"rewrite Int64.and_or_distrib.\nrewrite H1.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (m1 m2 : int64) (H1 : n1 = n2) : Val.lessdef\n  (Vlong\n     (Int64.or (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n1))) m1)\n        (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n2))) m2)))\n  (Vlong\n     (Int64.or (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n1))) m1)\n        (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n1))) m2))).","proofString":"rewrite H1.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (m1 m2 : int64) (H1 : n1 = n2) : Val.lessdef\n  (Vlong\n     (Int64.or (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n2))) m1)\n        (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n2))) m2)))\n  (Vlong\n     (Int64.or (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n2))) m1)\n        (Int64.and (Int64.rol i (Int64.repr (Int.unsigned n2))) m2))).","proofString":"auto."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\ Val.lessdef (Val.xorl x y) v.","proofString":"InvEval.\nrewrite Val.xorl_commut.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl (Vlong n1) y) v.","proofString":"rewrite Val.xorl_commut.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl y (Vlong n1)) v.","proofString":"apply eval_xorlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\ Val.lessdef (Val.xorl x y) v.","proofString":"InvEval.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\\n  Val.lessdef (Val.xorl x (Vlong n2)) v.","proofString":"apply eval_xorlimm; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.shrl x (Vint n)) x.","proofString":"subst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"destruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shr' i Int.zero)) (Vlong i).","proofString":"change (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shr i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.shr_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shr' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shrl (Vlong n1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : eval_operation ge sp (Olongconst (Int64.shr' n1 n)) nil m =\nSome (Val.shrl (Vlong n1) (Vint n)).","proofString":"simpl; rewrite LT; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero) : Val.lessdef (Val.addl (Vlong i) (Vlong Int64.zero)) (Vlong i).","proofString":"simpl.\nrewrite Int64.add_zero.\nconstructor."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero) : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.add_zero.\nconstructor."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero) : Val.lessdef (Vlong i) (Vlong i).","proofString":"constructor."},{"statement":"(n : int64) (le : letenv) (b : block) (i : ptrofs) (m0 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst m0) Enil) (Vptr b i)) (H0 : n = Int64.zero) : Val.lessdef (Val.addl (Vptr b i) (Vlong Int64.zero)) (Vptr b i).","proofString":"simpl.\nInvEval."},{"statement":"(n : int64) (le : letenv) (b : block) (i : ptrofs) (m0 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst m0) Enil) (Vptr b i)) (H0 : n = Int64.zero) : Val.lessdef\n  (if Archi.ptr64\n   then Vptr b (Ptrofs.add i (Ptrofs.of_int64 Int64.zero))\n   else Vundef) (Vptr b i).","proofString":"InvEval."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl (Vlong n1) y) v.","proofString":"exploit (eval_addlimm n1); eauto.\nintros (n & (H1 & H2)).\nexists n.\nsplit; auto.\nrewrite Val.addl_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : (exists v : val,\n   eval_expr ge sp e m le (addlimm n1 t2) v /\\\n   Val.lessdef (Val.addl y (Vlong n1)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl (Vlong n1) y) v.","proofString":"intros (n & (H1 & H2)).\nexists n.\nsplit; auto.\nrewrite Val.addl_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (addlimm n1 t2) n) (H2 : Val.lessdef (Val.addl y (Vlong n1)) n) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl (Vlong n1) y) v.","proofString":"exists n.\nsplit; auto.\nrewrite Val.addl_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (addlimm n1 t2) n) (H2 : Val.lessdef (Val.addl y (Vlong n1)) n) : eval_expr ge sp e m le (addlimm n1 t2) n /\\\nVal.lessdef (Val.addl (Vlong n1) y) n.","proofString":"split; auto.\nrewrite Val.addl_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (addlimm n1 t2) n) (H2 : Val.lessdef (Val.addl y (Vlong n1)) n) : Val.lessdef (Val.addl (Vlong n1) y) n.","proofString":"rewrite Val.addl_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (addlimm n1 t2) n) (H2 : Val.lessdef (Val.addl y (Vlong n1)) n) : Val.lessdef (Val.addl y (Vlong n1)) n.","proofString":"exact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 t1) v /\\\n  Val.lessdef (Val.addl x (Vlong n2)) v.","proofString":"exploit (eval_addlimm n2).\napply H.\nauto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))) v.","proofString":"rewrite Val.addl_permut_4.\nsimpl.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))) v.","proofString":"simpl.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 v0) (Vlong (Int64.add n1 n2))) v.","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.subl x (Vlong n2)) v.","proofString":"rewrite Val.subl_addl_opp.\napply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.addl x (Vlong (Int64.neg n2))) v.","proofString":"apply eval_addlimm; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exists (Vlong Int64.zero).\nsplit.\napply eval_longconst.\ndestruct x; simpl; auto.\nsubst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero) /\\\nVal.lessdef (Val.mull x (Vlong n)) (Vlong Int64.zero).","proofString":"split.\napply eval_longconst.\ndestruct x; simpl; auto.\nsubst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero).","proofString":"apply eval_longconst."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : Val.lessdef (Val.mull x (Vlong n)) (Vlong Int64.zero).","proofString":"destruct x; simpl; auto.\nsubst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong Int64.zero).","proofString":"subst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nsubst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : Val.lessdef (Val.mull x (Vlong n)) x.","proofString":"destruct x; simpl; auto.\nsubst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong i).","proofString":"subst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (n2 : int64) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mull (Vlong n2) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nrewrite Int64.mul_commut; auto."},{"statement":"(SL : Archi.splitlong = true) : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match mull_match e1 e2 with\n   | mull_case1 n1 t2 => mullimm n1 t2\n   | mull_case2 t1 n2 => mullimm n2 t1\n   | mull_default e0 e3 => Eop Omull (e0 ::: e3 ::: Enil)\n   end) Val.mull.","proofString":"red; intros.\ndestruct (mull_match a b).\nexploit (eval_mullimm n1); eauto.\nintros (n & (H1 & H2)).\nInvEval.\nexists n.\nsplit; auto.\nrewrite Val.mull_commut.\nexact H2.\nexploit (eval_mullimm n2).\napply H.\nInvEval.\nauto.\nTrivialExists."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    match mull_match a b with\n    | mull_case1 n1 t2 => mullimm n1 t2\n    | mull_case2 t1 n2 => mullimm n2 t1\n    | mull_default e1 e2 => Eop Omull (e1 ::: e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.mull x y) v.","proofString":"destruct (mull_match a b).\nexploit (eval_mullimm n1); eauto.\nintros (n & (H1 & H2)).\nInvEval.\nexists n.\nsplit; auto.\nrewrite Val.mull_commut.\nexact H2.\nexploit (eval_mullimm n2).\napply H.\nInvEval.\nauto.\nTrivialExists."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\ Val.lessdef (Val.mull x y) v.","proofString":"exploit (eval_mullimm n1); eauto.\nintros (n & (H1 & H2)).\nInvEval.\nexists n.\nsplit; auto.\nrewrite Val.mull_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : (exists v : val,\n   eval_expr ge sp e m le (mullimm n1 t2) v /\\\n   Val.lessdef (Val.mull y (Vlong n1)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\ Val.lessdef (Val.mull x y) v.","proofString":"intros (n & (H1 & H2)).\nInvEval.\nexists n.\nsplit; auto.\nrewrite Val.mull_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (mullimm n1 t2) n) (H2 : Val.lessdef (Val.mull y (Vlong n1)) n) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\ Val.lessdef (Val.mull x y) v.","proofString":"InvEval.\nexists n.\nsplit; auto.\nrewrite Val.mull_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (mullimm n1 t2) n) (H2 : Val.lessdef (Val.mull y (Vlong n1)) n) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull (Vlong n1) y) v.","proofString":"exists n.\nsplit; auto.\nrewrite Val.mull_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (mullimm n1 t2) n) (H2 : Val.lessdef (Val.mull y (Vlong n1)) n) : eval_expr ge sp e m le (mullimm n1 t2) n /\\\nVal.lessdef (Val.mull (Vlong n1) y) n.","proofString":"split; auto.\nrewrite Val.mull_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (mullimm n1 t2) n) (H2 : Val.lessdef (Val.mull y (Vlong n1)) n) : Val.lessdef (Val.mull (Vlong n1) y) n.","proofString":"rewrite Val.mull_commut.\nexact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (n : val) (H1 : eval_expr ge sp e m le (mullimm n1 t2) n) (H2 : Val.lessdef (Val.mull y (Vlong n1)) n) : Val.lessdef (Val.mull y (Vlong n1)) n.","proofString":"exact H2."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n2 t1) v /\\ Val.lessdef (Val.mull x y) v.","proofString":"exploit (eval_mullimm n2).\napply H.\nInvEval.\nauto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : (exists v : val,\n   eval_expr ge sp e m le (mullimm n2 t1) v /\\\n   Val.lessdef (Val.mull x (Vlong n2)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (mullimm n2 t1) v /\\\n  Val.lessdef (Val.mull x (Vlong n2)) v.","proofString":"auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (e1 : expr) (H : eval_expr ge sp e m le e1 x) (e2 : expr) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mull x y) v.","proofString":"TrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) : unary_constructor_sound\n  (fun a : expr => Eop Omullhu (a ::: longconst n ::: Enil))\n  (fun v : val => Val.mullhu v (Vlong n)).","proofString":"red; intros.\nTrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omullhu (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhu x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) : unary_constructor_sound\n  (fun a : expr => Eop Omullhs (a ::: longconst n ::: Enil))\n  (fun v : val => Val.mullhs v (Vlong n)).","proofString":"red; intros.\nTrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omullhs (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhs x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\ndestruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = true) (H1 : n = Int.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"subst n.\ndestruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint Int.zero) = Some z) (SL : Archi.splitlong = true) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"destruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le a v /\\\n  Val.lessdef\n    match\n      (if Int.ltu Int.zero (Int.repr 63)\n       then Some (Vlong (Int64.shrx' i Int.zero))\n       else None)\n    with\n    | Some v0 => v0\n    | None => Vlong (Int64.shrx' i Int.zero)\n    end v.","proofString":"econstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) : Val.lessdef\n  match\n    (if Int.ltu Int.zero (Int.repr 63)\n     then Some (Vlong (Int64.shrx' i Int.zero))\n     else None)\n  with\n  | Some v => v\n  | None => Vlong (Int64.shrx' i Int.zero)\n  end (Vlong i).","proofString":"change (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) : Val.lessdef\n  match (if true then Some (Vlong (Int64.shrx' i Int.zero)) else None) with\n  | Some v => v\n  | None => Vlong (Int64.shrx' i Int.zero)\n  end (Vlong i).","proofString":"simpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) : Val.lessdef (Vlong (Int64.shrx' i Int.zero)) (Vlong i).","proofString":"rewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = true) (H1 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivl (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivlu (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v.","proofString":"assert (DEFAULT: exists v : val, eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v).\nexploit Val.modlu_divlu; eauto.\nintros [v [A B]].\nsubst.\neconstructor; split; eauto.\napply eval_modl_aux with (semdivop := Val.divlu); auto.\ndestruct (is_longconst a) as [n1|] eqn:A.\nexploit is_longconst_sound; eauto.\ndestruct (is_longconst b) as [n2|] eqn:B; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v.","proofString":"exploit Val.modlu_divlu; eauto.\nintros [v [A B]].\nsubst.\neconstructor; split; eauto.\napply eval_modl_aux with (semdivop := Val.divlu); auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (SL : Archi.splitlong = true) : (exists v : val, Val.divlu x y = Some v /\\ z = Val.subl x (Val.mull v y)) ->\nexists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v.","proofString":"intros [v [A B]].\nsubst.\neconstructor; split; eauto.\napply eval_modl_aux with (semdivop := Val.divlu); auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (SL : Archi.splitlong = true) (v : val) (A : Val.divlu x y = Some v) (B : z = Val.subl x (Val.mull v y)) : exists v0 : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v0 /\\ Val.lessdef z v0.","proofString":"subst.\neconstructor; split; eauto.\napply eval_modl_aux with (semdivop := Val.divlu); auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull v y))) (SL : Archi.splitlong = true) (A : Val.divlu x y = Some v) : exists v0 : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v0 /\\\n  Val.lessdef (Val.subl x (Val.mull v y)) v0.","proofString":"econstructor; split; eauto.\napply eval_modl_aux with (semdivop := Val.divlu); auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull v y))) (SL : Archi.splitlong = true) (A : Val.divlu x y = Some v) : eval_expr ge sp e m le (modl_aux Odivlu a b) (Val.subl x (Val.mull v y)).","proofString":"apply eval_modl_aux with (semdivop := Val.divlu); auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (SL : Archi.splitlong = true) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v) : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v.","proofString":"destruct (is_longconst a) as [n1|] eqn:A.\nexploit is_longconst_sound; eauto.\ndestruct (is_longconst b) as [n2|] eqn:B; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (SL : Archi.splitlong = true) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v) (n1 : int64) (A : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v.","proofString":"exploit is_longconst_sound; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (SL : Archi.splitlong = true) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v) (A : is_longconst a = None) : exists v : val,\n  eval_expr ge sp e m le (modl_aux Odivlu a b) v /\\ Val.lessdef z v.","proofString":"destruct (is_longconst b) as [n2|] eqn:B; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longoffloat x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Olongoffloat (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatoflong (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."}]}