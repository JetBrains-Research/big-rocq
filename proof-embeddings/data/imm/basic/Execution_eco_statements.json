{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/basic/Execution_eco.v","fileSamples":[{"statement":"rf ⊆ eco.","proofString":"apply rf_in_eco."},{"statement":"co ⊆ eco.","proofString":"apply co_in_eco."},{"statement":"fr ⊆ eco.","proofString":"apply fr_in_eco."},{"statement":"(wf_index : forall a b : actid,\nE a /\\ E b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b) (data_in_sb : data G ⊆ sb) (wf_dataD : data G ≡ ⦗R⦘ ⨾ data G ⨾ ⦗W⦘) (addr_in_sb : addr G ⊆ sb) (wf_addrD : addr G ≡ ⦗R⦘ ⨾ addr G ⨾ ⦗RW⦘) (ctrl_in_sb : ctrl G ⊆ sb) (wf_ctrlD : ctrl G ≡ ⦗R⦘ ⨾ ctrl G) (ctrl_sb : ctrl G ⨾ sb ⊆ ctrl G) (wf_rmwD : rmw ≡ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) (wf_rmwl : rmw ⊆ same_loc) (wf_rmwi : rmw ⊆ immediate sb) (wf_rfE : rf ≡ ⦗E⦘ ⨾ rf ⨾ ⦗E⦘) (wf_rfD : rf ≡ ⦗W⦘ ⨾ rf ⨾ ⦗R⦘) (wf_rfl : rf ⊆ same_loc) (wf_rfv : funeq val rf) (wf_rff : functional rf⁻¹) (wf_coE : co ≡ ⦗E⦘ ⨾ co ⨾ ⦗E⦘) (wf_coD : co ≡ ⦗W⦘ ⨾ co ⨾ ⦗W⦘) (wf_col : co ⊆ same_loc) (co_trans : transitive co) (wf_co_total : forall ol : option location,\nis_total (E ∩₁ W ∩₁ (fun x : actid => loc x = ol)) co) (co_irr : irreflexive co) (wf_init : forall l : location,\n(exists b : actid, E b /\\ loc b = Some l) -> E (InitEvent l)) (wf_init_lab : forall l : location, lab (InitEvent l) = Astore Xpln Opln l 0) (rmw_dep_in_sb : rmw_dep G ⊆ sb) (wf_rmw_depD : rmw_dep G ≡ ⦗R⦘ ⨾ rmw_dep G ⨾ ⦗fun a : actid => R_ex lab a⦘) (wf_threads : forall e : actid, E e -> threads_set G (tid e)) : funeq loc eco.","proofString":"eauto 10 with hahn."},{"statement":"(WF : Wf G) : eco ⊆ ⦗E⦘ ⨾ eco ⨾ ⦗E⦘.","proofString":"unfold eco.\nrewrite (wf_rfE WF) at 1 2 3.\nrewrite (wf_coE WF) at 1.\nrewrite (wf_frE WF) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^? ⊆ ⦗E⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E⦘.","proofString":"rewrite (wf_rfE WF) at 1 2 3.\nrewrite (wf_coE WF) at 1.\nrewrite (wf_frE WF) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗E⦘ ⨾ rf ⨾ ⦗E⦘ ∪ co ⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^? ∪ fr ⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^?\n⊆ ⦗E⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E⦘.","proofString":"rewrite (wf_coE WF) at 1.\nrewrite (wf_frE WF) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗E⦘ ⨾ rf ⨾ ⦗E⦘ ∪ (⦗E⦘ ⨾ co ⨾ ⦗E⦘) ⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^?\n∪ fr ⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^? ⊆ ⦗E⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E⦘.","proofString":"rewrite (wf_frE WF) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗E⦘ ⨾ rf ⨾ ⦗E⦘ ∪ (⦗E⦘ ⨾ co ⨾ ⦗E⦘) ⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^?\n∪ (⦗E⦘ ⨾ fr ⨾ ⦗E⦘) ⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^?\n⊆ ⦗E⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : eco ⊆ ⦗RW⦘ ⨾ eco ⨾ ⦗RW⦘.","proofString":"unfold eco.\nrewrite wf_rfD at 1 2 3; try done.\nrewrite wf_coD at 1; try done.\nrewrite wf_frD at 1; try done.\ntype_solver 42."},{"statement":"(WF : Wf G) : rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^? ⊆ ⦗RW⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗RW⦘.","proofString":"rewrite wf_rfD at 1 2 3; try done.\nrewrite wf_coD at 1; try done.\nrewrite wf_frD at 1; try done.\ntype_solver 42."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ rf ⨾ ⦗R⦘ ∪ co ⨾ (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)^? ∪ fr ⨾ (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)^?\n⊆ ⦗RW⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗RW⦘.","proofString":"rewrite wf_coD at 1; try done.\nrewrite wf_frD at 1; try done.\ntype_solver 42."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ rf ⨾ ⦗R⦘ ∪ (⦗W⦘ ⨾ co ⨾ ⦗W⦘) ⨾ (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)^?\n∪ fr ⨾ (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)^? ⊆ ⦗RW⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗RW⦘.","proofString":"rewrite wf_frD at 1; try done.\ntype_solver 42."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ rf ⨾ ⦗R⦘ ∪ (⦗W⦘ ⨾ co ⨾ ⦗W⦘) ⨾ (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)^?\n∪ (⦗R⦘ ⨾ fr ⨾ ⦗W⦘) ⨾ (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)^?\n⊆ ⦗RW⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗RW⦘.","proofString":"type_solver 42."},{"statement":"(WF : Wf G) : irreflexive (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?).","proofString":"generalize (co_irr WF) (rf_irr WF) (fr_irr WF).\ngeneralize (rf_fr WF) (rf_co WF).\nbasic_solver 5."},{"statement":"(WF : Wf G) : irreflexive co ->\nirreflexive rf -> irreflexive fr -> irreflexive (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?).","proofString":"generalize (rf_fr WF) (rf_co WF).\nbasic_solver 5."},{"statement":"(WF : Wf G) : rf ⨾ fr ⊆ co ->\nrf ⨾ co ≡ ∅₂ ->\nirreflexive co ->\nirreflexive rf -> irreflexive fr -> irreflexive (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?).","proofString":"basic_solver 5."},{"statement":"(WF : Wf G) : eco ⊆ (rf ∪ co ∪ fr)⁺.","proofString":"unfold eco; rewrite !crE; relsf.\nunionL; eauto 6 using inclusion_step2_ct with hahn."},{"statement":"(WF : Wf G) : rf ∪ (co ∪ co ⨾ rf) ∪ (fr ∪ fr ⨾ rf) ⊆ (rf ∪ co ∪ fr)⁺.","proofString":"unionL; eauto 6 using inclusion_step2_ct with hahn."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : RW x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"generalize (dom_to_domb (wf_rfE WF)); intro rfE2; unfolder in rfE2.\ngeneralize (dom_to_doma (wf_rfD WF)); intro rfD1; unfolder in rfD1.\ngeneralize (dom_to_domb (wf_rfD WF)); intro rfD2; unfolder in rfD2.\ngeneralize (loceq_rf WF); intro rfL; unfolder in rfL.\nassert (exists l, loc x = l).\nby destruct x; eauto.\nunfolder in RWx.\nunfolder in RWy.\nins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : RW x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"generalize (dom_to_doma (wf_rfD WF)); intro rfD1; unfolder in rfD1.\ngeneralize (dom_to_domb (wf_rfD WF)); intro rfD2; unfolder in rfD2.\ngeneralize (loceq_rf WF); intro rfL; unfolder in rfL.\nassert (exists l, loc x = l).\nby destruct x; eauto.\nunfolder in RWx.\nunfolder in RWy.\nins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : RW x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"generalize (dom_to_domb (wf_rfD WF)); intro rfD2; unfolder in rfD2.\ngeneralize (loceq_rf WF); intro rfL; unfolder in rfL.\nassert (exists l, loc x = l).\nby destruct x; eauto.\nunfolder in RWx.\nunfolder in RWy.\nins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : RW x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"generalize (loceq_rf WF); intro rfL; unfolder in rfL.\nassert (exists l, loc x = l).\nby destruct x; eauto.\nunfolder in RWx.\nunfolder in RWy.\nins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : RW x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (exists l, loc x = l).\nby destruct x; eauto.\nunfolder in RWx.\nunfolder in RWy.\nins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : RW x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) : exists l : option location, loc x = l.","proofString":"by destruct x; eauto."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : RW x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (H : exists l : option location, loc x = l) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"unfolder in RWx.\nunfolder in RWy.\nins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x \\/ is_w lab x) (RWy : RW y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (H : exists l : option location, loc x = l) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"unfolder in RWy.\nins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x \\/ is_w lab x) (RWy : is_r lab y \\/ is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (H : exists l : option location, loc x = l) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"ins; desf.\nassert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\nassert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (H : exists wx : actid, rf wx x) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (H : exists wx : actid, rf wx x) (H0 : exists wy : actid, rf wy y) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"desf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (wy : actid) (H0 : rf wy y) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"destruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (wy : actid) (H0 : rf wy y) (H1 : wx <> wy) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (wy : actid) (H0 : rf wy y) (H1 : wx <> wy) (H2 : co wx wy \\/ co wy wx) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"by unfold eco, Execution.fr; basic_solver 42."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (wy : actid) (H0 : rf wy y) (H1 : wx <> wy) : co wx wy \\/ co wy wx.","proofString":"eapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (wy : actid) (H0 : rf wy y) (H1 : wx <> wy) : loc wy = loc wx.","proofString":"by apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (H : exists wy : actid, rf wy y) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"desf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wy : actid) (H : rf wy y) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"destruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wy : actid) (H : rf wy y) (H0 : wy <> x) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wy : actid) (H : rf wy y) (H0 : wy <> x) (H1 : co wy x \\/ co x wy) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"by unfold eco, Execution.fr; basic_solver 42."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wy : actid) (H : rf wy y) (H0 : wy <> x) : co wy x \\/ co x wy.","proofString":"eapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_r lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wy : actid) (H : rf wy y) (H0 : wy <> x) : loc x = loc wy.","proofString":"by apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) : exists wx : actid, rf wx x.","proofString":"by apply COMP; basic_solver."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (H : exists wx : actid, rf wx x) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"desf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"destruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (H0 : wx <> y) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (H0 : wx <> y) (H1 : co wx y \\/ co y wx) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"by unfold eco, Execution.fr; basic_solver 42."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (H0 : wx <> y) : co wx y \\/ co y wx.","proofString":"eapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_r lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) (wx : actid) (H : rf wx x) (H0 : wx <> y) : loc y = loc wx.","proofString":"by apply (loceq_rf WF) in H; congruence."},{"statement":"(WF : Wf G) (COMP : complete G) (x y : actid) (ACTx : E x) (ACTy : E y) (RWx : is_w lab x) (RWy : is_w lab y) (LOC : loc x = loc y) (NEQ : x <> y) (rfE1 : forall x0 y0 : actid, rf x0 y0 -> E x0) (rfE2 : forall x0 y0 : actid, rf x0 y0 -> E y0) (rfD1 : forall x0 y0 : actid, rf x0 y0 -> is_w lab x0) (rfD2 : forall x0 y0 : actid, rf x0 y0 -> is_r lab y0) (rfL : forall a b : actid, rf a b -> loc a = loc b) : eco x y \\/ eco y x \\/ (exists z : actid, rf z x /\\ rf z y).","proofString":"assert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10."},{"statement":"(WF : Wf G) : rf⁻¹ ⨾ rf ⨾ rf ∪ rf⁻¹ ⨾ rf ⨾ co ⨾ rf^? ∪ rf⁻¹ ⨾ rf ⨾ (rf⁻¹ ⨾ co) ⨾ rf^?\n⊆ rf ∪ co ⨾ rf^? ∪ (rf⁻¹ ⨾ co) ⨾ rf^?.","proofString":"rewrite rf_rf; auto.\nseq_rewrite rf_co; auto.\nrewrite !seqA.\nsin_rewrite rf_transp_rf; basic_solver 10."},{"statement":"(WF : Wf G) : rf⁻¹ ⨾ ∅₂ ∪ rf⁻¹ ⨾ rf ⨾ co ⨾ rf^? ∪ rf⁻¹ ⨾ rf ⨾ (rf⁻¹ ⨾ co) ⨾ rf^?\n⊆ rf ∪ co ⨾ rf^? ∪ (rf⁻¹ ⨾ co) ⨾ rf^?.","proofString":"seq_rewrite rf_co; auto.\nrewrite !seqA.\nsin_rewrite rf_transp_rf; basic_solver 10."},{"statement":"(WF : Wf G) : rf⁻¹ ⨾ ∅₂ ∪ rf⁻¹ ⨾ ∅₂ ⨾ rf^? ∪ rf⁻¹ ⨾ rf ⨾ (rf⁻¹ ⨾ co) ⨾ rf^?\n⊆ rf ∪ co ⨾ rf^? ∪ (rf⁻¹ ⨾ co) ⨾ rf^?.","proofString":"rewrite !seqA.\nsin_rewrite rf_transp_rf; basic_solver 10."},{"statement":"(WF : Wf G) : rf⁻¹ ⨾ ∅₂ ∪ rf⁻¹ ⨾ ∅₂ ⨾ rf^? ∪ rf⁻¹ ⨾ rf ⨾ rf⁻¹ ⨾ co ⨾ rf^?\n⊆ rf ∪ co ⨾ rf^? ∪ rf⁻¹ ⨾ co ⨾ rf^?.","proofString":"sin_rewrite rf_transp_rf; basic_solver 10."},{"statement":"(WF : Wf G) : rf ⨾ rf⁻¹ ⨾ rf ∪ (co ⨾ rf^?) ⨾ rf⁻¹ ⨾ rf ∪ ((rf⁻¹ ⨾ co) ⨾ rf^?) ⨾ rf⁻¹ ⨾ rf\n⊆ rf ∪ co ⨾ rf^? ∪ (rf⁻¹ ⨾ co) ⨾ rf^?.","proofString":"rewrite !seqA, !crE; relsf.\narewrite_false (co ⨾ rf⁻¹).\nby rewrite (wf_coD WF), (wf_rfD WF); type_solver.\nsin_rewrite !rf_transp_rf; auto.\nbasic_solver 8."},{"statement":"(WF : Wf G) : rf ⨾ rf⁻¹ ⨾ rf ∪ (co ⨾ rf⁻¹ ⨾ rf ∪ co ⨾ rf ⨾ rf⁻¹ ⨾ rf)\n∪ (rf⁻¹ ⨾ co ⨾ rf⁻¹ ⨾ rf ∪ rf⁻¹ ⨾ co ⨾ rf ⨾ rf⁻¹ ⨾ rf)\n⊆ rf ∪ (co ∪ co ⨾ rf) ∪ (rf⁻¹ ⨾ co ∪ rf⁻¹ ⨾ co ⨾ rf).","proofString":"arewrite_false (co ⨾ rf⁻¹).\nby rewrite (wf_coD WF), (wf_rfD WF); type_solver.\nsin_rewrite !rf_transp_rf; auto.\nbasic_solver 8."},{"statement":"(WF : Wf G) : co ⨾ rf⁻¹ ⊆ ∅₂.","proofString":"by rewrite (wf_coD WF), (wf_rfD WF); type_solver."},{"statement":"(WF : Wf G) : rf ⨾ rf⁻¹ ⨾ rf ∪ (∅₂ ⨾ rf ∪ co ⨾ rf ⨾ rf⁻¹ ⨾ rf)\n∪ (rf⁻¹ ⨾ ∅₂ ⨾ rf ∪ rf⁻¹ ⨾ co ⨾ rf ⨾ rf⁻¹ ⨾ rf)\n⊆ rf ∪ (co ∪ co ⨾ rf) ∪ (rf⁻¹ ⨾ co ∪ rf⁻¹ ⨾ co ⨾ rf).","proofString":"sin_rewrite !rf_transp_rf; auto.\nbasic_solver 8."},{"statement":"(WF : Wf G) : ⦗fun _ : actid => True⦘ ⨾ rf ∪ (∅₂ ⨾ rf ∪ co ⨾ ⦗fun _ : actid => True⦘ ⨾ rf)\n∪ (rf⁻¹ ⨾ ∅₂ ⨾ rf ∪ rf⁻¹ ⨾ co ⨾ ⦗fun _ : actid => True⦘ ⨾ rf)\n⊆ rf ∪ (co ∪ co ⨾ rf) ∪ (rf⁻¹ ⨾ co ∪ rf⁻¹ ⨾ co ⨾ rf).","proofString":"basic_solver 8."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : co ⊆ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"rewrite wf_coE at 1; try done.\nunfolder; ins; splits; auto; desf; intro.\neapply SC_PER_LOC; exists x; splits; [|eby apply co_in_eco].\nunfold Execution.sb; unfolder; splits; try done.\ncut (~ is_init x).\ndestruct x, y; ins.\nintro.\nassert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : ⦗E⦘ ⨾ co ⨾ ⦗E⦘ ⊆ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"unfolder; ins; splits; auto; desf; intro.\neapply SC_PER_LOC; exists x; splits; [|eby apply co_in_eco].\nunfold Execution.sb; unfolder; splits; try done.\ncut (~ is_init x).\ndestruct x, y; ins.\nintro.\nassert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) : False.","proofString":"eapply SC_PER_LOC; exists x; splits; [|eby apply co_in_eco].\nunfold Execution.sb; unfolder; splits; try done.\ncut (~ is_init x).\ndestruct x, y; ins.\nintro.\nassert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) : sb y x.","proofString":"unfold Execution.sb; unfolder; splits; try done.\ncut (~ is_init x).\ndestruct x, y; ins.\nintro.\nassert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) : ext_sb y x.","proofString":"cut (~ is_init x).\ndestruct x, y; ins.\nintro.\nassert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) : ~ is_init x -> ext_sb y x.","proofString":"destruct x, y; ins."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) : ~ is_init x.","proofString":"intro.\nassert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) (H3 : is_init x) : False.","proofString":"assert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) (H3 : is_init x) : x = y.","proofString":"eby apply (loceq_co WF) in H0; eapply init_same_loc."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H0 : co x y) (H1 : E y) (H2 : is_init y) (H3 : is_init x) (H4 : x = y) : False.","proofString":"eby subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ co^? ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"clear.\nbasic_solver."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ co^? ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : rf⁻¹ ⨾ co ⊆ (rf⁻¹ ⨾ co) ⨾ ⦗fun x : actid => ~ is_init x⦘.","proofString":"rewrite no_co_to_init at 1; try done.\nbasic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : rf⁻¹ ⨾ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n⊆ (rf⁻¹ ⨾ co) ⨾ ⦗fun x : actid => ~ is_init x⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : same_loc x y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) : co x y.","proofString":"generalize (init_w WF H); intro Wx.\ngeneralize (is_w_loc lab x Wx).\nunfold Events.same_loc in *; ins; desf.\neapply tot_ex.\neapply WF.\nbasic_solver.\nunfolder; splits; try edone.\ndestruct x; [|unfold is_init in *; desf].\neapply (wf_init WF); exists y; splits; eauto.\nunfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence.\nintro A.\nhahn_rewrite (no_co_to_init WF SC_PER_LOC) in A.\nunfolder in *; desf.\nintro; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : same_loc x y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) : co x y.","proofString":"generalize (is_w_loc lab x Wx).\nunfold Events.same_loc in *; ins; desf.\neapply tot_ex.\neapply WF.\nbasic_solver.\nunfolder; splits; try edone.\ndestruct x; [|unfold is_init in *; desf].\neapply (wf_init WF); exists y; splits; eauto.\nunfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence.\nintro A.\nhahn_rewrite (no_co_to_init WF SC_PER_LOC) in A.\nunfolder in *; desf.\nintro; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : same_loc x y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) : (exists l : location, loc x = Some l) -> co x y.","proofString":"unfold Events.same_loc in *; ins; desf.\neapply tot_ex.\neapply WF.\nbasic_solver.\nunfolder; splits; try edone.\ndestruct x; [|unfold is_init in *; desf].\neapply (wf_init WF); exists y; splits; eauto.\nunfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence.\nintro A.\nhahn_rewrite (no_co_to_init WF SC_PER_LOC) in A.\nunfolder in *; desf.\nintro; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : loc x = loc y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) (l : location) (H4 : loc x = Some l) : co x y.","proofString":"eapply tot_ex.\neapply WF.\nbasic_solver.\nunfolder; splits; try edone.\ndestruct x; [|unfold is_init in *; desf].\neapply (wf_init WF); exists y; splits; eauto.\nunfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence.\nintro A.\nhahn_rewrite (no_co_to_init WF SC_PER_LOC) in A.\nunfolder in *; desf.\nintro; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : loc x = loc y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) (l : location) (H4 : loc x = Some l) : E x.","proofString":"destruct x; [|unfold is_init in *; desf].\neapply (wf_init WF); exists y; splits; eauto.\nunfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (l0 : location) (y : actid) (H : is_init (InitEvent l0)) (H0 : loc (InitEvent l0) = loc y) (H3 : InitEvent l0 <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab (InitEvent l0)) (l : location) (H4 : loc (InitEvent l0) = Some l) : E (InitEvent l0).","proofString":"eapply (wf_init WF); exists y; splits; eauto.\nunfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (l0 : location) (y : actid) (H : is_init (InitEvent l0)) (H0 : loc (InitEvent l0) = loc y) (H3 : InitEvent l0 <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab (InitEvent l0)) (l : location) (H4 : loc (InitEvent l0) = Some l) : loc y = Some l0.","proofString":"unfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (l0 : location) (y : actid) (H : is_init (InitEvent l0)) (H0 : match lab (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend =\nmatch lab y with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend) (H3 : InitEvent l0 <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab (InitEvent l0)) (l : location) (H4 : match lab (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = Some l) : match lab y with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = Some l0.","proofString":"rewrite (wf_init_lab WF) in *.\ncongruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (l0 : location) (y : actid) (H : is_init (InitEvent l0)) (H0 : Some l0 =\nmatch lab y with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend) (H3 : InitEvent l0 <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab (InitEvent l0)) (l : location) (H4 : Some l0 = Some l) : match lab y with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = Some l0.","proofString":"congruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : loc x = loc y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) (l : location) (H4 : loc x = Some l) : ~ co y x.","proofString":"intro A.\nhahn_rewrite (no_co_to_init WF SC_PER_LOC) in A.\nunfolder in *; desf."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : loc x = loc y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) (l : location) (H4 : loc x = Some l) (A : co y x) : False.","proofString":"hahn_rewrite (no_co_to_init WF SC_PER_LOC) in A.\nunfolder in *; desf."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : loc x = loc y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) (l : location) (H4 : loc x = Some l) (A : (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) y x) : False.","proofString":"unfolder in *; desf."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : is_init x) (H0 : loc x = loc y) (H3 : x <> y) (H1 : E y) (H2 : is_w lab y) (Wx : is_w lab x) (l : location) (H4 : loc x = Some l) : y <> x.","proofString":"intro; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (ATOM : rmw_atomicity G) : (⦗fun x : actid => ~ is_init x⦘ ⨾ rmw)\n∩ ((fr ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ co) ⊆ ∅₂.","proofString":"unfolder; red in ATOM; red in SC_PER_LOC; ins; desf.\ndestruct (classic (sb x z));destruct (classic (sb z y)); eauto 8.\nby eapply wf_rmwi; eauto.\neapply sb_semi_total_l with (y:=y) in H4; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply co_in_eco].\neby intro; subst; eapply (co_irr WF).\neby apply rmw_in_sb.\neapply sb_semi_total_r with (x:=y) (y:=x) in H5; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply fr_in_eco].\neby intro; subst; eapply fr_irr.\neby apply rmw_in_sb.\nby eapply ATOM; unfolder; splits; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) : False.","proofString":"destruct (classic (sb x z));destruct (classic (sb z y)); eauto 8.\nby eapply wf_rmwi; eauto.\neapply sb_semi_total_l with (y:=y) in H4; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply co_in_eco].\neby intro; subst; eapply (co_irr WF).\neby apply rmw_in_sb.\neapply sb_semi_total_r with (x:=y) (y:=x) in H5; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply fr_in_eco].\neby intro; subst; eapply fr_irr.\neby apply rmw_in_sb.\nby eapply ATOM; unfolder; splits; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : sb x z) (H5 : sb z y) : False.","proofString":"by eapply wf_rmwi; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : sb x z) (H5 : ~ sb z y) : False.","proofString":"eapply sb_semi_total_l with (y:=y) in H4; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply co_in_eco].\neby intro; subst; eapply (co_irr WF).\neby apply rmw_in_sb."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : sb y z \\/ sb z y) (H5 : ~ sb z y) : False.","proofString":"desf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply co_in_eco]."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : sb y z) (H5 : ~ sb z y) : False.","proofString":"eapply SC_PER_LOC.\nby eexists; splits; [eauto| apply co_in_eco]."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : sb x z) (H5 : ~ sb z y) : y <> z.","proofString":"eby intro; subst; eapply (co_irr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : sb x z) (H5 : ~ sb z y) : sb x y.","proofString":"eby apply rmw_in_sb."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : ~ sb x z) (H5 : sb z y) : False.","proofString":"eapply sb_semi_total_r with (x:=y) (y:=x) in H5; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply fr_in_eco].\neby intro; subst; eapply fr_irr.\neby apply rmw_in_sb."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : ~ sb x z) (H5 : sb x z \\/ sb z x) : False.","proofString":"desf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply fr_in_eco]."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : ~ sb x z) (H5 : sb z x) : False.","proofString":"eapply SC_PER_LOC.\nby eexists; splits; [eauto| apply fr_in_eco]."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : ~ sb x z) (H5 : sb z y) : x <> z.","proofString":"eby intro; subst; eapply fr_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : ~ sb x z) (H5 : sb z y) : sb x y.","proofString":"eby apply rmw_in_sb."},{"statement":"(WF : Wf G) (SC_PER_LOC : irreflexive (sb ⨾ eco)) (ATOM : rmw ∩ ((fr \\ sb) ⨾ (co \\ sb)) ⊆ ∅₂) (x y : actid) (H : ~ is_init x) (H3 : rmw x y) (z : actid) (H0 : fr x z) (H1 : ~ is_init z) (H2 : co z y) (H4 : ~ sb x z) (H5 : ~ sb z y) : False.","proofString":"by eapply ATOM; unfolder; splits; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (co^? ⨾ rf ⨾ sb).","proofString":"unfold sc_per_loc, eco in *; unfolder in *; basic_solver 10."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (IRR : irreflexive r) (A : irreflexive (r ⨾ eco)) : ⦗W⦘ ⨾ (⦗E⦘ ⨾ r ⨾ ⦗E⦘) ∩ same_loc ⨾ ⦗W⦘ ⊆ co.","proofString":"unfolder; ins; desf.\neapply tot_ex.\neapply WF.\nunfolder; splits; try edone.\nunfolder; splits; try edone.\nintro; eapply A; unfold eco; basic_solver 12.\nintro; subst; eapply IRR; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (IRR : irreflexive r) (A : irreflexive (r ⨾ eco)) (y z : actid) (H : is_w lab z) (H6 : E z) (H3 : r z y) (H5 : E y) (H2 : same_loc z y) (H1 : is_w lab y) : co z y.","proofString":"eapply tot_ex.\neapply WF.\nunfolder; splits; try edone.\nunfolder; splits; try edone.\nintro; eapply A; unfold eco; basic_solver 12.\nintro; subst; eapply IRR; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (IRR : irreflexive r) (A : irreflexive (r ⨾ eco)) (y z : actid) (H : is_w lab z) (H6 : E z) (H3 : r z y) (H5 : E y) (H2 : same_loc z y) (H1 : is_w lab y) : ~ co y z.","proofString":"intro; eapply A; unfold eco; basic_solver 12."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (IRR : irreflexive r) (A : irreflexive (r ⨾ eco)) (y z : actid) (H : is_w lab z) (H6 : E z) (H3 : r z y) (H5 : E y) (H2 : same_loc z y) (H1 : is_w lab y) : y <> z.","proofString":"intro; subst; eapply IRR; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗W⦘ ⨾ (⦗E⦘ ⨾ r ⨾ ⦗E⦘) ∩ same_loc ⨾ ⦗R⦘ ⊆ co^? ⨾ rf.","proofString":"cut (⦗W⦘ ⨾  ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ co^? ⨾ rf).\nby basic_solver 12.\nred in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [|edone].\ndestruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗W⦘ ⨾ ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ co^? ⨾ rf ->\n⦗W⦘ ⨾ (⦗E⦘ ⨾ r ⨾ ⦗E⦘) ∩ same_loc ⨾ ⦗R⦘ ⊆ co^? ⨾ rf.","proofString":"by basic_solver 12."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗W⦘ ⨾ ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ co^? ⨾ rf.","proofString":"red in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [|edone].\ndestruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗W⦘ ⨾ ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗codom_rel rf⦘ ⊆ co^? ⨾ rf.","proofString":"rewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [|edone].\ndestruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗W⦘ ⨾ ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗codom_rel (⦗W⦘ ⨾ rf)⦘ ⊆ co^? ⨾ rf.","proofString":"rewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [|edone].\ndestruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗W⦘ ⨾ ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf)⦘ ⊆ co^? ⨾ rf.","proofString":"rewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [|edone].\ndestruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗W⦘ ⨾ ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf ∩ same_loc)⦘\n⊆ co^? ⨾ rf.","proofString":"unfolder; ins; desf; eexists; splits; [|edone].\ndestruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y : actid) (H : is_w lab x) (H7 : E x) (H0 : r x y) (H6 : same_loc x y) (z : actid) (H5 : E z) (H4 : is_w lab z) (H2 : rf z y) (H3 : same_loc z y) : x = z \\/ co x z.","proofString":"destruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y : actid) (H : is_w lab x) (H7 : E x) (H0 : r x y) (H6 : same_loc x y) (z : actid) (H5 : E z) (H4 : is_w lab z) (H2 : rf z y) (H3 : same_loc z y) (H1 : x <> z) : x = z \\/ co x z.","proofString":"right; eapply tot_ex.\neapply WF.\nsplits; try edone.\nsplits; try edone.\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\ncongruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y : actid) (H : is_w lab x) (H7 : E x) (H0 : r x y) (H6 : same_loc x y) (z : actid) (H5 : E z) (H4 : is_w lab z) (H2 : rf z y) (H3 : same_loc z y) (H1 : x <> z) : ~ co z x.","proofString":"intro; eapply A.\nunfold eco, Execution.fr; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y : actid) (H : is_w lab x) (H7 : E x) (H0 : r x y) (H6 : same_loc x y) (z : actid) (H5 : E z) (H4 : is_w lab z) (H2 : rf z y) (H3 : same_loc z y) (H1 : x <> z) : z <> x.","proofString":"congruence."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗R⦘ ⨾ (⦗E⦘ ⨾ r ⨾ ⦗E⦘) ∩ same_loc ⨾ ⦗W⦘ ⊆ fr.","proofString":"cut (⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr).\nby basic_solver 12.\nred in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco; basic_solver 22.\nintro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr ->\n⦗R⦘ ⨾ (⦗E⦘ ⨾ r ⨾ ⦗E⦘) ∩ same_loc ⨾ ⦗W⦘ ⊆ fr.","proofString":"by basic_solver 12."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr.","proofString":"red in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco; basic_solver 22.\nintro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel rf⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr.","proofString":"rewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco; basic_solver 22.\nintro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel (⦗W⦘ ⨾ rf)⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr.","proofString":"rewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco; basic_solver 22.\nintro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf)⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr.","proofString":"rewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco; basic_solver 22.\nintro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf ∩ same_loc)⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr.","proofString":"unfolder; ins; desf; eexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco; basic_solver 22.\nintro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H7 : E z) (H6 : is_w lab z) (H4 : rf z x) (H5 : same_loc z x) (H0 : r x y) (H3 : same_loc x y) (H1 : E y) (H2 : is_w lab y) : co z y.","proofString":"eapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco; basic_solver 22.\nintro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H7 : E z) (H6 : is_w lab z) (H4 : rf z x) (H5 : same_loc z x) (H0 : r x y) (H3 : same_loc x y) (H1 : E y) (H2 : is_w lab y) : ~ co y z.","proofString":"intro; eapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H7 : E z) (H6 : is_w lab z) (H4 : rf z x) (H5 : same_loc z x) (H0 : r x y) (H3 : same_loc x y) (H1 : E y) (H2 : is_w lab y) : y <> z.","proofString":"intro; subst.\neapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x z : actid) (H7 : E z) (H6 : is_w lab z) (H4 : rf z x) (H5 : same_loc z x) (H2 : is_w lab z) (H1 : E z) (H3 : same_loc x z) (H0 : r x z) : False.","proofString":"eapply A.\nunfold eco; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗R⦘ ⨾ (⦗E⦘ ⨾ r ⨾ ⦗E⦘) ∩ same_loc ⨾ ⦗R⦘ ⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf.","proofString":"cut (⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ fr ⨾ rf ∪ rf^{-1} ⨾ rf).\nby basic_solver 12.\nred in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1 2.\nrewrite (dom_l (wf_rfE WF)) at 1 2.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1 2.\nunfolder; ins; desf.\ndestruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf ->\n⦗R⦘ ⨾ (⦗E⦘ ⨾ r ⨾ ⦗E⦘) ∩ same_loc ⨾ ⦗R⦘ ⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf.","proofString":"by basic_solver 12."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : complete G) : ⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf.","proofString":"red in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1 2.\nrewrite (dom_l (wf_rfE WF)) at 1 2.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1 2.\nunfolder; ins; desf.\ndestruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel rf⦘ ⨾ r ∩ same_loc ⨾ ⦗codom_rel rf⦘ ⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf.","proofString":"rewrite (dom_l (wf_rfD WF)) at 1 2.\nrewrite (dom_l (wf_rfE WF)) at 1 2.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1 2.\nunfolder; ins; desf.\ndestruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel (⦗W⦘ ⨾ rf)⦘ ⨾ r ∩ same_loc ⨾ ⦗codom_rel (⦗W⦘ ⨾ rf)⦘\n⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf.","proofString":"rewrite (dom_l (wf_rfE WF)) at 1 2.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1 2.\nunfolder; ins; desf.\ndestruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf)⦘ ⨾ r ∩ same_loc ⨾ ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf)⦘\n⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf.","proofString":"rewrite (loceq_same_loc (loceq_rf WF)) at 1 2.\nunfolder; ins; desf.\ndestruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) : ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf ∩ same_loc)⦘\n⨾ r ∩ same_loc ⨾ ⦗codom_rel (⦗W⦘ ⨾ ⦗E⦘ ⨾ rf ∩ same_loc)⦘\n⊆ fr ⨾ rf ∪ rf⁻¹ ⨾ rf.","proofString":"unfolder; ins; desf.\ndestruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) : (exists z1 : actid, fr x z1 /\\ rf z1 y) \\/\n(exists z1 : actid, rf z1 x /\\ rf z1 y).","proofString":"destruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 = z) : (exists z1 : actid, fr x z1 /\\ rf z1 y) \\/\n(exists z1 : actid, rf z1 x /\\ rf z1 y).","proofString":"by right; eexists; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 <> z) : (exists z1 : actid, fr x z1 /\\ rf z1 y) \\/\n(exists z1 : actid, rf z1 x /\\ rf z1 y).","proofString":"left.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 <> z) : exists z1 : actid, fr x z1 /\\ rf z1 y.","proofString":"unfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 <> z) : exists z1 : actid, (exists z2 : actid, rf z2 x /\\ co z2 z1) /\\ rf z1 y.","proofString":"eexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 <> z) : exists z1 : actid, rf z1 x /\\ co z1 z0.","proofString":"eexists; splits; [edone|].\neapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 <> z) : co z z0.","proofString":"eapply tot_ex.\neapply WF.\nsplits; try edone.\nunfolder; splits; [done | done | unfolder in *; congruence].\nintro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\nintro; subst; eauto."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 <> z) : ~ co z0 z.","proofString":"intro; eapply A.\nunfold eco, Execution.fr; basic_solver 22."},{"statement":"(WF : Wf G) (r : relation actid) (rE : r ≡ ⦗E⦘ ⨾ r ⨾ ⦗E⦘) (A : irreflexive (r ⨾ eco)) (COMP : E ∩₁ R ⊆₁ codom_rel rf) (x y z : actid) (H10 : E z) (H9 : is_w lab z) (H7 : rf z x) (H8 : same_loc z x) (H0 : r x y) (H6 : same_loc x y) (z0 : actid) (H5 : E z0) (H4 : is_w lab z0) (H2 : rf z0 y) (H3 : same_loc z0 y) (H : z0 <> z) : z0 <> z.","proofString":"intro; subst; eauto."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : ⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ (⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘) ∩ sb.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘) ∩ sb ⊆ coi.","proofString":"rewrite (w_r_loc_w_in_co WF (@wf_sbE G) (@sb_irr G) SC_PER_LOC).\nby ie_unfolder."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : co ∩ sb ⊆ coi.","proofString":"by ie_unfolder."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (COMP : complete G) : ⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ (⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘) ∩ sb.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (COMP : complete G) : (⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘) ∩ sb ⊆ fri.","proofString":"rewrite (r_r_loc_w_in_fr WF (@wf_sbE G) SC_PER_LOC COMP).\nby ie_unfolder."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (COMP : complete G) : fr ∩ sb ⊆ fri.","proofString":"by ie_unfolder."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : rmw ∪ rmw ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ rmw ∪ rmw ⨾ coi.","proofString":"apply union_mori; [done|].\nrewrite (dom_r (wf_rmwD WF)) at 1.\nrewrite !seqA.\nby rewrite (w_sb_loc_w_in_coi WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : rmw ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ rmw ⨾ coi.","proofString":"rewrite (dom_r (wf_rmwD WF)) at 1.\nrewrite !seqA.\nby rewrite (w_sb_loc_w_in_coi WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (rmw ⨾ ⦗W⦘) ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ rmw ⨾ coi.","proofString":"rewrite !seqA.\nby rewrite (w_sb_loc_w_in_coi WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : rmw ⨾ ⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ rmw ⨾ coi.","proofString":"by rewrite (w_sb_loc_w_in_coi WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (COMP : complete G) : ⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ fri.","proofString":"rewrite (r_sb_loc_w_in_fri WF SC_PER_LOC COMP).\nie_unfolder; basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (COMP : complete G) : fri ⊆ fri.","proofString":"ie_unfolder; basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (COMP : complete G) : fri ⊆ fr.","proofString":"apply fri_in_fr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (⦗E⦘ ⨾ rf) ⨾ rmw ⊆ co ∪ co⁻¹.","proofString":"rewrite (dom_r (wf_rmwE WF)).\nrewrite (dom_l (wf_rfD WF)).\nrewrite (dom_r (wf_rmwD WF)).\nunfolder; ins; desf.\neapply (wf_co_total WF); [basic_solver| |].\nunfolder; ins; desf; splits; eauto.\napply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence.\nintro; subst.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (⦗E⦘ ⨾ rf) ⨾ rmw ⨾ ⦗E⦘ ⊆ co ∪ co⁻¹.","proofString":"rewrite (dom_l (wf_rfD WF)).\nrewrite (dom_r (wf_rmwD WF)).\nunfolder; ins; desf.\neapply (wf_co_total WF); [basic_solver| |].\nunfolder; ins; desf; splits; eauto.\napply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence.\nintro; subst.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (⦗E⦘ ⨾ ⦗W⦘ ⨾ rf) ⨾ rmw ⨾ ⦗E⦘ ⊆ co ∪ co⁻¹.","proofString":"rewrite (dom_r (wf_rmwD WF)).\nunfolder; ins; desf.\neapply (wf_co_total WF); [basic_solver| |].\nunfolder; ins; desf; splits; eauto.\napply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence.\nintro; subst.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (⦗E⦘ ⨾ ⦗W⦘ ⨾ rf) ⨾ (rmw ⨾ ⦗W⦘) ⨾ ⦗E⦘ ⊆ co ∪ co⁻¹.","proofString":"unfolder; ins; desf.\neapply (wf_co_total WF); [basic_solver| |].\nunfolder; ins; desf; splits; eauto.\napply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence.\nintro; subst.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H4 : is_w lab x) (z : actid) (H0 : rf x z) (H1 : rmw z y) (H2 : is_w lab y) (H3 : E y) : co x y \\/ co y x.","proofString":"eapply (wf_co_total WF); [basic_solver| |].\nunfolder; ins; desf; splits; eauto.\napply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence.\nintro; subst.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H4 : is_w lab x) (z : actid) (H0 : rf x z) (H1 : rmw z y) (H2 : is_w lab y) (H3 : E y) : (E ∩₁ W ∩₁ (fun x0 : actid => loc x0 = loc x)) y.","proofString":"unfolder; ins; desf; splits; eauto.\napply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H4 : is_w lab x) (z : actid) (H0 : rf x z) (H1 : rmw z y) (H2 : is_w lab y) (H3 : E y) : loc y = loc x.","proofString":"apply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H4 : is_w lab x) (z : actid) (H0 : same_loc x z) (H1 : rmw z y) (H2 : is_w lab y) (H3 : E y) : loc y = loc x.","proofString":"apply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H4 : is_w lab x) (z : actid) (H0 : same_loc x z) (H1 : same_loc z y) (H2 : is_w lab y) (H3 : E y) : loc y = loc x.","proofString":"unfold Events.same_loc in *; congruence."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : E x) (H4 : is_w lab x) (z : actid) (H0 : rf x z) (H1 : rmw z y) (H2 : is_w lab y) (H3 : E y) : x <> y.","proofString":"intro; subst.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (y : actid) (H4 : is_w lab y) (H : E y) (z : actid) (H0 : rf y z) (H1 : rmw z y) (H2 : is_w lab y) (H3 : E y) : False.","proofString":"eapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (rf ⨾ rmw) ∩ (rf ⨾ rmw) ⊆ co.","proofString":"rewrite rf_rmw_in_co_helper at 1; eauto.\nrewrite inter_union_l; unionL; [basic_solver|].\ntransitivity (fun _ _ : actid => False); [|basic_solver].\nunfolder; ins; desf.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply co_rf_in_eco; basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (co ∪ co⁻¹) ∩ (rf ⨾ rmw) ⊆ co.","proofString":"rewrite inter_union_l; unionL; [basic_solver|].\ntransitivity (fun _ _ : actid => False); [|basic_solver].\nunfolder; ins; desf.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply co_rf_in_eco; basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : co⁻¹ ∩ (rf ⨾ rmw) ⊆ co.","proofString":"transitivity (fun _ _ : actid => False); [|basic_solver].\nunfolder; ins; desf.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply co_rf_in_eco; basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : co⁻¹ ∩ (rf ⨾ rmw) ⊆ ∅₂.","proofString":"unfolder; ins; desf.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply co_rf_in_eco; basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (x y : actid) (H : co y x) (z : actid) (H0 : rf x z) (H1 : rmw z y) : False.","proofString":"eapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply co_rf_in_eco; basic_solver."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (ATOM : rmw_atomicity G) (x y : actid) (H : (rf ⨾ rmw) x y) : forall c : actid, co x c -> co c y -> False.","proofString":"ins; unfolder in *; desf.\neapply atomicity_alt; try done.\nunfold Execution.fr; basic_solver 10."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) (ATOM : rmw_atomicity G) (x y z : actid) (H : rf x z) (H0 : rmw z y) (c : actid) (R1 : co x c) (R2 : co c y) : False.","proofString":"eapply atomicity_alt; try done.\nunfold Execution.fr; basic_solver 10."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (co \\ sb) ⨾ co ∩ sb ⊆ co ⨾ co \\ sb -> coe ⨾ coi ⊆ coe.","proofString":"by rewrite (co_co WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (co \\ sb) ⨾ co ∩ sb ⊆ co ⨾ co \\ sb.","proofString":"apply re_ri; try done; try by apply no_co_to_init.\nby apply co_irr.\nrotate 1.\nby rewrite co_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive co.","proofString":"by apply co_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (co ⨾ sb).","proofString":"rotate 1.\nby rewrite co_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (sb ⨾ co).","proofString":"by rewrite co_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (fr \\ sb) ⨾ co ∩ sb ⊆ fr ⨾ co \\ sb -> fre ⨾ coi ⊆ fre.","proofString":"by rewrite (fr_co WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (fr \\ sb) ⨾ co ∩ sb ⊆ fr ⨾ co \\ sb.","proofString":"apply re_ri; try done; try by apply no_fr_to_init.\nby apply fr_irr.\nrotate 1.\nby rewrite fr_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive fr.","proofString":"by apply fr_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (fr ⨾ sb).","proofString":"rotate 1.\nby rewrite fr_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (sb ⨾ fr).","proofString":"by rewrite fr_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : ⦗fun x : actid => ~ is_init x⦘ ⨾ co ∩ sb ⨾ (co \\ sb) ⊆ co ⨾ co \\ sb ->\n⦗fun x : actid => ~ is_init x⦘ ⨾ coi ⨾ coe ⊆ coe.","proofString":"by rewrite (co_co WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : ⦗fun x : actid => ~ is_init x⦘ ⨾ co ∩ sb ⨾ (co \\ sb) ⊆ co ⨾ co \\ sb.","proofString":"apply ri_re; try done; try by apply no_co_to_init.\nby apply co_irr.\nrotate 1.\nby rewrite co_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive co.","proofString":"by apply co_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (co ⨾ sb).","proofString":"rotate 1.\nby rewrite co_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (sb ⨾ co).","proofString":"by rewrite co_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (rf \\ sb) ⨾ fr ∩ sb ⊆ rf ⨾ fr \\ sb -> rfe ⨾ fri ⊆ coe.","proofString":"by rewrite (rf_fr WF)."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : (rf \\ sb) ⨾ fr ∩ sb ⊆ rf ⨾ fr \\ sb.","proofString":"apply re_ri; try done; try by apply no_rf_to_init.\nby apply rf_irr.\nrotate 1.\nby rewrite rf_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive rf.","proofString":"by apply rf_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (rf ⨾ sb).","proofString":"rotate 1.\nby rewrite rf_in_eco."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : irreflexive (sb ⨾ rf).","proofString":"by rewrite rf_in_eco."},{"statement":"(rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?)^?\n⊆ (co ∪ fre)^? ⨾ rf^? ∪ fri ⨾ rfi^? ∪ fri ⨾ rfe.","proofString":"rewrite !(@fri_union_fre G).\nrewrite !(@rfi_union_rfe G).\nbasic_solver 12."},{"statement":"(rf ∪ co ⨾ rf^? ∪ (fri ∪ fre) ⨾ rf^?)^?\n⊆ (co ∪ fre)^? ⨾ rf^? ∪ fri ⨾ rfi^? ∪ fri ⨾ rfe.","proofString":"rewrite !(@rfi_union_rfe G).\nbasic_solver 12."},{"statement":"(rfi ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ (fri ∪ fre) ⨾ (rfi ∪ rfe)^?)^?\n⊆ (co ∪ fre)^? ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfi^? ∪ fri ⨾ rfe.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) : rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"rewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_frD WF)) at 1.\nrewrite !(@fri_union_fre G); relsf.\nunionL.\nrewrite !(@rfi_union_rfe G).\narewrite (rfi ⊆ sb) at 1.\nbasic_solver 12.\nbasic_solver 12.\nrewrite !(@rfi_union_rfe G).\ncase_refl (rfi ∪ rfe).\narewrite (fri ⊆ sb); basic_solver 12.\nrelsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"rewrite (dom_l (wf_frD WF)) at 1.\nrewrite !(@fri_union_fre G); relsf.\nunionL.\nrewrite !(@rfi_union_rfe G).\narewrite (rfi ⊆ sb) at 1.\nbasic_solver 12.\nbasic_solver 12.\nrewrite !(@rfi_union_rfe G).\ncase_refl (rfi ∪ rfe).\narewrite (fri ⊆ sb); basic_solver 12.\nrelsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ rf ∪ co ⨾ rf^? ∪ (⦗R⦘ ⨾ fr) ⨾ rf^?\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"rewrite !(@fri_union_fre G); relsf.\nunionL.\nrewrite !(@rfi_union_rfe G).\narewrite (rfi ⊆ sb) at 1.\nbasic_solver 12.\nbasic_solver 12.\nrewrite !(@rfi_union_rfe G).\ncase_refl (rfi ∪ rfe).\narewrite (fri ⊆ sb); basic_solver 12.\nrelsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ rf ∪ co ⨾ rf^? ∪ ((⦗R⦘ ⨾ fri) ⨾ rf^? ∪ (⦗R⦘ ⨾ fre) ⨾ rf^?)\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"unionL.\nrewrite !(@rfi_union_rfe G).\narewrite (rfi ⊆ sb) at 1.\nbasic_solver 12.\nbasic_solver 12.\nrewrite !(@rfi_union_rfe G).\ncase_refl (rfi ∪ rfe).\narewrite (fri ⊆ sb); basic_solver 12.\nrelsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ rf ⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"rewrite !(@rfi_union_rfe G).\narewrite (rfi ⊆ sb) at 1.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ (rfi ∪ rfe)\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"arewrite (rfi ⊆ sb) at 1.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ (sb ∪ rfe)\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) : co ⨾ rf^? ⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) : (⦗R⦘ ⨾ fri) ⨾ rf^? ⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"rewrite !(@rfi_union_rfe G).\ncase_refl (rfi ∪ rfe).\narewrite (fri ⊆ sb); basic_solver 12.\nrelsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12."},{"statement":"(WF : Wf G) : (⦗R⦘ ⨾ fri) ⨾ (rfi ∪ rfe)^?\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"case_refl (rfi ∪ rfe).\narewrite (fri ⊆ sb); basic_solver 12.\nrelsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗R⦘ ⨾ fri\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"arewrite (fri ⊆ sb); basic_solver 12."},{"statement":"(WF : Wf G) : ⦗R⦘ ⨾ fri ⨾ (rfi ∪ rfe)\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"relsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗R⦘ ⨾ fri ⨾ rfi\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"arewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗R⦘ ⨾ sb ⨾ sb\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"generalize (@sb_trans G).\nbasic_solver 12."},{"statement":"(WF : Wf G) : transitive sb ->\n⦗R⦘ ⨾ sb ⨾ sb\n⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ (rfi ∪ rfe)^? ∪ fre ⨾ (rfi ∪ rfe)^? ∪ fri ⨾ rfe.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) : (⦗R⦘ ⨾ fre) ⨾ rf^? ⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : ⦗W⦘ ⨾ co^? ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ co^?.","proofString":"rewrite (dom_r (wf_coD WF)).\narewrite (⦗W⦘ ⨾ (co ⨾ ⦗W⦘)^? ⊆ co^? ⨾ ⦗W⦘) by basic_solver.\nrewrite (w_sb_loc_w_in_coi WF SC_PER_LOC), (dom_r (wf_coiD WF)).\ngeneralize (co_trans WF); ie_unfolder; basic_solver 12."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : ⦗W⦘ ⨾ (co ⨾ ⦗W⦘)^? ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ (co ⨾ ⦗W⦘)^?.","proofString":"arewrite (⦗W⦘ ⨾ (co ⨾ ⦗W⦘)^? ⊆ co^? ⨾ ⦗W⦘) by basic_solver.\nrewrite (w_sb_loc_w_in_coi WF SC_PER_LOC), (dom_r (wf_coiD WF)).\ngeneralize (co_trans WF); ie_unfolder; basic_solver 12."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : co^? ⨾ ⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ (co ⨾ ⦗W⦘)^?.","proofString":"rewrite (w_sb_loc_w_in_coi WF SC_PER_LOC), (dom_r (wf_coiD WF)).\ngeneralize (co_trans WF); ie_unfolder; basic_solver 12."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc) : co^? ⨾ coi ⨾ ⦗W⦘ ⊆ (co ⨾ ⦗W⦘)^?.","proofString":"generalize (co_trans WF); ie_unfolder; basic_solver 12."}]}