{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Cop.v","fileSamples":[{"statement":"(f0 : meminj) (b : bool) : Val.inject f0 (Val.of_bool b) (Val.of_bool b).","proofString":"unfold Val.of_bool.\ndestruct b; [apply val_inject_vtrue|apply val_inject_vfalse]."},{"statement":"(f0 : meminj) (b : bool) : Val.inject f0 (if b then Vtrue else Vfalse) (if b then Vtrue else Vfalse).","proofString":"destruct b; [apply val_inject_vtrue|apply val_inject_vfalse]."},{"statement":"(n : ptrofs) : Val.inject f (Vptrofs n) (Vptrofs n).","proofString":"unfold Vptrofs.\ndestruct Archi.ptr64; auto."},{"statement":"(n : ptrofs) : Val.inject f\n  (if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n))\n  (if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n)).","proofString":"destruct Archi.ptr64; auto."},{"statement":"(ty1 ty : type) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : Val.inject f (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"econstructor; eauto."},{"statement":"(ty1 ty : type) (b1 : block) (ofs1 : ptrofs) (Heqb : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : exists tv : val,\n  (if\n    Mem.weak_valid_pointer m' b2\n      (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n   then Some Vone\n   else None) = Some tv /\\ Val.inject f Vone tv.","proofString":"erewrite weak_valid_pointer_inj by eauto.\nTrivialInject."},{"statement":"(ty1 ty : type) (b1 : block) (ofs1 : ptrofs) (Heqb : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : exists tv : val, Some Vone = Some tv /\\ Val.inject f Vone tv.","proofString":"TrivialInject."},{"statement":"(ty1 ty : type) (b1 : block) (ofs1 : ptrofs) (Heqb : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : exists tv : val,\n  (if\n    Mem.weak_valid_pointer m' b2\n      (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n   then Some Vone\n   else None) = Some tv /\\ Val.inject f Vone tv.","proofString":"erewrite weak_valid_pointer_inj by eauto.\nTrivialInject."},{"statement":"(ty1 ty : type) (b1 : block) (ofs1 : ptrofs) (Heqb : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : exists tv : val, Some Vone = Some tv /\\ Val.inject f Vone tv.","proofString":"TrivialInject."},{"statement":"(ty1 ty : type) (v : val) (id1 id2 : ident) (b1 : block) (ofs1 : ptrofs) (H : (if ident_eq id1 id2 then Some (Vptr b1 ofs1) else None) = Some v) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : exists tv : val,\n  (if ident_eq id1 id2\n   then Some (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n   else None) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (ident_eq id1 id2); TrivialInject.\neconstructor; eauto."},{"statement":"(ty1 ty : type) (id2 : ident) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : Val.inject f (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"econstructor; eauto."},{"statement":"(ty1 ty : type) (v : val) (id1 id2 : ident) (b1 : block) (ofs1 : ptrofs) (H : (if ident_eq id1 id2 then Some (Vptr b1 ofs1) else None) = Some v) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : exists tv : val,\n  (if ident_eq id1 id2\n   then Some (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n   else None) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (ident_eq id1 id2); TrivialInject.\neconstructor; eauto."},{"statement":"(ty1 ty : type) (id2 : ident) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : Val.inject f (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"econstructor; eauto."},{"statement":"(ty1 ty : type) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : Val.inject f (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"econstructor; eauto."},{"statement":"(v : val) (ty : type) (b : bool) (tv : val) (H : match classify_bool ty with\n| bool_case_i =>\n    match v with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match v with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match v with\n    | Vfloat f0 => Some (negb (Float.cmp Ceq f0 Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match v with\n    | Vsingle f0 => Some (negb (Float32.cmp Ceq f0 Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b) (H0 : Val.inject f v tv) : match classify_bool ty with\n| bool_case_i =>\n    match tv with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m' b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match tv with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m' b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match tv with\n    | Vfloat f0 => Some (negb (Float.cmp Ceq f0 Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match tv with\n    | Vsingle f0 => Some (negb (Float32.cmp Ceq f0 Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b.","proofString":"destruct (classify_bool ty); inv H0; try congruence.\ndestruct Archi.ptr64; try discriminate.\ndestruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)) eqn:VP; inv H.\nerewrite weak_valid_pointer_inj by eauto.\nauto.\ndestruct Archi.ptr64; try discriminate.\ndestruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)) eqn:VP; inv H.\nerewrite weak_valid_pointer_inj by eauto.\nauto."},{"statement":"(ty : type) (b : bool) (b1 : block) (ofs1 : ptrofs) (H : (if Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)\n  then Some true\n  else None) = Some b) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : (if Archi.ptr64\n then None\n else\n  if\n   Mem.weak_valid_pointer m' b2\n     (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  then Some true\n  else None) = Some b.","proofString":"destruct Archi.ptr64; try discriminate.\ndestruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)) eqn:VP; inv H.\nerewrite weak_valid_pointer_inj by eauto.\nauto."},{"statement":"(ty : type) (b : bool) (b1 : block) (ofs1 : ptrofs) (H : (if Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)\n then Some true\n else None) = Some b) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : (if\n  Mem.weak_valid_pointer m' b2\n    (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n then Some true\n else None) = Some b.","proofString":"destruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)) eqn:VP; inv H.\nerewrite weak_valid_pointer_inj by eauto.\nauto."},{"statement":"(ty : type) (b1 : block) (ofs1 : ptrofs) (VP : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : (if\n  Mem.weak_valid_pointer m' b2\n    (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n then Some true\n else None) = Some true.","proofString":"erewrite weak_valid_pointer_inj by eauto.\nauto."},{"statement":"(ty : type) (b1 : block) (ofs1 : ptrofs) (VP : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : Some true = Some true.","proofString":"auto."},{"statement":"(ty : type) (b : bool) (b1 : block) (ofs1 : ptrofs) (H : (if negb Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)\n  then Some true\n  else None) = Some b) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : (if negb Archi.ptr64\n then None\n else\n  if\n   Mem.weak_valid_pointer m' b2\n     (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  then Some true\n  else None) = Some b.","proofString":"destruct Archi.ptr64; try discriminate.\ndestruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)) eqn:VP; inv H.\nerewrite weak_valid_pointer_inj by eauto.\nauto."},{"statement":"(ty : type) (b : bool) (b1 : block) (ofs1 : ptrofs) (H : (if negb true\n then None\n else\n  if Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)\n  then Some true\n  else None) = Some b) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : (if negb true\n then None\n else\n  if\n   Mem.weak_valid_pointer m' b2\n     (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  then Some true\n  else None) = Some b.","proofString":"destruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)) eqn:VP; inv H.\nerewrite weak_valid_pointer_inj by eauto.\nauto."},{"statement":"(ty : type) (b1 : block) (ofs1 : ptrofs) (VP : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : (if negb true\n then None\n else\n  if\n   Mem.weak_valid_pointer m' b2\n     (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  then Some true\n  else None) = Some true.","proofString":"erewrite weak_valid_pointer_inj by eauto.\nauto."},{"statement":"(ty : type) (b1 : block) (ofs1 : ptrofs) (VP : Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) : (if negb true then None else Some true) = Some true.","proofString":"auto."},{"statement":"(op : unary_operation) (v1 : val) (ty : type) (v tv1 : val) (H : match op with\n| Onotbool => sem_notbool v1 ty m\n| Onotint => sem_notint v1 ty\n| Oneg => sem_neg v1 ty\n| Oabsfloat => sem_absfloat v1 ty\nend = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val,\n  match op with\n  | Onotbool => sem_notbool tv1 ty m'\n  | Onotint => sem_notint tv1 ty\n  | Oneg => sem_neg tv1 ty\n  | Oabsfloat => sem_absfloat tv1 ty\n  end = Some tv /\\ Val.inject f v tv.","proofString":"destruct op.\nunfold sem_notbool in *.\ndestruct (bool_val v1 ty m) as [b|] eqn:BV; simpl in H; inv H.\nerewrite bool_val_inj by eauto.\nsimpl.\nTrivialInject.\nunfold sem_notint in *; destruct (classify_notint ty); inv H0; inv H; TrivialInject.\nunfold sem_neg in *; destruct (classify_neg ty); inv H0; inv H; TrivialInject.\nunfold sem_absfloat in *; destruct (classify_neg ty); inv H0; inv H; TrivialInject."},{"statement":"(v1 : val) (ty : type) (v tv1 : val) (H : sem_notbool v1 ty m = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, sem_notbool tv1 ty m' = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_notbool in *.\ndestruct (bool_val v1 ty m) as [b|] eqn:BV; simpl in H; inv H.\nerewrite bool_val_inj by eauto.\nsimpl.\nTrivialInject."},{"statement":"(v1 : val) (ty : type) (v tv1 : val) (H : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty m) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val,\n  option_map (fun b : bool => Val.of_bool (negb b)) (bool_val tv1 ty m') =\n  Some tv /\\ Val.inject f v tv.","proofString":"destruct (bool_val v1 ty m) as [b|] eqn:BV; simpl in H; inv H.\nerewrite bool_val_inj by eauto.\nsimpl.\nTrivialInject."},{"statement":"(v1 : val) (ty : type) (tv1 : val) (b : bool) (BV : bool_val v1 ty m = Some b) (H0 : Val.inject f v1 tv1) : exists tv : val,\n  option_map (fun b0 : bool => Val.of_bool (negb b0)) (bool_val tv1 ty m') =\n  Some tv /\\ Val.inject f (Val.of_bool (negb b)) tv.","proofString":"erewrite bool_val_inj by eauto.\nsimpl.\nTrivialInject."},{"statement":"(v1 : val) (ty : type) (tv1 : val) (b : bool) (BV : bool_val v1 ty m = Some b) (H0 : Val.inject f v1 tv1) : exists tv : val,\n  option_map (fun b0 : bool => Val.of_bool (negb b0)) (Some b) = Some tv /\\\n  Val.inject f (Val.of_bool (negb b)) tv.","proofString":"simpl.\nTrivialInject."},{"statement":"(v1 : val) (ty : type) (tv1 : val) (b : bool) (BV : bool_val v1 ty m = Some b) (H0 : Val.inject f v1 tv1) : exists tv : val,\n  Some (Val.of_bool (negb b)) = Some tv /\\\n  Val.inject f (Val.of_bool (negb b)) tv.","proofString":"TrivialInject."},{"statement":"(v1 : val) (ty : type) (v tv1 : val) (H : sem_notint v1 ty = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, sem_notint tv1 ty = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_notint in *; destruct (classify_notint ty); inv H0; inv H; TrivialInject."},{"statement":"(v1 : val) (ty : type) (v tv1 : val) (H : sem_neg v1 ty = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, sem_neg tv1 ty = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_neg in *; destruct (classify_neg ty); inv H0; inv H; TrivialInject."},{"statement":"(v1 : val) (ty : type) (v tv1 : val) (H : sem_absfloat v1 ty = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, sem_absfloat tv1 ty = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_absfloat in *; destruct (classify_neg ty); inv H0; inv H; TrivialInject."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : sem_binarith sem_int sem_long sem_float sem_single v1 t1 v2 t2 m = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) : exists v' : val,\n  sem_binarith sem_int sem_long sem_float sem_single v1' t1 v2' t2 m' =\n  Some v' /\\ Val.inject f v v'.","proofString":"assert (SELF: forall ov v, ov = Some v -> optval_self_injects ov -> Val.inject f v v).\nintros.\nsubst ov; simpl in H7.\ndestruct v0; contradiction || constructor.\nunfold sem_binarith in *.\nset (c := classify_binarith t1 t2) in *.\nset (t := binarith_type c) in *.\ndestruct (sem_cast v1 t1 t m) as [w1|] eqn:C1; try discriminate.\ndestruct (sem_cast v2 t2 t m) as [w2|] eqn:C2; try discriminate.\nexploit (sem_cast_inj v1); eauto.\nintros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : sem_binarith sem_int sem_long sem_float sem_single v1 t1 v2 t2 m = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0.","proofString":"intros.\nsubst ov; simpl in H7.\ndestruct v0; contradiction || constructor."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : sem_binarith sem_int sem_long sem_float sem_single v1 t1 v2 t2 m = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (ov : option val) (v0 : val) (H6 : ov = Some v0) (H7 : optval_self_injects ov) : Val.inject f v0 v0.","proofString":"subst ov; simpl in H7.\ndestruct v0; contradiction || constructor."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : sem_binarith sem_int sem_long sem_float sem_single v1 t1 v2 t2 m = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (v0 : val) (H7 : match v0 with\n| Vptr _ _ => False\n| _ => True\nend) : Val.inject f v0 v0.","proofString":"destruct v0; contradiction || constructor."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : sem_binarith sem_int sem_long sem_float sem_single v1 t1 v2 t2 m = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) : exists v' : val,\n  sem_binarith sem_int sem_long sem_float sem_single v1' t1 v2' t2 m' =\n  Some v' /\\ Val.inject f v v'.","proofString":"unfold sem_binarith in *.\nset (c := classify_binarith t1 t2) in *.\nset (t := binarith_type c) in *.\ndestruct (sem_cast v1 t1 t m) as [w1|] eqn:C1; try discriminate.\ndestruct (sem_cast v2 t2 t m) as [w2|] eqn:C2; try discriminate.\nexploit (sem_cast_inj v1); eauto.\nintros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : match sem_cast v1 t1 (binarith_type (classify_binarith t1 t2)) m with\n| Some v1'0 =>\n    match sem_cast v2 t2 (binarith_type (classify_binarith t1 t2)) m with\n    | Some v2'0 =>\n        match classify_binarith t1 t2 with\n        | bin_case_i sg =>\n            match v1'0 with\n            | Vint n1 =>\n                match v2'0 with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1'0 with\n            | Vlong n1 =>\n                match v2'0 with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1'0 with\n            | Vfloat n1 =>\n                match v2'0 with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1'0 with\n            | Vsingle n1 =>\n                match v2'0 with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) : exists v' : val,\n  match sem_cast v1' t1 (binarith_type (classify_binarith t1 t2)) m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 (binarith_type (classify_binarith t1 t2)) m' with\n      | Some v2'0 =>\n          match classify_binarith t1 t2 with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"set (c := classify_binarith t1 t2) in *.\nset (t := binarith_type c) in *.\ndestruct (sem_cast v1 t1 t m) as [w1|] eqn:C1; try discriminate.\ndestruct (sem_cast v2 t2 t m) as [w2|] eqn:C2; try discriminate.\nexploit (sem_cast_inj v1); eauto.\nintros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (H : match sem_cast v1 t1 (binarith_type c) m with\n| Some v1'0 =>\n    match sem_cast v2 t2 (binarith_type c) m with\n    | Some v2'0 =>\n        match c with\n        | bin_case_i sg =>\n            match v1'0 with\n            | Vint n1 =>\n                match v2'0 with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1'0 with\n            | Vlong n1 =>\n                match v2'0 with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1'0 with\n            | Vfloat n1 =>\n                match v2'0 with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1'0 with\n            | Vsingle n1 =>\n                match v2'0 with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) : exists v' : val,\n  match sem_cast v1' t1 (binarith_type c) m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 (binarith_type c) m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"set (t := binarith_type c) in *.\ndestruct (sem_cast v1 t1 t m) as [w1|] eqn:C1; try discriminate.\ndestruct (sem_cast v2 t2 t m) as [w2|] eqn:C2; try discriminate.\nexploit (sem_cast_inj v1); eauto.\nintros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (H : match sem_cast v1 t1 t m with\n| Some v1'0 =>\n    match sem_cast v2 t2 t m with\n    | Some v2'0 =>\n        match c with\n        | bin_case_i sg =>\n            match v1'0 with\n            | Vint n1 =>\n                match v2'0 with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1'0 with\n            | Vlong n1 =>\n                match v2'0 with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1'0 with\n            | Vfloat n1 =>\n                match v2'0 with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1'0 with\n            | Vsingle n1 =>\n                match v2'0 with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) : exists v' : val,\n  match sem_cast v1' t1 t m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 t m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"destruct (sem_cast v1 t1 t m) as [w1|] eqn:C1; try discriminate.\ndestruct (sem_cast v2 t2 t m) as [w2|] eqn:C2; try discriminate.\nexploit (sem_cast_inj v1); eauto.\nintros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (w1 : val) (C1 : sem_cast v1 t1 t m = Some w1) (H : match sem_cast v2 t2 t m with\n| Some v2'0 =>\n    match c with\n    | bin_case_i sg =>\n        match w1 with\n        | Vint n1 =>\n            match v2'0 with\n            | Vint n2 => sem_int sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_l sg =>\n        match w1 with\n        | Vlong n1 =>\n            match v2'0 with\n            | Vlong n2 => sem_long sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_f =>\n        match w1 with\n        | Vfloat n1 =>\n            match v2'0 with\n            | Vfloat n2 => sem_float n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_s =>\n        match w1 with\n        | Vsingle n1 =>\n            match v2'0 with\n            | Vsingle n2 => sem_single n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_default => None\n    end\n| None => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) : exists v' : val,\n  match sem_cast v1' t1 t m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 t m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"destruct (sem_cast v2 t2 t m) as [w2|] eqn:C2; try discriminate.\nexploit (sem_cast_inj v1); eauto.\nintros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (w1 : val) (C1 : sem_cast v1 t1 t m = Some w1) (w2 : val) (C2 : sem_cast v2 t2 t m = Some w2) (H : match c with\n| bin_case_i sg =>\n    match w1 with\n    | Vint n1 => match w2 with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match w1 with\n    | Vlong n1 =>\n        match w2 with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match w1 with\n    | Vfloat n1 =>\n        match w2 with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match w1 with\n    | Vsingle n1 =>\n        match w2 with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) : exists v' : val,\n  match sem_cast v1' t1 t m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 t m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"exploit (sem_cast_inj v1); eauto.\nintros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (w1 : val) (C1 : sem_cast v1 t1 t m = Some w1) (w2 : val) (C2 : sem_cast v2 t2 t m = Some w2) (H : match c with\n| bin_case_i sg =>\n    match w1 with\n    | Vint n1 => match w2 with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match w1 with\n    | Vlong n1 =>\n        match w2 with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match w1 with\n    | Vfloat n1 =>\n        match w2 with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match w1 with\n    | Vsingle n1 =>\n        match w2 with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) : (exists tv : val, sem_cast v1' t1 t m' = Some tv /\\ Val.inject f w1 tv) ->\nexists v' : val,\n  match sem_cast v1' t1 t m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 t m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"intros (w1' & C1' & INJ1).\nexploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (w1 : val) (C1 : sem_cast v1 t1 t m = Some w1) (w2 : val) (C2 : sem_cast v2 t2 t m = Some w2) (H : match c with\n| bin_case_i sg =>\n    match w1 with\n    | Vint n1 => match w2 with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match w1 with\n    | Vlong n1 =>\n        match w2 with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match w1 with\n    | Vfloat n1 =>\n        match w2 with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match w1 with\n    | Vsingle n1 =>\n        match w2 with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) (w1' : val) (C1' : sem_cast v1' t1 t m' = Some w1') (INJ1 : Val.inject f w1 w1') : exists v' : val,\n  match sem_cast v1' t1 t m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 t m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"exploit (sem_cast_inj v2); eauto.\nintros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (w1 : val) (C1 : sem_cast v1 t1 t m = Some w1) (w2 : val) (C2 : sem_cast v2 t2 t m = Some w2) (H : match c with\n| bin_case_i sg =>\n    match w1 with\n    | Vint n1 => match w2 with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match w1 with\n    | Vlong n1 =>\n        match w2 with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match w1 with\n    | Vfloat n1 =>\n        match w2 with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match w1 with\n    | Vsingle n1 =>\n        match w2 with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) (w1' : val) (C1' : sem_cast v1' t1 t m' = Some w1') (INJ1 : Val.inject f w1 w1') : (exists tv : val, sem_cast v2' t2 t m' = Some tv /\\ Val.inject f w2 tv) ->\nexists v' : val,\n  match sem_cast v1' t1 t m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 t m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"intros (w2' & C2' & INJ2).\nrewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (w1 : val) (C1 : sem_cast v1 t1 t m = Some w1) (w2 : val) (C2 : sem_cast v2 t2 t m = Some w2) (H : match c with\n| bin_case_i sg =>\n    match w1 with\n    | Vint n1 => match w2 with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match w1 with\n    | Vlong n1 =>\n        match w2 with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match w1 with\n    | Vfloat n1 =>\n        match w2 with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match w1 with\n    | Vsingle n1 =>\n        match w2 with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) (w1' : val) (C1' : sem_cast v1' t1 t m' = Some w1') (INJ1 : Val.inject f w1 w1') (w2' : val) (C2' : sem_cast v2' t2 t m' = Some w2') (INJ2 : Val.inject f w2 w2') : exists v' : val,\n  match sem_cast v1' t1 t m' with\n  | Some v1'0 =>\n      match sem_cast v2' t2 t m' with\n      | Some v2'0 =>\n          match c with\n          | bin_case_i sg =>\n              match v1'0 with\n              | Vint n1 =>\n                  match v2'0 with\n                  | Vint n2 => sem_int sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_l sg =>\n              match v1'0 with\n              | Vlong n1 =>\n                  match v2'0 with\n                  | Vlong n2 => sem_long sg n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_f =>\n              match v1'0 with\n              | Vfloat n1 =>\n                  match v2'0 with\n                  | Vfloat n2 => sem_float n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_case_s =>\n              match v1'0 with\n              | Vsingle n1 =>\n                  match v2'0 with\n                  | Vsingle n2 => sem_single n1 n2\n                  | _ => None\n                  end\n              | _ => None\n              end\n          | bin_default => None\n          end\n      | None => None\n      end\n  | None => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"rewrite C1'; rewrite C2'.\ndestruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (c : binarith_cases) (t : type) (w1 : val) (C1 : sem_cast v1 t1 t m = Some w1) (w2 : val) (C2 : sem_cast v2 t2 t m = Some w2) (H : match c with\n| bin_case_i sg =>\n    match w1 with\n    | Vint n1 => match w2 with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match w1 with\n    | Vlong n1 =>\n        match w2 with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match w1 with\n    | Vfloat n1 =>\n        match w2 with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match w1 with\n    | Vsingle n1 =>\n        match w2 with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') (H2 : forall (sg : signedness) (n1 n2 : int),\noptval_self_injects (sem_int sg n1 n2)) (H3 : forall (sg : signedness) (n1 n2 : int64),\noptval_self_injects (sem_long sg n1 n2)) (H4 : forall n1 n2 : float, optval_self_injects (sem_float n1 n2)) (H5 : forall n1 n2 : float32, optval_self_injects (sem_single n1 n2)) (SELF : forall (ov : option val) (v0 : val),\nov = Some v0 -> optval_self_injects ov -> Val.inject f v0 v0) (w1' : val) (C1' : sem_cast v1' t1 t m' = Some w1') (INJ1 : Val.inject f w1 w1') (w2' : val) (C2' : sem_cast v2' t2 t m' = Some w2') (INJ2 : Val.inject f w2 w2') : exists v' : val,\n  match c with\n  | bin_case_i sg =>\n      match w1' with\n      | Vint n1 =>\n          match w2' with\n          | Vint n2 => sem_int sg n1 n2\n          | _ => None\n          end\n      | _ => None\n      end\n  | bin_case_l sg =>\n      match w1' with\n      | Vlong n1 =>\n          match w2' with\n          | Vlong n2 => sem_long sg n1 n2\n          | _ => None\n          end\n      | _ => None\n      end\n  | bin_case_f =>\n      match w1' with\n      | Vfloat n1 =>\n          match w2' with\n          | Vfloat n2 => sem_float n1 n2\n          | _ => None\n          end\n      | _ => None\n      end\n  | bin_case_s =>\n      match w1' with\n      | Vsingle n1 =>\n          match w2' with\n          | Vsingle n2 => sem_single n1 n2\n          | _ => None\n          end\n      | _ => None\n      end\n  | bin_default => None\n  end = Some v' /\\ Val.inject f v v'.","proofString":"destruct c; inv INJ1; inv INJ2; discriminate || eauto."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : sem_shift sem_int sem_long v1 t1 v2 t2 = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') : exists v' : val,\n  sem_shift sem_int sem_long v1' t1 v2' t2 = Some v' /\\ Val.inject f v v'.","proofString":"exists v.\nunfold sem_shift in *; destruct (classify_shift t1 t2); inv H0; inv H1; try discriminate.\ndestruct (Int.ltu i0 Int.iwordsize); inv H; auto.\ndestruct (Int64.ltu i0 Int64.iwordsize); inv H; auto.\ndestruct (Int64.ltu i0 (Int64.repr 32)); inv H; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); inv H; auto."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (v1 : val) (t1 : type) (v2 : val) (t2 : type) (v v1' v2' : val) (H : sem_shift sem_int sem_long v1 t1 v2 t2 = Some v) (H0 : Val.inject f v1 v1') (H1 : Val.inject f v2 v2') : sem_shift sem_int sem_long v1' t1 v2' t2 = Some v /\\ Val.inject f v v.","proofString":"unfold sem_shift in *; destruct (classify_shift t1 t2); inv H0; inv H1; try discriminate.\ndestruct (Int.ltu i0 Int.iwordsize); inv H; auto.\ndestruct (Int64.ltu i0 Int64.iwordsize); inv H; auto.\ndestruct (Int64.ltu i0 (Int64.repr 32)); inv H; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); inv H; auto."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (t1 t2 : type) (v : val) (s : signedness) (i i0 : int) (H : (if Int.ltu i0 Int.iwordsize then Some (Vint (sem_int s i i0)) else None) =\nSome v) : (if Int.ltu i0 Int.iwordsize then Some (Vint (sem_int s i i0)) else None) =\nSome v /\\ Val.inject f v v.","proofString":"destruct (Int.ltu i0 Int.iwordsize); inv H; auto."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (t1 t2 : type) (v : val) (s : signedness) (i i0 : int64) (H : (if Int64.ltu i0 Int64.iwordsize\n then Some (Vlong (sem_long s i i0))\n else None) = Some v) : (if Int64.ltu i0 Int64.iwordsize\n then Some (Vlong (sem_long s i i0))\n else None) = Some v /\\ Val.inject f v v.","proofString":"destruct (Int64.ltu i0 Int64.iwordsize); inv H; auto."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (t1 t2 : type) (v : val) (s : signedness) (i : int) (i0 : int64) (H : (if Int64.ltu i0 (Int64.repr 32)\n then Some (Vint (sem_int s i (Int64.loword i0)))\n else None) = Some v) : (if Int64.ltu i0 (Int64.repr 32)\n then Some (Vint (sem_int s i (Int64.loword i0)))\n else None) = Some v /\\ Val.inject f v v.","proofString":"destruct (Int64.ltu i0 (Int64.repr 32)); inv H; auto."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (t1 t2 : type) (v : val) (s : signedness) (i : int64) (i0 : int) (H : (if Int.ltu i0 Int64.iwordsize'\n then Some (Vlong (sem_long s i (Int64.repr (Int.unsigned i0))))\n else None) = Some v) : (if Int.ltu i0 Int64.iwordsize'\n then Some (Vlong (sem_long s i (Int64.repr (Int.unsigned i0))))\n else None) = Some v /\\ Val.inject f v v.","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); inv H; auto."},{"statement":"(c : comparison) (v1 v2 v tv1 tv2 : val) (H : option_map Val.of_bool\n  (if Archi.ptr64\n   then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n   else Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) = \nSome v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  option_map Val.of_bool\n    (if Archi.ptr64\n     then Val.cmplu_bool (Mem.valid_pointer m') c tv1 tv2\n     else Val.cmpu_bool (Mem.valid_pointer m') c tv1 tv2) = \n  Some tv /\\ Val.inject f v tv.","proofString":"remember (if Archi.ptr64       then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2       else Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) as ob.\ndestruct ob as [b|]; simpl in H; inv H.\nexists (Val.of_bool b); split; auto.\ndestruct Archi.ptr64.\nerewrite Val.cmplu_bool_inject by eauto.\nauto.\nerewrite Val.cmpu_bool_inject by eauto.\nauto."},{"statement":"(c : comparison) (v1 v2 v tv1 tv2 : val) (ob : option bool) (Heqob : ob =\n(if Archi.ptr64\n then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n else Val.cmpu_bool (Mem.valid_pointer m) c v1 v2)) (H : option_map Val.of_bool ob = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  option_map Val.of_bool\n    (if Archi.ptr64\n     then Val.cmplu_bool (Mem.valid_pointer m') c tv1 tv2\n     else Val.cmpu_bool (Mem.valid_pointer m') c tv1 tv2) = \n  Some tv /\\ Val.inject f v tv.","proofString":"destruct ob as [b|]; simpl in H; inv H.\nexists (Val.of_bool b); split; auto.\ndestruct Archi.ptr64.\nerewrite Val.cmplu_bool_inject by eauto.\nauto.\nerewrite Val.cmpu_bool_inject by eauto.\nauto."},{"statement":"(c : comparison) (v1 v2 tv1 tv2 : val) (b : bool) (Heqob : Some b =\n(if Archi.ptr64\n then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n else Val.cmpu_bool (Mem.valid_pointer m) c v1 v2)) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  option_map Val.of_bool\n    (if Archi.ptr64\n     then Val.cmplu_bool (Mem.valid_pointer m') c tv1 tv2\n     else Val.cmpu_bool (Mem.valid_pointer m') c tv1 tv2) = \n  Some tv /\\ Val.inject f (Val.of_bool b) tv.","proofString":"exists (Val.of_bool b); split; auto.\ndestruct Archi.ptr64.\nerewrite Val.cmplu_bool_inject by eauto.\nauto.\nerewrite Val.cmpu_bool_inject by eauto.\nauto."},{"statement":"(c : comparison) (v1 v2 tv1 tv2 : val) (b : bool) (Heqob : Some b =\n(if Archi.ptr64\n then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n else Val.cmpu_bool (Mem.valid_pointer m) c v1 v2)) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : option_map Val.of_bool\n  (if Archi.ptr64\n   then Val.cmplu_bool (Mem.valid_pointer m') c tv1 tv2\n   else Val.cmpu_bool (Mem.valid_pointer m') c tv1 tv2) =\nSome (Val.of_bool b).","proofString":"destruct Archi.ptr64.\nerewrite Val.cmplu_bool_inject by eauto.\nauto.\nerewrite Val.cmpu_bool_inject by eauto.\nauto."},{"statement":"(c : comparison) (v1 v2 tv1 tv2 : val) (b : bool) (Heqob : Some b = Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m') c tv1 tv2) =\nSome (Val.of_bool b).","proofString":"erewrite Val.cmplu_bool_inject by eauto.\nauto."},{"statement":"(c : comparison) (v1 v2 tv1 tv2 : val) (b : bool) (Heqob : Some b = Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : option_map Val.of_bool (Some b) = Some (Val.of_bool b).","proofString":"auto."},{"statement":"(c : comparison) (v1 v2 tv1 tv2 : val) (b : bool) (Heqob : Some b = Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m') c tv1 tv2) =\nSome (Val.of_bool b).","proofString":"erewrite Val.cmpu_bool_inject by eauto.\nauto."},{"statement":"(c : comparison) (v1 v2 tv1 tv2 : val) (b : bool) (Heqob : Some b = Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : option_map Val.of_bool (Some b) = Some (Val.of_bool b).","proofString":"auto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (H : sem_cmp cmp v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_cmp cmp tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_cmp in *; destruct (classify_cmp ty1 ty2).\neapply sem_cmp_ptr_inj; eauto.\ninversion H1; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto.\ninversion H0; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto.\ninversion H1; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto.\ninversion H0; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto.\nassert (SELF: forall b, optval_self_injects (Some (Val.of_bool b))).\ndestruct b; exact I.\neapply sem_binarith_inject; eauto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (H : cmp_ptr m cmp v1 v2 = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, cmp_ptr m' cmp tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cmp_ptr_inj; eauto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (si : signedness) (H : match v2 with\n| Vint n2 => cmp_ptr m cmp v1 (Vptrofs (ptrofs_of_int si n2))\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp v1 v2\n| _ => None\nend = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  match tv2 with\n  | Vint n2 => cmp_ptr m' cmp tv1 (Vptrofs (ptrofs_of_int si n2))\n  | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m' cmp tv1 tv2\n  | _ => None\n  end = Some tv /\\ Val.inject f v tv.","proofString":"inversion H1; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (si : signedness) (H : match v1 with\n| Vint n1 => cmp_ptr m cmp (Vptrofs (ptrofs_of_int si n1)) v2\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp v1 v2\n| _ => None\nend = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  match tv1 with\n  | Vint n1 => cmp_ptr m' cmp (Vptrofs (ptrofs_of_int si n1)) tv2\n  | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m' cmp tv1 tv2\n  | _ => None\n  end = Some tv /\\ Val.inject f v tv.","proofString":"inversion H0; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (H : match v2 with\n| Vlong n2 => cmp_ptr m cmp v1 (Vptrofs (Ptrofs.of_int64 n2))\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp v1 v2 else None\n| _ => None\nend = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  match tv2 with\n  | Vlong n2 => cmp_ptr m' cmp tv1 (Vptrofs (Ptrofs.of_int64 n2))\n  | Vptr _ _ => if Archi.ptr64 then cmp_ptr m' cmp tv1 tv2 else None\n  | _ => None\n  end = Some tv /\\ Val.inject f v tv.","proofString":"inversion H1; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (H : match v1 with\n| Vlong n1 => cmp_ptr m cmp (Vptrofs (Ptrofs.of_int64 n1)) v2\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp v1 v2 else None\n| _ => None\nend = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  match tv1 with\n  | Vlong n1 => cmp_ptr m' cmp (Vptrofs (Ptrofs.of_int64 n1)) tv2\n  | Vptr _ _ => if Archi.ptr64 then cmp_ptr m' cmp tv1 tv2 else None\n  | _ => None\n  end = Some tv /\\ Val.inject f v tv.","proofString":"inversion H0; subst; TrivialInject; eapply sem_cmp_ptr_inj; eauto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (H : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int.cmp cmp n1 n2\n        | Unsigned => Int.cmpu cmp n1 n2\n        end))\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int64.cmp cmp n1 n2\n        | Unsigned => Int64.cmpu cmp n1 n2\n        end)) (fun n1 n2 : float => Some (Val.of_bool (Float.cmp cmp n1 n2)))\n  (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp cmp n1 n2))) v1 ty1\n  v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_binarith\n    (fun (sg : signedness) (n1 n2 : int) =>\n     Some\n       (Val.of_bool\n          match sg with\n          | Signed => Int.cmp cmp n1 n2\n          | Unsigned => Int.cmpu cmp n1 n2\n          end))\n    (fun (sg : signedness) (n1 n2 : int64) =>\n     Some\n       (Val.of_bool\n          match sg with\n          | Signed => Int64.cmp cmp n1 n2\n          | Unsigned => Int64.cmpu cmp n1 n2\n          end))\n    (fun n1 n2 : float => Some (Val.of_bool (Float.cmp cmp n1 n2)))\n    (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp cmp n1 n2))) tv1\n    ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"assert (SELF: forall b, optval_self_injects (Some (Val.of_bool b))).\ndestruct b; exact I.\neapply sem_binarith_inject; eauto."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (H : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int.cmp cmp n1 n2\n        | Unsigned => Int.cmpu cmp n1 n2\n        end))\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int64.cmp cmp n1 n2\n        | Unsigned => Int64.cmpu cmp n1 n2\n        end)) (fun n1 n2 : float => Some (Val.of_bool (Float.cmp cmp n1 n2)))\n  (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp cmp n1 n2))) v1 ty1\n  v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : forall b : bool, optval_self_injects (Some (Val.of_bool b)).","proofString":"destruct b; exact I."},{"statement":"(cmp : comparison) (v1 tv1 : val) (ty1 : type) (v2 tv2 : val) (ty2 : type) (v : val) (H : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int.cmp cmp n1 n2\n        | Unsigned => Int.cmpu cmp n1 n2\n        end))\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int64.cmp cmp n1 n2\n        | Unsigned => Int64.cmpu cmp n1 n2\n        end)) (fun n1 n2 : float => Some (Val.of_bool (Float.cmp cmp n1 n2)))\n  (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp cmp n1 n2))) v1 ty1\n  v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (SELF : forall b : bool, optval_self_injects (Some (Val.of_bool b))) : exists tv : val,\n  sem_binarith\n    (fun (sg : signedness) (n1 n2 : int) =>\n     Some\n       (Val.of_bool\n          match sg with\n          | Signed => Int.cmp cmp n1 n2\n          | Unsigned => Int.cmpu cmp n1 n2\n          end))\n    (fun (sg : signedness) (n1 n2 : int64) =>\n     Some\n       (Val.of_bool\n          match sg with\n          | Signed => Int64.cmp cmp n1 n2\n          | Unsigned => Int64.cmpu cmp n1 n2\n          end))\n    (fun n1 n2 : float => Some (Val.of_bool (Float.cmp cmp n1 n2)))\n    (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp cmp n1 n2))) tv1\n    ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_add cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_add cenv tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"assert (A: forall cenv ty si v1' v2' tv1' tv2',             Val.inject f v1' tv1' -> Val.inject f v2' tv2' ->             sem_add_ptr_int cenv ty si v1' v2' = Some v ->             exists tv, sem_add_ptr_int cenv ty si tv1' tv2' = Some tv /\\ Val.inject f v tv).\nintros.\nunfold sem_add_ptr_int in *; inv H2; inv H3; TrivialInject.\neconstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\nassert (B: forall cenv ty v1' v2' tv1' tv2',             Val.inject f v1' tv1' -> Val.inject f v2' tv2' ->             sem_add_ptr_long cenv ty v1' v2' = Some v ->             exists tv, sem_add_ptr_long cenv ty tv1' tv2' = Some tv /\\ Val.inject f v tv).\nintros.\nunfold sem_add_ptr_long in *; inv H2; inv H3; TrivialInject.\neconstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\nunfold sem_add in *; destruct (classify_add ty1 ty2); eauto.\neapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_add cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : forall (cenv0 : composite_env) (ty : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv0 ty si v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_int cenv0 ty si tv1' tv2' = Some tv /\\ Val.inject f v tv.","proofString":"intros.\nunfold sem_add_ptr_int in *; inv H2; inv H3; TrivialInject.\neconstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_add cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (cenv0 : composite_env) (ty : type) (si : signedness) (v1' v2' tv1' tv2' : val) (H2 : Val.inject f v1' tv1') (H3 : Val.inject f v2' tv2') (H4 : sem_add_ptr_int cenv0 ty si v1' v2' = Some v) : exists tv : val,\n  sem_add_ptr_int cenv0 ty si tv1' tv2' = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_add_ptr_int in *; inv H2; inv H3; TrivialInject.\neconstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (tv1 tv2 : val) (cenv0 : composite_env) (ty : type) (si : signedness) (b1 : block) (ofs1 : ptrofs) (i : int) (H : sem_add cenv v1 ty1 v2 ty2 m =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i))))) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (b2 : block) (delta : Z) (H5 : f b1 = Some (b2, delta)) : Val.inject f\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i))))\n  (Vptr b2\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta))\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i)))).","proofString":"econstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (tv1 tv2 : val) (cenv0 : composite_env) (ty : type) (si : signedness) (b1 : block) (ofs1 : ptrofs) (i : int) (H : sem_add cenv v1 ty1 v2 ty2 m =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i))))) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (b2 : block) (delta : Z) (H5 : f b1 = Some (b2, delta)) : Ptrofs.add ofs1\n  (Ptrofs.add (Ptrofs.repr delta)\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i))) =\nPtrofs.add ofs1\n  (Ptrofs.add\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i))\n     (Ptrofs.repr delta)).","proofString":"decEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (tv1 tv2 : val) (cenv0 : composite_env) (ty : type) (si : signedness) (b1 : block) (ofs1 : ptrofs) (i : int) (H : sem_add cenv v1 ty1 v2 ty2 m =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i))))) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (b2 : block) (delta : Z) (H5 : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.repr delta)\n  (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i)) =\nPtrofs.add (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (ptrofs_of_int si i))\n  (Ptrofs.repr delta).","proofString":"apply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_add cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv0 : composite_env) (ty : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv0 ty si v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_int cenv0 ty si tv1' tv2' = Some tv /\\ Val.inject f v tv) : exists tv : val,\n  sem_add cenv tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"assert (B: forall cenv ty v1' v2' tv1' tv2',             Val.inject f v1' tv1' -> Val.inject f v2' tv2' ->             sem_add_ptr_long cenv ty v1' v2' = Some v ->             exists tv, sem_add_ptr_long cenv ty tv1' tv2' = Some tv /\\ Val.inject f v tv).\nintros.\nunfold sem_add_ptr_long in *; inv H2; inv H3; TrivialInject.\neconstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\nunfold sem_add in *; destruct (classify_add ty1 ty2); eauto.\neapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_add cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv0 : composite_env) (ty : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv0 ty si v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_int cenv0 ty si tv1' tv2' = Some tv /\\ Val.inject f v tv) : forall (cenv0 : composite_env) (ty : type) (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_long cenv0 ty v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_long cenv0 ty tv1' tv2' = Some tv /\\ Val.inject f v tv.","proofString":"intros.\nunfold sem_add_ptr_long in *; inv H2; inv H3; TrivialInject.\neconstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_add cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv1 : composite_env) (ty0 : type) (si : signedness)\n  (v1'0 v2'0 tv1'0 tv2'0 : val),\nVal.inject f v1'0 tv1'0 ->\nVal.inject f v2'0 tv2'0 ->\nsem_add_ptr_int cenv1 ty0 si v1'0 v2'0 = Some v ->\nexists tv : val,\n  sem_add_ptr_int cenv1 ty0 si tv1'0 tv2'0 = Some tv /\\ Val.inject f v tv) (cenv0 : composite_env) (ty : type) (v1' v2' tv1' tv2' : val) (H2 : Val.inject f v1' tv1') (H3 : Val.inject f v2' tv2') (H4 : sem_add_ptr_long cenv0 ty v1' v2' = Some v) : exists tv : val,\n  sem_add_ptr_long cenv0 ty tv1' tv2' = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_add_ptr_long in *; inv H2; inv H3; TrivialInject.\neconstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (tv1 tv2 : val) (cenv0 : composite_env) (ty : type) (b1 : block) (ofs1 : ptrofs) (i : int64) (H : sem_add cenv v1 ty1 v2 ty2 m =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))))) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv1 : composite_env) (ty0 : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv1 ty0 si v1' v2' =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i)))) ->\nexists tv : val,\n  sem_add_ptr_int cenv1 ty0 si tv1' tv2' = Some tv /\\\n  Val.inject f\n    (Vptr b1\n       (Ptrofs.add ofs1\n          (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))))\n    tv) (b2 : block) (delta : Z) (H5 : f b1 = Some (b2, delta)) : Val.inject f\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))))\n  (Vptr b2\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta))\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i)))).","proofString":"econstructor.\neauto.\nrepeat rewrite Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (tv1 tv2 : val) (cenv0 : composite_env) (ty : type) (b1 : block) (ofs1 : ptrofs) (i : int64) (H : sem_add cenv v1 ty1 v2 ty2 m =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))))) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv1 : composite_env) (ty0 : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv1 ty0 si v1' v2' =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i)))) ->\nexists tv : val,\n  sem_add_ptr_int cenv1 ty0 si tv1' tv2' = Some tv /\\\n  Val.inject f\n    (Vptr b1\n       (Ptrofs.add ofs1\n          (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))))\n    tv) (b2 : block) (delta : Z) (H5 : f b1 = Some (b2, delta)) : Ptrofs.add ofs1\n  (Ptrofs.add (Ptrofs.repr delta)\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))) =\nPtrofs.add ofs1\n  (Ptrofs.add\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))\n     (Ptrofs.repr delta)).","proofString":"decEq.\napply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (tv1 tv2 : val) (cenv0 : composite_env) (ty : type) (b1 : block) (ofs1 : ptrofs) (i : int64) (H : sem_add cenv v1 ty1 v2 ty2 m =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))))) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv1 : composite_env) (ty0 : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv1 ty0 si v1' v2' =\nSome\n  (Vptr b1\n     (Ptrofs.add ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i)))) ->\nexists tv : val,\n  sem_add_ptr_int cenv1 ty0 si tv1' tv2' = Some tv /\\\n  Val.inject f\n    (Vptr b1\n       (Ptrofs.add ofs1\n          (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))))\n    tv) (b2 : block) (delta : Z) (H5 : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.repr delta)\n  (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i)) =\nPtrofs.add (Ptrofs.mul (Ptrofs.repr (sizeof cenv0 ty)) (Ptrofs.of_int64 i))\n  (Ptrofs.repr delta).","proofString":"apply Ptrofs.add_commut."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_add cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv0 : composite_env) (ty : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv0 ty si v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_int cenv0 ty si tv1' tv2' = Some tv /\\ Val.inject f v tv) (B : forall (cenv0 : composite_env) (ty : type) (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_long cenv0 ty v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_long cenv0 ty tv1' tv2' = Some tv /\\ Val.inject f v tv) : exists tv : val,\n  sem_add cenv tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_add in *; destruct (classify_add ty1 ty2); eauto.\neapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.add n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.add n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.add n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.add n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (A : forall (cenv0 : composite_env) (ty : type) (si : signedness)\n  (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_int cenv0 ty si v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_int cenv0 ty si tv1' tv2' = Some tv /\\ Val.inject f v tv) (B : forall (cenv0 : composite_env) (ty : type) (v1' v2' tv1' tv2' : val),\nVal.inject f v1' tv1' ->\nVal.inject f v2' tv2' ->\nsem_add_ptr_long cenv0 ty v1' v2' = Some v ->\nexists tv : val,\n  sem_add_ptr_long cenv0 ty tv1' tv2' = Some tv /\\ Val.inject f v tv) : exists tv : val,\n  sem_binarith\n    (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.add n1 n2)))\n    (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.add n1 n2)))\n    (fun n1 n2 : float => Some (Vfloat (Float.add n1 n2)))\n    (fun n1 n2 : float32 => Some (Vsingle (Float32.add n1 n2))) tv1 ty1 tv2\n    ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_sub cenv v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_sub cenv tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"unfold sem_sub in *; destruct (classify_sub ty1 ty2).\ninv H0; inv H1; TrivialInject.\neconstructor.\neauto.\nrewrite Ptrofs.sub_add_l.\nauto.\ninv H0; inv H1; TrivialInject.\ndestruct (eq_block b1 b0); try discriminate.\nsubst b1.\nrewrite H0 in H2; inv H2.\nrewrite dec_eq_true.\ndestruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.\nrewrite Ptrofs.sub_shifted.\nTrivialInject.\ninv H0; inv H1; TrivialInject.\neconstructor.\neauto.\nrewrite Ptrofs.sub_add_l.\nauto.\neapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (ty : type) (si : signedness) (H : match v1 with\n| Vint n1 =>\n    match v2 with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some (Vint (Int.sub n1 (Int.mul (Int.repr (sizeof cenv ty)) n2)))\n    | _ => None\n    end\n| Vlong n1 =>\n    match v2 with\n    | Vint n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.sub n1\n                 (Int64.mul (Int64.repr (sizeof cenv ty))\n                    (cast_int_long si n2))))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2 with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  match tv1 with\n  | Vint n1 =>\n      match tv2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then None\n          else\n           Some (Vint (Int.sub n1 (Int.mul (Int.repr (sizeof cenv ty)) n2)))\n      | _ => None\n      end\n  | Vlong n1 =>\n      match tv2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then\n           Some\n             (Vlong\n                (Int64.sub n1\n                   (Int64.mul (Int64.repr (sizeof cenv ty))\n                      (cast_int_long si n2))))\n          else None\n      | _ => None\n      end\n  | Vptr b1 ofs1 =>\n      match tv2 with\n      | Vint n2 =>\n          Some\n            (Vptr b1\n               (Ptrofs.sub ofs1\n                  (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty))\n                     (ptrofs_of_int si n2))))\n      | _ => None\n      end\n  | _ => None\n  end = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; inv H1; TrivialInject.\neconstructor.\neauto.\nrewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(cenv : composite_env) (ty1 ty2 ty : type) (si : signedness) (b1 : block) (ofs1 : ptrofs) (i : int) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : Val.inject f\n  (Vptr b1\n     (Ptrofs.sub ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (ptrofs_of_int si i))))\n  (Vptr b2\n     (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (ptrofs_of_int si i)))).","proofString":"econstructor.\neauto.\nrewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(cenv : composite_env) (ty1 ty2 ty : type) (si : signedness) (b1 : block) (ofs1 : ptrofs) (i : int) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : Ptrofs.add\n  (Ptrofs.sub ofs1\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (ptrofs_of_int si i)))\n  (Ptrofs.repr delta) =\nPtrofs.add\n  (Ptrofs.sub ofs1\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (ptrofs_of_int si i)))\n  (Ptrofs.repr delta).","proofString":"auto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (ty : type) (H : match v1 with\n| Vptr b1 ofs1 =>\n    match v2 with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs\n               (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                  (Ptrofs.repr (sizeof cenv ty))))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  match tv1 with\n  | Vptr b1 ofs1 =>\n      match tv2 with\n      | Vptr b2 ofs2 =>\n          if eq_block b1 b2\n          then\n           if\n            zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n           then\n            Some\n              (Vptrofs\n                 (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                    (Ptrofs.repr (sizeof cenv ty))))\n           else None\n          else None\n      | _ => None\n      end\n  | _ => None\n  end = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; inv H1; TrivialInject.\ndestruct (eq_block b1 b0); try discriminate.\nsubst b1.\nrewrite H0 in H2; inv H2.\nrewrite dec_eq_true.\ndestruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.\nrewrite Ptrofs.sub_shifted.\nTrivialInject."},{"statement":"(cenv : composite_env) (ty1 ty2 : type) (v : val) (ty : type) (b1 : block) (ofs1 : ptrofs) (b0 : block) (ofs0 : ptrofs) (H : (if eq_block b1 b0\n then\n  if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n  then\n   Some\n     (Vptrofs\n        (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty))))\n  else None\n else None) = Some v) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H0 : f b0 = Some (b3, delta0)) : exists tv : val,\n  (if eq_block b2 b3\n   then\n    if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n    then\n     Some\n       (Vptrofs\n          (Ptrofs.divs\n             (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n                (Ptrofs.add ofs0 (Ptrofs.repr delta0)))\n             (Ptrofs.repr (sizeof cenv ty))))\n    else None\n   else None) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (eq_block b1 b0); try discriminate.\nsubst b1.\nrewrite H0 in H2; inv H2.\nrewrite dec_eq_true.\ndestruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.\nrewrite Ptrofs.sub_shifted.\nTrivialInject."},{"statement":"(cenv : composite_env) (ty1 ty2 : type) (v : val) (ty : type) (b1 : block) (ofs1 : ptrofs) (b0 : block) (ofs0 : ptrofs) (e : b1 = b0) (H : (if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n then\n  Some\n    (Vptrofs\n       (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty))))\n else None) = Some v) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H0 : f b0 = Some (b3, delta0)) : exists tv : val,\n  (if eq_block b2 b3\n   then\n    if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n    then\n     Some\n       (Vptrofs\n          (Ptrofs.divs\n             (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n                (Ptrofs.add ofs0 (Ptrofs.repr delta0)))\n             (Ptrofs.repr (sizeof cenv ty))))\n    else None\n   else None) = Some tv /\\ Val.inject f v tv.","proofString":"subst b1.\nrewrite H0 in H2; inv H2.\nrewrite dec_eq_true.\ndestruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.\nrewrite Ptrofs.sub_shifted.\nTrivialInject."},{"statement":"(cenv : composite_env) (ty1 ty2 : type) (v : val) (ty : type) (ofs1 : ptrofs) (b0 : block) (ofs0 : ptrofs) (H : (if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n then\n  Some\n    (Vptrofs\n       (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty))))\n else None) = Some v) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H0 : f b0 = Some (b3, delta0)) : exists tv : val,\n  (if eq_block b2 b3\n   then\n    if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n    then\n     Some\n       (Vptrofs\n          (Ptrofs.divs\n             (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n                (Ptrofs.add ofs0 (Ptrofs.repr delta0)))\n             (Ptrofs.repr (sizeof cenv ty))))\n    else None\n   else None) = Some tv /\\ Val.inject f v tv.","proofString":"rewrite H0 in H2; inv H2.\nrewrite dec_eq_true.\ndestruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.\nrewrite Ptrofs.sub_shifted.\nTrivialInject."},{"statement":"(cenv : composite_env) (ty1 ty2 : type) (v : val) (ty : type) (ofs1 : ptrofs) (b0 : block) (ofs0 : ptrofs) (H : (if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n then\n  Some\n    (Vptrofs\n       (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty))))\n else None) = Some v) (b2 : block) (delta : Z) (H0 : f b0 = Some (b2, delta)) : exists tv : val,\n  (if eq_block b2 b2\n   then\n    if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n    then\n     Some\n       (Vptrofs\n          (Ptrofs.divs\n             (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n                (Ptrofs.add ofs0 (Ptrofs.repr delta)))\n             (Ptrofs.repr (sizeof cenv ty))))\n    else None\n   else None) = Some tv /\\ Val.inject f v tv.","proofString":"rewrite dec_eq_true.\ndestruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.\nrewrite Ptrofs.sub_shifted.\nTrivialInject."},{"statement":"(cenv : composite_env) (ty1 ty2 : type) (v : val) (ty : type) (ofs1 : ptrofs) (b0 : block) (ofs0 : ptrofs) (H : (if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n then\n  Some\n    (Vptrofs\n       (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty))))\n else None) = Some v) (b2 : block) (delta : Z) (H0 : f b0 = Some (b2, delta)) : exists tv : val,\n  (if zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed\n   then\n    Some\n      (Vptrofs\n         (Ptrofs.divs\n            (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n               (Ptrofs.add ofs0 (Ptrofs.repr delta)))\n            (Ptrofs.repr (sizeof cenv ty))))\n   else None) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.\nrewrite Ptrofs.sub_shifted.\nTrivialInject."},{"statement":"(cenv : composite_env) (ty1 ty2 ty : type) (ofs1 : ptrofs) (b0 : block) (ofs0 : ptrofs) (b2 : block) (delta : Z) (H0 : f b0 = Some (b2, delta)) : exists tv : val,\n  Some\n    (Vptrofs\n       (Ptrofs.divs\n          (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n             (Ptrofs.add ofs0 (Ptrofs.repr delta)))\n          (Ptrofs.repr (sizeof cenv ty)))) = Some tv /\\\n  Val.inject f\n    (Vptrofs\n       (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty))))\n    tv.","proofString":"rewrite Ptrofs.sub_shifted.\nTrivialInject."},{"statement":"(cenv : composite_env) (ty1 ty2 ty : type) (ofs1 : ptrofs) (b0 : block) (ofs0 : ptrofs) (b2 : block) (delta : Z) (H0 : f b0 = Some (b2, delta)) : exists tv : val,\n  Some\n    (Vptrofs\n       (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty)))) =\n  Some tv /\\\n  Val.inject f\n    (Vptrofs\n       (Ptrofs.divs (Ptrofs.sub ofs1 ofs0) (Ptrofs.repr (sizeof cenv ty))))\n    tv.","proofString":"TrivialInject."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (ty : type) (H : match v1 with\n| Vint n1 =>\n    match v2 with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.sub n1\n                 (Int.mul (Int.repr (sizeof cenv ty))\n                    (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong n1 =>\n    match v2 with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong (Int64.sub n1 (Int64.mul (Int64.repr (sizeof cenv ty)) n2)))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2 with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  match tv1 with\n  | Vint n1 =>\n      match tv2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then None\n          else\n           Some\n             (Vint\n                (Int.sub n1\n                   (Int.mul (Int.repr (sizeof cenv ty))\n                      (Int.repr (Int64.unsigned n2)))))\n      | _ => None\n      end\n  | Vlong n1 =>\n      match tv2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then\n           Some\n             (Vlong\n                (Int64.sub n1 (Int64.mul (Int64.repr (sizeof cenv ty)) n2)))\n          else None\n      | _ => None\n      end\n  | Vptr b1 ofs1 =>\n      match tv2 with\n      | Vlong n2 =>\n          Some\n            (Vptr b1\n               (Ptrofs.sub ofs1\n                  (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty))\n                     (Ptrofs.of_int64 n2))))\n      | _ => None\n      end\n  | _ => None\n  end = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; inv H1; TrivialInject.\neconstructor.\neauto.\nrewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(cenv : composite_env) (ty1 ty2 ty : type) (b1 : block) (ofs1 : ptrofs) (i : int64) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : Val.inject f\n  (Vptr b1\n     (Ptrofs.sub ofs1\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (Ptrofs.of_int64 i))))\n  (Vptr b2\n     (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n        (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (Ptrofs.of_int64 i)))).","proofString":"econstructor.\neauto.\nrewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(cenv : composite_env) (ty1 ty2 ty : type) (b1 : block) (ofs1 : ptrofs) (i : int64) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : Ptrofs.add\n  (Ptrofs.sub ofs1\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (Ptrofs.of_int64 i)))\n  (Ptrofs.repr delta) =\nPtrofs.add\n  (Ptrofs.sub ofs1\n     (Ptrofs.mul (Ptrofs.repr (sizeof cenv ty)) (Ptrofs.of_int64 i)))\n  (Ptrofs.repr delta).","proofString":"auto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.sub n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.sub n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.sub n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.sub n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_binarith\n    (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.sub n1 n2)))\n    (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.sub n1 n2)))\n    (fun n1 n2 : float => Some (Vfloat (Float.sub n1 n2)))\n    (fun n1 n2 : float32 => Some (Vsingle (Float32.sub n1 n2))) tv1 ty1 tv2\n    ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mul v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_mul tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_div tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros.\ndestruct sg.\ndestruct (Int.eq n2 Int.zero            || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); exact I.\ndestruct (Int.eq n2 Int.zero); exact I.\ndestruct sg.\ndestruct (Int64.eq n2 Int64.zero            || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); exact I.\ndestruct (Int64.eq n2 Int64.zero); exact I.\nexact I.\nexact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (sg : signedness) (n1 n2 : int) : optval_self_injects\n  match sg with\n  | Signed =>\n      if\n       Int.eq n2 Int.zero\n       || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n      then None\n      else Some (Vint (Int.divs n1 n2))\n  | Unsigned =>\n      if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))\n  end.","proofString":"destruct sg.\ndestruct (Int.eq n2 Int.zero            || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); exact I.\ndestruct (Int.eq n2 Int.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int) : optval_self_injects\n  (if\n    Int.eq n2 Int.zero\n    || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n   then None\n   else Some (Vint (Int.divs n1 n2))).","proofString":"destruct (Int.eq n2 Int.zero            || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int) : optval_self_injects\n  (if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))).","proofString":"destruct (Int.eq n2 Int.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (sg : signedness) (n1 n2 : int64) : optval_self_injects\n  match sg with\n  | Signed =>\n      if\n       Int64.eq n2 Int64.zero\n       || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n      then None\n      else Some (Vlong (Int64.divs n1 n2))\n  | Unsigned =>\n      if Int64.eq n2 Int64.zero\n      then None\n      else Some (Vlong (Int64.divu n1 n2))\n  end.","proofString":"destruct sg.\ndestruct (Int64.eq n2 Int64.zero            || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); exact I.\ndestruct (Int64.eq n2 Int64.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int64) : optval_self_injects\n  (if\n    Int64.eq n2 Int64.zero\n    || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs n1 n2))).","proofString":"destruct (Int64.eq n2 Int64.zero            || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int64) : optval_self_injects\n  (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.divu n1 n2))).","proofString":"destruct (Int64.eq n2 Int64.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : float) : optval_self_injects (Some (Vfloat (Float.div n1 n2))).","proofString":"exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_div v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : float32) : optval_self_injects (Some (Vsingle (Float32.div n1 n2))).","proofString":"exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_mod tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros.\ndestruct sg.\ndestruct (Int.eq n2 Int.zero            || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); exact I.\ndestruct (Int.eq n2 Int.zero); exact I.\ndestruct sg.\ndestruct (Int64.eq n2 Int64.zero            || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); exact I.\ndestruct (Int64.eq n2 Int64.zero); exact I.\nexact I.\nexact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (sg : signedness) (n1 n2 : int) : optval_self_injects\n  match sg with\n  | Signed =>\n      if\n       Int.eq n2 Int.zero\n       || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n      then None\n      else Some (Vint (Int.mods n1 n2))\n  | Unsigned =>\n      if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))\n  end.","proofString":"destruct sg.\ndestruct (Int.eq n2 Int.zero            || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); exact I.\ndestruct (Int.eq n2 Int.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int) : optval_self_injects\n  (if\n    Int.eq n2 Int.zero\n    || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n   then None\n   else Some (Vint (Int.mods n1 n2))).","proofString":"destruct (Int.eq n2 Int.zero            || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int) : optval_self_injects\n  (if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))).","proofString":"destruct (Int.eq n2 Int.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (sg : signedness) (n1 n2 : int64) : optval_self_injects\n  match sg with\n  | Signed =>\n      if\n       Int64.eq n2 Int64.zero\n       || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n      then None\n      else Some (Vlong (Int64.mods n1 n2))\n  | Unsigned =>\n      if Int64.eq n2 Int64.zero\n      then None\n      else Some (Vlong (Int64.modu n1 n2))\n  end.","proofString":"destruct sg.\ndestruct (Int64.eq n2 Int64.zero            || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); exact I.\ndestruct (Int64.eq n2 Int64.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int64) : optval_self_injects\n  (if\n    Int64.eq n2 Int64.zero\n    || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n   then None\n   else Some (Vlong (Int64.mods n1 n2))).","proofString":"destruct (Int64.eq n2 Int64.zero            || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : int64) : optval_self_injects\n  (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.modu n1 n2))).","proofString":"destruct (Int64.eq n2 Int64.zero); exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : float) : optval_self_injects None.","proofString":"exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_mod v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (n1 n2 : float32) : optval_self_injects None.","proofString":"exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_and v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_and tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_or v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_or tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_xor v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_xor tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_binarith_inject; eauto; intros; exact I."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_shl v1 ty1 v2 ty2 = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_shl tv1 ty1 tv2 ty2 = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_shift_inject; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_shr v1 ty1 v2 ty2 = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val, sem_shr tv1 ty1 tv2 ty2 = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_shift_inject; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_cmp Ceq v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_cmp Ceq tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cmp_inj; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_cmp Cne v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_cmp Cne tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cmp_inj; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_cmp Clt v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_cmp Clt tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cmp_inj; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_cmp Cgt v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_cmp Cgt tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cmp_inj; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_cmp Cle v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_cmp Cle tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cmp_inj; eauto."},{"statement":"(cenv : composite_env) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_cmp Cge v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) : exists tv : val,\n  sem_cmp Cge tv1 ty1 tv2 ty2 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cmp_inj; eauto."},{"statement":"(f : meminj) (v1 : val) (ty1 ty : type) (m : mem) (v tv1 : val) (tm : mem) (H : sem_cast v1 ty1 ty m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Mem.inject f m tm) : exists tv : val, sem_cast tv1 ty1 ty tm = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_cast_inj; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (v1 : val) (ty1 ty : type) (m : mem) (v tv1 : val) (tm : mem) (H : sem_cast v1 ty1 ty m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Mem.inject f m tm) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer tm b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (m m' : mem) (op : unary_operation) (v1 : val) (ty1 : type) (v tv1 : val) (H : sem_unary_operation op v1 ty1 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Mem.inject f m m') : exists tv : val,\n  sem_unary_operation op tv1 ty1 m' = Some tv /\\ Val.inject f v tv.","proofString":"eapply sem_unary_operation_inj; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (m m' : mem) (op : unary_operation) (v1 : val) (ty1 : type) (v tv1 : val) (H : sem_unary_operation op v1 ty1 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Mem.inject f m m') : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m' b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (m m' : mem) (cenv : composite_env) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_binary_operation cenv op v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m m') : exists tv : val,\n  sem_binary_operation cenv op tv1 ty1 tv2 ty2 m' = Some tv /\\\n  Val.inject f v tv.","proofString":"eapply sem_binary_operation_inj; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (m m' : mem) (cenv : composite_env) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_binary_operation cenv op v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m m') : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m' b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (m m' : mem) (cenv : composite_env) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_binary_operation cenv op v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m m') : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m' b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (m m' : mem) (cenv : composite_env) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_binary_operation cenv op v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m m') : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(f : meminj) (m m' : mem) (cenv : composite_env) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v tv1 tv2 : val) (H : sem_binary_operation cenv op v1 ty1 v2 ty2 m = Some v) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m m') : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (m m' : mem) (v : val) (ty : type) (b : bool) (tv : val) (H : bool_val v ty m = Some b) (H0 : Val.inject f v tv) (H1 : Mem.inject f m m') : bool_val tv ty m' = Some b.","proofString":"eapply bool_val_inj; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (m m' : mem) (v : val) (ty : type) (b : bool) (tv : val) (H : bool_val v ty m = Some b) (H0 : Val.inject f v tv) (H1 : Mem.inject f m m') : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m' b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(v : val) (t : type) (m : mem) : sem_notbool v t m =\nmatch bool_val v t m with\n| Some b => Some (Val.of_bool (negb b))\n| None => None\nend.","proofString":"unfold sem_notbool.\ndestruct (bool_val v t m) as [[] | ]; reflexivity."},{"statement":"(v : val) (t : type) (m : mem) : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v t m) =\nmatch bool_val v t m with\n| Some b => Some (Val.of_bool (negb b))\n| None => None\nend.","proofString":"destruct (bool_val v t m) as [[] | ]; reflexivity."},{"statement":"(sz : intsize) (sg : signedness) (i : int) : cast_int_int sz sg (cast_int_int sz sg i) = cast_int_int sz sg i.","proofString":"destruct sz; simpl; auto.\ndestruct sg; [apply Int.sign_ext_idem|apply Int.zero_ext_idem]; compute; intuition congruence.\ndestruct sg; [apply Int.sign_ext_idem|apply Int.zero_ext_idem]; compute; intuition congruence.\ndestruct (Int.eq i Int.zero); auto."},{"statement":"(sg : signedness) (i : int) : match sg with\n| Signed =>\n    Int.sign_ext 8\n      match sg with\n      | Signed => Int.sign_ext 8 i\n      | Unsigned => Int.zero_ext 8 i\n      end\n| Unsigned =>\n    Int.zero_ext 8\n      match sg with\n      | Signed => Int.sign_ext 8 i\n      | Unsigned => Int.zero_ext 8 i\n      end\nend =\nmatch sg with\n| Signed => Int.sign_ext 8 i\n| Unsigned => Int.zero_ext 8 i\nend.","proofString":"destruct sg; [apply Int.sign_ext_idem|apply Int.zero_ext_idem]; compute; intuition congruence."},{"statement":"(sg : signedness) (i : int) : match sg with\n| Signed =>\n    Int.sign_ext 16\n      match sg with\n      | Signed => Int.sign_ext 16 i\n      | Unsigned => Int.zero_ext 16 i\n      end\n| Unsigned =>\n    Int.zero_ext 16\n      match sg with\n      | Signed => Int.sign_ext 16 i\n      | Unsigned => Int.zero_ext 16 i\n      end\nend =\nmatch sg with\n| Signed => Int.sign_ext 16 i\n| Unsigned => Int.zero_ext 16 i\nend.","proofString":"destruct sg; [apply Int.sign_ext_idem|apply Int.zero_ext_idem]; compute; intuition congruence."},{"statement":"(sg : signedness) (i : int) : (if Int.eq (if Int.eq i Int.zero then Int.zero else Int.one) Int.zero\n then Int.zero\n else Int.one) = (if Int.eq i Int.zero then Int.zero else Int.one).","proofString":"destruct (Int.eq i Int.zero); auto."},{"statement":"(v : val) (ty ty' : type) (v' : val) (m : mem) (H : match classify_cast ty ty' with\n| cast_case_pointer =>\n    match v with\n    | Vint _ => if Archi.ptr64 then None else Some v\n    | Vlong _ => if Archi.ptr64 then Some v else None\n    | Vptr _ _ => Some v\n    | _ => None\n    end\n| cast_case_i2i sz2 si2 =>\n    match v with\n    | Vint i => Some (Vint (cast_int_int sz2 si2 i))\n    | _ => None\n    end\n| cast_case_f2f => match v with\n                   | Vfloat f => Some (Vfloat f)\n                   | _ => None\n                   end\n| cast_case_s2s =>\n    match v with\n    | Vsingle f => Some (Vsingle f)\n    | _ => None\n    end\n| cast_case_f2s =>\n    match v with\n    | Vfloat f => Some (Vsingle (Float.to_single f))\n    | _ => None\n    end\n| cast_case_s2f =>\n    match v with\n    | Vsingle f => Some (Vfloat (Float.of_single f))\n    | _ => None\n    end\n| cast_case_i2f si1 =>\n    match v with\n    | Vint i => Some (Vfloat (cast_int_float si1 i))\n    | _ => None\n    end\n| cast_case_i2s si1 =>\n    match v with\n    | Vint i => Some (Vsingle (cast_int_single si1 i))\n    | _ => None\n    end\n| cast_case_f2i sz2 si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2i sz2 si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_l2l => match v with\n                   | Vlong n => Some (Vlong n)\n                   | _ => None\n                   end\n| cast_case_i2l si =>\n    match v with\n    | Vint n => Some (Vlong (cast_int_long si n))\n    | _ => None\n    end\n| cast_case_l2i sz si =>\n    match v with\n    | Vlong n =>\n        Some (Vint (cast_int_int sz si (Int.repr (Int64.unsigned n))))\n    | _ => None\n    end\n| cast_case_l2f si1 =>\n    match v with\n    | Vlong i => Some (Vfloat (cast_long_float si1 i))\n    | _ => None\n    end\n| cast_case_l2s si1 =>\n    match v with\n    | Vlong i => Some (Vsingle (cast_long_single si1 i))\n    | _ => None\n    end\n| cast_case_f2l si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2l si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_i2bool =>\n    match v with\n    | Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_l2bool =>\n    match v with\n    | Vlong n =>\n        Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_f2bool =>\n    match v with\n    | Vfloat f =>\n        Some\n          (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))\n    | _ => None\n    end\n| cast_case_s2bool =>\n    match v with\n    | Vsingle f =>\n        Some\n          (Vint\n             (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))\n    | _ => None\n    end\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    match v with\n    | Vptr _ _ => if ident_eq id1 id2 then Some v else None\n    | _ => None\n    end\n| cast_case_void => Some v\n| cast_case_default => None\nend = Some v') : val_casted v' ty'.","proofString":"destruct ty, ty'; simpl in H; DestructCases; InvBooleans; subst;  try discriminate; constructor; auto."},{"statement":"(v : val) (ty : type) (m : mem) (H : val_casted v ty) : sem_cast v ty ty m = Some v.","proofString":"unfold sem_cast; inversion H; clear H; subst v ty; simpl.\ndestruct sz.\ncongruence.\ncongruence.\ndestruct Archi.ptr64; congruence.\nsimpl in H0.\ncongruence.\nauto.\nauto.\ndestruct Archi.ptr64; auto.\nauto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite dec_eq_true; auto.\nrewrite dec_eq_true; auto.\nauto."},{"statement":"(m : mem) (sz : intsize) (si : signedness) (attr : Ctypes.attr) (n : int) (H0 : cast_int_int sz si n = n) : match\n  match sz with\n  | I32 => if Archi.ptr64 then cast_case_i2i sz si else cast_case_pointer\n  | IBool => cast_case_i2bool\n  | _ => cast_case_i2i sz si\n  end\nwith\n| cast_case_pointer => if Archi.ptr64 then None else Some (Vint n)\n| cast_case_i2i sz2 si2 => Some (Vint (cast_int_int sz2 si2 n))\n| cast_case_i2f si1 => Some (Vfloat (cast_int_float si1 n))\n| cast_case_i2s si1 => Some (Vsingle (cast_int_single si1 n))\n| cast_case_i2l si0 => Some (Vlong (cast_int_long si0 n))\n| cast_case_i2bool =>\n    Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n| cast_case_void => Some (Vint n)\n| _ => None\nend = Some (Vint n).","proofString":"destruct sz.\ncongruence.\ncongruence.\ndestruct Archi.ptr64; congruence.\nsimpl in H0.\ncongruence."},{"statement":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int) (H0 : cast_int_int I8 si n = n) : Some (Vint (cast_int_int I8 si n)) = Some (Vint n).","proofString":"congruence."},{"statement":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int) (H0 : cast_int_int I16 si n = n) : Some (Vint (cast_int_int I16 si n)) = Some (Vint n).","proofString":"congruence."},{"statement":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int) (H0 : cast_int_int I32 si n = n) : match (if Archi.ptr64 then cast_case_i2i I32 si else cast_case_pointer) with\n| cast_case_pointer => if Archi.ptr64 then None else Some (Vint n)\n| cast_case_i2i sz2 si2 => Some (Vint (cast_int_int sz2 si2 n))\n| cast_case_i2f si1 => Some (Vfloat (cast_int_float si1 n))\n| cast_case_i2s si1 => Some (Vsingle (cast_int_single si1 n))\n| cast_case_i2l si0 => Some (Vlong (cast_int_long si0 n))\n| cast_case_i2bool =>\n    Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n| cast_case_void => Some (Vint n)\n| _ => None\nend = Some (Vint n).","proofString":"destruct Archi.ptr64; congruence."},{"statement":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int) (H0 : cast_int_int IBool si n = n) : Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)) = Some (Vint n).","proofString":"simpl in H0.\ncongruence."},{"statement":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int) (H0 : (if Int.eq n Int.zero then Int.zero else Int.one) = n) : Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)) = Some (Vint n).","proofString":"congruence."},{"statement":"(m : mem) (attr : Ctypes.attr) (n : float) : Some (Vfloat n) = Some (Vfloat n).","proofString":"auto."},{"statement":"(m : mem) (attr : Ctypes.attr) (n : float32) : Some (Vsingle n) = Some (Vsingle n).","proofString":"auto."},{"statement":"(m : mem) (si : signedness) (attr : Ctypes.attr) (n : int64) : match (if Archi.ptr64 then cast_case_pointer else cast_case_l2l) with\n| cast_case_pointer => if Archi.ptr64 then Some (Vlong n) else None\n| cast_case_l2i sz si0 =>\n    Some (Vint (cast_int_int sz si0 (Int.repr (Int64.unsigned n))))\n| cast_case_l2f si1 => Some (Vfloat (cast_long_float si1 n))\n| cast_case_l2s si1 => Some (Vsingle (cast_long_single si1 n))\n| cast_case_l2bool =>\n    Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n| cast_case_l2l | cast_case_void => Some (Vlong n)\n| _ => None\nend = Some (Vlong n).","proofString":"destruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (ty0 : type) (attr : Ctypes.attr) : Some (Vptr b ofs) = Some (Vptr b ofs).","proofString":"auto."},{"statement":"(m : mem) (n : int) (ty0 : type) (attr : Ctypes.attr) (H0 : Archi.ptr64 = false) : (if Archi.ptr64 then None else Some (Vint n)) = Some (Vint n).","proofString":"rewrite H0; auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (si : signedness) (attr : Ctypes.attr) (H0 : Archi.ptr64 = false) : match (if Archi.ptr64 then cast_case_i2i I32 si else cast_case_pointer) with\n| cast_case_i2bool =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_l2bool =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    if ident_eq id1 id2 then Some (Vptr b ofs) else None\n| cast_case_pointer | cast_case_void => Some (Vptr b ofs)\n| _ => None\nend = Some (Vptr b ofs).","proofString":"rewrite H0; auto."},{"statement":"(m : mem) (n : int64) (ty0 : type) (attr : Ctypes.attr) (H0 : Archi.ptr64 = true) : (if Archi.ptr64 then Some (Vlong n) else None) = Some (Vlong n).","proofString":"rewrite H0; auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (si : signedness) (attr : Ctypes.attr) (H0 : Archi.ptr64 = true) : match (if Archi.ptr64 then cast_case_pointer else cast_case_l2l) with\n| cast_case_i2bool =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_l2bool =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    if ident_eq id1 id2 then Some (Vptr b ofs) else None\n| cast_case_pointer | cast_case_void => Some (Vptr b ofs)\n| _ => None\nend = Some (Vptr b ofs).","proofString":"rewrite H0; auto."},{"statement":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : (if ident_eq id id then Some (Vptr b ofs) else None) = Some (Vptr b ofs).","proofString":"rewrite dec_eq_true; auto."},{"statement":"(m : mem) (id : ident) (attr : Ctypes.attr) (b : block) (ofs : ptrofs) : (if ident_eq id id then Some (Vptr b ofs) else None) = Some (Vptr b ofs).","proofString":"rewrite dec_eq_true; auto."},{"statement":"(m : mem) (v0 : val) : Some v0 = Some v0.","proofString":"auto."},{"statement":"(v : val) (ty ty' : type) (v' : val) (m : mem) (H : sem_cast v ty ty' m = Some v') : sem_cast v' ty' ty' m = Some v'.","proofString":"apply cast_val_casted.\neapply cast_val_is_casted; eauto."},{"statement":"(v : val) (ty ty' : type) (v' : val) (m : mem) (H : sem_cast v ty ty' m = Some v') : val_casted v' ty'.","proofString":"eapply cast_val_is_casted; eauto."},{"statement":"(sz : intsize) (si : signedness) (attr : Ctypes.attr) (n : int) (H : cast_int_int sz si n = n) : Val.has_argtype (Vint n)\n  match sz with\n  | I8 =>\n      match si with\n      | Signed => Xint8signed\n      | Unsigned => Xint8unsigned\n      end\n  | I16 =>\n      match si with\n      | Signed => Xint16signed\n      | Unsigned => Xint16unsigned\n      end\n  | I32 => Xint\n  | IBool => Xbool\n  end.","proofString":"destruct sz; [destruct si | destruct si | | ]; simpl in *; auto.\ndestruct (Int.eq n Int.zero); auto."},{"statement":"(si : signedness) (attr : Ctypes.attr) (n : int) (H : (if Int.eq n Int.zero then Int.zero else Int.one) = n) : n = Int.zero \\/ n = Int.one.","proofString":"destruct (Int.eq n Int.zero); auto."},{"statement":"(v : val) (ty : type) (H : val_casted v ty) (H0 : ty <> Tvoid) : Val.has_type v (typ_of_type ty).","proofString":"inv H; simpl typ_of_type.\nexact I.\nexact I.\nexact I.\nexact I.\napply Val.Vptr_has_type.\nred; unfold Tptr; rewrite H1; auto.\nred; unfold Tptr; rewrite H1; auto.\nred; unfold Tptr; rewrite H1; auto.\nred; unfold Tptr; rewrite H1; auto.\napply Val.Vptr_has_type.\napply Val.Vptr_has_type.\ncongruence."},{"statement":"(sz : intsize) (si : signedness) (attr : Ctypes.attr) (H0 : Tint sz si attr <> Tvoid) (n : int) (H1 : cast_int_int sz si n = n) : Val.has_type (Vint n) AST.Tint.","proofString":"exact I."},{"statement":"(attr : Ctypes.attr) (H0 : Tfloat F64 attr <> Tvoid) (n : float) : Val.has_type (Vfloat n) AST.Tfloat.","proofString":"exact I."},{"statement":"(attr : Ctypes.attr) (H0 : Tfloat F32 attr <> Tvoid) (n : float32) : Val.has_type (Vsingle n) Tsingle.","proofString":"exact I."},{"statement":"(si : signedness) (attr : Ctypes.attr) (H0 : Tlong si attr <> Tvoid) (n : int64) : Val.has_type (Vlong n) AST.Tlong.","proofString":"exact I."},{"statement":"(ty0 : type) (attr : Ctypes.attr) (H0 : Tpointer ty0 attr <> Tvoid) (b : block) (ofs : ptrofs) : Val.has_type (Vptr b ofs) Tptr.","proofString":"apply Val.Vptr_has_type."},{"statement":"(ty0 : type) (attr : Ctypes.attr) (H0 : Tpointer ty0 attr <> Tvoid) (n : int) (H1 : Archi.ptr64 = false) : Val.has_type (Vint n) Tptr.","proofString":"red; unfold Tptr; rewrite H1; auto."},{"statement":"(si : signedness) (attr : Ctypes.attr) (H0 : Tint I32 si attr <> Tvoid) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = false) : Val.has_type (Vptr b ofs) AST.Tint.","proofString":"red; unfold Tptr; rewrite H1; auto."},{"statement":"(ty0 : type) (attr : Ctypes.attr) (H0 : Tpointer ty0 attr <> Tvoid) (n : int64) (H1 : Archi.ptr64 = true) : Val.has_type (Vlong n) Tptr.","proofString":"red; unfold Tptr; rewrite H1; auto."},{"statement":"(si : signedness) (attr : Ctypes.attr) (H0 : Tlong si attr <> Tvoid) (b : block) (ofs : ptrofs) (H1 : Archi.ptr64 = true) : Val.has_type (Vptr b ofs) AST.Tlong.","proofString":"red; unfold Tptr; rewrite H1; auto."},{"statement":"(id : ident) (attr : Ctypes.attr) (H0 : Tstruct id attr <> Tvoid) (b : block) (ofs : ptrofs) : Val.has_type (Vptr b ofs) Tptr.","proofString":"apply Val.Vptr_has_type."},{"statement":"(id : ident) (attr : Ctypes.attr) (H0 : Tunion id attr <> Tvoid) (b : block) (ofs : ptrofs) : Val.has_type (Vptr b ofs) Tptr.","proofString":"apply Val.Vptr_has_type."},{"statement":"(v : val) (H0 : Tvoid <> Tvoid) : Val.has_type v AST.Tint.","proofString":"congruence."},{"statement":"(it it0 : int_type) : binarith_type (classify_binarith (proj_type (I it)) (proj_type (I it0))) =\nproj_type (usual_arithmetic_conversion (I it) (I it0)).","proofString":"destruct it; destruct it0; reflexivity."},{"statement":"(it : int_type) : binarith_type (classify_binarith (proj_type (I it)) (proj_type Float)) =\nproj_type (usual_arithmetic_conversion (I it) Float).","proofString":"destruct it; reflexivity."},{"statement":"(it : int_type) : binarith_type (classify_binarith (proj_type (I it)) (proj_type Double)) =\nproj_type (usual_arithmetic_conversion (I it) Double).","proofString":"destruct it; reflexivity."},{"statement":"(it : int_type) : binarith_type (classify_binarith (proj_type (I it)) (proj_type Longdouble)) =\nproj_type (usual_arithmetic_conversion (I it) Longdouble).","proofString":"destruct it; reflexivity."},{"statement":"(it : int_type) : binarith_type (classify_binarith (proj_type Float) (proj_type (I it))) =\nproj_type (usual_arithmetic_conversion Float (I it)).","proofString":"destruct it; reflexivity."},{"statement":"(it : int_type) : binarith_type (classify_binarith (proj_type Double) (proj_type (I it))) =\nproj_type (usual_arithmetic_conversion Double (I it)).","proofString":"destruct it; reflexivity."},{"statement":"(it : int_type) : binarith_type (classify_binarith (proj_type Longdouble) (proj_type (I it))) =\nproj_type (usual_arithmetic_conversion Longdouble (I it)).","proofString":"destruct it; reflexivity."}]}