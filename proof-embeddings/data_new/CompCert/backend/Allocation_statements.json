{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Allocation.v","fileSamples":[{"statement":"(x y z : t) (H : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc y) \\/\n eloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc y) \\/\n eloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H.\ndestruct H0.\nleft; eapply Plt_trans; eauto.\ndestruct H0.\nrewrite <- H0.\nauto.\ndestruct H.\nrewrite H.\ndestruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply OrderedLoc.lt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nleft; eapply Plt_trans; eauto.\ndestruct H0.\nrewrite <- H0.\nauto."},{"statement":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : Plt (ereg y) (ereg z)) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : Plt (ereg y) (ereg z))","proofString":"left; eapply Plt_trans; eauto."},{"statement":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : ereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : ereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nrewrite <- H0.\nauto."},{"statement":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : ereg y = ereg z) (H1 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : ereg y = ereg z) (H1 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"rewrite <- H0.\nauto."},{"statement":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : ereg y = ereg z) (H1 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : Plt (ereg x) (ereg y)) (H0 : ereg y = ereg z) (H1 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"auto."},{"statement":"(x y z : t) (H : ereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc y) \\/\n eloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : ereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc y) \\/\n eloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H.\nrewrite H.\ndestruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply OrderedLoc.lt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"rewrite H.\ndestruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply OrderedLoc.lt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply OrderedLoc.lt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : Plt (ereg y) (ereg z)) : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : Plt (ereg y) (ereg z))","proofString":"auto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : ereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : ereg y = ereg z /\\\n(OrderedLoc.lt (eloc y) (eloc z) \\/\n eloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nright; split; auto.\nintuition.\nleft; eapply OrderedLoc.lt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : ereg y = ereg z) (H2 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\\n(OrderedLoc.lt (eloc x) (eloc z) \\/\n eloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : ereg y = ereg z) (H2 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"right; split; auto.\nintuition.\nleft; eapply OrderedLoc.lt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : ereg y = ereg z) (H2 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H1 : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : ereg y = ereg z) (H2 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"intuition.\nleft; eapply OrderedLoc.lt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H3 : OrderedLoc.lt (eloc x) (eloc y)) (H1 : OrderedLoc.lt (eloc y) (eloc z)) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H3 : OrderedLoc.lt (eloc x) (eloc y)) (H1 : OrderedLoc.lt (eloc y) (eloc z))","proofString":"left; eapply OrderedLoc.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H3 : OrderedLoc.lt (eloc x) (eloc y)) (H2 : eloc y = eloc z) (H4 : OrderedEqKind.lt (ekind y) (ekind z)) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H3 : OrderedLoc.lt (eloc x) (eloc y)) (H2 : eloc y = eloc z) (H4 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"left; congruence."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H3 : OrderedLoc.lt (eloc y) (eloc z)) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H3 : OrderedLoc.lt (eloc y) (eloc z))","proofString":"left; congruence."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : eloc y = eloc z) (H5 : OrderedEqKind.lt (ekind y) (ekind z)) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : eloc y = eloc z) (H5 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"right; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : eloc y = eloc z) (H5 : OrderedEqKind.lt (ekind y) (ekind z)) : eloc x = eloc z.","conclusion":"eloc x = eloc z","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : eloc y = eloc z) (H5 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"congruence."},{"statement":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : eloc y = eloc z) (H5 : OrderedEqKind.lt (ekind y) (ekind z)) : OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : ereg x = ereg y) (H0 : ereg y = ereg z) (H1 : eloc x = eloc y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : eloc y = eloc z) (H5 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"eapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y : t) (H : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc y) \\/\n eloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : x = y) : False.","conclusion":"False","hypotheses":"(x y : t) (H : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\\n(OrderedLoc.lt (eloc x) (eloc y) \\/\n eloc x = eloc y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : x = y)","proofString":"subst y.\nintuition.\neelim Plt_strict; eauto.\neelim OrderedLoc.lt_not_eq; eauto.\nred; auto.\neelim OrderedEqKind.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H : Plt (ereg x) (ereg x) \\/\nereg x = ereg x /\\\n(OrderedLoc.lt (eloc x) (eloc x) \\/\n eloc x = eloc x /\\ OrderedEqKind.lt (ekind x) (ekind x))) : False.","conclusion":"False","hypotheses":"(x : t) (H : Plt (ereg x) (ereg x) \\/\nereg x = ereg x /\\\n(OrderedLoc.lt (eloc x) (eloc x) \\/\n eloc x = eloc x /\\ OrderedEqKind.lt (ekind x) (ekind x)))","proofString":"intuition.\neelim Plt_strict; eauto.\neelim OrderedLoc.lt_not_eq; eauto.\nred; auto.\neelim OrderedEqKind.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H0 : Plt (ereg x) (ereg x)) : False.","conclusion":"False","hypotheses":"(x : t) (H0 : Plt (ereg x) (ereg x))","proofString":"eelim Plt_strict; eauto."},{"statement":"(x : t) (H : ereg x = ereg x) (H0 : OrderedLoc.lt (eloc x) (eloc x)) : False.","conclusion":"False","hypotheses":"(x : t) (H : ereg x = ereg x) (H0 : OrderedLoc.lt (eloc x) (eloc x))","proofString":"eelim OrderedLoc.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H : ereg x = ereg x) (H0 : OrderedLoc.lt (eloc x) (eloc x)) : OrderedLoc.eq (eloc x) (eloc x).","conclusion":"OrderedLoc.eq (eloc x) (eloc x)","hypotheses":"(x : t) (H : ereg x = ereg x) (H0 : OrderedLoc.lt (eloc x) (eloc x))","proofString":"red; auto."},{"statement":"(x : t) (H : ereg x = ereg x) (H1 : eloc x = eloc x) (H2 : OrderedEqKind.lt (ekind x) (ekind x)) : False.","conclusion":"False","hypotheses":"(x : t) (H : ereg x = ereg x) (H1 : eloc x = eloc x) (H2 : OrderedEqKind.lt (ekind x) (ekind x))","proofString":"eelim OrderedEqKind.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H : ereg x = ereg x) (H1 : eloc x = eloc x) (H2 : OrderedEqKind.lt (ekind x) (ekind x)) : OrderedEqKind.eq (ekind x) (ekind x).","conclusion":"OrderedEqKind.eq (ekind x) (ekind x)","hypotheses":"(x : t) (H : ereg x = ereg x) (H1 : eloc x = eloc x) (H2 : OrderedEqKind.lt (ekind x) (ekind x))","proofString":"red; auto."},{"statement":"(x y : t) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t)","proofString":"destruct (OrderedPositive.compare (ereg x) (ereg y)).\napply LT.\nred; auto.\ndestruct (OrderedLoc.compare (eloc x) (eloc y)).\napply LT.\nred; auto.\ndestruct (OrderedEqKind.compare (ekind x) (ekind y)).\napply LT.\nred; auto.\napply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence.\napply GT.\nred; auto.\napply GT.\nred; auto.\napply GT.\nred; auto."},{"statement":"(x y : t) (l : OrderedPositive.lt (ereg x) (ereg y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (l : OrderedPositive.lt (ereg x) (ereg y))","proofString":"apply LT.\nred; auto."},{"statement":"(x y : t) (l : OrderedPositive.lt (ereg x) (ereg y)) : lt x y.","conclusion":"lt x y","hypotheses":"(x y : t) (l : OrderedPositive.lt (ereg x) (ereg y))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y))","proofString":"destruct (OrderedLoc.compare (eloc x) (eloc y)).\napply LT.\nred; auto.\ndestruct (OrderedEqKind.compare (ekind x) (ekind y)).\napply LT.\nred; auto.\napply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence.\napply GT.\nred; auto.\napply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc x) (eloc y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc x) (eloc y))","proofString":"apply LT.\nred; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc x) (eloc y)) : lt x y.","conclusion":"lt x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc x) (eloc y))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y))","proofString":"destruct (OrderedEqKind.compare (ekind x) (ekind y)).\napply LT.\nred; auto.\napply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence.\napply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind x) (ekind y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind x) (ekind y))","proofString":"apply LT.\nred; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind x) (ekind y)) : lt x y.","conclusion":"lt x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind x) (ekind y))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y))","proofString":"apply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y)) : eq x y.","conclusion":"eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y))","proofString":"red in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence."},{"statement":"(x y : t) (e : ereg x = ereg y) (e0 : eloc x = eloc y) (e1 : ekind x = ekind y) : x = y.","conclusion":"x = y","hypotheses":"(x y : t) (e : ereg x = ereg y) (e0 : eloc x = eloc y) (e1 : ekind x = ekind y)","proofString":"destruct x; destruct y; simpl in *; congruence."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind y) (ekind x)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind y) (ekind x))","proofString":"apply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind y) (ekind x)) : lt y x.","conclusion":"lt y x","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (e0 : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedEqKind.lt (ekind y) (ekind x))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc y) (eloc x)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc y) (eloc x))","proofString":"apply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc y) (eloc x)) : lt y x.","conclusion":"lt y x","hypotheses":"(x y : t) (e : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedLoc.lt (eloc y) (eloc x))","proofString":"red; auto."},{"statement":"(x y : t) (l : OrderedPositive.lt (ereg y) (ereg x)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (l : OrderedPositive.lt (ereg y) (ereg x))","proofString":"apply GT.\nred; auto."},{"statement":"(x y : t) (l : OrderedPositive.lt (ereg y) (ereg x)) : lt y x.","conclusion":"lt y x","hypotheses":"(x y : t) (l : OrderedPositive.lt (ereg y) (ereg x))","proofString":"red; auto."},{"statement":"(x y : t) : {x = y} + {x <> y}.","conclusion":"{x = y} + {x <> y}","hypotheses":"(x y : t)","proofString":"decide equality.\napply Loc.eq.\napply peq.\napply IndexedEqKind.eq."},{"statement":"(x y : t) (ekind0 : equation_kind) (ereg0 : reg) (eloc0 : loc) (ekind1 : equation_kind) (ereg1 : reg) (eloc1 : loc) (a : ekind0 = ekind1) (a0 : ereg0 = ereg1) : {eloc0 = eloc1} + {eloc0 <> eloc1}.","conclusion":"{eloc0 = eloc1} + {eloc0 <> eloc1}","hypotheses":"(x y : t) (ekind0 : equation_kind) (ereg0 : reg) (eloc0 : loc) (ekind1 : equation_kind) (ereg1 : reg) (eloc1 : loc) (a : ekind0 = ekind1) (a0 : ereg0 = ereg1)","proofString":"apply Loc.eq."},{"statement":"(x y : t) (ekind0 : equation_kind) (ereg0 : reg) (eloc0 : loc) (ekind1 : equation_kind) (ereg1 : reg) (eloc1 : loc) (a : ekind0 = ekind1) : {ereg0 = ereg1} + {ereg0 <> ereg1}.","conclusion":"{ereg0 = ereg1} + {ereg0 <> ereg1}","hypotheses":"(x y : t) (ekind0 : equation_kind) (ereg0 : reg) (eloc0 : loc) (ekind1 : equation_kind) (ereg1 : reg) (eloc1 : loc) (a : ekind0 = ekind1)","proofString":"apply peq."},{"statement":"(x y : t) (ekind0 : equation_kind) (ereg0 : reg) (eloc0 : loc) (ekind1 : equation_kind) (ereg1 : reg) (eloc1 : loc) : {ekind0 = ekind1} + {ekind0 <> ekind1}.","conclusion":"{ekind0 = ekind1} + {ekind0 <> ekind1}","hypotheses":"(x y : t) (ekind0 : equation_kind) (ereg0 : reg) (eloc0 : loc) (ekind1 : equation_kind) (ereg1 : reg) (eloc1 : loc)","proofString":"apply IndexedEqKind.eq."},{"statement":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\\n(Plt (ereg x) (ereg y) \\/\n ereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\\n(Plt (ereg x) (ereg y) \\/\n ereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H.\ndestruct H0.\nleft; eapply OrderedLoc.lt_trans; eauto.\ndestruct H0.\nrewrite <- H0.\nauto.\ndestruct H.\nrewrite H.\ndestruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply Plt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nleft; eapply OrderedLoc.lt_trans; eauto.\ndestruct H0.\nrewrite <- H0.\nauto."},{"statement":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : OrderedLoc.lt (eloc y) (eloc z)) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : OrderedLoc.lt (eloc y) (eloc z))","proofString":"left; eapply OrderedLoc.lt_trans; eauto."},{"statement":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : eloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : eloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nrewrite <- H0.\nauto."},{"statement":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : eloc y = eloc z) (H1 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : eloc y = eloc z) (H1 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"rewrite <- H0.\nauto."},{"statement":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : eloc y = eloc z) (H1 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : OrderedLoc.lt (eloc x) (eloc y)) (H0 : eloc y = eloc z) (H1 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"auto."},{"statement":"(x y z : t) (H : eloc x = eloc y /\\\n(Plt (ereg x) (ereg y) \\/\n ereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : eloc x = eloc y /\\\n(Plt (ereg x) (ereg y) \\/\n ereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H.\nrewrite H.\ndestruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply Plt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc x) (eloc z) \\/\neloc x = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"rewrite H.\ndestruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply Plt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nauto.\ndestruct H0.\nright; split; auto.\nintuition.\nleft; eapply Plt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : OrderedLoc.lt (eloc y) (eloc z)) : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : OrderedLoc.lt (eloc y) (eloc z))","proofString":"auto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : eloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))) : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : eloc y = eloc z /\\\n(Plt (ereg y) (ereg z) \\/\n ereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)))","proofString":"destruct H0.\nright; split; auto.\nintuition.\nleft; eapply Plt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : eloc y = eloc z) (H2 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)).","conclusion":"OrderedLoc.lt (eloc y) (eloc z) \\/\neloc y = eloc z /\\\n(Plt (ereg x) (ereg z) \\/\n ereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z))","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : eloc y = eloc z) (H2 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"right; split; auto.\nintuition.\nleft; eapply Plt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : eloc y = eloc z) (H2 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z)) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H1 : Plt (ereg x) (ereg y) \\/\nereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y)) (H0 : eloc y = eloc z) (H2 : Plt (ereg y) (ereg z) \\/\nereg y = ereg z /\\ OrderedEqKind.lt (ekind y) (ekind z))","proofString":"intuition.\nleft; eapply Plt_trans; eauto.\nleft; congruence.\nleft; congruence.\nright; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H3 : Plt (ereg x) (ereg y)) (H1 : Plt (ereg y) (ereg z)) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H3 : Plt (ereg x) (ereg y)) (H1 : Plt (ereg y) (ereg z))","proofString":"left; eapply Plt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H3 : Plt (ereg x) (ereg y)) (H2 : ereg y = ereg z) (H4 : OrderedEqKind.lt (ekind y) (ekind z)) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H3 : Plt (ereg x) (ereg y)) (H2 : ereg y = ereg z) (H4 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"left; congruence."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H3 : Plt (ereg y) (ereg z)) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H3 : Plt (ereg y) (ereg z))","proofString":"left; congruence."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : ereg y = ereg z) (H5 : OrderedEqKind.lt (ekind y) (ekind z)) : Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"Plt (ereg x) (ereg z) \\/\nereg x = ereg z /\\ OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : ereg y = ereg z) (H5 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"right; split.\ncongruence.\neapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : ereg y = ereg z) (H5 : OrderedEqKind.lt (ekind y) (ekind z)) : ereg x = ereg z.","conclusion":"ereg x = ereg z","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : ereg y = ereg z) (H5 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"congruence."},{"statement":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : ereg y = ereg z) (H5 : OrderedEqKind.lt (ekind y) (ekind z)) : OrderedEqKind.lt (ekind x) (ekind z).","conclusion":"OrderedEqKind.lt (ekind x) (ekind z)","hypotheses":"(x y z : t) (H : eloc x = eloc y) (H0 : eloc y = eloc z) (H1 : ereg x = ereg y) (H4 : OrderedEqKind.lt (ekind x) (ekind y)) (H2 : ereg y = ereg z) (H5 : OrderedEqKind.lt (ekind y) (ekind z))","proofString":"eapply OrderedEqKind.lt_trans; eauto."},{"statement":"(x y : t) (H : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\\n(Plt (ereg x) (ereg y) \\/\n ereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : x = y) : False.","conclusion":"False","hypotheses":"(x y : t) (H : OrderedLoc.lt (eloc x) (eloc y) \\/\neloc x = eloc y /\\\n(Plt (ereg x) (ereg y) \\/\n ereg x = ereg y /\\ OrderedEqKind.lt (ekind x) (ekind y))) (H0 : x = y)","proofString":"subst y.\nintuition.\neelim OrderedLoc.lt_not_eq; eauto.\nred; auto.\neelim Plt_strict; eauto.\neelim OrderedEqKind.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H : OrderedLoc.lt (eloc x) (eloc x) \\/\neloc x = eloc x /\\\n(Plt (ereg x) (ereg x) \\/\n ereg x = ereg x /\\ OrderedEqKind.lt (ekind x) (ekind x))) : False.","conclusion":"False","hypotheses":"(x : t) (H : OrderedLoc.lt (eloc x) (eloc x) \\/\neloc x = eloc x /\\\n(Plt (ereg x) (ereg x) \\/\n ereg x = ereg x /\\ OrderedEqKind.lt (ekind x) (ekind x)))","proofString":"intuition.\neelim OrderedLoc.lt_not_eq; eauto.\nred; auto.\neelim Plt_strict; eauto.\neelim OrderedEqKind.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H0 : OrderedLoc.lt (eloc x) (eloc x)) : False.","conclusion":"False","hypotheses":"(x : t) (H0 : OrderedLoc.lt (eloc x) (eloc x))","proofString":"eelim OrderedLoc.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H0 : OrderedLoc.lt (eloc x) (eloc x)) : OrderedLoc.eq (eloc x) (eloc x).","conclusion":"OrderedLoc.eq (eloc x) (eloc x)","hypotheses":"(x : t) (H0 : OrderedLoc.lt (eloc x) (eloc x))","proofString":"red; auto."},{"statement":"(x : t) (H : eloc x = eloc x) (H0 : Plt (ereg x) (ereg x)) : False.","conclusion":"False","hypotheses":"(x : t) (H : eloc x = eloc x) (H0 : Plt (ereg x) (ereg x))","proofString":"eelim Plt_strict; eauto."},{"statement":"(x : t) (H : eloc x = eloc x) (H1 : ereg x = ereg x) (H2 : OrderedEqKind.lt (ekind x) (ekind x)) : False.","conclusion":"False","hypotheses":"(x : t) (H : eloc x = eloc x) (H1 : ereg x = ereg x) (H2 : OrderedEqKind.lt (ekind x) (ekind x))","proofString":"eelim OrderedEqKind.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H : eloc x = eloc x) (H1 : ereg x = ereg x) (H2 : OrderedEqKind.lt (ekind x) (ekind x)) : OrderedEqKind.eq (ekind x) (ekind x).","conclusion":"OrderedEqKind.eq (ekind x) (ekind x)","hypotheses":"(x : t) (H : eloc x = eloc x) (H1 : ereg x = ereg x) (H2 : OrderedEqKind.lt (ekind x) (ekind x))","proofString":"red; auto."},{"statement":"(x y : t) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t)","proofString":"destruct (OrderedLoc.compare (eloc x) (eloc y)).\napply LT.\nred; auto.\ndestruct (OrderedPositive.compare (ereg x) (ereg y)).\napply LT.\nred; auto.\ndestruct (OrderedEqKind.compare (ekind x) (ekind y)).\napply LT.\nred; auto.\napply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence.\napply GT.\nred; auto.\napply GT.\nred; auto.\napply GT.\nred; auto."},{"statement":"(x y : t) (l : OrderedLoc.lt (eloc x) (eloc y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (l : OrderedLoc.lt (eloc x) (eloc y))","proofString":"apply LT.\nred; auto."},{"statement":"(x y : t) (l : OrderedLoc.lt (eloc x) (eloc y)) : lt x y.","conclusion":"lt x y","hypotheses":"(x y : t) (l : OrderedLoc.lt (eloc x) (eloc y))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y))","proofString":"destruct (OrderedPositive.compare (ereg x) (ereg y)).\napply LT.\nred; auto.\ndestruct (OrderedEqKind.compare (ekind x) (ekind y)).\napply LT.\nred; auto.\napply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence.\napply GT.\nred; auto.\napply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg x) (ereg y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg x) (ereg y))","proofString":"apply LT.\nred; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg x) (ereg y)) : lt x y.","conclusion":"lt x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg x) (ereg y))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y))","proofString":"destruct (OrderedEqKind.compare (ekind x) (ekind y)).\napply LT.\nred; auto.\napply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence.\napply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind x) (ekind y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind x) (ekind y))","proofString":"apply LT.\nred; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind x) (ekind y)) : lt x y.","conclusion":"lt x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind x) (ekind y))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y))","proofString":"apply EQ.\nred in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y)) : eq x y.","conclusion":"eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (e1 : OrderedEqKind.eq (ekind x) (ekind y))","proofString":"red in e; red in e0; red in e1; red.\ndestruct x; destruct y; simpl in *; congruence."},{"statement":"(x y : t) (e : eloc x = eloc y) (e0 : ereg x = ereg y) (e1 : ekind x = ekind y) : x = y.","conclusion":"x = y","hypotheses":"(x y : t) (e : eloc x = eloc y) (e0 : ereg x = ereg y) (e1 : ekind x = ekind y)","proofString":"destruct x; destruct y; simpl in *; congruence."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind y) (ekind x)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind y) (ekind x))","proofString":"apply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind y) (ekind x)) : lt y x.","conclusion":"lt y x","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (e0 : OrderedPositive.eq (ereg x) (ereg y)) (l : OrderedEqKind.lt (ekind y) (ekind x))","proofString":"red; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg y) (ereg x)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg y) (ereg x))","proofString":"apply GT.\nred; auto."},{"statement":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg y) (ereg x)) : lt y x.","conclusion":"lt y x","hypotheses":"(x y : t) (e : OrderedLoc.eq (eloc x) (eloc y)) (l : OrderedPositive.lt (ereg y) (ereg x))","proofString":"red; auto."},{"statement":"(x y : t) (l : OrderedLoc.lt (eloc y) (eloc x)) : Compare lt eq x y.","conclusion":"Compare lt eq x y","hypotheses":"(x y : t) (l : OrderedLoc.lt (eloc y) (eloc x))","proofString":"apply GT.\nred; auto."},{"statement":"(x y : t) (l : OrderedLoc.lt (eloc y) (eloc x)) : lt y x.","conclusion":"lt y x","hypotheses":"(x y : t) (l : OrderedLoc.lt (eloc y) (eloc x))","proofString":"red; auto."},{"statement":"(e : eqs) : EqSet.Equal e e.","conclusion":"EqSet.Equal e e","hypotheses":"(e : eqs)","proofString":"red; tauto."},{"statement":"(e e0 : eqs) (H : EqSet.Equal e e0) : EqSet.Equal e0 e.","conclusion":"EqSet.Equal e0 e","hypotheses":"(e e0 : eqs) (H : EqSet.Equal e e0)","proofString":"red in H; red; intros.\nrewrite H; tauto."},{"statement":"(e e0 : eqs) (H : forall a0 : EqSet.elt, EqSet.In a0 e <-> EqSet.In a0 e0) (a : EqSet.elt) : EqSet.In a e0 <-> EqSet.In a e.","conclusion":"EqSet.In a e0 <-> EqSet.In a e","hypotheses":"(e e0 : eqs) (H : forall a0 : EqSet.elt, EqSet.In a0 e <-> EqSet.In a0 e0) (a : EqSet.elt)","proofString":"rewrite H; tauto."},{"statement":"(x y z : t) (H : match x with\n| OK a => match y with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match y with\n             | OK _ => False\n             | Error _ => True\n             end\nend) (H0 : match y with\n| OK a => match z with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match z with\n             | OK _ => False\n             | Error _ => True\n             end\nend) : match x with\n| OK a => match z with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match z with\n             | OK _ => False\n             | Error _ => True\n             end\nend.","conclusion":"match x with\n| OK a => match z with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match z with\n             | OK _ => False\n             | Error _ => True\n             end\nend","hypotheses":"(x y z : t) (H : match x with\n| OK a => match y with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match y with\n             | OK _ => False\n             | Error _ => True\n             end\nend) (H0 : match y with\n| OK a => match z with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match z with\n             | OK _ => False\n             | Error _ => True\n             end\nend)","proofString":"destruct x; destruct y; try contradiction; destruct z; auto.\nred in H; red in H0; red; intros.\nrewrite H.\nauto."},{"statement":"(e e0 e1 : eqs) (H : EqSet.Equal e e0) (H0 : EqSet.Equal e0 e1) : EqSet.Equal e e1.","conclusion":"EqSet.Equal e e1","hypotheses":"(e e0 e1 : eqs) (H : EqSet.Equal e e0) (H0 : EqSet.Equal e0 e1)","proofString":"red in H; red in H0; red; intros.\nrewrite H.\nauto."},{"statement":"(e e0 e1 : eqs) (H : forall a0 : EqSet.elt, EqSet.In a0 e <-> EqSet.In a0 e0) (H0 : forall a0 : EqSet.elt, EqSet.In a0 e0 <-> EqSet.In a0 e1) (a : EqSet.elt) : EqSet.In a e <-> EqSet.In a e1.","conclusion":"EqSet.In a e <-> EqSet.In a e1","hypotheses":"(e e0 e1 : eqs) (H : forall a0 : EqSet.elt, EqSet.In a0 e <-> EqSet.In a0 e0) (H0 : forall a0 : EqSet.elt, EqSet.In a0 e0 <-> EqSet.In a0 e1) (a : EqSet.elt)","proofString":"rewrite H.\nauto."},{"statement":"(e e0 e1 : eqs) (H : forall a0 : EqSet.elt, EqSet.In a0 e <-> EqSet.In a0 e0) (H0 : forall a0 : EqSet.elt, EqSet.In a0 e0 <-> EqSet.In a0 e1) (a : EqSet.elt) : EqSet.In a e0 <-> EqSet.In a e1.","conclusion":"EqSet.In a e0 <-> EqSet.In a e1","hypotheses":"(e e0 e1 : eqs) (H : forall a0 : EqSet.elt, EqSet.In a0 e <-> EqSet.In a0 e0) (H0 : forall a0 : EqSet.elt, EqSet.In a0 e0 <-> EqSet.In a0 e1) (a : EqSet.elt)","proofString":"auto."},{"statement":"(x y : t) (H : match x with\n| OK a => match y with\n          | OK b => EqSet.equal a b\n          | Error _ => false\n          end\n| Error _ => match y with\n             | OK _ => false\n             | Error _ => true\n             end\nend = true) : match x with\n| OK a => match y with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match y with\n             | OK _ => False\n             | Error _ => True\n             end\nend.","conclusion":"match x with\n| OK a => match y with\n          | OK b => EqSet.Equal a b\n          | Error _ => False\n          end\n| Error _ => match y with\n             | OK _ => False\n             | Error _ => True\n             end\nend","hypotheses":"(x y : t) (H : match x with\n| OK a => match y with\n          | OK b => EqSet.equal a b\n          | Error _ => false\n          end\n| Error _ => match y with\n             | OK _ => false\n             | Error _ => true\n             end\nend = true)","proofString":"destruct x; destruct y.\napply EqSet.equal_2.\nauto.\ndiscriminate.\ndiscriminate.\nauto."},{"statement":"(e e0 : eqs) (H : EqSet.equal e e0 = true) : EqSet.Equal e e0.","conclusion":"EqSet.Equal e e0","hypotheses":"(e e0 : eqs) (H : EqSet.equal e e0 = true)","proofString":"apply EqSet.equal_2.\nauto."},{"statement":"(e e0 : eqs) (H : EqSet.equal e e0 = true) : EqSet.equal e e0 = true.","conclusion":"EqSet.equal e e0 = true","hypotheses":"(e e0 : eqs) (H : EqSet.equal e e0 = true)","proofString":"auto."},{"statement":"(e : eqs) (e0 : errmsg) (H : false = true) : False.","conclusion":"False","hypotheses":"(e : eqs) (e0 : errmsg) (H : false = true)","proofString":"discriminate."},{"statement":"(e : errmsg) (e0 : eqs) (H : false = true) : False.","conclusion":"False","hypotheses":"(e : errmsg) (e0 : eqs) (H : false = true)","proofString":"discriminate."},{"statement":"(e e0 : errmsg) (H : true = true) : True.","conclusion":"True","hypotheses":"(e e0 : errmsg) (H : true = true)","proofString":"auto."},{"statement":"(x y : t) (H : match x with\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 a <-> EqSet.In a0 b\n    | Error _ => False\n    end\n| Error _ => match y with\n             | OK _ => False\n             | Error _ => True\n             end\nend) : match x with\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend.","conclusion":"match x with\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend","hypotheses":"(x y : t) (H : match x with\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 a <-> EqSet.In a0 b\n    | Error _ => False\n    end\n| Error _ => match y with\n             | OK _ => False\n             | Error _ => True\n             end\nend)","proofString":"destruct x; destruct y; auto.\nintros; rewrite H; auto."},{"statement":"(e e0 : eqs) (H : forall a : EqSet.elt, EqSet.In a e <-> EqSet.In a e0) : forall a : EqSet.elt, EqSet.In a e0 -> EqSet.In a e.","conclusion":"forall a : EqSet.elt, EqSet.In a e0 -> EqSet.In a e","hypotheses":"(e e0 : eqs) (H : forall a : EqSet.elt, EqSet.In a e <-> EqSet.In a e0)","proofString":"intros; rewrite H; auto."},{"statement":"(x y z : t) (H : match x with\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend) (H0 : match y with\n| OK a =>\n    match z with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend) : match x with\n| OK a =>\n    match z with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend.","conclusion":"match x with\n| OK a =>\n    match z with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend","hypotheses":"(x y z : t) (H : match x with\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend) (H0 : match y with\n| OK a =>\n    match z with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend)","proofString":"destruct x; auto; destruct y; try contradiction.\ndestruct z; eauto."},{"statement":"(e e0 : eqs) (z : t) (H : forall a : EqSet.elt, EqSet.In a e0 -> EqSet.In a e) (H0 : match z with\n| OK b => forall a : EqSet.elt, EqSet.In a b -> EqSet.In a e0\n| Error _ => False\nend) : match z with\n| OK b => forall a : EqSet.elt, EqSet.In a b -> EqSet.In a e\n| Error _ => False\nend.","conclusion":"match z with\n| OK b => forall a : EqSet.elt, EqSet.In a b -> EqSet.In a e\n| Error _ => False\nend","hypotheses":"(e e0 : eqs) (z : t) (H : forall a : EqSet.elt, EqSet.In a e0 -> EqSet.In a e) (H0 : match z with\n| OK b => forall a : EqSet.elt, EqSet.In a b -> EqSet.In a e0\n| Error _ => False\nend)","proofString":"destruct z; eauto."},{"statement":"(x : t) : match x with\n| OK a => forall a0 : EqSet.elt, EqSet.In a0 EqSet.empty -> EqSet.In a0 a\n| Error _ => True\nend.","conclusion":"match x with\n| OK a => forall a0 : EqSet.elt, EqSet.In a0 EqSet.empty -> EqSet.In a0 a\n| Error _ => True\nend","hypotheses":"(x : t)","proofString":"destruct x; auto.\nintros.\nelim (EqSet.empty_1 H)."},{"statement":"(e : eqs) : forall a : EqSet.elt, EqSet.In a EqSet.empty -> EqSet.In a e.","conclusion":"forall a : EqSet.elt, EqSet.In a EqSet.empty -> EqSet.In a e","hypotheses":"(e : eqs)","proofString":"intros.\nelim (EqSet.empty_1 H)."},{"statement":"(e : eqs) (a : EqSet.elt) (H : EqSet.In a EqSet.empty) : EqSet.In a e.","conclusion":"EqSet.In a e","hypotheses":"(e : eqs) (a : EqSet.elt) (H : EqSet.In a EqSet.empty)","proofString":"elim (EqSet.empty_1 H)."},{"statement":"(x y : t) : match\n  match x with\n  | OK a =>\n      match y with\n      | OK b =>\n          OK\n            {|\n              eqs1 := EqSet.union a b;\n              eqs2 := EqSet2.union (eqs2 a) (eqs2 b);\n              eqs_same := fun q : EqSet2.elt => lub_obligation_1 a b q\n            |}\n      | Error _ => y\n      end\n  | Error _ => x\n  end\nwith\n| OK a =>\n    match x with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend.","conclusion":"match\n  match x with\n  | OK a =>\n      match y with\n      | OK b =>\n          OK\n            {|\n              eqs1 := EqSet.union a b;\n              eqs2 := EqSet2.union (eqs2 a) (eqs2 b);\n              eqs_same := fun q : EqSet2.elt => lub_obligation_1 a b q\n            |}\n      | Error _ => y\n      end\n  | Error _ => x\n  end\nwith\n| OK a =>\n    match x with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend","hypotheses":"(x y : t)","proofString":"destruct x; destruct y; auto.\nintros; apply EqSet.union_2; auto."},{"statement":"(e e0 : eqs) : forall a : EqSet.elt,\nEqSet.In a e ->\nEqSet.In a\n  {|\n    eqs1 := EqSet.union e e0;\n    eqs2 := EqSet2.union (eqs2 e) (eqs2 e0);\n    eqs_same := fun q : EqSet2.elt => lub_obligation_1 e e0 q\n  |}.","conclusion":"forall a : EqSet.elt,\nEqSet.In a e ->\nEqSet.In a\n  {|\n    eqs1 := EqSet.union e e0;\n    eqs2 := EqSet2.union (eqs2 e) (eqs2 e0);\n    eqs_same := fun q : EqSet2.elt => lub_obligation_1 e e0 q\n  |}","hypotheses":"(e e0 : eqs)","proofString":"intros; apply EqSet.union_2; auto."},{"statement":"(x y : t) : match\n  match x with\n  | OK a =>\n      match y with\n      | OK b =>\n          OK\n            {|\n              eqs1 := EqSet.union a b;\n              eqs2 := EqSet2.union (eqs2 a) (eqs2 b);\n              eqs_same := fun q : EqSet2.elt => lub_obligation_1 a b q\n            |}\n      | Error _ => y\n      end\n  | Error _ => x\n  end\nwith\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend.","conclusion":"match\n  match x with\n  | OK a =>\n      match y with\n      | OK b =>\n          OK\n            {|\n              eqs1 := EqSet.union a b;\n              eqs2 := EqSet2.union (eqs2 a) (eqs2 b);\n              eqs_same := fun q : EqSet2.elt => lub_obligation_1 a b q\n            |}\n      | Error _ => y\n      end\n  | Error _ => x\n  end\nwith\n| OK a =>\n    match y with\n    | OK b => forall a0 : EqSet.elt, EqSet.In a0 b -> EqSet.In a0 a\n    | Error _ => False\n    end\n| Error _ => True\nend","hypotheses":"(x y : t)","proofString":"destruct x; destruct y; auto.\nintros; apply EqSet.union_3; auto."},{"statement":"(e e0 : eqs) : forall a : EqSet.elt,\nEqSet.In a e0 ->\nEqSet.In a\n  {|\n    eqs1 := EqSet.union e e0;\n    eqs2 := EqSet2.union (eqs2 e) (eqs2 e0);\n    eqs_same := fun q : EqSet2.elt => lub_obligation_1 e e0 q\n  |}.","conclusion":"forall a : EqSet.elt,\nEqSet.In a e0 ->\nEqSet.In a\n  {|\n    eqs1 := EqSet.union e e0;\n    eqs2 := EqSet2.union (eqs2 e) (eqs2 e0);\n    eqs_same := fun q : EqSet2.elt => lub_obligation_1 e e0 q\n  |}","hypotheses":"(e e0 : eqs)","proofString":"intros; apply EqSet.union_3; auto."}]}