{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/traces/ThreadTrace.v","fileSamples":[{"statement":"(n : nat) (t : thread_id) : ThreadEvent t ↑₁ seq_set (1 + n)\n≡₁ ThreadEvent t ↑₁ seq_set n ∪₁ eq (ThreadEvent t n).","proofString":"rewrite seq_set_S, set_collect_union.\nbasic_solver."},{"statement":"(n : nat) (t : thread_id) : ThreadEvent t ↑₁ seq_set n ∪₁ ThreadEvent t ↑₁ eq n\n≡₁ ThreadEvent t ↑₁ seq_set n ∪₁ eq (ThreadEvent t n).","proofString":"basic_solver."},{"statement":"(t : thread_id) : set_size (thread_seq_set t 0) = NOnum 0.","proofString":"apply set_size_empty.\nunfold thread_seq_set.\nrewrite seq_set_0.\nbasic_solver."},{"statement":"(t : thread_id) : thread_seq_set t 0 ≡₁ ∅.","proofString":"unfold thread_seq_set.\nrewrite seq_set_0.\nbasic_solver."},{"statement":"(t : thread_id) : ThreadEvent t ↑₁ seq_set 0 ≡₁ ∅.","proofString":"rewrite seq_set_0.\nbasic_solver."},{"statement":"(t : thread_id) : ThreadEvent t ↑₁ ∅ ≡₁ ∅.","proofString":"basic_solver."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : set_size (thread_seq_set t (S n)) = NOnum (S n).","proofString":"rewrite thread_set_S.\nerewrite set_size_union_disjoint with (a:=n) (b:=1);    auto using set_size_single.\nf_equal.\nlia.\nunfolder.\nins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : set_size (thread_seq_set t n ∪₁ eq (ThreadEvent t n)) = NOnum (S n).","proofString":"erewrite set_size_union_disjoint with (a:=n) (b:=1);    auto using set_size_single.\nf_equal.\nlia.\nunfolder.\nins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : NOnum (n + 1) = NOnum (S n).","proofString":"f_equal.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : n + 1 = S n.","proofString":"lia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : set_disjoint (thread_seq_set t n) (eq (ThreadEvent t n)).","proofString":"unfolder.\nins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : forall x : actid,\n(exists y : nat, y < n /\\ ThreadEvent t y = x) ->\nThreadEvent t n = x -> False.","proofString":"ins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) (x : actid) (IN : exists y : nat, y < n /\\ ThreadEvent t y = x) (IN' : ThreadEvent t n = x) : False.","proofString":"desf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) (IN : n < n) : False.","proofString":"lia."},{"statement":"(t : thread_id) (n n' : nat) (EQ : NOnum n' = NOnum n) : thread_seq_set t n' ≡₁ thread_seq_set t n.","proofString":"desf."},{"statement":"(t : thread_id) (n n' : nat) (LE : n' <= n) : ThreadEvent t ↑₁ seq_set n' ⊆₁ ThreadEvent t ↑₁ seq_set n.","proofString":"now apply set_subset_collect, seq_set_sub."},{"statement":"(t : thread_id) (k n : nat) (H : k < n) : exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k.","proofString":"eauto."},{"statement":"(t : thread_id) (k n : nat) : ~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k) -> n <= k.","proofString":"destruct (classic (k < n)) as [LT|LT]; try lia.\nins; exfalso; eauto."},{"statement":"(t : thread_id) (k n : nat) (LT : k < n) : ~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k) -> n <= k.","proofString":"ins; exfalso; eauto."},{"statement":"(t : thread_id) (k n : nat) : n <= k -> ~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k).","proofString":"intros LE F; desf.\nlia."},{"statement":"(t : thread_id) (k n : nat) (LE : n <= k) (F : k < n) : False.","proofString":"lia."},{"statement":"(t : thread_id) (n n' : nat) : thread_seq_set t n' \\₁ thread_seq_set t n\n≡₁ ThreadEvent t ↑₁ (seq_set n' \\₁ seq_set n).","proofString":"unfolder; split; ins; desf.\nexists y; split; try easy.\nsplit; try easy.\ndestruct (classic (y < n)) as [LT|LT]; eauto.\nsplit; eauto.\napply all_not_not_ex.\nintros n'' F; desf."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)) : exists y0 : nat, (y0 < n' /\\ ~ y0 < n) /\\ ThreadEvent t y0 = ThreadEvent t y.","proofString":"exists y; split; try easy.\nsplit; try easy.\ndestruct (classic (y < n)) as [LT|LT]; eauto."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)) : y < n' /\\ ~ y < n.","proofString":"split; try easy.\ndestruct (classic (y < n)) as [LT|LT]; eauto."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)) : ~ y < n.","proofString":"destruct (classic (y < n)) as [LT|LT]; eauto."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n) : (exists y0 : nat, y0 < n' /\\ ThreadEvent t y0 = ThreadEvent t y) /\\\n~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y).","proofString":"split; eauto.\napply all_not_not_ex.\nintros n'' F; desf."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n) : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y).","proofString":"apply all_not_not_ex.\nintros n'' F; desf."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n) : forall n0 : nat, ~ (n0 < n /\\ ThreadEvent t n0 = ThreadEvent t y).","proofString":"intros n'' F; desf."},{"statement":"(t : thread_id) (n : nat) : forall b : actid,\next_sb (ThreadEvent t (n - 1)) b /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t (n - 1)) /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = b) -> False.","proofString":"ins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (b : actid) (REL : match b with\n| InitEvent _ => False\n| ThreadEvent t' i' => t = t' /\\ n - 1 < i'\nend /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t (n - 1)) /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = b)) : False.","proofString":"desf.\nlia."},{"statement":"(t : thread_id) (n y : nat) (REL : t = t /\\ n - 1 < y) (REL0 : n - 1 < n) (REL1 : y < n) : False.","proofString":"lia."},{"statement":"(t : thread_id) (n : nat) (e1 e2 : actid) (NINIT : ~ is_init e1) (HIN : exists y : nat, y < n /\\ ThreadEvent t y = e2) (SB : match e1 with\n| InitEvent _ =>\n    match e2 with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t0 i =>\n    match e2 with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t0 = t' /\\ i < i'\n    end\nend) : exists y : nat, y < n /\\ ThreadEvent t y = e1.","proofString":"desf.\nexists index; split; [lia| desf]."},{"statement":"(t : thread_id) (n : nat) (thread : thread_id) (index : nat) (NINIT : ~ is_init (ThreadEvent thread index)) (y : nat) (HIN : y < n) (SB : thread = t /\\ index < y) : exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent thread index.","proofString":"exists index; split; [lia| desf]."},{"statement":"(thr : thread_id) (K : nat) : (exists x : nat, ThreadEvent thr x = ThreadEvent thr K /\\ In x (List.seq 0 N)) <->\nIn K (List.seq 0 N).","proofString":"split; ins; desf; eauto."},{"statement":"trace_map (ThreadEvent t)\n  match set_size Et with\n  | NOinfinity => trace_inf (fun x : nat => x)\n  | NOnum n => trace_fin (List.seq 0 n)\n  end = trace_map (ThreadEvent t) (trace_fin (List.seq 0 N)).","proofString":"now rewrite THREAD_EVENTS, thread_seq_set_size."},{"statement":"(K : nat) : In (ThreadEvent t K) (map (ThreadEvent t) (List.seq 0 N)) <-> K < N.","proofString":"apply thread_seq_helper."},{"statement":"trace_length (trace_map (ThreadEvent t) (trace_fin (List.seq 0 N))) = NOnum N.","proofString":"simpl.\nnow rewrite map_length, seq_length."},{"statement":"NOnum (length (map (ThreadEvent t) (List.seq 0 N))) = NOnum N.","proofString":"now rewrite map_length, seq_length."},{"statement":"(n : nat) (d : actid) (LT : n < N) : nth n (map (ThreadEvent t) (List.seq 0 N)) (ThreadEvent t 0) =\nThreadEvent t n.","proofString":"now rewrite map_nth, seq_nth."},{"statement":"thread_seq_set t N ≡₁ ThreadEvent t ↑₁ trace_elems (trace_fin (List.seq 0 N)).","proofString":"unfold thread_seq_set.\nins.\napply set_collect_more; auto.\nunfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"ThreadEvent t ↑₁ seq_set N\n≡₁ ThreadEvent t ↑₁ trace_elems (trace_fin (List.seq 0 N)).","proofString":"ins.\napply set_collect_more; auto.\nunfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"ThreadEvent t ↑₁ seq_set N\n≡₁ ThreadEvent t ↑₁ (fun a : nat => In a (List.seq 0 N)).","proofString":"apply set_collect_more; auto.\nunfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"seq_set N ≡₁ (fun a : nat => In a (List.seq 0 N)).","proofString":"unfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"forall i j : nat,\ni < j ->\nNOmega.lt_nat_l j (trace_length thread_actid_trace) ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","proofString":"rewrite thread_actid_trace_length.\nsimpl.\nintros i j LT SZ d.\nrewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"forall i j : nat,\ni < j ->\nNOmega.lt_nat_l j (NOnum N) ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","proofString":"simpl.\nintros i j LT SZ d.\nrewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"forall i j : nat,\ni < j ->\nj < N ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","proofString":"intros i j LT SZ d.\nrewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"(i j : nat) (LT : i < j) (SZ : j < N) (d : actid) : trace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","proofString":"rewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"(i j : nat) (LT : i < j) (SZ : j < N) (d : actid) : ThreadEvent t i <> ThreadEvent t j.","proofString":"injection; lia."},{"statement":"lab ↑₁ Et ≡₁ trace_elems (trace_map lab thread_actid_trace).","proofString":"now rewrite trace_elems_map, trace_elems_eq_thread_events."},{"statement":"(n : nat) (d : label) (LT : n < N) : trace_nth n (trace_map lab thread_actid_trace) (lab (ThreadEvent t 0)) =\nlab (ThreadEvent t n).","proofString":"now rewrite trace_nth_map, thread_actid_trace_nth."},{"statement":"(n : nat) (d : label) (LT : n < N) : NOmega.lt_nat_l n (trace_length (trace_map lab thread_actid_trace)).","proofString":"rewrite trace_length_map, thread_actid_trace_length; ins."},{"statement":"(G : execution) (e : actid) (d : label) (NINIT : match e with\n| InitEvent _ => tid_init\n| ThreadEvent i _ => i\nend <> tid_init) (CONT : contigious_actids G) (IN : acts_set G e) : trace_nth (index e)\n  (thread_trace G\n     match e with\n     | InitEvent _ => tid_init\n     | ThreadEvent i _ => i\n     end) d = lab G e.","proofString":"destruct e as [el | et en]; [congruence |].\nred in CONT.\ndestruct (CONT _ NINIT) as [N EQ].\nrewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : contigious_actids G) (IN : acts_set G (ThreadEvent et en)) : trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en).","proofString":"red in CONT.\ndestruct (CONT _ NINIT) as [N EQ].\nrewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N) (IN : acts_set G (ThreadEvent et en)) : trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en).","proofString":"destruct (CONT _ NINIT) as [N EQ].\nrewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) : trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en).","proofString":"rewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) : index (ThreadEvent et en) < N.","proofString":"assert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en).","proofString":"basic_solver."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (IN' : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)) : index (ThreadEvent et en) < N.","proofString":"ins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (IN' : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)) : en < N.","proofString":"now apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (N : nat) (t : BinNums.positive) (EQ : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N) : acts_set G ∩₁ (fun e : actid => t = tid e) ⊆₁ acts_set G.","proofString":"basic_solver."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e))).","proofString":"now apply set_size_mori."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) : trace_prefix (thread_actid_trace G' t) (thread_actid_trace G t).","proofString":"unfold thread_actid_trace; desf; ins.\nsetoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\neasy.\nrewrite nth_indep with (d' := ThreadEvent t 0); auto.\nrewrite map_nth, seq_nth; auto.\nnow autorewrite with calc_length in LLEN.\nsetoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\nunfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (n : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n) : False.","proofString":"setoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\neasy."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new NOinfinity (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (n : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n) : False.","proofString":"setoid_rewrite Heq0 in LE.\neasy."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n : nat) (LE : le_new NOinfinity (NOnum n)) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n) : False.","proofString":"easy."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid) : ThreadEvent t i = nth i (map (ThreadEvent t) (List.seq 0 n)) d.","proofString":"rewrite nth_indep with (d' := ThreadEvent t 0); auto.\nrewrite map_nth, seq_nth; auto.\nnow autorewrite with calc_length in LLEN."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid) : ThreadEvent t i =\nnth i (map (ThreadEvent t) (List.seq 0 n)) (ThreadEvent t 0).","proofString":"rewrite map_nth, seq_nth; auto.\nnow autorewrite with calc_length in LLEN."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid) : i < n.","proofString":"now autorewrite with calc_length in LLEN."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (n0 : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","proofString":"setoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\nunfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n : nat) (LE : le_new (NOnum n) (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (n0 : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","proofString":"setoid_rewrite Heq0 in LE.\nunfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : le_new (NOnum n) (NOnum n0)) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","proofString":"unfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","proofString":"exists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : map (ThreadEvent t) (List.seq 0 n0) =\nmap (ThreadEvent t) (List.seq 0 n) ++\nmap (ThreadEvent t) (List.seq n (n0 - n)).","proofString":"rewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : map (ThreadEvent t) (List.seq 0 n0) =\nmap (ThreadEvent t) (List.seq 0 (n + (n0 - n))).","proofString":"do 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : n0 = n + (n0 - n).","proofString":"lia."},{"statement":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (SZ_EQ : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum N) (CONT_APP : exists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N.","proofString":"desf.\nrewrite CONT_APP in SZ_EQ.\nrewrite CONT_APP, thread_seq_N_eq_set_size; eauto."},{"statement":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (SZ_EQ : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum N) (N0 : nat) (CONT_APP : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N.","proofString":"rewrite CONT_APP in SZ_EQ.\nrewrite CONT_APP, thread_seq_N_eq_set_size; eauto."},{"statement":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (N0 : nat) (SZ_EQ : set_size (thread_seq_set t N0) = NOnum N) (CONT_APP : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N.","proofString":"rewrite CONT_APP, thread_seq_N_eq_set_size; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : ThreadEvent t idx = ThreadEvent t N.","proofString":"f_equal; enough (N <= idx < N + 1) by lia.\napply seq_set_diff.\nenough (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N)          (ThreadEvent t idx)).\nunfolder in HIN; split; desf; eauto.\nsplit; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : N <= idx < N + 1.","proofString":"apply seq_set_diff.\nenough (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N)          (ThreadEvent t idx)).\nunfolder in HIN; split; desf; eauto.\nsplit; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : (seq_set (N + 1) \\₁ seq_set N) idx.","proofString":"enough (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N)          (ThreadEvent t idx)).\nunfolder in HIN; split; desf; eauto.\nsplit; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N) (ThreadEvent t idx)) : (seq_set (N + 1) \\₁ seq_set N) idx.","proofString":"unfolder in HIN; split; desf; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N) (ThreadEvent t idx).","proofString":"split; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : thread_seq_set t (N + 1) (ThreadEvent t idx).","proofString":"eapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum (N + 1).","proofString":"change (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : set_size (acts_set G' ∩₁ same_tid (ThreadEvent t idx)) = NOnum (N + 1).","proofString":"erewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(e : actid) (N : nat) (G : execution) (NOT_INIT : tid e <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (NOTIN : ~ acts_set G e) (F : trace_elems (thread_actid_trace G (tid e)) e) : False.","proofString":"eapply trace_elems_eq_thread_events in F.\neapply NOTIN, in_restr_acts; eauto.\napply contactids_eq; eauto."},{"statement":"(e : actid) (N : nat) (G : execution) (NOT_INIT : tid e <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (NOTIN : ~ acts_set G e) (F : (acts_set G ∩₁ (fun e0 : actid => tid e = tid e0)) e) : False.","proofString":"eapply NOTIN, in_restr_acts; eauto."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) : trace_map (upd (lab G) e l)\n  (trace_app (thread_actid_trace G (tid e)) (trace_fin [e])) =\ntrace_app (trace_map (lab G) (thread_actid_trace G (tid e)))\n  (trace_fin [upd (lab G) e l e]).","proofString":"destruct (thread_actid_trace G (tid e)) eqn:Heq; ins.\nrewrite map_app, map_upd_irr; ins.\nintro F; eapply event_not_in_actid_trace; eauto.\nrewrite Heq; ins.\nexfalso.\nerewrite thread_actid_trace_form in Heq; ins.\neapply contactids_eq; eauto."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0) : trace_fin (map (upd (lab G) e l) (l0 ++ [e])) =\ntrace_fin (map (lab G) l0 ++ [upd (lab G) e l e]).","proofString":"rewrite map_app, map_upd_irr; ins.\nintro F; eapply event_not_in_actid_trace; eauto.\nrewrite Heq; ins."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0) : ~ In e l0.","proofString":"intro F; eapply event_not_in_actid_trace; eauto.\nrewrite Heq; ins."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0) (F : In e l0) : trace_elems (thread_actid_trace G (tid e)) e.","proofString":"rewrite Heq; ins."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (fl : nat -> actid) (Heq : thread_actid_trace G (tid e) = trace_inf fl) : trace_inf (fun x : nat => upd (lab G) e l (fl x)) =\ntrace_inf (fun x : nat => lab G (fl x)).","proofString":"exfalso.\nerewrite thread_actid_trace_form in Heq; ins.\neapply contactids_eq; eauto."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (fl : nat -> actid) (Heq : thread_actid_trace G (tid e) = trace_inf fl) : False.","proofString":"erewrite thread_actid_trace_form in Heq; ins.\neapply contactids_eq; eauto."}]}