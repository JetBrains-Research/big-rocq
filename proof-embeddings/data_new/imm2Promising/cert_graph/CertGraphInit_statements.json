{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/promising2ToImm/src/cert_graph/CertGraphInit.v","fileSamples":[{"statement":"(G : execution) (T : trav_label -> Prop) (thread : BinNums.positive) (FAIR : mem_fair G) : mem_fair (restrict G (E0 G T thread)).","conclusion":"mem_fair (restrict G (E0 G T thread))","hypotheses":"(G : execution) (T : trav_label -> Prop) (thread : BinNums.positive) (FAIR : mem_fair G)","proofString":"by apply restrict_fair."},{"statement":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal) : thread <> tid_init.","conclusion":"thread <> tid_init","hypotheses":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal)","proofString":"cdes LOCAL.\nauto."},{"statement":"forall e : actid,\nacts_set (restrict Gf (E0 Gf T thread)) e ->\nthreads_set (restrict Gf (E0 Gf T thread)) (tid e).","conclusion":"forall e : actid,\nacts_set (restrict Gf (E0 Gf T thread)) e ->\nthreads_set (restrict Gf (E0 Gf T thread)) (tid e)","hypotheses":"","proofString":"intros e HH.\napply WF.\napply HH."},{"statement":"(e : actid) (HH : acts_set (restrict Gf (E0 Gf T thread)) e) : threads_set (restrict Gf (E0 Gf T thread)) (tid e).","conclusion":"threads_set (restrict Gf (E0 Gf T thread)) (tid e)","hypotheses":"(e : actid) (HH : acts_set (restrict Gf (E0 Gf T thread)) e)","proofString":"apply WF.\napply HH."},{"statement":"(e : actid) (HH : acts_set (restrict Gf (E0 Gf T thread)) e) : acts_set Gf e.","conclusion":"acts_set Gf e","hypotheses":"(e : actid) (HH : acts_set (restrict Gf (E0 Gf T thread)) e)","proofString":"apply HH."},{"statement":"(t : thread_id) (LTB : threads_set Gf t) : Tid_ t ∩₁ (E0 Gf T thread ∩₁ acts_set Gf) \\₁ (fun a : actid => is_init a)\n⊆₁ mkCT Gf T thread t \\₁ (fun a : actid => is_init a).","conclusion":"Tid_ t ∩₁ (E0 Gf T thread ∩₁ acts_set Gf) \\₁ (fun a : actid => is_init a)\n⊆₁ mkCT Gf T thread t \\₁ (fun a : actid => is_init a)","hypotheses":"(t : thread_id) (LTB : threads_set Gf t)","proofString":"simpl.\nunfold mkCT.\nbasic_solver 10."},{"statement":"(t : thread_id) (LTB : threads_set Gf t) : Tid_ t ∩₁ (E0 Gf T thread ∩₁ acts_set Gf) \\₁ (fun a : actid => is_init a)\n⊆₁ mkCT Gf T thread t \\₁ (fun a : actid => is_init a).","conclusion":"Tid_ t ∩₁ (E0 Gf T thread ∩₁ acts_set Gf) \\₁ (fun a : actid => is_init a)\n⊆₁ mkCT Gf T thread t \\₁ (fun a : actid => is_init a)","hypotheses":"(t : thread_id) (LTB : threads_set Gf t)","proofString":"unfold mkCT.\nbasic_solver 10."},{"statement":"(t : thread_id) (LTB : threads_set Gf t) : Tid_ t ∩₁ (E0 Gf T thread ∩₁ acts_set Gf) \\₁ (fun a : actid => is_init a)\n⊆₁ E0 Gf T thread ∩₁ Tid_ t \\₁ (fun a : actid => is_init a).","conclusion":"Tid_ t ∩₁ (E0 Gf T thread ∩₁ acts_set Gf) \\₁ (fun a : actid => is_init a)\n⊆₁ E0 Gf T thread ∩₁ Tid_ t \\₁ (fun a : actid => is_init a)","hypotheses":"(t : thread_id) (LTB : threads_set Gf t)","proofString":"basic_solver 10."},{"statement":"sub_execution Gf G sc Gsc.","conclusion":"sub_execution Gf G sc Gsc","hypotheses":"","proofString":"apply restrict_sub; eauto.\nrewrite <- E_E0, E_E0, E0_in_Gf; auto."},{"statement":"E0 Gf T thread ⊆₁ acts_set Gf.","conclusion":"E0 Gf T thread ⊆₁ acts_set Gf","hypotheses":"","proofString":"rewrite <- E_E0, E_E0, E0_in_Gf; auto."},{"statement":"(fun a : actid => is_w (lab Gf) a) ∩₁ (fun a : actid => is_rel (lab Gf) a)\n∩₁ issued T ⊆₁ covered T.","conclusion":"(fun a : actid => is_w (lab Gf) a) ∩₁ (fun a : actid => is_rel (lab Gf) a)\n∩₁ issued T ⊆₁ covered T","hypotheses":"","proofString":"eauto."},{"statement":"dom_rel (⦗fun a : actid => is_r (lab G) a⦘ ⨾ ppo G ⨾ ⦗issued T⦘)\n⊆₁ codom_rel (rf G).","conclusion":"dom_rel (⦗fun a : actid => is_r (lab G) a⦘ ⨾ ppo G ⨾ ⦗issued T⦘)\n⊆₁ codom_rel (rf G)","hypotheses":"","proofString":"rewrite dom_eqv1.\nrewrite set_interC.\napply COMP_PPO."},{"statement":"(fun a : actid => is_r (lab G) a) ∩₁ dom_rel (ppo G ⨾ ⦗issued T⦘)\n⊆₁ codom_rel (rf G).","conclusion":"(fun a : actid => is_r (lab G) a) ∩₁ dom_rel (ppo G ⨾ ⦗issued T⦘)\n⊆₁ codom_rel (rf G)","hypotheses":"","proofString":"rewrite set_interC.\napply COMP_PPO."},{"statement":"dom_rel (ppo G ⨾ ⦗issued T⦘) ∩₁ (fun a : actid => is_r (lab G) a)\n⊆₁ codom_rel (rf G).","conclusion":"dom_rel (ppo G ⨾ ⦗issued T⦘) ∩₁ (fun a : actid => is_r (lab G) a)\n⊆₁ codom_rel (rf G)","hypotheses":"","proofString":"apply COMP_PPO."},{"statement":"rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘\n⊆ ⦗NTid_ thread⦘ ⨾ rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘.","conclusion":"rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘\n⊆ ⦗NTid_ thread⦘ ⨾ rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘","hypotheses":"","proofString":"intros x y HH.\napply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r in HH.\ndestruct HH as [RMW [AA BB]].\nintros CC.\napply AA.\nrewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (HH : (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y) : (⦗NTid_ thread⦘ ⨾ rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y.","conclusion":"(⦗NTid_ thread⦘ ⨾ rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y","hypotheses":"(x y : actid) (HH : (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y)","proofString":"apply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r in HH.\ndestruct HH as [RMW [AA BB]].\nintros CC.\napply AA.\nrewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (HH : (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y) : tid x <> thread /\\ (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y.","conclusion":"tid x <> thread /\\ (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y","hypotheses":"(x y : actid) (HH : (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y)","proofString":"split; auto.\napply seq_eqv_r in HH.\ndestruct HH as [RMW [AA BB]].\nintros CC.\napply AA.\nrewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (HH : (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y) : tid x <> thread.","conclusion":"tid x <> thread","hypotheses":"(x y : actid) (HH : (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘) x y)","proofString":"apply seq_eqv_r in HH.\ndestruct HH as [RMW [AA BB]].\nintros CC.\napply AA.\nrewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (HH : rmw Gf x y /\\ (NTid_ thread ∩₁ issued T) y) : tid x <> thread.","conclusion":"tid x <> thread","hypotheses":"(x y : actid) (HH : rmw Gf x y /\\ (NTid_ thread ∩₁ issued T) y)","proofString":"destruct HH as [RMW [AA BB]].\nintros CC.\napply AA.\nrewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) : tid x <> thread.","conclusion":"tid x <> thread","hypotheses":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y)","proofString":"intros CC.\napply AA.\nrewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread) : False.","conclusion":"False","hypotheses":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread)","proofString":"apply AA.\nrewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread) : tid y = thread.","conclusion":"tid y = thread","hypotheses":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread)","proofString":"rewrite <- CC.\nsymmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread) : tid y = tid x.","conclusion":"tid y = tid x","hypotheses":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread)","proofString":"symmetry.\nby apply (wf_rmwt WF)."},{"statement":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread) : tid x = tid y.","conclusion":"tid x = tid y","hypotheses":"(x y : actid) (RMW : rmw Gf x y) (AA : tid y <> thread) (BB : issued T y) (CC : tid x = thread)","proofString":"by apply (wf_rmwt WF)."},{"statement":"(covered T ∪₁ issued T ∪₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ reserved T⦘))\n∩₁ Tid_ thread ⊆₁ acts_set Gf.","conclusion":"(covered T ∪₁ issued T ∪₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ reserved T⦘))\n∩₁ Tid_ thread ⊆₁ acts_set Gf","hypotheses":"","proofString":"erewrite coveredE, issuedE, rcoh_S_in_E; eauto.\nrewrite wf_sbE.\nbasic_solver."},{"statement":"(acts_set Gf ∪₁ acts_set Gf\n ∪₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ acts_set Gf⦘)) ∩₁ Tid_ thread\n⊆₁ acts_set Gf.","conclusion":"(acts_set Gf ∪₁ acts_set Gf\n ∪₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ acts_set Gf⦘)) ∩₁ Tid_ thread\n⊆₁ acts_set Gf","hypotheses":"","proofString":"rewrite wf_sbE.\nbasic_solver."},{"statement":"(acts_set Gf ∪₁ acts_set Gf\n ∪₁ dom_rel\n      ((⦗acts_set Gf⦘ ⨾ sb Gf ⨾ ⦗acts_set Gf⦘)^?\n       ⨾ ⦗Tid_ thread ∩₁ acts_set Gf⦘)) ∩₁ Tid_ thread ⊆₁ \nacts_set Gf.","conclusion":"(acts_set Gf ∪₁ acts_set Gf\n ∪₁ dom_rel\n      ((⦗acts_set Gf⦘ ⨾ sb Gf ⨾ ⦗acts_set Gf⦘)^?\n       ⨾ ⦗Tid_ thread ∩₁ acts_set Gf⦘)) ∩₁ Tid_ thread ⊆₁ \nacts_set Gf","hypotheses":"","proofString":"basic_solver."},{"statement":"dom_rel\n  (⦗fun a : actid => is_r (lab G) a⦘\n   ⨾ (data G ∪ rfi G ∪ rmw G)＊ ⨾ rppo G ⨾ ⦗reserved T⦘) ⊆₁ \ncodom_rel (rf G).","conclusion":"dom_rel\n  (⦗fun a : actid => is_r (lab G) a⦘\n   ⨾ (data G ∪ rfi G ∪ rmw G)＊ ⨾ rppo G ⨾ ⦗reserved T⦘) ⊆₁ \ncodom_rel (rf G)","hypotheses":"","proofString":"eapply COMP_RPPO; eauto."},{"statement":"reserved T ⊆₁ (fun a : actid => is_w (lab Gf) a).","conclusion":"reserved T ⊆₁ (fun a : actid => is_w (lab Gf) a)","hypotheses":"","proofString":"erewrite reservedW; eauto."},{"statement":"reserved T ∩₁ Tid_ thread ⊆₁ acts_set (rstG Gf T thread).","conclusion":"reserved T ∩₁ Tid_ thread ⊆₁ acts_set (rstG Gf T thread)","hypotheses":"","proofString":"rewrite E_E0; eauto.\nunfold E0.\nunionR left -> right.\nbasic_solver 10."},{"statement":"reserved T ∩₁ Tid_ thread ⊆₁ E0 Gf T thread.","conclusion":"reserved T ∩₁ Tid_ thread ⊆₁ E0 Gf T thread","hypotheses":"","proofString":"unfold E0.\nunionR left -> right.\nbasic_solver 10."},{"statement":"reserved T ∩₁ Tid_ thread\n⊆₁ covered T ∪₁ issued T ∪₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ reserved T⦘)\n   ∪₁ dom_rel (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘).","conclusion":"reserved T ∩₁ Tid_ thread\n⊆₁ covered T ∪₁ issued T ∪₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ reserved T⦘)\n   ∪₁ dom_rel (rmw Gf ⨾ ⦗NTid_ thread ∩₁ issued T⦘)","hypotheses":"","proofString":"unionR left -> right.\nbasic_solver 10."},{"statement":"reserved T ∩₁ Tid_ thread\n⊆₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ reserved T⦘).","conclusion":"reserved T ∩₁ Tid_ thread\n⊆₁ dom_rel ((sb Gf)^? ⨾ ⦗Tid_ thread ∩₁ reserved T⦘)","hypotheses":"","proofString":"basic_solver 10."},{"statement":"dom_rel\n  (⦗(fun a : actid => is_f (lab Gf) a) ∩₁ (fun a : actid => is_ra (lab G) a)⦘\n   ⨾ sb G ⨾ ⦗reserved T⦘) ⊆₁ covered T.","conclusion":"dom_rel\n  (⦗(fun a : actid => is_f (lab Gf) a) ∩₁ (fun a : actid => is_ra (lab G) a)⦘\n   ⨾ sb G ⨾ ⦗reserved T⦘) ⊆₁ covered T","hypotheses":"","proofString":"rewrite sub_AcqRel; eauto.\nrewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  (⦗(fun a : actid => is_f (lab Gf) a) ∩₁ (fun a : actid => is_ra (lab Gf) a)⦘\n   ⨾ sb G ⨾ ⦗reserved T⦘) ⊆₁ covered T.","conclusion":"dom_rel\n  (⦗(fun a : actid => is_f (lab Gf) a) ∩₁ (fun a : actid => is_ra (lab Gf) a)⦘\n   ⨾ sb G ⨾ ⦗reserved T⦘) ⊆₁ covered T","hypotheses":"","proofString":"rewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  (⦗(fun a : actid => is_f (lab Gf) a) ∩₁ (fun a : actid => is_ra (lab Gf) a)⦘\n   ⨾ sb Gf ⨾ ⦗reserved T⦘) ⊆₁ covered T.","conclusion":"dom_rel\n  (⦗(fun a : actid => is_f (lab Gf) a) ∩₁ (fun a : actid => is_ra (lab Gf) a)⦘\n   ⨾ sb Gf ⨾ ⦗reserved T⦘) ⊆₁ covered T","hypotheses":"","proofString":"apply RCOH."},{"statement":"dom_rel ((detour Gf ∪ rfe G) ⨾ rmw G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel ((detour Gf ∪ rfe G) ⨾ rmw G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_rfe_in; eauto.\nrewrite sub_rmw_in; eauto.\neapply rcoh_rmw_S with (T:=T); eauto."},{"statement":"dom_rel ((detour Gf ∪ rfe Gf) ⨾ rmw G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel ((detour Gf ∪ rfe Gf) ⨾ rmw G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_rmw_in; eauto.\neapply rcoh_rmw_S with (T:=T); eauto."},{"statement":"dom_rel ((detour Gf ∪ rfe Gf) ⨾ rmw Gf ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel ((detour Gf ∪ rfe Gf) ⨾ rmw Gf ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"eapply rcoh_rmw_S with (T:=T); eauto."},{"statement":"dom_rel (detour G ⨾ rmw G ⨾ ⦗reserved T⦘)\n⊆₁ dom_rel ((detour G ∪ rfe G) ⨾ rmw G ⨾ ⦗reserved T⦘).","conclusion":"dom_rel (detour G ⨾ rmw G ⨾ ⦗reserved T⦘)\n⊆₁ dom_rel ((detour G ∪ rfe G) ⨾ rmw G ⨾ ⦗reserved T⦘)","hypotheses":"","proofString":"clear.\nbasic_solver 10."},{"statement":"dom_rel (detour G ⨾ rmw G ⨾ ⦗reserved T⦘)\n⊆₁ dom_rel ((detour G ∪ rfe G) ⨾ rmw G ⨾ ⦗reserved T⦘).","conclusion":"dom_rel (detour G ⨾ rmw G ⨾ ⦗reserved T⦘)\n⊆₁ dom_rel ((detour G ∪ rfe G) ⨾ rmw G ⨾ ⦗reserved T⦘)","hypotheses":"","proofString":"basic_solver 10."},{"statement":"dom_rel\n  ((detour Gf ∪ rfe G)\n   ⨾ (rmw G ⨾ rfi G)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel\n  ((detour Gf ∪ rfe G)\n   ⨾ (rmw G ⨾ rfi G)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_rfe_in; eauto.\nrewrite sub_rmw_in; eauto.\nrewrite sub_rfi_in; eauto.\nrewrite sub_R; eauto.\nrewrite sub_Acq; eauto.\nrewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw G ⨾ rfi G)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw G ⨾ rfi G)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_rmw_in; eauto.\nrewrite sub_rfi_in; eauto.\nrewrite sub_R; eauto.\nrewrite sub_Acq; eauto.\nrewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi G)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi G)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_rfi_in; eauto.\nrewrite sub_R; eauto.\nrewrite sub_Acq; eauto.\nrewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab G) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_R; eauto.\nrewrite sub_Acq; eauto.\nrewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab Gf) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab Gf) a)\n        ∩₁ (fun a : actid => is_acq (lab G) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_Acq; eauto.\nrewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab Gf) a)\n        ∩₁ (fun a : actid => is_acq (lab Gf) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab Gf) a)\n        ∩₁ (fun a : actid => is_acq (lab Gf) a)⦘ ⨾ \n       sb G ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_sb_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab Gf) a)\n        ∩₁ (fun a : actid => is_acq (lab Gf) a)⦘ ⨾ \n       sb Gf ⨾ ⦗reserved T⦘) ⊆₁ issued T.","conclusion":"dom_rel\n  ((detour Gf ∪ rfe Gf)\n   ⨾ (rmw Gf ⨾ rfi Gf)＊\n     ⨾ ⦗(fun a : actid => is_r (lab Gf) a)\n        ∩₁ (fun a : actid => is_acq (lab Gf) a)⦘ ⨾ \n       sb Gf ⨾ ⦗reserved T⦘) ⊆₁ issued T","hypotheses":"","proofString":"apply RCOH."},{"statement":"new_rf G Gsc T thread ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘\n⊆ rf G ⨾ ⦗D G T thread⦘\n  ∪ new_rf G Gsc T thread ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n  ∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘.","conclusion":"new_rf G Gsc T thread ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘\n⊆ rf G ⨾ ⦗D G T thread⦘\n  ∪ new_rf G Gsc T thread ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n  ∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘","hypotheses":"","proofString":"basic_solver 20."},{"statement":"delta_rf ⊆ acts_set G × (acts_set G \\₁ D G T thread).","conclusion":"delta_rf ⊆ acts_set G × (acts_set G \\₁ D G T thread)","hypotheses":"","proofString":"arewrite (delta_rf ⊆ ⦗acts_set G⦘ ⨾ delta_rf ⨾ ⦗acts_set G⦘).\napply dom_helper_3.\nrewrite DELTA_RF_CERT.\nrewrite cert_rfE; eauto.\nclear.\nbasic_solver.\nunfold delta_rf.\nrewrite wf_new_rfE; auto.\nbasic_solver."},{"statement":"delta_rf ⊆ ⦗acts_set G⦘ ⨾ delta_rf ⨾ ⦗acts_set G⦘.","conclusion":"delta_rf ⊆ ⦗acts_set G⦘ ⨾ delta_rf ⨾ ⦗acts_set G⦘","hypotheses":"","proofString":"apply dom_helper_3.\nrewrite DELTA_RF_CERT.\nrewrite cert_rfE; eauto.\nclear.\nbasic_solver."},{"statement":"delta_rf ⊆ acts_set G × acts_set G.","conclusion":"delta_rf ⊆ acts_set G × acts_set G","hypotheses":"","proofString":"rewrite DELTA_RF_CERT.\nrewrite cert_rfE; eauto.\nclear.\nbasic_solver."},{"statement":"cert_rf G Gsc T thread ⊆ acts_set G × acts_set G.","conclusion":"cert_rf G Gsc T thread ⊆ acts_set G × acts_set G","hypotheses":"","proofString":"rewrite cert_rfE; eauto.\nclear.\nbasic_solver."},{"statement":"⦗acts_set G⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗acts_set G⦘\n⊆ acts_set G × acts_set G.","conclusion":"⦗acts_set G⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗acts_set G⦘\n⊆ acts_set G × acts_set G","hypotheses":"","proofString":"clear.\nbasic_solver."},{"statement":"⦗acts_set G⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗acts_set G⦘\n⊆ acts_set G × acts_set G.","conclusion":"⦗acts_set G⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗acts_set G⦘\n⊆ acts_set G × acts_set G","hypotheses":"","proofString":"basic_solver."},{"statement":"⦗acts_set G⦘ ⨾ delta_rf ⨾ ⦗acts_set G⦘\n⊆ acts_set G × (acts_set G \\₁ D G T thread).","conclusion":"⦗acts_set G⦘ ⨾ delta_rf ⨾ ⦗acts_set G⦘\n⊆ acts_set G × (acts_set G \\₁ D G T thread)","hypotheses":"","proofString":"unfold delta_rf.\nrewrite wf_new_rfE; auto.\nbasic_solver."},{"statement":"⦗acts_set G⦘\n⨾ (new_rf G Gsc T thread ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n   ∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘)\n  ⨾ ⦗acts_set G⦘ ⊆ acts_set G × (acts_set G \\₁ D G T thread).","conclusion":"⦗acts_set G⦘\n⨾ (new_rf G Gsc T thread ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n   ∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘)\n  ⨾ ⦗acts_set G⦘ ⊆ acts_set G × (acts_set G \\₁ D G T thread)","hypotheses":"","proofString":"rewrite wf_new_rfE; auto.\nbasic_solver."},{"statement":"⦗acts_set G⦘\n⨾ ((⦗acts_set G⦘ ⨾ new_rf G Gsc T thread ⨾ ⦗acts_set G \\₁ D G T thread⦘)\n   ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n   ∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘)\n  ⨾ ⦗acts_set G⦘ ⊆ acts_set G × (acts_set G \\₁ D G T thread).","conclusion":"⦗acts_set G⦘\n⨾ ((⦗acts_set G⦘ ⨾ new_rf G Gsc T thread ⨾ ⦗acts_set G \\₁ D G T thread⦘)\n   ⨾ ⦗set_compl (dom_rel (rmw G))⦘\n   ∪ immediate (cert_co G T thread) ⨾ (rmw G)⁻¹ ⨾ ⦗set_compl (D G T thread)⦘)\n  ⨾ ⦗acts_set G⦘ ⊆ acts_set G × (acts_set G \\₁ D G T thread)","hypotheses":"","proofString":"basic_solver."},{"statement":"delta_rf\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a).","conclusion":"delta_rf\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a)","hypotheses":"","proofString":"rewrite DELTA_RF_CERT.\nrewrite cert_rfD; auto.\nclear.\nbasic_solver 10."},{"statement":"cert_rf G Gsc T thread\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a).","conclusion":"cert_rf G Gsc T thread\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a)","hypotheses":"","proofString":"rewrite cert_rfD; auto.\nclear.\nbasic_solver 10."},{"statement":"⦗fun a : actid => is_w (lab G) a⦘\n⨾ cert_rf G Gsc T thread ⨾ ⦗fun a : actid => is_r (lab G) a⦘\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a).","conclusion":"⦗fun a : actid => is_w (lab G) a⦘\n⨾ cert_rf G Gsc T thread ⨾ ⦗fun a : actid => is_r (lab G) a⦘\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a)","hypotheses":"","proofString":"clear.\nbasic_solver 10."},{"statement":"⦗fun a : actid => is_w (lab G) a⦘\n⨾ cert_rf G Gsc T thread ⨾ ⦗fun a : actid => is_r (lab G) a⦘\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a).","conclusion":"⦗fun a : actid => is_w (lab G) a⦘\n⨾ cert_rf G Gsc T thread ⨾ ⦗fun a : actid => is_r (lab G) a⦘\n⊆ (fun a : actid => is_w (lab G) a) × (fun a : actid => is_r (lab G) a)","hypotheses":"","proofString":"basic_solver 10."},{"statement":"⦗Tid_ thread⦘ ⨾ delta_rf ⨾ ⦗Tid_ thread⦘ ⊆ cert_rf G Gsc T thread.","conclusion":"⦗Tid_ thread⦘ ⨾ delta_rf ⨾ ⦗Tid_ thread⦘ ⊆ cert_rf G Gsc T thread","hypotheses":"","proofString":"rewrite DELTA_RF_CERT.\nbasic_solver 20."},{"statement":"⦗Tid_ thread⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗Tid_ thread⦘\n⊆ cert_rf G Gsc T thread.","conclusion":"⦗Tid_ thread⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗Tid_ thread⦘\n⊆ cert_rf G Gsc T thread","hypotheses":"","proofString":"basic_solver 20."},{"statement":"functional (cert_rf G Gsc T thread)⁻¹.","conclusion":"functional (cert_rf G Gsc T thread)⁻¹","hypotheses":"","proofString":"apply cert_rff; auto."},{"statement":"⦗NTid_ thread⦘ ⨾ delta_rf ⨾ ⦗Tid_ thread⦘ ⊆ cert_rf G Gsc T thread.","conclusion":"⦗NTid_ thread⦘ ⨾ delta_rf ⨾ ⦗Tid_ thread⦘ ⊆ cert_rf G Gsc T thread","hypotheses":"","proofString":"rewrite DELTA_RF_CERT.\nbasic_solver 20."},{"statement":"⦗NTid_ thread⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗Tid_ thread⦘\n⊆ cert_rf G Gsc T thread.","conclusion":"⦗NTid_ thread⦘ ⨾ cert_rf G Gsc T thread ⨾ ⦗Tid_ thread⦘\n⊆ cert_rf G Gsc T thread","hypotheses":"","proofString":"basic_solver 20."},{"statement":"functional (cert_rf G Gsc T thread)⁻¹.","conclusion":"functional (cert_rf G Gsc T thread)⁻¹","hypotheses":"","proofString":"apply cert_rff; auto."},{"statement":"(r : actid) : exists ! w : actid, new_rfe_ex⁻¹ r w.","conclusion":"exists ! w : actid, new_rfe_ex⁻¹ r w","hypotheses":"(r : actid)","proofString":"destruct (classic ((codom_rel new_rfe) r)) as [X|X].\nunfolder in X; desf.\nexists x; red; splits.\nunfold new_rfe_ex; basic_solver 12.\nunfold new_rfe_ex; unfolder; ins; desf.\neapply new_rfef; basic_solver.\nexfalso; eauto.\nexists r; red; splits.\nunfold new_rfe_ex; basic_solver 12.\nunfold new_rfe_ex; unfolder; ins; desf.\nunfolder in X; exfalso; eauto."},{"statement":"(r : actid) (X : codom_rel new_rfe r) : exists ! w : actid, new_rfe_ex⁻¹ r w.","conclusion":"exists ! w : actid, new_rfe_ex⁻¹ r w","hypotheses":"(r : actid) (X : codom_rel new_rfe r)","proofString":"unfolder in X; desf.\nexists x; red; splits.\nunfold new_rfe_ex; basic_solver 12.\nunfold new_rfe_ex; unfolder; ins; desf.\neapply new_rfef; basic_solver.\nexfalso; eauto."},{"statement":"(r x : actid) (X : new_rfe x r) : exists ! w : actid, new_rfe_ex⁻¹ r w.","conclusion":"exists ! w : actid, new_rfe_ex⁻¹ r w","hypotheses":"(r x : actid) (X : new_rfe x r)","proofString":"exists x; red; splits.\nunfold new_rfe_ex; basic_solver 12.\nunfold new_rfe_ex; unfolder; ins; desf.\neapply new_rfef; basic_solver.\nexfalso; eauto."},{"statement":"(r x : actid) (X : new_rfe x r) : new_rfe_ex⁻¹ r x.","conclusion":"new_rfe_ex⁻¹ r x","hypotheses":"(r x : actid) (X : new_rfe x r)","proofString":"unfold new_rfe_ex; basic_solver 12."},{"statement":"(r x : actid) (X : new_rfe x r) : forall x' : actid, new_rfe_ex⁻¹ r x' -> x = x'.","conclusion":"forall x' : actid, new_rfe_ex⁻¹ r x' -> x = x'","hypotheses":"(r x : actid) (X : new_rfe x r)","proofString":"unfold new_rfe_ex; unfolder; ins; desf.\neapply new_rfef; basic_solver.\nexfalso; eauto."},{"statement":"(r x : actid) (X : new_rfe x r) (x' : actid) (H : new_rfe x' r) : x = x'.","conclusion":"x = x'","hypotheses":"(r x : actid) (X : new_rfe x r) (x' : actid) (H : new_rfe x' r)","proofString":"eapply new_rfef; basic_solver."},{"statement":"(r x : actid) (X : new_rfe x r) (H0 : ~ (exists x0 : actid, new_rfe x0 r)) : x = r.","conclusion":"x = r","hypotheses":"(r x : actid) (X : new_rfe x r) (H0 : ~ (exists x0 : actid, new_rfe x0 r))","proofString":"exfalso; eauto."},{"statement":"(r : actid) (X : ~ codom_rel new_rfe r) : exists ! w : actid, new_rfe_ex⁻¹ r w.","conclusion":"exists ! w : actid, new_rfe_ex⁻¹ r w","hypotheses":"(r : actid) (X : ~ codom_rel new_rfe r)","proofString":"exists r; red; splits.\nunfold new_rfe_ex; basic_solver 12.\nunfold new_rfe_ex; unfolder; ins; desf.\nunfolder in X; exfalso; eauto."},{"statement":"(r : actid) (X : ~ codom_rel new_rfe r) : new_rfe_ex⁻¹ r r.","conclusion":"new_rfe_ex⁻¹ r r","hypotheses":"(r : actid) (X : ~ codom_rel new_rfe r)","proofString":"unfold new_rfe_ex; basic_solver 12."},{"statement":"(r : actid) (X : ~ codom_rel new_rfe r) : forall x' : actid, new_rfe_ex⁻¹ r x' -> r = x'.","conclusion":"forall x' : actid, new_rfe_ex⁻¹ r x' -> r = x'","hypotheses":"(r : actid) (X : ~ codom_rel new_rfe r)","proofString":"unfold new_rfe_ex; unfolder; ins; desf.\nunfolder in X; exfalso; eauto."},{"statement":"(r : actid) (X : ~ codom_rel new_rfe r) (x' : actid) (H : new_rfe x' r) : r = x'.","conclusion":"r = x'","hypotheses":"(r : actid) (X : ~ codom_rel new_rfe r) (x' : actid) (H : new_rfe x' r)","proofString":"unfolder in X; exfalso; eauto."},{"statement":"dom_rel (sb G ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n⊆₁ reserved T.","conclusion":"dom_rel (sb G ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n⊆₁ reserved T","hypotheses":"","proofString":"rewrite sub_sb_in; eauto.\nrewrite sub_rf_in; eauto.\nrewrite sub_R_ex; eauto.\nrewrite sub_rmw_in; eauto.\napply RCOH."},{"statement":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n⊆₁ reserved T.","conclusion":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n⊆₁ reserved T","hypotheses":"","proofString":"rewrite sub_rf_in; eauto.\nrewrite sub_R_ex; eauto.\nrewrite sub_rmw_in; eauto.\napply RCOH."},{"statement":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n⊆₁ reserved T.","conclusion":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n⊆₁ reserved T","hypotheses":"","proofString":"rewrite sub_R_ex; eauto.\nrewrite sub_rmw_in; eauto.\napply RCOH."},{"statement":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw G)\n⊆₁ reserved T.","conclusion":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw G)\n⊆₁ reserved T","hypotheses":"","proofString":"rewrite sub_rmw_in; eauto.\napply RCOH."},{"statement":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T.","conclusion":"dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T","hypotheses":"","proofString":"apply RCOH."},{"statement":"dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab G) a).","conclusion":"dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab G) a)","hypotheses":"","proofString":"rewrite sub_R_ex; eauto.\ncdes SIMREL.\napply COMMON."},{"statement":"dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab Gf) a).","conclusion":"dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab Gf) a)","hypotheses":"","proofString":"cdes SIMREL.\napply COMMON."},{"statement":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal) : dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab Gf) a).","conclusion":"dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab Gf) a)","hypotheses":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal)","proofString":"apply COMMON."},{"statement":"issued T ⊆₁ reserved T -> issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T.","conclusion":"issued T ⊆₁ reserved T -> issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T","hypotheses":"","proofString":"simpls.\nbasic_solver."},{"statement":"issued T ⊆₁ reserved T -> issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T.","conclusion":"issued T ⊆₁ reserved T -> issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T","hypotheses":"","proofString":"basic_solver."},{"statement":"dom_rel\n  (⦗W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)⦘ ⨾ sb Gf ⨾ ⦗reserved T⦘)\n⊆₁ issued T.","conclusion":"dom_rel\n  (⦗W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)⦘ ⨾ sb Gf ⨾ ⦗reserved T⦘)\n⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_xacq; eauto.\nrewrite sub_W_ex_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  (⦗W_ex G ∩₁ (fun a : actid => is_xacq (lab Gf) a)⦘ ⨾ sb Gf ⨾ ⦗reserved T⦘)\n⊆₁ issued T.","conclusion":"dom_rel\n  (⦗W_ex G ∩₁ (fun a : actid => is_xacq (lab Gf) a)⦘ ⨾ sb Gf ⨾ ⦗reserved T⦘)\n⊆₁ issued T","hypotheses":"","proofString":"rewrite sub_W_ex_in; eauto.\napply RCOH."},{"statement":"dom_rel\n  (⦗W_ex Gf ∩₁ (fun a : actid => is_xacq (lab Gf) a)⦘ ⨾ sb Gf ⨾ ⦗reserved T⦘)\n⊆₁ issued T.","conclusion":"dom_rel\n  (⦗W_ex Gf ∩₁ (fun a : actid => is_xacq (lab Gf) a)⦘ ⨾ sb Gf ⨾ ⦗reserved T⦘)\n⊆₁ issued T","hypotheses":"","proofString":"apply RCOH."},{"statement":"dom_rel (rmw (rstG Gf T thread) ⨾ ⦗reserved T⦘)\n⊆₁ codom_rel (rf (rstG Gf T thread)).","conclusion":"dom_rel (rmw (rstG Gf T thread) ⨾ ⦗reserved T⦘)\n⊆₁ codom_rel (rf (rstG Gf T thread))","hypotheses":"","proofString":"eapply COMP_RMW_S; eauto."},{"statement":"init_tls (rstG Gf T thread) ⊆₁ T.","conclusion":"init_tls (rstG Gf T thread) ⊆₁ T","hypotheses":"","proofString":"rewrite <- init_tls_eq_rstG; auto.\ncdes SIMREL.\ncdes COMMON.\napply TCOH."},{"statement":"init_tls Gf ⊆₁ T.","conclusion":"init_tls Gf ⊆₁ T","hypotheses":"","proofString":"cdes SIMREL.\ncdes COMMON.\napply TCOH."},{"statement":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal) : init_tls Gf ⊆₁ T.","conclusion":"init_tls Gf ⊆₁ T","hypotheses":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal)","proofString":"cdes COMMON.\napply TCOH."},{"statement":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal) (ALLRLX : acts_set Gf \\₁ (fun a : actid => is_init a)\n⊆₁ (fun a : actid => is_rlx (lab Gf) a)) (FRELACQ : acts_set Gf ∩₁ (fun a : actid => is_f (lab Gf) a)\n⊆₁ (fun a : actid => is_ra (lab Gf) a)) (TLSCOH : tls_coherent Gf T) (IORDCOH : iord_coherent Gf sc T) (RCOH0 : reserve_coherent Gf T) (RELCOV0 : (fun a : actid => is_w (lab Gf) a) ∩₁ (fun a : actid => is_rel (lab Gf) a)\n∩₁ issued T ⊆₁ covered T) (RMWCOV0 : forall r w : actid, rmw Gf r w -> covered T r <-> covered T w) (THREAD : forall t : thread_id,\n(threads_set Gf \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : Event.language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH : FtoCoherent.f_to_coherent Gf (reserved T) f_to f_from) (SC_COV : sim_normal = sim_certification ->\nacts_set Gf ∩₁ (fun a : actid => is_f (lab Gf) a)\n∩₁ (fun a : actid => is_sc (lab Gf) a) ⊆₁ covered T) (SC_REQ : sim_normal = sim_normal ->\nforall l : location,\nmax_value f_to (S_tm Gf l (covered T)) (LocFun.find l (Configuration.sc PC))) (RMWREX0 : dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab Gf) a)) (RESERVED_TIME : reserved_time Gf T f_to f_from sim_normal (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC)) : init_tls Gf ⊆₁ T.","conclusion":"init_tls Gf ⊆₁ T","hypotheses":"(COMMON : simrel_common Gf sc PC T f_to f_from sim_normal) (LOCAL : simrel_thread_local Gf sc PC T f_to f_from thread sim_normal) (ALLRLX : acts_set Gf \\₁ (fun a : actid => is_init a)\n⊆₁ (fun a : actid => is_rlx (lab Gf) a)) (FRELACQ : acts_set Gf ∩₁ (fun a : actid => is_f (lab Gf) a)\n⊆₁ (fun a : actid => is_ra (lab Gf) a)) (TLSCOH : tls_coherent Gf T) (IORDCOH : iord_coherent Gf sc T) (RCOH0 : reserve_coherent Gf T) (RELCOV0 : (fun a : actid => is_w (lab Gf) a) ∩₁ (fun a : actid => is_rel (lab Gf) a)\n∩₁ issued T ⊆₁ covered T) (RMWCOV0 : forall r w : actid, rmw Gf r w -> covered T r <-> covered T w) (THREAD : forall t : thread_id,\n(threads_set Gf \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : Event.language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH : FtoCoherent.f_to_coherent Gf (reserved T) f_to f_from) (SC_COV : sim_normal = sim_certification ->\nacts_set Gf ∩₁ (fun a : actid => is_f (lab Gf) a)\n∩₁ (fun a : actid => is_sc (lab Gf) a) ⊆₁ covered T) (SC_REQ : sim_normal = sim_normal ->\nforall l : location,\nmax_value f_to (S_tm Gf l (covered T)) (LocFun.find l (Configuration.sc PC))) (RMWREX0 : dom_rel (rmw Gf) ⊆₁ (fun a : actid => R_ex (lab Gf) a)) (RESERVED_TIME : reserved_time Gf T f_to f_from sim_normal (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC))","proofString":"apply TCOH."},{"statement":"cert_rf G Gsc T thread ⨾ rmw G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘\n⊆ rf Gf ⨾ rmw Gf.","conclusion":"cert_rf G Gsc T thread ⨾ rmw G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘\n⊆ rf Gf ⨾ rmw Gf","hypotheses":"","proofString":"rewrite <- seqA.\napply RFRMW_IST_IN."},{"statement":"(cert_rf G Gsc T thread ⨾ rmw G) ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘\n⊆ rf Gf ⨾ rmw Gf.","conclusion":"(cert_rf G Gsc T thread ⨾ rmw G) ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘\n⊆ rf Gf ⨾ rmw Gf","hypotheses":"","proofString":"apply RFRMW_IST_IN."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ codom_rel\n     (⦗issued T⦘\n      ⨾ rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘ ⨾ rmw G ⨾ ⦗W_ex G⦘)\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ codom_rel\n     (⦗issued T⦘\n      ⨾ rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘ ⨾ rmw G ⨾ ⦗W_ex G⦘)\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite (dom_r (wf_rmwE WF_G)).\nrewrite <- !seqA.\nrewrite !codom_eqv1.\nrewrite !seqA.\narewrite (R_ex (lab G) ⊆₁ R_ex (lab Gf)).\nrewrite sub_rf_in; eauto.\nrewrite sub_rmw_in; eauto.\nrewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ codom_rel\n     (⦗issued T⦘\n      ⨾ rf G\n        ⨾ ⦗fun a : actid => R_ex (lab G) a⦘\n          ⨾ (rmw G ⨾ ⦗acts_set G⦘) ⨾ ⦗W_ex G⦘)\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ codom_rel\n     (⦗issued T⦘\n      ⨾ rf G\n        ⨾ ⦗fun a : actid => R_ex (lab G) a⦘\n          ⨾ (rmw G ⨾ ⦗acts_set G⦘) ⨾ ⦗W_ex G⦘)\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite <- !seqA.\nrewrite !codom_eqv1.\nrewrite !seqA.\narewrite (R_ex (lab G) ⊆₁ R_ex (lab Gf)).\nrewrite sub_rf_in; eauto.\nrewrite sub_rmw_in; eauto.\nrewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ codom_rel\n     (((((⦗issued T⦘ ⨾ rf G) ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n       ⨾ ⦗acts_set G⦘) ⨾ ⦗W_ex G⦘) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ codom_rel\n     (((((⦗issued T⦘ ⨾ rf G) ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n       ⨾ ⦗acts_set G⦘) ⨾ ⦗W_ex G⦘) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite !codom_eqv1.\nrewrite !seqA.\narewrite (R_ex (lab G) ⊆₁ R_ex (lab Gf)).\nrewrite sub_rf_in; eauto.\nrewrite sub_rmw_in; eauto.\nrewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (((⦗issued T⦘ ⨾ rf G) ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (((⦗issued T⦘ ⨾ rf G) ⨾ ⦗fun a : actid => R_ex (lab G) a⦘) ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite !seqA.\narewrite (R_ex (lab G) ⊆₁ R_ex (lab Gf)).\nrewrite sub_rf_in; eauto.\nrewrite sub_rmw_in; eauto.\nrewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel (⦗issued T⦘ ⨾ rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘ ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel (⦗issued T⦘ ⨾ rf G ⨾ ⦗fun a : actid => R_ex (lab G) a⦘ ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"arewrite (R_ex (lab G) ⊆₁ R_ex (lab Gf)).\nrewrite sub_rf_in; eauto.\nrewrite sub_rmw_in; eauto.\nrewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf G ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf G ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite sub_rf_in; eauto.\nrewrite sub_rmw_in; eauto.\nrewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw G)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite sub_rmw_in; eauto.\nrewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb G ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite sub_sb_in; eauto.\narewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"arewrite (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ⊆₁                      dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁                      dom_rel (sb Gf ⨾ ⦗reserved T⦘)).\ngeneralize IST_in_S.\nclear.\nbasic_solver 10.\nrewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n⊆₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n   ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘).","conclusion":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n⊆₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n   ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)","hypotheses":"","proofString":"generalize IST_in_S.\nclear.\nbasic_solver 10."},{"statement":"issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T ->\ndom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n⊆₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n   ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘).","conclusion":"issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T ->\ndom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n⊆₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n   ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)","hypotheses":"","proofString":"clear.\nbasic_solver 10."},{"statement":"issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T ->\ndom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n⊆₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n   ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘).","conclusion":"issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T ->\ndom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n⊆₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n   ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)","hypotheses":"","proofString":"basic_solver 10."},{"statement":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ (codom_rel\n      (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G ∩₁ W_ex G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite <- !set_interA.\nrewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n∩₁ acts_set G ∩₁ W_ex G ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n∩₁ acts_set G ∩₁ W_ex G ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite set_interC with (s':=W_ex G).\nrewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"W_ex G\n∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n    ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n    ∩₁ codom_rel\n         (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"W_ex G\n∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n    ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n    ∩₁ codom_rel\n         (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n    ∩₁ acts_set G) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite <- !set_interA.\nrewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"W_ex G ∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n∩₁ acts_set G ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"W_ex G ∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n∩₁ acts_set G ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite set_interC with (s':=acts_set G).\nrewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"acts_set G\n∩₁ (W_ex G ∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n    ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n    ∩₁ codom_rel\n         (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G ∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n    ∩₁ dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n    ∩₁ codom_rel\n         (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"rewrite !set_interA.\nforward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"","proofString":"forward eapply rcoh_sb_S; eauto; intro AA1.\nunfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_sb_S_rfrmw Gf T (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) (issued T)\n⊆₁ reserved T) : acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_sb_S_rfrmw Gf T (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) (issued T)\n⊆₁ reserved T)","proofString":"unfold dom_sb_S_rfrmw in AA1.\nsimpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T) : acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"simpl in AA1.\nsimpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T) : acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"simpl in AA1.\nrewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T) : acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ (rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘) ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"rewrite !seqA in AA1.\nrewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) : acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ (dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n            ∩₁ codom_rel\n                 (⦗issued T⦘\n                  ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf))))\n⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"rewrite AA1.\nrewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) : acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ reserved T)) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G\n∩₁ (W_ex G\n    ∩₁ (dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘)\n        ∩₁ reserved T)) ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"rewrite <- !set_interA.\nrewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) : acts_set G ∩₁ W_ex G\n∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁ \nreserved T ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G ∩₁ W_ex G\n∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁ \nreserved T ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"rewrite (W_ex_in_W WF_G).\nsimpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) : acts_set G ∩₁ (fun a : actid => is_w (lab G) a)\n∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁ \nreserved T ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"acts_set G ∩₁ (fun a : actid => is_w (lab G) a)\n∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁ \nreserved T ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"simpls.\nintros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) : E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)\n∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁ \nreserved T ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread.","conclusion":"E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)\n∩₁ dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) ∩₁ \nreserved T ⊆₁ issued T ∪₁ reserved T ∩₁ Tid_ thread","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T)","proofString":"intros x [[HH AA] SX].\ndestruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) : (issued T ∪₁ reserved T ∩₁ Tid_ thread) x.","conclusion":"(issued T ∪₁ reserved T ∩₁ Tid_ thread) x","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x)","proofString":"destruct (classic (issued T x)) as [|NISS]; [by left|].\ndestruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x) : (issued T ∪₁ reserved T ∩₁ Tid_ thread) x.","conclusion":"(issued T ∪₁ reserved T ∩₁ Tid_ thread) x","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x)","proofString":"destruct (classic (Tid_ thread x)) as [|NTID]; [by right; split|].\nexfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x) (NTID : tid x <> thread) : (issued T ∪₁ reserved T ∩₁ Tid_ thread) x.","conclusion":"(issued T ∪₁ reserved T ∩₁ Tid_ thread) x","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x) (NTID : tid x <> thread)","proofString":"exfalso.\napply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x) (NTID : tid x <> thread) : False.","conclusion":"False","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (E0 Gf T thread ∩₁ acts_set Gf ∩₁ (fun a : actid => is_w (lab Gf) a)) x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x) (NTID : tid x <> thread)","proofString":"apply IT_new_co in HH.\ndestruct HH as [HH|[_ HH]]; desf."},{"statement":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (issued T ∪₁ acts_set G ∩₁ (fun a : actid => is_w (lab G) a) ∩₁ Tid_ thread)\n  x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x) (NTID : tid x <> thread) : False.","conclusion":"False","hypotheses":"(AA1 : dom_rel (sb Gf ⨾ ⦗reserved T⦘)\n∩₁ codom_rel\n     (⦗issued T⦘ ⨾ rf Gf ⨾ ⦗fun a : actid => R_ex (lab Gf) a⦘ ⨾ rmw Gf)\n⊆₁ reserved T) (x : actid) (HH : (issued T ∪₁ acts_set G ∩₁ (fun a : actid => is_w (lab G) a) ∩₁ Tid_ thread)\n  x) (AA : dom_rel (sb Gf ⨾ ⦗issued T ∪₁ reserved T ∩₁ Tid_ thread⦘) x) (SX : reserved T x) (NISS : ~ issued T x) (NTID : tid x <> thread)","proofString":"destruct HH as [HH|[_ HH]]; desf."},{"statement":"forall e : actid,\nacts_set (ProgToExecution.G s') e ->\nsame_label_u2v (lab' e) (lab (ProgToExecution.G s') e).","conclusion":"forall e : actid,\nacts_set (ProgToExecution.G s') e ->\nsame_label_u2v (lab' e) (lab (ProgToExecution.G s') e)","hypotheses":"","proofString":"ins.\nred.\nunfold lab'.\ndesf."},{"statement":"(e : actid) (EE : acts_set (ProgToExecution.G s') e) : same_label_u2v (lab' e) (lab (ProgToExecution.G s') e).","conclusion":"same_label_u2v (lab' e) (lab (ProgToExecution.G s') e)","hypotheses":"(e : actid) (EE : acts_set (ProgToExecution.G s') e)","proofString":"red.\nunfold lab'.\ndesf."},{"statement":"(e : actid) (EE : acts_set (ProgToExecution.G s') e) : match lab' e with\n| Aload r1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Aload r2 o2 l2 _ => r1 = r2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Astore s1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Astore s2 o2 l2 _ => s1 = s2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Afence o1 =>\n    match lab (ProgToExecution.G s') e with\n    | Afence o2 => o1 = o2\n    | _ => False\n    end\nend.","conclusion":"match lab' e with\n| Aload r1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Aload r2 o2 l2 _ => r1 = r2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Astore s1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Astore s2 o2 l2 _ => s1 = s2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Afence o1 =>\n    match lab (ProgToExecution.G s') e with\n    | Afence o2 => o1 = o2\n    | _ => False\n    end\nend","hypotheses":"(e : actid) (EE : acts_set (ProgToExecution.G s') e)","proofString":"unfold lab'.\ndesf."},{"statement":"(e : actid) (EE : acts_set (ProgToExecution.G s') e) : match\n  (ifP acts_set (ProgToExecution.G s') e then lab (ProgToExecution.G s') e\n   else lab G e)\nwith\n| Aload r1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Aload r2 o2 l2 _ => r1 = r2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Astore s1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Astore s2 o2 l2 _ => s1 = s2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Afence o1 =>\n    match lab (ProgToExecution.G s') e with\n    | Afence o2 => o1 = o2\n    | _ => False\n    end\nend.","conclusion":"match\n  (ifP acts_set (ProgToExecution.G s') e then lab (ProgToExecution.G s') e\n   else lab G e)\nwith\n| Aload r1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Aload r2 o2 l2 _ => r1 = r2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Astore s1 o1 l1 _ =>\n    match lab (ProgToExecution.G s') e with\n    | Astore s2 o2 l2 _ => s1 = s2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Afence o1 =>\n    match lab (ProgToExecution.G s') e with\n    | Afence o2 => o1 = o2\n    | _ => False\n    end\nend","hypotheses":"(e : actid) (EE : acts_set (ProgToExecution.G s') e)","proofString":"desf."},{"statement":"(STEPS' : (step thread)＊ st s') (RACTS : acts_set (ProgToExecution.G state'') = acts_set (ProgToExecution.G s')) (RTS : threads_set (ProgToExecution.G state'') ≡₁ threads_set (ProgToExecution.G s')) (RRMW : rmw (ProgToExecution.G state'') ≡ rmw (ProgToExecution.G s')) (RDATA : data (ProgToExecution.G state'') ≡ data (ProgToExecution.G s')) (RADDR : addr (ProgToExecution.G state'') ≡ addr (ProgToExecution.G s')) (RCTRL : ctrl (ProgToExecution.G state'') ≡ ctrl (ProgToExecution.G s')) (RFAILRMW : rmw_dep (ProgToExecution.G state'') ≡ rmw_dep (ProgToExecution.G s')) (SAME1 : same_lab_u2v (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state''))) (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nval (lab (ProgToExecution.G s')) r = val (lab (ProgToExecution.G s')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (ProgToExecution.G s')) r ->\n(E0 Gf T thread \\₁ D G T thread) r ->\n~ codom_rel new_rfi r ->\nval (lab (ProgToExecution.G s')) r = Some (new_val r)) (OLD_VAL : forall a : actid,\n~ (E0 Gf T thread \\₁ D G T thread) a ->\nval (lab (ProgToExecution.G s')) a = val (lab (ProgToExecution.G state'')) a) : same_lab_u2v_dom (acts_set (ProgToExecution.G s'))\n  (lab (ProgToExecution.G state'')) (lab G).","conclusion":"same_lab_u2v_dom (acts_set (ProgToExecution.G s'))\n  (lab (ProgToExecution.G state'')) (lab G)","hypotheses":"(STEPS' : (step thread)＊ st s') (RACTS : acts_set (ProgToExecution.G state'') = acts_set (ProgToExecution.G s')) (RTS : threads_set (ProgToExecution.G state'') ≡₁ threads_set (ProgToExecution.G s')) (RRMW : rmw (ProgToExecution.G state'') ≡ rmw (ProgToExecution.G s')) (RDATA : data (ProgToExecution.G state'') ≡ data (ProgToExecution.G s')) (RADDR : addr (ProgToExecution.G state'') ≡ addr (ProgToExecution.G s')) (RCTRL : ctrl (ProgToExecution.G state'') ≡ ctrl (ProgToExecution.G s')) (RFAILRMW : rmw_dep (ProgToExecution.G state'') ≡ rmw_dep (ProgToExecution.G s')) (SAME1 : same_lab_u2v (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state''))) (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nval (lab (ProgToExecution.G s')) r = val (lab (ProgToExecution.G s')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (ProgToExecution.G s')) r ->\n(E0 Gf T thread \\₁ D G T thread) r ->\n~ codom_rel new_rfi r ->\nval (lab (ProgToExecution.G s')) r = Some (new_val r)) (OLD_VAL : forall a : actid,\n~ (E0 Gf T thread \\₁ D G T thread) a ->\nval (lab (ProgToExecution.G s')) a = val (lab (ProgToExecution.G state'')) a)","proofString":"rewrite <- RACTS.\napply same_lab_u2v_dom_comm.\neapply same_lab_u2v_dom_restricted; auto.\napply TEH''."},{"statement":"(STEPS' : (step thread)＊ st s') (RACTS : acts_set (ProgToExecution.G state'') = acts_set (ProgToExecution.G s')) (RTS : threads_set (ProgToExecution.G state'') ≡₁ threads_set (ProgToExecution.G s')) (RRMW : rmw (ProgToExecution.G state'') ≡ rmw (ProgToExecution.G s')) (RDATA : data (ProgToExecution.G state'') ≡ data (ProgToExecution.G s')) (RADDR : addr (ProgToExecution.G state'') ≡ addr (ProgToExecution.G s')) (RCTRL : ctrl (ProgToExecution.G state'') ≡ ctrl (ProgToExecution.G s')) (RFAILRMW : rmw_dep (ProgToExecution.G state'') ≡ rmw_dep (ProgToExecution.G s')) (SAME1 : same_lab_u2v (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state''))) (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nval (lab (ProgToExecution.G s')) r = val (lab (ProgToExecution.G s')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (ProgToExecution.G s')) r ->\n(E0 Gf T thread \\₁ D G T thread) r ->\n~ codom_rel new_rfi r ->\nval (lab (ProgToExecution.G s')) r = Some (new_val r)) (OLD_VAL : forall a : actid,\n~ (E0 Gf T thread \\₁ D G T thread) a ->\nval (lab (ProgToExecution.G s')) a = val (lab (ProgToExecution.G state'')) a) : same_lab_u2v_dom (acts_set (ProgToExecution.G state''))\n  (lab (ProgToExecution.G state'')) (lab G).","conclusion":"same_lab_u2v_dom (acts_set (ProgToExecution.G state''))\n  (lab (ProgToExecution.G state'')) (lab G)","hypotheses":"(STEPS' : (step thread)＊ st s') (RACTS : acts_set (ProgToExecution.G state'') = acts_set (ProgToExecution.G s')) (RTS : threads_set (ProgToExecution.G state'') ≡₁ threads_set (ProgToExecution.G s')) (RRMW : rmw (ProgToExecution.G state'') ≡ rmw (ProgToExecution.G s')) (RDATA : data (ProgToExecution.G state'') ≡ data (ProgToExecution.G s')) (RADDR : addr (ProgToExecution.G state'') ≡ addr (ProgToExecution.G s')) (RCTRL : ctrl (ProgToExecution.G state'') ≡ ctrl (ProgToExecution.G s')) (RFAILRMW : rmw_dep (ProgToExecution.G state'') ≡ rmw_dep (ProgToExecution.G s')) (SAME1 : same_lab_u2v (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state''))) (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nval (lab (ProgToExecution.G s')) r = val (lab (ProgToExecution.G s')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (ProgToExecution.G s')) r ->\n(E0 Gf T thread \\₁ D G T thread) r ->\n~ codom_rel new_rfi r ->\nval (lab (ProgToExecution.G s')) r = Some (new_val r)) (OLD_VAL : forall a : actid,\n~ (E0 Gf T thread \\₁ D G T thread) a ->\nval (lab (ProgToExecution.G s')) a = val (lab (ProgToExecution.G state'')) a)","proofString":"apply same_lab_u2v_dom_comm.\neapply same_lab_u2v_dom_restricted; auto.\napply TEH''."},{"statement":"(STEPS' : (step thread)＊ st s') (RACTS : acts_set (ProgToExecution.G state'') = acts_set (ProgToExecution.G s')) (RTS : threads_set (ProgToExecution.G state'') ≡₁ threads_set (ProgToExecution.G s')) (RRMW : rmw (ProgToExecution.G state'') ≡ rmw (ProgToExecution.G s')) (RDATA : data (ProgToExecution.G state'') ≡ data (ProgToExecution.G s')) (RADDR : addr (ProgToExecution.G state'') ≡ addr (ProgToExecution.G s')) (RCTRL : ctrl (ProgToExecution.G state'') ≡ ctrl (ProgToExecution.G s')) (RFAILRMW : rmw_dep (ProgToExecution.G state'') ≡ rmw_dep (ProgToExecution.G s')) (SAME1 : same_lab_u2v (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state''))) (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nval (lab (ProgToExecution.G s')) r = val (lab (ProgToExecution.G s')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (ProgToExecution.G s')) r ->\n(E0 Gf T thread \\₁ D G T thread) r ->\n~ codom_rel new_rfi r ->\nval (lab (ProgToExecution.G s')) r = Some (new_val r)) (OLD_VAL : forall a : actid,\n~ (E0 Gf T thread \\₁ D G T thread) a ->\nval (lab (ProgToExecution.G s')) a = val (lab (ProgToExecution.G state'')) a) : same_lab_u2v_dom (acts_set (ProgToExecution.G state'')) \n  (lab G) (lab (ProgToExecution.G state'')).","conclusion":"same_lab_u2v_dom (acts_set (ProgToExecution.G state'')) \n  (lab G) (lab (ProgToExecution.G state''))","hypotheses":"(STEPS' : (step thread)＊ st s') (RACTS : acts_set (ProgToExecution.G state'') = acts_set (ProgToExecution.G s')) (RTS : threads_set (ProgToExecution.G state'') ≡₁ threads_set (ProgToExecution.G s')) (RRMW : rmw (ProgToExecution.G state'') ≡ rmw (ProgToExecution.G s')) (RDATA : data (ProgToExecution.G state'') ≡ data (ProgToExecution.G s')) (RADDR : addr (ProgToExecution.G state'') ≡ addr (ProgToExecution.G s')) (RCTRL : ctrl (ProgToExecution.G state'') ≡ ctrl (ProgToExecution.G s')) (RFAILRMW : rmw_dep (ProgToExecution.G state'') ≡ rmw_dep (ProgToExecution.G s')) (SAME1 : same_lab_u2v (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state''))) (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nval (lab (ProgToExecution.G s')) r = val (lab (ProgToExecution.G s')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (ProgToExecution.G s')) r ->\n(E0 Gf T thread \\₁ D G T thread) r ->\n~ codom_rel new_rfi r ->\nval (lab (ProgToExecution.G s')) r = Some (new_val r)) (OLD_VAL : forall a : actid,\n~ (E0 Gf T thread \\₁ D G T thread) a ->\nval (lab (ProgToExecution.G s')) a = val (lab (ProgToExecution.G state'')) a)","proofString":"eapply same_lab_u2v_dom_restricted; auto.\napply TEH''."},{"statement":"same_lab_u2v_dom (acts_set (ProgToExecution.G s'))\n  (lab (ProgToExecution.G s')) (lab G).","conclusion":"same_lab_u2v_dom (acts_set (ProgToExecution.G s'))\n  (lab (ProgToExecution.G s')) (lab G)","hypotheses":"","proofString":"eapply same_lab_u2v_dom_trans; eauto using SAME2.\nby apply same_lab_u2v_follows_set."},{"statement":"same_lab_u2v_dom (acts_set (ProgToExecution.G s'))\n  (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state'')).","conclusion":"same_lab_u2v_dom (acts_set (ProgToExecution.G s'))\n  (lab (ProgToExecution.G s')) (lab (ProgToExecution.G state''))","hypotheses":"","proofString":"by apply same_lab_u2v_follows_set."},{"statement":"same_lab_u2v_dom (fun _ : actid => True) lab' (lab G).","conclusion":"same_lab_u2v_dom (fun _ : actid => True) lab' (lab G)","hypotheses":"","proofString":"red.\nins.\ndestruct (classic (acts_set (ProgToExecution.G s') e)) as [XX|XX].\neapply SAME3; eauto.\nunfold lab'.\ndesf.\nred.\nbasic_solver."},{"statement":"forall e : actid, True -> same_label_u2v (lab' e) (lab G e).","conclusion":"forall e : actid, True -> same_label_u2v (lab' e) (lab G e)","hypotheses":"","proofString":"ins.\ndestruct (classic (acts_set (ProgToExecution.G s') e)) as [XX|XX].\neapply SAME3; eauto.\nunfold lab'.\ndesf.\nred.\nbasic_solver."},{"statement":"(e : actid) (EE : True) : same_label_u2v (lab' e) (lab Gf e).","conclusion":"same_label_u2v (lab' e) (lab Gf e)","hypotheses":"(e : actid) (EE : True)","proofString":"destruct (classic (acts_set (ProgToExecution.G s') e)) as [XX|XX].\neapply SAME3; eauto.\nunfold lab'.\ndesf.\nred.\nbasic_solver."},{"statement":"(e : actid) (EE : True) (XX : acts_set (ProgToExecution.G s') e) : same_label_u2v (lab' e) (lab Gf e).","conclusion":"same_label_u2v (lab' e) (lab Gf e)","hypotheses":"(e : actid) (EE : True) (XX : acts_set (ProgToExecution.G s') e)","proofString":"eapply SAME3; eauto."},{"statement":"(e : actid) (EE : True) (XX : ~ acts_set (ProgToExecution.G s') e) : same_label_u2v (lab' e) (lab Gf e).","conclusion":"same_label_u2v (lab' e) (lab Gf e)","hypotheses":"(e : actid) (EE : True) (XX : ~ acts_set (ProgToExecution.G s') e)","proofString":"unfold lab'.\ndesf.\nred.\nbasic_solver."},{"statement":"(e : actid) (EE : True) (XX : ~ acts_set (ProgToExecution.G s') e) : same_label_u2v\n  (ifP acts_set (ProgToExecution.G s') e then lab (ProgToExecution.G s') e\n   else lab G e) (lab Gf e).","conclusion":"same_label_u2v\n  (ifP acts_set (ProgToExecution.G s') e then lab (ProgToExecution.G s') e\n   else lab G e) (lab Gf e)","hypotheses":"(e : actid) (EE : True) (XX : ~ acts_set (ProgToExecution.G s') e)","proofString":"desf.\nred.\nbasic_solver."},{"statement":"(e : actid) (EE : True) (XX n : ~ acts_set (ProgToExecution.G s') e) : same_label_u2v (lab G e) (lab Gf e).","conclusion":"same_label_u2v (lab G e) (lab Gf e)","hypotheses":"(e : actid) (EE : True) (XX n : ~ acts_set (ProgToExecution.G s') e)","proofString":"red.\nbasic_solver."},{"statement":"(e : actid) (EE : True) (XX n : ~ acts_set (ProgToExecution.G s') e) : match lab G e with\n| Aload r1 o1 l1 _ =>\n    match lab Gf e with\n    | Aload r2 o2 l2 _ => r1 = r2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Astore s1 o1 l1 _ =>\n    match lab Gf e with\n    | Astore s2 o2 l2 _ => s1 = s2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Afence o1 => match lab Gf e with\n               | Afence o2 => o1 = o2\n               | _ => False\n               end\nend.","conclusion":"match lab G e with\n| Aload r1 o1 l1 _ =>\n    match lab Gf e with\n    | Aload r2 o2 l2 _ => r1 = r2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Astore s1 o1 l1 _ =>\n    match lab Gf e with\n    | Astore s2 o2 l2 _ => s1 = s2 /\\ o1 = o2 /\\ l1 = l2\n    | _ => False\n    end\n| Afence o1 => match lab Gf e with\n               | Afence o2 => o1 = o2\n               | _ => False\n               end\nend","hypotheses":"(e : actid) (EE : True) (XX n : ~ acts_set (ProgToExecution.G s') e)","proofString":"basic_solver."},{"statement":"delta_rf ⨾ ⦗Tid_ thread⦘ ≡ ⦗fun _ : actid => True⦘ ⨾ delta_rf ⨾ ⦗Tid_ thread⦘.","conclusion":"delta_rf ⨾ ⦗Tid_ thread⦘ ≡ ⦗fun _ : actid => True⦘ ⨾ delta_rf ⨾ ⦗Tid_ thread⦘","hypotheses":"","proofString":"basic_solver."},{"statement":"(fun _ : actid => True) ⊆₁ Tid_ thread ∪₁ NTid_ thread.","conclusion":"(fun _ : actid => True) ⊆₁ Tid_ thread ∪₁ NTid_ thread","hypotheses":"","proofString":"intros x _.\nred.\nby destruct (classic (tid x = thread)); [left|right]."},{"statement":"(x : actid) : (Tid_ thread ∪₁ NTid_ thread) x.","conclusion":"(Tid_ thread ∪₁ NTid_ thread) x","hypotheses":"(x : actid)","proofString":"red.\nby destruct (classic (tid x = thread)); [left|right]."},{"statement":"(x : actid) : tid x = thread \\/ tid x <> thread.","conclusion":"tid x = thread \\/ tid x <> thread","hypotheses":"(x : actid)","proofString":"by destruct (classic (tid x = thread)); [left|right]."},{"statement":"delta_rf ⊆ delta_rf ⨾ ⦗Tid_ thread⦘.","conclusion":"delta_rf ⊆ delta_rf ⨾ ⦗Tid_ thread⦘","hypotheses":"","proofString":"cut (codom_rel delta_rf ⊆₁ Tid_ thread).\nclear.\nbasic_solver 21.\nrewrite delta_rfE at 1; try done.\nunfold D.\nunfolder; ins; desf.\ndestruct (classic (tid x = thread)); [done|].\nexfalso; eapply H3.\ndo 5 left.\nby right."},{"statement":"codom_rel delta_rf ⊆₁ Tid_ thread -> delta_rf ⊆ delta_rf ⨾ ⦗Tid_ thread⦘.","conclusion":"codom_rel delta_rf ⊆₁ Tid_ thread -> delta_rf ⊆ delta_rf ⨾ ⦗Tid_ thread⦘","hypotheses":"","proofString":"clear.\nbasic_solver 21."},{"statement":"codom_rel delta_rf ⊆₁ Tid_ thread -> delta_rf ⊆ delta_rf ⨾ ⦗Tid_ thread⦘.","conclusion":"codom_rel delta_rf ⊆₁ Tid_ thread -> delta_rf ⊆ delta_rf ⨾ ⦗Tid_ thread⦘","hypotheses":"","proofString":"basic_solver 21."},{"statement":"codom_rel delta_rf ⊆₁ Tid_ thread.","conclusion":"codom_rel delta_rf ⊆₁ Tid_ thread","hypotheses":"","proofString":"rewrite delta_rfE at 1; try done.\nunfold D.\nunfolder; ins; desf.\ndestruct (classic (tid x = thread)); [done|].\nexfalso; eapply H3.\ndo 5 left.\nby right."},{"statement":"codom_rel (⦗acts_set G⦘ ⨾ delta_rf ⨾ ⦗acts_set G \\₁ D G T thread⦘)\n⊆₁ Tid_ thread.","conclusion":"codom_rel (⦗acts_set G⦘ ⨾ delta_rf ⨾ ⦗acts_set G \\₁ D G T thread⦘)\n⊆₁ Tid_ thread","hypotheses":"","proofString":"unfold D.\nunfolder; ins; desf.\ndestruct (classic (tid x = thread)); [done|].\nexfalso; eapply H3.\ndo 5 left.\nby right."},{"statement":"codom_rel\n  (⦗acts_set G⦘\n   ⨾ delta_rf\n     ⨾ ⦗acts_set G \\₁\n        (covered T ∪₁ issued T ∪₁ acts_set G ∩₁ NTid_ thread\n         ∪₁ dom_rel ((rfi G)^? ⨾ ppo G ⨾ ⦗issued T⦘)\n         ∪₁ dom_rel ((data G ∪ rfi G ∪ rmw G)＊ ⨾ rppo G ⨾ ⦗reserved T⦘)\n         ∪₁ codom_rel (⦗issued T⦘ ⨾ rfi G)\n         ∪₁ codom_rel\n              (rfe G\n               ⨾ ⦗(fun a : actid => is_r (lab G) a)\n                  ∩₁ (fun a : actid => is_acq (lab G) a)⦘)\n         ∪₁ codom_rel (rfe G) ∩₁ dom_rel (rmw G ⨾ ⦗reserved T⦘))⦘)\n⊆₁ Tid_ thread.","conclusion":"codom_rel\n  (⦗acts_set G⦘\n   ⨾ delta_rf\n     ⨾ ⦗acts_set G \\₁\n        (covered T ∪₁ issued T ∪₁ acts_set G ∩₁ NTid_ thread\n         ∪₁ dom_rel ((rfi G)^? ⨾ ppo G ⨾ ⦗issued T⦘)\n         ∪₁ dom_rel ((data G ∪ rfi G ∪ rmw G)＊ ⨾ rppo G ⨾ ⦗reserved T⦘)\n         ∪₁ codom_rel (⦗issued T⦘ ⨾ rfi G)\n         ∪₁ codom_rel\n              (rfe G\n               ⨾ ⦗(fun a : actid => is_r (lab G) a)\n                  ∩₁ (fun a : actid => is_acq (lab G) a)⦘)\n         ∪₁ codom_rel (rfe G) ∩₁ dom_rel (rmw G ⨾ ⦗reserved T⦘))⦘)\n⊆₁ Tid_ thread","hypotheses":"","proofString":"unfolder; ins; desf.\ndestruct (classic (tid x = thread)); [done|].\nexfalso; eapply H3.\ndo 5 left.\nby right."},{"statement":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z))) : tid x = thread.","conclusion":"tid x = thread","hypotheses":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z)))","proofString":"destruct (classic (tid x = thread)); [done|].\nexfalso; eapply H3.\ndo 5 left.\nby right."},{"statement":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z))) (H4 : tid x <> thread) : tid x = thread.","conclusion":"tid x = thread","hypotheses":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z))) (H4 : tid x <> thread)","proofString":"exfalso; eapply H3.\ndo 5 left.\nby right."},{"statement":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z))) (H4 : tid x <> thread) : ((((((covered T x \\/ issued T x) \\/\n     (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n    (exists y z : actid,\n       (x = z \\/ rfi G x z) /\\\n       (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n   (exists y z : actid,\n      (fun x1 y0 : actid =>\n       ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n       (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n      (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n  (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n (exists x1 z : actid,\n    rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n(exists x1 : actid, rfe G x1 x) /\\\n(exists y z : actid,\n   (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n   z = y /\\ reserved T z).","conclusion":"((((((covered T x \\/ issued T x) \\/\n     (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n    (exists y z : actid,\n       (x = z \\/ rfi G x z) /\\\n       (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n   (exists y z : actid,\n      (fun x1 y0 : actid =>\n       ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n       (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n      (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n  (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n (exists x1 z : actid,\n    rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n(exists x1 : actid, rfe G x1 x) /\\\n(exists y z : actid,\n   (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n   z = y /\\ reserved T z)","hypotheses":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z))) (H4 : tid x <> thread)","proofString":"do 5 left.\nby right."},{"statement":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z))) (H4 : tid x <> thread) : (covered T x \\/ issued T x) \\/\n(E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread.","conclusion":"(covered T x \\/ issued T x) \\/\n(E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread","hypotheses":"(x x0 : actid) (H : (E0 Gf T thread ∩₁ acts_set Gf) x0) (H1 : delta_rf x0 x) (H2 : (E0 Gf T thread ∩₁ acts_set Gf) x) (H3 : ~\n(((((((covered T x \\/ issued T x) \\/\n      (E0 Gf T thread ∩₁ acts_set Gf) x /\\ tid x <> thread) \\/\n     (exists y z : actid,\n        (x = z \\/ rfi G x z) /\\\n        (exists z0 : actid, ppo G z z0 /\\ z0 = y /\\ issued T z0))) \\/\n    (exists y z : actid,\n       (fun x1 y0 : actid =>\n        ((⦗E0 Gf T thread⦘ ⨾ data Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0 \\/ rfi G x1 y0) \\/\n        (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x1 y0)＊ x z /\\\n       (exists z0 : actid, rppo G z z0 /\\ z0 = y /\\ reserved T z0))) \\/\n   (exists x1 z : actid, (x1 = z /\\ issued T x1) /\\ rfi G z x)) \\/\n  (exists x1 z : actid,\n     rfe G x1 z /\\ z = x /\\ is_r (lab Gf) z /\\ is_acq (lab Gf) z)) \\/\n (exists x1 : actid, rfe G x1 x) /\\\n (exists y z : actid,\n    (⦗E0 Gf T thread⦘ ⨾ rmw Gf ⨾ ⦗E0 Gf T thread⦘) x z /\\\n    z = y /\\ reserved T z))) (H4 : tid x <> thread)","proofString":"by right."},{"statement":"(b : actid) (ISSB : issued T b) : val lab' b = val (lab Gf) b.","conclusion":"val lab' b = val (lab Gf) b","hypotheses":"(b : actid) (ISSB : issued T b)","proofString":"rewrite <- lab_G_eq_lab_Gf.\nrewrite SAME_VAL; auto.\nintros [_ HH].\napply HH.\nby apply I_in_D."},{"statement":"(b : actid) (ISSB : issued T b) : val lab' b = val (lab G) b.","conclusion":"val lab' b = val (lab G) b","hypotheses":"(b : actid) (ISSB : issued T b)","proofString":"rewrite SAME_VAL; auto.\nintros [_ HH].\napply HH.\nby apply I_in_D."},{"statement":"(b : actid) (ISSB : issued T b) : ~ (acts_set G \\₁ D G T thread) b.","conclusion":"~ (acts_set G \\₁ D G T thread) b","hypotheses":"(b : actid) (ISSB : issued T b)","proofString":"intros [_ HH].\napply HH.\nby apply I_in_D."},{"statement":"(b : actid) (ISSB : issued T b) (HH : ~ D G T thread b) : False.","conclusion":"False","hypotheses":"(b : actid) (ISSB : issued T b) (HH : ~ D G T thread b)","proofString":"apply HH.\nby apply I_in_D."},{"statement":"(b : actid) (ISSB : issued T b) (HH : ~ D G T thread b) : D G T thread b.","conclusion":"D G T thread b","hypotheses":"(b : actid) (ISSB : issued T b) (HH : ~ D G T thread b)","proofString":"by apply I_in_D."},{"statement":"acts_set\n  {|\n    acts_set := acts_set (rstG Gf T thread);\n    threads_set := threads_set (rstG Gf T thread);\n    lab := lab';\n    rmw := rmw (rstG Gf T thread);\n    data := data (rstG Gf T thread);\n    addr := addr (rstG Gf T thread);\n    ctrl := ctrl (rstG Gf T thread);\n    rmw_dep := rmw_dep (rstG Gf T thread);\n    rf := cert_rf (rstG Gf T thread) Gsc T thread;\n    co := cert_co (rstG Gf T thread) T thread\n  |} ⊆₁ acts_set Gf.","conclusion":"acts_set\n  {|\n    acts_set := acts_set (rstG Gf T thread);\n    threads_set := threads_set (rstG Gf T thread);\n    lab := lab';\n    rmw := rmw (rstG Gf T thread);\n    data := data (rstG Gf T thread);\n    addr := addr (rstG Gf T thread);\n    ctrl := ctrl (rstG Gf T thread);\n    rmw_dep := rmw_dep (rstG Gf T thread);\n    rf := cert_rf (rstG Gf T thread) Gsc T thread;\n    co := cert_co (rstG Gf T thread) T thread\n  |} ⊆₁ acts_set Gf","hypotheses":"","proofString":"simpl.\nbasic_solver."},{"statement":"E0 Gf T thread ∩₁ acts_set Gf ⊆₁ acts_set Gf.","conclusion":"E0 Gf T thread ∩₁ acts_set Gf ⊆₁ acts_set Gf","hypotheses":"","proofString":"basic_solver."},{"statement":"acts_set Gf ∩₁ (fun a : actid => is_f (lab G) a)\n⊆₁ (fun a : actid => is_ra (lab G) a).","conclusion":"acts_set Gf ∩₁ (fun a : actid => is_f (lab G) a)\n⊆₁ (fun a : actid => is_ra (lab G) a)","hypotheses":"","proofString":"rewrite lab_G_eq_lab_Gf.\napply SIMREL."},{"statement":"acts_set Gf ∩₁ (fun a : actid => is_f (lab Gf) a)\n⊆₁ (fun a : actid => is_ra (lab Gf) a).","conclusion":"acts_set Gf ∩₁ (fun a : actid => is_f (lab Gf) a)\n⊆₁ (fun a : actid => is_ra (lab Gf) a)","hypotheses":"","proofString":"apply SIMREL."},{"statement":"issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T.","conclusion":"issued T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T","hypotheses":"","proofString":"rewrite rcoh_I_in_S; eauto.\nbasic_solver."},{"statement":"reserved T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T.","conclusion":"reserved T ∪₁ reserved T ∩₁ Tid_ thread ⊆₁ reserved T","hypotheses":"","proofString":"basic_solver."}]}