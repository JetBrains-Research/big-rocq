{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/imm/SubExecution.v","fileSamples":[{"statement":"forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b.","proofString":"by ins; desf; apply (wf_index WF); splits; eauto; apply sub_E_in."},{"statement":"data' ⊆ sb'.","proofString":"by rewrite (sub_data SUB), data_in_sb, sub_sb."},{"statement":"data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘.","proofString":"apply dom_helper_3; rewrite (sub_data SUB), wf_dataD, sub_R, sub_W; basic_solver."},{"statement":"addr' ⊆ sb'.","proofString":"by rewrite (sub_addr SUB), addr_in_sb, sub_sb."},{"statement":"addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘.","proofString":"apply dom_helper_3; rewrite (sub_addr SUB), wf_addrD, sub_R, sub_W; basic_solver 12."},{"statement":"ctrl' ⊆ sb'.","proofString":"by rewrite (sub_ctrl SUB), ctrl_in_sb, sub_sb."},{"statement":"ctrl' ≡ ⦗R'⦘ ⨾ ctrl'.","proofString":"rewrite (sub_ctrl SUB), wf_ctrlD, sub_R; basic_solver 12."},{"statement":"ctrl' ⨾ sb' ⊆ ctrl'.","proofString":"rewrite (sub_ctrl SUB), sub_sb.\ngeneralize (ctrl_sb WF); basic_solver 12."},{"statement":"(⦗E'⦘ ⨾ ctrl ⨾ ⦗E'⦘) ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ⊆ ⦗E'⦘ ⨾ ctrl ⨾ ⦗E'⦘.","proofString":"generalize (ctrl_sb WF); basic_solver 12."},{"statement":"rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘.","proofString":"apply dom_helper_3; rewrite (sub_rmw SUB), wf_rmwD, sub_R, sub_W; basic_solver 12."},{"statement":"rmw' ⊆ same_loc'.","proofString":"rewrite sub_rmw_in, sub_same_loc; apply WF."},{"statement":"rmw' ⊆ immediate sb'.","proofString":"rewrite (sub_rmw SUB).\nunfolder; ins; desf; splits.\napply sub_sb; generalize (rmw_in_sb WF); basic_solver 12.\nins; eapply  (wf_rmwi WF); eauto; apply (sub_sb_in); edone."},{"statement":"⦗E'⦘ ⨾ rmw ⨾ ⦗E'⦘ ⊆ immediate sb'.","proofString":"unfolder; ins; desf; splits.\napply sub_sb; generalize (rmw_in_sb WF); basic_solver 12.\nins; eapply  (wf_rmwi WF); eauto; apply (sub_sb_in); edone."},{"statement":"(x y : actid) (H : E' x) (H0 : rmw x y) (H1 : E' y) : sb' x y.","proofString":"apply sub_sb; generalize (rmw_in_sb WF); basic_solver 12."},{"statement":"(x y : actid) (H : E' x) (H0 : rmw x y) (H1 : E' y) : forall c : actid, sb' x c -> sb' c y -> False.","proofString":"ins; eapply  (wf_rmwi WF); eauto; apply (sub_sb_in); edone."},{"statement":"rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘.","proofString":"apply dom_helper_3; rewrite (sub_rf SUB); basic_solver."},{"statement":"rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘.","proofString":"apply dom_helper_3; rewrite (sub_rf SUB), wf_rfD, sub_R, sub_W; basic_solver 12."},{"statement":"rf' ⊆ same_loc'.","proofString":"rewrite sub_rf_in, sub_same_loc; apply WF."},{"statement":"funeq val' rf'.","proofString":"rewrite sub_val, sub_rf_in; apply WF."},{"statement":"functional rf'⁻¹.","proofString":"rewrite sub_rf_in; apply WF."},{"statement":"co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘.","proofString":"apply dom_helper_3; rewrite (sub_co SUB); basic_solver 12."},{"statement":"co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘.","proofString":"apply dom_helper_3; rewrite (sub_co SUB), wf_coD, sub_W; basic_solver 12."},{"statement":"co' ⊆ same_loc'.","proofString":"rewrite sub_co_in, sub_same_loc; apply WF."},{"statement":"transitive co'.","proofString":"rewrite (sub_co SUB), <- restr_relE; apply transitive_restr, WF."},{"statement":"forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co'.","proofString":"intro ol.\nrewrite (sub_co SUB), sub_W.\nunfolder; ins; eapply (wf_co_total WF) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; [apply sub_E_in| rewrite <- sub_loc]."},{"statement":"(ol : option location) : is_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co'.","proofString":"rewrite (sub_co SUB), sub_W.\nunfolder; ins; eapply (wf_co_total WF) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; [apply sub_E_in| rewrite <- sub_loc]."},{"statement":"(ol : option location) : is_total (E' ∩₁ W ∩₁ (fun x : actid => loc' x = ol)) (⦗E'⦘ ⨾ co ⨾ ⦗E'⦘).","proofString":"unfolder; ins; eapply (wf_co_total WF) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; [apply sub_E_in| rewrite <- sub_loc]."},{"statement":"(ol : option location) (a : actid) (IWa : (E' a /\\ is_w lab a) /\\ loc' a = ol) (b : actid) (IWb : (E' b /\\ is_w lab b) /\\ loc' b = ol) (NEQ : co a b \\/ co b a) : E' a /\\ co a b /\\ E' b \\/ E' b /\\ co b a /\\ E' a.","proofString":"by desf; eauto."},{"statement":"irreflexive co'.","proofString":"rewrite sub_co_in; apply WF."},{"statement":"forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l).","proofString":"ins; desf.\napply INIT; unfolder; splits; eauto.\napply (wf_init WF); splits; exists b; splits; eauto.\nby apply sub_E_in.\ngeneralize sub_loc; congruence."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : E' (InitEvent l).","proofString":"apply INIT; unfolder; splits; eauto.\napply (wf_init WF); splits; exists b; splits; eauto.\nby apply sub_E_in.\ngeneralize sub_loc; congruence."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : E (InitEvent l).","proofString":"apply (wf_init WF); splits; exists b; splits; eauto.\nby apply sub_E_in.\ngeneralize sub_loc; congruence."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : E b.","proofString":"by apply sub_E_in."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : loc b = Some l.","proofString":"generalize sub_loc; congruence."},{"statement":"forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0.","proofString":"ins; rewrite (sub_lab SUB); apply WF."},{"statement":"rmw_dep' ⊆ sb'.","proofString":"by rewrite (sub_frmw SUB), rmw_dep_in_sb, sub_sb."},{"statement":"rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘.","proofString":"apply dom_helper_3; rewrite (sub_frmw SUB), wf_rmw_depD, sub_R, sub_R_ex; basic_solver 12."},{"statement":"forall e : actid, E' e -> threads_set' (tid e).","proofString":"ins.\napply sub_threads; auto.\napply WF.\napply sub_E; auto."},{"statement":"(e : actid) (EE : E' e) : threads_set' (tid e).","proofString":"apply sub_threads; auto.\napply WF.\napply sub_E; auto."},{"statement":"(e : actid) (EE : E' e) : threads_set (tid e).","proofString":"apply WF.\napply sub_E; auto."},{"statement":"(e : actid) (EE : E' e) : E e.","proofString":"apply sub_E; auto."},{"statement":"(⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗W ∩₁ Rel⦘\n∪ ⦗W ∩₁ Rel⦘ ⨾ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ∩ same_loc ⨾ ⦗W⦘\n∪ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘\n≡ ⦗E'⦘\n  ⨾ (sb ⨾ ⦗W ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ sb ⨾ ⦗F ∩₁ Acq/Rel⦘\n     ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb) ⨾ ⦗E'⦘.","proofString":"basic_solver 21."},{"statement":"⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘ ∪ ⦗R ∩₁ Acq⦘ ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘\n≡ ⦗E'⦘ ⨾ (fwbob ∪ ⦗R ∩₁ Acq⦘ ⨾ sb) ⨾ ⦗E'⦘.","proofString":"basic_solver 21."},{"statement":"⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (rf \\ sb) ⨾ ⦗E'⦘.","proofString":"split; [basic_solver 15 | unfolder; ins; desf; splits; eauto; intro; desf]."},{"statement":"⦗E'⦘ ⨾ co ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (co \\ sb) ⨾ ⦗E'⦘.","proofString":"split; [basic_solver 15 | unfolder; ins; desf; splits; eauto; intro; desf]."},{"statement":"(coe' ⨾ rfe') ∩ sb' ⊆ (coe ⨾ rfe) ∩ sb.","proofString":"rewrite sub_sb, sub_coe, sub_rfe_in.\nbasic_solver 21."},{"statement":"((⦗E'⦘ ⨾ coe ⨾ ⦗E'⦘) ⨾ rfe) ∩ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⊆ (coe ⨾ rfe) ∩ sb.","proofString":"basic_solver 21."},{"statement":"⦗R'⦘\n⨾ (data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n   ∪ ⦗R_ex'⦘ ⨾ sb')⁺ ⨾ ⦗W'⦘\n⊆ ⦗R⦘\n  ⨾ (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb)⁺\n    ⨾ ⦗W⦘.","proofString":"rewrite sub_W, sub_R.\nhahn_frame; apply inclusion_t_t.\napply union_mori.\nrewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12.\nrewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"⦗R⦘\n⨾ (data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n   ∪ ⦗R_ex'⦘ ⨾ sb')⁺ ⨾ ⦗W⦘\n⊆ ⦗R⦘\n  ⨾ (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb)⁺\n    ⨾ ⦗W⦘.","proofString":"hahn_frame; apply inclusion_t_t.\napply union_mori.\nrewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12.\nrewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n∪ ⦗R_ex'⦘ ⨾ sb'\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb.","proofString":"apply union_mori.\nrewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12.\nrewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","proofString":"rewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12."},{"statement":"data' ∪ ctrl' ∪ addr' ⨾ sb^? ∪ rfi ∪ rmw' ∪ rmw_dep' ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","proofString":"rewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12."},{"statement":"data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw' ∪ rmw_dep ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","proofString":"rewrite sub_rmw_in at 1.\nbasic_solver 12."},{"statement":"data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","proofString":"basic_solver 12."},{"statement":"⦗R_ex'⦘ ⨾ sb' ⊆ ⦗R_ex⦘ ⨾ sb.","proofString":"rewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"⦗R_ex'⦘ ⨾ ⦗E'⦘ ⨾ sb' ⊆ ⦗R_ex⦘ ⨾ sb.","proofString":"rewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"⦗R_ex⦘ ⨾ ⦗E'⦘ ⨾ sb ⊆ ⦗R_ex⦘ ⨾ sb.","proofString":"unfolder.\nins.\ndesf."},{"statement":"rf'⁻¹ ⨾ co' ⊆ rf⁻¹ ⨾ co.","proofString":"by rewrite sub_rf_in, sub_co_in."},{"statement":"⦗E'⦘ ⨾ fre' ⨾ ⦗E'⦘ ⊆ fre.","proofString":"ie_unfolder.\nrewrite sub_fr_in, sub_sb.\nbasic_solver 21."},{"statement":"⦗E'⦘ ⨾ (fr' \\ sb') ⨾ ⦗E'⦘ ⊆ fr \\ sb.","proofString":"rewrite sub_fr_in, sub_sb.\nbasic_solver 21."},{"statement":"⦗E'⦘ ⨾ (fr \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗E'⦘ ⊆ fr \\ sb.","proofString":"basic_solver 21."},{"statement":"rf' ∪ co' ⨾ rf'^? ∪ fr' ⨾ rf'^? ⊆ rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?.","proofString":"rewrite sub_rf_in, sub_co_in, sub_fr_in.\nbasic_solver 21."},{"statement":"rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^? ⊆ rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?.","proofString":"basic_solver 21."},{"statement":"⦗W'⦘ ⨾ (sb' ∩ same_loc')^? ⨾ ⦗W'⦘ ⨾ (rf' ⨾ rmw')＊\n⊆ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw)＊.","proofString":"by rewrite sub_rf_in, sub_rmw_in, sub_sb_in, sub_same_loc, sub_W."},{"statement":"⦗Rel'⦘ ⨾ (⦗F'⦘ ⨾ sb')^? ⨾ rs' ⊆ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","proofString":"by rewrite sub_sb_in, sub_rs_in, sub_F, sub_Rel."},{"statement":"release' ⨾ rf' ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘\n⊆ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘.","proofString":"by rewrite sub_sb_in, sub_release_in, sub_rf_in, sub_F, sub_Acq."},{"statement":"(sb' ∪ sw')⁺ ⊆ (sb ∪ sw)⁺.","proofString":"by rewrite sub_sb_in, sub_sw_in."},{"statement":"bob' ∪ ppo' ∪ detour' ∪ ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘\n∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","proofString":"rewrite sub_bob_in, sub_ppo_in, sub_detour_in, sub_sb_in.\nrewrite sub_W_ex_acq_in, sub_W.\nrewrite sub_W_ex_in, sub_rfi_in.\nrewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq'⦘ ⨾ sb ⨾ ⦗W'⦘ ∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","proofString":"rewrite sub_W_ex_acq_in, sub_W.\nrewrite sub_W_ex_in, sub_rfi_in.\nrewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","proofString":"rewrite sub_W_ex_in, sub_rfi_in.\nrewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","proofString":"rewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","proofString":"done."},{"statement":"sc' ∪ rfe' ∪ ar_int' ⊆ sc ∪ rfe ∪ ar_int.","proofString":"by rewrite sub_sc_in, sub_rfe_in, sub_ar_int_in."},{"statement":"(l : location) : ⦗W'_ l⦘ ⨾ rf'^? ⨾ (hb' ⨾ ⦗F' ∩₁ Sc'⦘)^? ⨾ sc'^? ⨾ hb'^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?.","proofString":"by rewrite sub_rf_in, sub_hb_in, (sub_W_ l), sub_F, sub_Sc, sub_sc_in."},{"statement":"(fun x y : actid => exists l : location, urr' l x y)\n⊆ (fun x y : actid => exists l : location, urr l x y).","proofString":"unfolder; ins; desf; eexists; apply sub_urr_in; eauto."},{"statement":"(⋃₁t ∈ threads_set' \\₁ eq tid_init, eq (ta_propagate t))\n≡₁ (⋃₁t ∈ threads_set \\₁ eq tid_init, eq (ta_propagate t)).","proofString":"now rewrite sub_threads."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc')⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘.","proofString":"hahn_frame; apply map_rel_mori; auto.\ntry apply clos_trans_mori.\nrewrite sub_sc, sub_E; auto using SUB.\nclear; basic_solver."},{"statement":"(⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc')⁺ ⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc)⁺.","proofString":"try apply clos_trans_mori.\nrewrite sub_sc, sub_E; auto using SUB.\nclear; basic_solver."},{"statement":"⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc' ⊆ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc.","proofString":"rewrite sub_sc, sub_E; auto using SUB.\nclear; basic_solver."},{"statement":"⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘ ⊆ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc.","proofString":"clear; basic_solver."},{"statement":"⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W'⦘ ⨾ rf'^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘.","proofString":"hahn_frame; apply map_rel_mori; auto.\ntry apply clos_trans_mori.\nrewrite sub_rf, sub_W; auto using SUB.\nclear; basic_solver."},{"statement":"⦗W'⦘ ⨾ rf'^? ⊆ ⦗W⦘ ⨾ rf^?.","proofString":"try apply clos_trans_mori.\nrewrite sub_rf, sub_W; auto using SUB.\nclear; basic_solver."},{"statement":"⦗W'⦘ ⨾ rf'^? ⊆ ⦗W⦘ ⨾ rf^?.","proofString":"rewrite sub_rf, sub_W; auto using SUB.\nclear; basic_solver."},{"statement":"⦗W⦘ ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^? ⊆ ⦗W⦘ ⨾ rf^?.","proofString":"clear; basic_solver."},{"statement":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob' ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"rewrite sub_fwbob; eauto using SUB; ins.\nrewrite sub_W; eauto using SUB; ins.\nclear; basic_solver 20."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ((⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘) ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"rewrite sub_W; eauto using SUB; ins.\nclear; basic_solver 20."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ((⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘) ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"clear; basic_solver 20."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W'⦘ ⨾ (ar' sc' ∪ rf' ⨾ ppo' ∩ same_loc')⁺ ⨾ ⦗W'⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"rewrite sub_ar_in, sub_ppo_in, sub_rf, sub_W; eauto using SUB.\nrewrite sub_same_loc; eauto using SUB.\nrepeat (apply seq_mori; try easy).\napply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc')⁺ ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"rewrite sub_same_loc; eauto using SUB.\nrepeat (apply seq_mori; try easy).\napply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"repeat (apply seq_mori; try easy).\napply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","proofString":"apply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘.","proofString":"repeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"(ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺\n⊆ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"apply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc ⊆ ar sc ∪ rf ⨾ ppo ∩ same_loc.","proofString":"clear; basic_solver 10."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (eq ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G'⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","proofString":"rewrite sub_is_ta_propagate_to_G.\nnow rewrite sub_W; eauto using SUB."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (eq ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","proofString":"now rewrite sub_W; eauto using SUB."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G'⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","proofString":"rewrite sub_is_ta_propagate_to_G.\nrepeat (apply seq_mori; try easy).\napply inter_rel_mori; try easy.\napply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","proofString":"repeat (apply seq_mori; try easy).\napply inter_rel_mori; try easy.\napply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n∩ (fun ta1 ta2 : trav_label =>\n   tid (event ta1) = ta_propagate_tid (action ta2))\n⊆ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2)).","proofString":"apply inter_rel_mori; try easy.\napply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘) ⊆ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘).","proofString":"apply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘ ⊆ fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘.","proofString":"by rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"restr_rel (event ↓₁ (E' \\₁ (fun a : actid => is_init a)))\n  (SB G' sc' ∪ RF G' ∪ FWBOB G' ∪ AR G' sc' ∪ IPROP G' ∪ PROP G' sc')\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc).","proofString":"apply restr_rel_mori.\nrewrite sub_E; eauto using SUB.\nrewrite sub_SB, sub_RF, sub_FWBOB, sub_AR, sub_IPROP, sub_PROP.\neasy."},{"statement":"event ↓₁ (E' \\₁ (fun a : actid => is_init a))\n⊆₁ event ↓₁ (E \\₁ (fun a : actid => is_init a)).","proofString":"rewrite sub_E; eauto using SUB."},{"statement":"SB G' sc' ∪ RF G' ∪ FWBOB G' ∪ AR G' sc' ∪ IPROP G' ∪ PROP G' sc'\n⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc.","proofString":"rewrite sub_SB, sub_RF, sub_FWBOB, sub_AR, sub_IPROP, sub_PROP.\neasy."},{"statement":"SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc\n⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc.","proofString":"easy."},{"statement":"sc' ≡ ⦗E'⦘ ⨾ sc' ⨾ ⦗E'⦘.","proofString":"apply dom_helper_3; rewrite (sub_sc SUB); basic_solver."},{"statement":"sc' ≡ ⦗F' ∩₁ Sc'⦘ ⨾ sc' ⨾ ⦗F' ∩₁ Sc'⦘.","proofString":"apply dom_helper_3; rewrite (sub_sc SUB), (wf_scD WF_SC).\nrewrite sub_F, sub_Sc; basic_solver 12."},{"statement":"⦗E'⦘ ⨾ (⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ ⦗E'⦘ ⊆ (F' ∩₁ Sc') × (F' ∩₁ Sc').","proofString":"rewrite sub_F, sub_Sc; basic_solver 12."},{"statement":"transitive sc'.","proofString":"rewrite (sub_sc SUB), <- restr_relE; apply transitive_restr, WF_SC."},{"statement":"is_total (E' ∩₁ F' ∩₁ Sc') sc'.","proofString":"rewrite (sub_sc SUB), sub_F, sub_Sc.\nunfolder; ins; eapply (wf_sc_total WF_SC) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"is_total (E' ∩₁ F ∩₁ Sc) (⦗E'⦘ ⨾ sc ⨾ ⦗E'⦘).","proofString":"unfolder; ins; eapply (wf_sc_total WF_SC) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : sc a b \\/ sc b a) : E' a /\\ sc a b /\\ E' b \\/ E' b /\\ sc b a /\\ E' a.","proofString":"by desf; eauto."},{"statement":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : a <> b) : (E ∩₁ F ∩₁ Sc) a.","proofString":"by unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : a <> b) : (E ∩₁ F ∩₁ Sc) b.","proofString":"by unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"irreflexive sc'.","proofString":"rewrite sub_sc_in; apply WF_SC."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : (coe' ⨾ (rf' \\ sb')) ∩ sb' ≡ ⦗E'⦘ ⨾ (coe ⨾ (rf \\ sb)) ∩ sb ⨾ ⦗E'⦘.","proofString":"rewrite sub_sb, sub_coe, (sub_rf SUB).\nunfolder in RF_A; unfolder; splits; ins; desf; eauto 20.\nsplits; eauto 20.\nexists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : ((⦗E'⦘ ⨾ coe ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘))\n∩ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ≡ ⦗E'⦘ ⨾ (coe ⨾ (rf \\ sb)) ∩ sb ⨾ ⦗E'⦘.","proofString":"unfolder in RF_A; unfolder; splits; ins; desf; eauto 20.\nsplits; eauto 20.\nexists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : (E' x /\\\n (exists z0 : actid,\n    coe x z0 /\\\n    (exists z1 : actid,\n       (z0 = z1 /\\ E' z0) /\\\n       (E' z1 /\\ rf z1 y /\\ E' y) /\\ ~ (E' z1 /\\ sb z1 y /\\ E' y)))) /\\\nE' x /\\ sb x y /\\ E' y.","proofString":"splits; eauto 20.\nexists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : exists z0 : actid,\n  coe x z0 /\\\n  (exists z1 : actid,\n     (z0 = z1 /\\ E' z0) /\\\n     (E' z1 /\\ rf z1 y /\\ E' y) /\\ ~ (E' z1 /\\ sb z1 y /\\ E' y)).","proofString":"exists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : exists z0 : actid,\n  (z = z0 /\\ E' z) /\\\n  (E' z0 /\\ rf z0 y /\\ E' y) /\\ ~ (E' z0 /\\ sb z0 y /\\ E' y).","proofString":"exists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : ~ (E' z /\\ sb z y /\\ E' y).","proofString":"intro; desf."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : rf'⁻¹ ⨾ co' ≡ ⦗E'⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E'⦘.","proofString":"rewrite (sub_rf SUB), (sub_co SUB).\nunfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)⁻¹ ⨾ ⦗E'⦘ ⨾ co ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E'⦘.","proofString":"unfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : rf' ∪ co' ⨾ rf'^? ∪ fr' ⨾ rf'^? ≡ ⦗E'⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E'⦘.","proofString":"rewrite (sub_rf SUB), (sub_co SUB), (sub_fr RF_A).\nunfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : ⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ ∪ (⦗E'⦘ ⨾ co ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^?\n∪ (⦗E'⦘ ⨾ fr ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^?\n≡ ⦗E'⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E'⦘.","proofString":"unfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) : E' ∩₁ R ⊆₁ codom_rel (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘).","proofString":"unfolder; ins.\nedestruct (COMP x); eauto.\ngeneralize sub_E_in; basic_solver.\nunfolder; ins; desf.\ngeneralize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x) : exists x0 : actid, E' x0 /\\ rf x0 x /\\ E' x.","proofString":"edestruct (COMP x); eauto.\ngeneralize sub_E_in; basic_solver.\nunfolder; ins; desf.\ngeneralize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x) : (E ∩₁ R) x.","proofString":"generalize sub_E_in; basic_solver."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x) (x0 : actid) (H0 : rf x0 x) : exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","proofString":"unfolder; ins; desf.\ngeneralize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x) : exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","proofString":"generalize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x) : E' ⊆₁ E -> exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","proofString":"revert RF_A.\nbasic_solver 21."},{"statement":"(COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x) : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E' ->\nE' ⊆₁ E -> exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","proofString":"basic_solver 21."},{"statement":"(G : execution) (D : actid -> Prop) (IN : forall x0 : actid, D x0 -> acts_set G x0) (x : actid) (H : (D ∩₁ acts_set G) x) : D x.","proofString":"apply H."},{"statement":"(G : execution) (D : actid -> Prop) (IN : forall x0 : actid, D x0 -> acts_set G x0) (x : actid) (H : D x) : (D ∩₁ acts_set G) x.","proofString":"split; auto."},{"statement":"(G : execution) : acts_set G\n≡₁ (⋃₁t,\n     acts_set\n       {|\n         acts_set := Tid_ t ∩₁ acts_set G;\n         threads_set := threads_set G;\n         lab := lab G;\n         rmw := ⦗Tid_ t⦘ ⨾ rmw G ⨾ ⦗Tid_ t⦘;\n         data := ⦗Tid_ t⦘ ⨾ data G ⨾ ⦗Tid_ t⦘;\n         addr := ⦗Tid_ t⦘ ⨾ addr G ⨾ ⦗Tid_ t⦘;\n         ctrl := ⦗Tid_ t⦘ ⨾ ctrl G ⨾ ⦗Tid_ t⦘;\n         rmw_dep := ⦗Tid_ t⦘ ⨾ rmw_dep G ⨾ ⦗Tid_ t⦘;\n         rf := ⦗Tid_ t⦘ ⨾ rf G ⨾ ⦗Tid_ t⦘;\n         co := ⦗Tid_ t⦘ ⨾ co G ⨾ ⦗Tid_ t⦘\n       |}).","proofString":"simpl.\nrewrite set_bunion_inter_compat_r, set_interC, <- set_bunion_inter_compat_l.\napply set_bunion_separation."},{"statement":"(G : execution) : acts_set G ≡₁ (⋃₁t, Tid_ t ∩₁ acts_set G).","proofString":"rewrite set_bunion_inter_compat_r, set_interC, <- set_bunion_inter_compat_l.\napply set_bunion_separation."},{"statement":"(G : execution) : acts_set G ≡₁ (⋃₁x, acts_set G ∩₁ Tid_ x).","proofString":"apply set_bunion_separation."},{"statement":"(G : execution) (b : thread_id) (TB : threads_bound G b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (IN : exists y : BinNums.positive,\n  ~ BinPos.Pos.lt y b /\\ (tid x = y /\\ acts_set G x) /\\ ~ is_init x) : False.","proofString":"desc.\nred in TB.\napply TB in IN2.\ncongruence."},{"statement":"(G : execution) (b : thread_id) (TB : threads_bound G b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : acts_set G x) (IN1 : ~ is_init x) : False.","proofString":"red in TB.\napply TB in IN2.\ncongruence."},{"statement":"(G : execution) (b : thread_id) (TB : forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : acts_set G x) (IN1 : ~ is_init x) : False.","proofString":"apply TB in IN2.\ncongruence."},{"statement":"(G : execution) (b : thread_id) (TB : forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : BinPos.Pos.lt (tid x) b) (IN1 : ~ is_init x) : False.","proofString":"congruence."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (FIN_THREADS : exists b : thread_id, threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) : fin_exec G.","proofString":"desf.\neapply fin_exec_bounded_threads; eauto.\nins.\ndestruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) : fin_exec G.","proofString":"eapply fin_exec_bounded_threads; eauto.\nins.\ndestruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t).","proofString":"ins.\ndestruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) : fin_exec (restrict G Tid_ t).","proofString":"destruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) : fin_exec (restrict G Tid_ t).","proofString":"red.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) : set_finite (acts_set (restrict G Tid_ t) \\₁ (fun a : actid => is_init a)).","proofString":"exists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x) : False.","proofString":"exfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x) : False.","proofString":"apply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x) : threads_set G t.","proofString":"unfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (tid x = t /\\ acts_set G x) /\\ ~ is_init x) : threads_set G t.","proofString":"desf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) (x : actid) (NTS : threads_set G (tid x) -> False) (LTB : BinPos.Pos.lt (tid x) b) (IN1 : acts_set G x) (IN0 : ~ is_init x) : threads_set G (tid x).","proofString":"now apply ACTS."},{"statement":"(G : execution) (S : actid -> Prop) (FAIR : mem_fair G) : fsupp\n  (co\n     {|\n       acts_set := S ∩₁ acts_set G;\n       threads_set := threads_set G;\n       lab := lab G;\n       rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n       data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n       addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n       ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n       rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n       rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n       co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n     |}) /\\\nfsupp\n  ((rf\n      {|\n        acts_set := S ∩₁ acts_set G;\n        threads_set := threads_set G;\n        lab := lab G;\n        rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n        data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n        addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n        ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n        rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n        rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n        co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n      |})⁻¹\n   ⨾ co\n       {|\n         acts_set := S ∩₁ acts_set G;\n         threads_set := threads_set G;\n         lab := lab G;\n         rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n         data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n         addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n         ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n         rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n         rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n         co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n       |}).","proofString":"simpl.\ndestruct FAIR as [FSco FSfr].\nsplit.\neapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver.\neapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FAIR : mem_fair G) : fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘) /\\ fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","proofString":"destruct FAIR as [FSco FSfr].\nsplit.\neapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver.\neapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘) /\\ fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","proofString":"split.\neapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver.\neapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","proofString":"eapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : Basics.flip inclusion (co G) (⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","proofString":"red.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ co G.","proofString":"basic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","proofString":"eapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : Basics.flip inclusion (fr G) ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","proofString":"red.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : (⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ fr G.","proofString":"unfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : (⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ (rf G)⁻¹ ⨾ co G.","proofString":"basic_solver."},{"statement":"(G : execution) (b : thread_id) (S : actid -> Prop) (BOUND : threads_bound G b) (e : actid) (Ge : (S ∩₁ acts_set G) e) : BinPos.Pos.lt (tid e) b.","proofString":"apply BOUND, Ge."}]}