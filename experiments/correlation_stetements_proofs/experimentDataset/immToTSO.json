[{"statement":"Lemma WF : Wf G.","proof":"apply CON.\n"},{"statement":"Lemma release_in : release ⊆ sb^? ⨾ ⦗W⦘ ⨾ (ppot ∪ rfe)＊.","proof":"unfold imm_hb.release, imm_hb.rs.\narewrite (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ sb^?) by basic_solver.\narewrite (⦗W⦘ ⊆ ⦗W⦘ ⨾ ⦗W⦘) at 1.\nby basic_solver.\nhahn_frame; relsf; unionL.\nrewrite rt_begin; rewrite TSO.ppo_alt; basic_solver 12.\nrewrite (dom_r (wf_rmwD WF)).\nrewrite <- !seqA.\nrewrite <- rt_seq_swap.\narewrite_id ⦗W⦘ at 2; rels.\nrewrite <- (rt_of_rt (ppot ∪ rfe)).\napply inclusion_rt_rt.\nrewrite rfi_union_rfe; relsf; unionL.\n- arewrite (rfi ⊆ sb).\nrewrite (dom_r (wf_rmwD WF)).\nrewrite (rmw_in_sb WF).\ngeneralize (@sb_trans G).\nrewrite rt_begin; rewrite TSO.ppo_alt; basic_solver 21.\n- rewrite (wf_rfeD WF).\nrewrite (dom_r (wf_rmwD WF)).\nrewrite rt_begin.\nrewrite rt_begin.\nrewrite rt_begin.\nrewrite (rmw_in_sb WF).\nrewrite TSO.ppo_alt; basic_solver 42.\n"},{"statement":"Lemma sw_in : sw ⊆ sb ∪ sb^? ⨾ ⦗W⦘ ⨾ (ppot ∪ rfe)⁺ ⨾ ⦗R⦘ ⨾ sb^?.","proof":"generalize (@sb_trans G); ins.\nunfold imm_hb.sw.\nrewrite (dom_r (wf_releaseD WF)).\nrewrite release_in.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆ sb^?) by basic_solver.\nrelsf; unionL.\n- rewrite rtE; relsf; unionL.\nby arewrite (rfi ⊆ sb); basic_solver 12.\nrewrite path_ut_last at 1; relsf; unionL.\nrewrite TSO.ppo_in_sb at 1.\narewrite (rfi ⊆ sb); relsf; basic_solver 21.\nrewrite TSO.ppo_in_sb at 2.\nrewrite (dom_r (wf_rfiD WF)); rewrite (dom_r (wf_rfeD WF)) at 2; rewrite !seqA.\narewrite (rfi ⊆ sb).\narewrite_id ⦗W⦘ at 2.\nrelsf.\narewrite (⦗R⦘ ⊆ ⦗R⦘ ⨾ ⦗R⦘) at 2.\nbasic_solver.\narewrite (⦗R⦘ ⨾ sb ⨾ ⦗R⦘ ⊆ ppot).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot ⊆ (ppot ∪ rfe)＊) at 2.\narewrite (rfe ⊆ (ppot ∪ rfe)⁺) at 2.\nrelsf.\n- rewrite (wf_rfeD WF) at 2; rewrite !seqA.\narewrite (⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot ⊆ (ppot ∪ rfe)＊) at 2.\narewrite (rfe ⊆ (ppot ∪ rfe)⁺) at 3.\nrelsf.\n"},{"statement":"Lemma hb_in : hb ⊆ sb ∪ sb^? ⨾ ⦗W⦘ ⨾ (ppot ∪ rfe)⁺ ⨾ ⦗R⦘ ⨾ sb^?.","proof":"generalize (@sb_trans G); ins.\nunfold imm_hb.hb.\nrewrite sw_in, <- !unionA; rels.\napply inclusion_t_ind_right.\nbasic_solver.\nrelsf; rewrite !seqA; relsf; unionL.\n1,2,3: basic_solver 21.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot).\ncase_refl _; [type_solver| rewrite TSO.ppo_alt; basic_solver 21].\narewrite (ppot ⊆ (ppot ∪ rfe)＊) at 2.\narewrite ((ppot ∪ rfe)⁺ ⊆ (ppot ∪ rfe)＊) at 1.\nrelsf.\n"},{"statement":"Lemma Coherence : coherence G.","proof":"generalize (@sb_trans G); ins.\ngeneralize (eco_trans WF); ins.\ncdes CON; unfold TSO.hb in *.\napply coherence_alt.\nrewrite hb_in; relsf; unionL.\n- apply sb_irr.\n- rotate 2; relsf.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ (ppot ∪ rfe)＊) at 1.\nrelsf; eapply acyclic_mon; [edone|basic_solver 12].\n- arewrite (rfe ⊆ rf); rewrite (rf_in_eco); apply SC_PER_LOC.\n- rewrite (wf_rfeD WF) at 2; rewrite !seqA; rotate 1.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ (ppot ∪ rfe)＊).\narewrite (rfe ⊆ (ppot ∪ rfe)＊) at 4.\nrelsf; eapply acyclic_mon; [edone|basic_solver 12].\n- arewrite (rfe ⊆ rf); rewrite (rf_in_eco); rewrite (co_in_eco); relsf.\n- arewrite (co ⨾ rfe^? ⊆ co ⨾ rfe^? ⨾ ⦗RW⦘).\nrewrite (dom_r (wf_rfeD WF)).\nrewrite (dom_r (wf_coD WF)).\nbasic_solver 12.\nrewrite (dom_l (wf_coD WF)).\nrewrite !seqA.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\nrotate 1.\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ (ppot ∪ rfe)＊).\narewrite (rfe ⊆ (ppot ∪ rfe)＊) at 4.\nrotate 1; relsf.\narewrite (ppot ∪ rfe ⊆ (ppot ∪ rfe ∪ co)).\narewrite (co ⊆ (ppot ∪ rfe ∪ co)＊) at 2.\nrelsf; eapply acyclic_mon; [edone|basic_solver 12].\n- arewrite (rfe ⊆ rf); rewrite (rf_in_eco); rewrite (fr_in_eco); relsf.\n- arewrite (fr ⨾ rfe^? ⊆ fr ⨾ rfe^? ⨾ ⦗RW⦘).\nrewrite (dom_r (wf_rfeD WF)).\nrewrite (dom_r (wf_frD WF)).\nbasic_solver 12.\nrewrite (dom_l (wf_frD WF)).\nrewrite !seqA.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗R⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\nrotate 1.\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ (ppot ∪ rfe)＊).\narewrite (rfe ⊆ (ppot ∪ rfe)＊) at 4.\nrotate 1; relsf.\narewrite (ppot ∪ rfe ⊆ (ppot ∪ rfe ∪ fr)).\narewrite (fr ⊆ (ppot ∪ rfe ∪ fr)＊) at 2.\nrelsf; eapply acyclic_mon; [edone|basic_solver 12].\n"},{"statement":"Lemma hb_rel_co_acyc : acyclic (hb ∪ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co).","proof":"assert (Wf G) as WF by apply CON.\nassert (coherence G) as COH by apply Coherence.\nassert (transitive hb) by apply hb_trans.\nassert (⦗W⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hbt) as WWHB.\n{\nunfold TSO.hb, TSO.ppo.\nrepeat unionR left.\nunfolder.\nins.\ndesf.\nsplits; auto.\nintros HH.\ndesf.\ntype_solver.\n}\nassert (⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hbt) as RWHB.\n{\nunfold TSO.hb, TSO.ppo.\nrepeat unionR left.\nunfolder.\nins.\ndesf.\nsplits; auto.\nintros HH.\ndesf.\ntype_solver.\n}\narewrite_id ⦗Rel⦘.\nrewrite seq_id_l.\napply acyclic_utt; auto.\n{\nby apply sb_co_trans.\n}\nsplits.\n{\napply hb_irr; auto.\n}\n{\nby apply sb_co_irr.\n}\narewrite_id ⦗F⦘.\nrewrite !seq_id_l.\nrewrite sb_in_hb.\nsin_rewrite rewrite_trans_seq_cr_r; auto.\nrewrite (wf_coD WF), <- !seqA.\napply acyclic_seqC.\nrewrite !seqA.\narewrite (⦗W⦘ ⨾ hb ⨾ ⦗W⦘ ⊆ hbt⁺).\n{\nrewrite hb_in.\nrewrite seq_union_l, seq_union_r, !seqA.\nunionL.\n{\nby rewrite <- ct_step.\n}\narewrite (⦗W⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ hbt^?).\n{\nrewrite crE, seq_union_l, seq_union_r.\nrewrite WWHB.\nbasic_solver.\n}\narewrite (ppot ⊆ hbt).\n{\nunfold TSO.hb.\neauto with hahn.\n}\narewrite (rfe ⊆ hbt).\nrewrite unionK.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ hbt^?).\n{\nrewrite crE, seq_union_l, seq_union_r.\nrewrite RWHB.\nbasic_solver.\n}\nby rewrite ct_cr, cr_ct.\n}\narewrite (co ⊆ hbt).\nrewrite ct_unit.\nred.\nrewrite ct_of_ct.\napply CON.\n"},{"statement":"Lemma eco_in : eco ⊆ sb ∪ hbt⁺ ⨾ sb^?.","proof":"unfold Execution_eco.eco.\nrewrite rfi_union_rfe.\narewrite (rfi ⊆ sb).\nrewrite ct_begin.\nrewrite rt_begin.\nunfold TSO.hb.\nbasic_solver 40.\n"},{"statement":"Lemma psct : psc ⊆ sb ∪ sb ⨾ hbt⁺ ⨾ sb.","proof":"generalize (@sb_trans G); ins.\nunfold imm.psc.\nrewrite (wf_ecoD WF), !seqA.\nrewrite eco_in.\nrewrite hb_in.\narewrite (ppot ∪ rfe ⊆ hbt).\nunfold TSO.hb; basic_solver 12.\nrelsf; unionL.\n1: by unionR left; basic_solver 21.\nall: unionR right.\n- type_solver 21.\n- basic_solver 21.\n- rewrite !seqA.\nrewrite (dom_r (wf_ct_hbD WF)) at 1; rewrite !seqA.\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗RW⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\narewrite (hbt⁺ ⊆ hbt＊) at 1.\nrelsf; type_solver 21.\n- type_solver 21.\n- rewrite !seqA.\nrewrite (dom_r (wf_ct_hbD WF)) at 1; rewrite !seqA.\narewrite_id !⦗RW⦘; rels.\narewrite (⦗R⦘ ⨾ sb^? ⨾ sb ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\narewrite (hbt⁺ ⊆ hbt＊) at 1.\nrelsf; type_solver 21.\n- rewrite !seqA.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗RW⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\narewrite (hbt⁺ ⊆ hbt＊) at 1.\nrelsf; type_solver 21.\n- rewrite !seqA.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗RW⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\narewrite (hbt⁺ ⊆ hbt＊) at 1.\nrewrite (dom_r (wf_ct_hbD WF)) at 1; rewrite !seqA.\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗RW⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppot^?).\nrewrite TSO.ppo_alt; basic_solver 21.\narewrite (ppot^? ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\narewrite (hbt⁺ ⊆ hbt＊) at 1.\nrelsf; type_solver 21.\n"},{"statement":"Lemma ct_pscXt X (XX : X ⊆ sb ∪ sb ⨾ hbt⁺ ⨾ sb)\n      (XD : X ⊆ ⦗ MFENCE ⦘ ⨾ X ⨾ ⦗ MFENCE ⦘) : \n  (sb^? ⨾ X ⨾ sb^?)⁺ ⊆ \n       sb^? ⨾ ⦗MFENCE⦘ ⨾ (sb ∪ sb ⨾ hbt⁺ ⨾ sb) ⨾ ⦗MFENCE⦘ ⨾ sb^?.","proof":"generalize (@sb_trans G); ins.\nrewrite XD, XX.\napply inclusion_t_ind_right.\nbasic_solver 21.\nrelsf; rewrite !seqA.\nunionL.\n1: unionR left; basic_solver 21.\nall: unionR right.\n1,2: basic_solver 42.\nrewrite (dom_r (wf_ct_hbD WF)) at 1.\nrewrite (dom_l (wf_ct_hbD WF)) at 2.\nrewrite !seqA; relsf.\narewrite_id  ⦗MFENCE⦘ at 2.\nrelsf.\narewrite (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘ ⊆ fence).\narewrite (fence ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\narewrite (hbt⁺ ⊆ hbt＊ ) at 1.\nrelsf; basic_solver 21.\n"},{"statement":"Lemma ct_psct : \n  (sb^? ⨾ psc ⨾ sb^?)⁺ ⊆ \n       sb^? ⨾ ⦗MFENCE⦘ ⨾ (sb ∪ sb ⨾ hbt⁺ ⨾ sb) ⨾ ⦗MFENCE⦘ ⨾ sb^?.","proof":"apply (ct_pscXt psct).\nby rewrite (@wf_pscD G) at 1.\n"},{"statement":"Lemma psc_ft : psc_f ⊆ sb ∪ sb ⨾ hbt⁺ ⨾ sb.","proof":"unfold imm.psc_f.\nrewrite crE.\nrewrite !seq_union_l, !seq_union_r, !seq_id_l, !seqA.\nunionL.\n2: by apply psct.\nrewrite hb_in.\nrewrite !seq_union_l, !seq_union_r.\nunionL; [basic_solver|].\nrewrite !seqA.\narewrite (⦗MFENCE⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗W⦘) by type_solver.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗MFENCE⦘ ⊆ ⦗R⦘ ⨾ sb ⨾ ⦗MFENCE⦘) by type_solver.\nunionR right.\narewrite (ppot ∪ rfe ⊆ hbt).\n{\nunfold TSO.hb.\nbasic_solver 10.\n}\nbasic_solver 10.\n"},{"statement":"Lemma ct_psc_ft : \n  (sb^? ⨾ psc_f ⨾ sb^?)⁺ ⊆ \n       sb^? ⨾ ⦗MFENCE⦘ ⨾ (sb ∪ sb ⨾ hbt⁺ ⨾ sb) ⨾ ⦗MFENCE⦘ ⨾ sb^?.","proof":"apply (ct_pscXt psc_ft).\nunfold imm.psc_f.\nrewrite !seqA.\nbasic_solver 10.\n"},{"statement":"Lemma C_EXT : acyc_ext G.","proof":"generalize (@sb_trans G); ins.\napply (acyc_ext_helper WF).\narewrite (rfe ⊆ hbt⁺).\nrewrite (ar_int_in_sb WF); relsf.\narewrite (⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ppot).\n{\nrewrite TSO.ppo_alt.\nbasic_solver 21.\n}\narewrite (ppot ⊆ hbt⁺).\n{\nunfold TSO.hb.\nrewrite <- ct_step.\nbasic_solver 12.\n}\nrewrite unionA; rels.\napply acyclic_union1.\n2: {\nred; rels; eapply CON.\n}\n{\nred.\nrewrite ct_psct; relsf; unionL.\n{\ngeneralize sb_irr.\nbasic_solver 21.\n}\nrewrite (wf_ct_hbD WF); rotate 4.\narewrite_id ⦗MFENCE⦘ at 1.\nrelsf.\narewrite (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘ ⊆ fence).\narewrite (fence ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\nrels.\nred; rels; eapply CON.\n}\nrewrite ct_psct; relsf.\nrewrite !seqA.\nrewrite (dom_r (wf_ct_hbD WF)) at 2.\nrewrite (dom_l (wf_ct_hbD WF)) at 3.\nrewrite !seqA; relsf.\narewrite (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb^? ⨾ ⦗RW⦘ ⊆ fence).\ncase_refl _; [type_solver|vauto].\narewrite (fence ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\narewrite (hbt⁺ ⊆ hbt＊ ) at 2.\nrelsf.\narewrite (sb^? ⨾ ⦗MFENCE⦘ ⨾ sb ⊆ sb^?).\nbasic_solver.\narewrite (⦗MFENCE⦘ ⨾ sb^? ⨾ hbt⁺ ⊆ ⦗MFENCE⦘ ⨾ sb ⨾ hbt⁺).\nrewrite (dom_l (wf_ct_hbD WF)) at 1; type_solver 12.\nrels.\nrewrite (wf_ct_hbD WF); rotate 1.\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘ ⊆ fence).\ncase_refl _; [type_solver|vauto].\narewrite (fence ⊆ hbt^?) by (unfold TSO.hb; basic_solver 12).\nrels.\nred; rels; eapply CON.\n"},{"statement":"Lemma wf_psc_baseD : psc_base ≡ ⦗Sc⦘ ⨾ psc_base ⨾ ⦗Sc⦘.","proof":"split; [|basic_solver].\nunfold imm.psc_base.\nbasic_solver 42.\n"},{"statement":"Lemma wf_psc_fD : psc_f ≡ ⦗Sc⦘ ⨾ psc_f ⨾ ⦗Sc⦘.","proof":"split; [|basic_solver].\nunfold imm.psc_f.\nbasic_solver 42.\n"},{"statement":"Lemma ehbt_ac : acyclic ehbt.","proof":"unfold ehbt.\nrewrite unionA.\nrewrite unionC.\napply acyclic_union.\n{\narewrite (sb ⨾ ⦗MFENCE⦘ ∪ ⦗MFENCE⦘ ⨾ sb ⊆ sb).\napply trans_irr_acyclic.\n{\napply sb_irr.\n}\napply sb_trans.\n}\nrewrite (wf_hbD WF).\nrewrite !seqA.\napply acyclic_seqC.\nrewrite !seqA.\narewrite (⦗RW⦘ ⨾ (sb ⨾ ⦗MFENCE⦘ ∪ ⦗MFENCE⦘ ⨾ sb)＊ ⨾ ⦗RW⦘ ⊆            ⦗RW⦘ ⨾ (sb ⨾ ⦗MFENCE⦘ ⨾ sb)^? ⨾ ⦗RW⦘).\n2: {\narewrite (⦗RW⦘ ⨾ (sb ⨾ ⦗MFENCE⦘ ⨾ sb)^? ⨾ ⦗RW⦘ ⊆ hbt^?).\n{\nrewrite crE.\nrewrite seq_union_l, seq_union_r.\nunionL; [basic_solver|].\nrewrite crE.\nunionR right.\nrewrite !seqA.\nunfold TSO.hb, TSO.fence.\neauto with hahn.\n}\nrewrite ct_step with (r:=hbt) at 1.\nrewrite ct_cr.\nred.\nrewrite ct_of_ct.\napply CON.\n}\nrewrite rtE, crE.\nrewrite !seq_union_l, !seq_union_r.\napply union_mori; [done|].\nrewrite ct_begin, !seqA.\narewrite (⦗RW⦘ ⨾ (sb ⨾ ⦗MFENCE⦘ ∪ ⦗MFENCE⦘ ⨾ sb) ⊆            ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘).\n{\nrewrite seq_union_r.\nunionL; [done|].\nunfolder.\ntype_solver.\n}\nrewrite rtE.\nrewrite !seq_union_l, !seq_union_r, seq_id_l.\narewrite (⦗MFENCE⦘ ⨾ ⦗RW⦘ ⊆ ∅₂).\n{\nunfolder.\ntype_solver.\n}\nunionL; [basic_solver|].\nrewrite ct_end, !seqA.\narewrite ((sb ⨾ ⦗MFENCE⦘ ∪ ⦗MFENCE⦘ ⨾ sb) ⨾ ⦗RW⦘ ⊆ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘).\n{\nrewrite seq_union_l, !seqA.\nunionL; [|done].\nunfolder.\ntype_solver.\n}\narewrite (sb ⨾ ⦗MFENCE⦘ ∪ ⦗MFENCE⦘ ⨾ sb ⊆ sb).\narewrite (sb＊ ⨾ ⦗MFENCE⦘ ⨾ sb ⊆ sb).\n2: done.\narewrite_id ⦗MFENCE⦘.\nrewrite seq_id_l.\nrewrite <- ct_end.\napply ct_of_trans.\napply sb_trans.\n"},{"statement":"Lemma fsc_hb_rw_in_ehbt : ⦗MFENCE⦘ ⨾ hb ⨾ ⦗RW⦘ ⊆ ehbt⁺.","proof":"assert (ppot ∪ rfe ⊆ hbt) as EE.\n{\nunfold TSO.hb.\nunionL; eauto 10 with hahn.\n}\nassert (⦗MFENCE⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ⦗MFENCE⦘ ⨾ sb) as AA    by type_solver 10.\nassert (⦗R⦘ ⨾ sb^? ⨾ ⦗MFENCE⦘ ⊆ sb ⨾ ⦗MFENCE⦘) as BB    by type_solver 10.\nrewrite hb_in.\nrewrite !seq_union_l, !seq_union_r.\nunionL.\n{\nrewrite <- ct_step.\nunfold ehbt.\neauto with hahn hahn_full.\n}\nrewrite !seqA.\nsin_rewrite AA.\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗RW⦘ ⊆ hbt^?).\n{\nrewrite !crE.\nrewrite !seq_union_l, !seq_union_r.\napply union_mori; [basic_solver|].\nunfold TSO.hb.\nrepeat (unionR left).\nunfold TSO.ppo.\nunfolder.\nins.\ndesf.\nall: splits; auto; intros HH; desf.\nall: type_solver.\n}\narewrite (⦗MFENCE⦘ ⨾ sb ⊆ ehbt).\nrewrite EE.\narewrite (hbt ⊆ ehbt).\nrewrite ct_cr.\nrewrite ct_step with (r:=ehbt) at 1.\napply ct_ct.\n"},{"statement":"Lemma rw_hb_fsc_in_ehbt : ⦗RW⦘ ⨾ hb ⨾ ⦗MFENCE⦘ ⊆ ehbt⁺.","proof":"assert (ppot ∪ rfe ⊆ hbt) as EE.\n{\nunfold TSO.hb.\nunionL; eauto 10 with hahn.\n}\nassert (⦗MFENCE⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ⦗MFENCE⦘ ⨾ sb) as AA    by type_solver 10.\nassert (⦗R⦘ ⨾ sb^? ⨾ ⦗MFENCE⦘ ⊆ sb ⨾ ⦗MFENCE⦘) as BB    by type_solver 10.\nrewrite hb_in.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nunionL.\n{\narewrite (sb ⨾ ⦗MFENCE⦘ ⊆ ehbt).\nrewrite <- ct_step.\nbasic_solver.\n}\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ hbt^?).\n{\nrewrite !crE.\nrewrite !seq_union_l, !seq_union_r.\napply union_mori; [basic_solver|].\narewrite (⦗RW⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ppot).\n2: {\nunfold TSO.hb.\neauto with hahn.\n}\nunfold TSO.ppo.\nunfolder.\nins.\ndesf.\nall: splits; auto.\nall: intros HH; type_solver.\n}\nrewrite EE.\nsin_rewrite BB.\narewrite (sb ⨾ ⦗MFENCE⦘ ⊆ ehbt).\narewrite (hbt ⊆ ehbt).\nrewrite ct_unit.\napply cr_ct.\n"},{"statement":"Lemma fsc_hb_fsc_in_ehbt : ⦗MFENCE⦘ ⨾ hb ⨾ ⦗MFENCE⦘ ⊆ ehbt⁺.","proof":"assert (ppot ∪ rfe ⊆ hbt) as EE.\n{\nunfold TSO.hb.\nunionL; eauto 10 with hahn.\n}\nassert (⦗MFENCE⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ⦗MFENCE⦘ ⨾ sb) as AA    by type_solver 10.\nassert (⦗R⦘ ⨾ sb^? ⨾ ⦗MFENCE⦘ ⊆ sb ⨾ ⦗MFENCE⦘) as BB    by type_solver 10.\nrewrite hb_in.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nunionL.\n{\narewrite (sb ⨾ ⦗MFENCE⦘ ⊆ ehbt).\nrewrite <- ct_step.\nbasic_solver.\n}\nsin_rewrite AA.\nsin_rewrite BB.\narewrite (sb ⨾ ⦗MFENCE⦘ ⊆ ehbt).\narewrite (⦗MFENCE⦘ ⨾ sb ⊆ ehbt).\nrewrite EE.\narewrite (hbt ⊆ ehbt).\nrewrite ct_unit.\narewrite (ehbt ⊆ ehbt⁺).\napply ct_ct.\n"},{"statement":"Lemma psc_f_in_ehbt : psc_f ⊆ ehbt⁺.","proof":"assert (ppot ∪ rfe ⊆ hbt) as EE.\n{\nunfold TSO.hb.\nunionL; eauto 10 with hahn.\n}\nassert (⦗MFENCE⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ⦗MFENCE⦘ ⨾ sb) as AA    by type_solver 10.\nassert (⦗R⦘ ⨾ sb^? ⨾ ⦗MFENCE⦘ ⊆ sb ⨾ ⦗MFENCE⦘) as BB    by type_solver 10.\nassert (hbt ⨾ ⦗RW⦘ ⊆ (hbt ⨾ ⦗RW⦘)＊) as FF.\n{\nred.\nins.\napply rt_step; eauto.\n}\nunfold imm.psc_f.\nrewrite crE.\nrewrite !seq_union_l, !seq_union_r, seq_id_l, !seqA.\nunionL.\n{\napply fsc_hb_fsc_in_ehbt.\n}\nrewrite (dom_l (wf_ecoD WF)).\nrewrite !seqA.\nsin_rewrite fsc_hb_rw_in_ehbt.\narewrite (eco ⊆ (hbt)＊ ⨾ ⦗ RW ⦘ ⨾ rfi^?).\n{\nrewrite (eco_alt WF).\nrewrite (dom_r (wf_coD WF)).\nrewrite (dom_r (wf_frD WF)).\narewrite (co ⊆ hbt).\narewrite (fr ⊆ hbt).\nrewrite !unionK.\nrewrite rfi_union_rfe.\nrewrite (dom_r (wf_rfeD WF)).\narewrite (rfe ⊆ hbt).\nrewrite seq_union_r.\nunionL.\n{\narewrite (hbt ⊆ hbt＊).\nbasic_solver 10.\n}\n2: {\narewrite_id ⦗W⦘.\nrewrite seq_id_r.\narewrite (hbt ⊆ hbt＊) at 2.\narewrite (hbt^? ⨾ hbt＊ ⊆ hbt＊).\nbasic_solver 10.\n}\narewrite_id ⦗W⦘.\nrewrite seq_id_r.\narewrite (hbt^? ⊆ hbt＊).\nrewrite (dom_l (wf_rfiD WF)).\nbasic_solver 10.\n}\narewrite (rfi^? ⊆ sb^?).\nrewrite sb_in_hb.\nsin_rewrite rewrite_trans_seq_cr_l.\n2: {\nunfold imm_hb.hb.\napply transitive_ct.\n}\nrewrite rw_hb_fsc_in_ehbt.\narewrite (hbt ⊆ ehbt).\nrewrite rt_ct.\napply ct_ct.\n"},{"statement":"Lemma sc_hb_fsc_in_ehbt : ⦗Sc⦘ ⨾ hb ⨾ ⦗MFENCE⦘ ⊆ ehbt⁺.","proof":"arewrite (hb ⊆ ⦗F ∪₁ RW⦘ ⨾ hb) by type_solver 10.\nrewrite id_union, !seq_union_l, !seq_union_r.\narewrite (⦗Sc⦘ ⨾ ⦗F⦘ ⊆ ⦗MFENCE⦘) by basic_solver.\nrewrite fsc_hb_fsc_in_ehbt.\nrewrite rw_hb_fsc_in_ehbt.\nbasic_solver.\n"},{"statement":"Lemma fsc_hb_sc_in_ehbt : ⦗MFENCE⦘ ⨾ hb ⨾ ⦗Sc⦘ ⊆ ehbt⁺.","proof":"arewrite (hb ⊆ hb ⨾ ⦗F ∪₁ RW⦘) by type_solver 10.\nrewrite id_union, !seq_union_l, !seq_union_r.\narewrite (⦗F⦘ ⨾ ⦗Sc⦘ ⊆ ⦗MFENCE⦘) by basic_solver.\nrewrite fsc_hb_fsc_in_ehbt.\nsin_rewrite fsc_hb_rw_in_ehbt.\nbasic_solver.\n"},{"statement":"Lemma ppot_in_ehbt : ppot ⊆ ehbt.","proof":"arewrite (ppot ⊆ hbt).\n{\nunfold TSO.hb.\neauto with hahn.\n}\nunfold ehbt.\nbasic_solver.\n"},{"statement":"Lemma psc_base_in_ehbt\n      (SCF : ⦗ W∩₁Sc ⦘ ⨾ sb ⨾ ⦗ R∩₁Sc⦘ ⊆\n                sb ⨾ ⦗MFENCE⦘ ⨾ sb) :\n  psc_base ⊆ ehbt⁺.","proof":"assert (⦗Sc⦘ ⨾ sb ⨾ ⦗Sc⦘ ⊆ ehbt⁺) as SCSB.\n{\narewrite (sb ⊆ ⦗F ∪₁ RW⦘ ⨾ sb) by type_solver 10.\nrewrite id_union.\nrewrite !seq_union_l, !seq_union_r.\narewrite (⦗Sc⦘ ⨾ ⦗F⦘ ⊆ ⦗MFENCE⦘) by basic_solver.\nunionL.\n{\nrewrite <- ct_step.\nunfold ehbt.\nbasic_solver.\n}\narewrite (sb ⊆ sb ⨾ ⦗F ∪₁ RW⦘) by type_solver 10.\nrewrite id_union with (s:=F).\nrewrite !seq_union_l, !seq_union_r.\nunionL.\n{\nrewrite <- ct_step.\nunfold ehbt.\nbasic_solver 10.\n}\narewrite (⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ ⊆ ppot ∪ ⦗W⦘ ⨾ sb ⨾ ⦗R⦘).\n{\nunfold TSO.ppo.\nunfolder.\nins.\ndesf.\n2: {\nright.\nsplits; auto.\n}\nall: left; splits; auto.\nall: intros HH; type_solver 10.\n}\nrewrite !seq_union_l, !seq_union_r.\nunionL.\n{\nrewrite ppot_in_ehbt.\nrewrite <- ct_step.\nbasic_solver.\n}\nrewrite !seqA.\narewrite (⦗Sc⦘ ⨾ ⦗W⦘ ⊆ ⦗W∩₁Sc⦘) by basic_solver.\narewrite (⦗R⦘ ⨾ ⦗Sc⦘ ⊆ ⦗R∩₁Sc⦘) by basic_solver.\nrewrite SCF.\nrewrite <- seq_eqvK, !seqA.\narewrite (sb ⨾ ⦗MFENCE⦘ ⊆ ehbt⁺).\narewrite (⦗MFENCE⦘ ⨾ sb ⊆ ehbt⁺).\napply ct_ct.\n}\nassert (⦗Sc⦘ ⨾ hb ⨾ ⦗Sc⦘ ⊆ ehbt⁺) as SCHB.\n{\nrewrite hb_in.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nunionL; auto.\narewrite (⦗Sc⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ehbt^?).\n{\nrewrite !crE.\nrewrite !seq_union_l, !seq_union_r.\napply union_mori; [basic_solver|].\narewrite (sb ⊆ ⦗F ∪₁ RW⦘ ⨾ sb) by type_solver 10.\nrewrite id_union.\nrewrite !seq_union_l, !seq_union_r.\narewrite (⦗Sc⦘ ⨾ ⦗F⦘ ⊆ ⦗MFENCE⦘) by basic_solver.\nunionL.\n{\nunfold ehbt.\nbasic_solver.\n}\narewrite (⦗RW⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ppot).\n2: rewrite ppot_in_ehbt; basic_solver.\nunfold TSO.ppo.\nunfolder.\nins.\ndesf; splits; auto.\nall: intros HH; type_solver 10.\n}\narewrite (⦗R⦘ ⨾ sb^? ⨾ ⦗Sc⦘ ⊆ ehbt^?).\n{\nrewrite !crE.\nrewrite !seq_union_l, !seq_union_r.\napply union_mori; [basic_solver|].\narewrite (sb ⊆ sb ⨾ ⦗F ∪₁ RW⦘) by type_solver 10.\nrewrite id_union.\nrewrite !seq_union_l, !seq_union_r.\narewrite (⦗F⦘ ⨾ ⦗Sc⦘ ⊆ ⦗MFENCE⦘) by basic_solver.\nunionL.\n{\nunfold ehbt.\nbasic_solver 10.\n}\narewrite (⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ⊆ ppot).\n2: rewrite ppot_in_ehbt; basic_solver.\nunfold TSO.ppo.\nunfolder.\nins.\ndesf; splits; auto.\nall: intros HH; type_solver 10.\n}\narewrite (ppot ∪ rfe ⊆ ehbt).\n{\nunfold ehbt, TSO.hb.\neauto 10 with hahn.\n}\nrewrite ct_cr.\nby rewrite cr_ct.\n}\nassert (hb ⨾ hb ⨾ hb ⊆ hb) as HBA.\n{\ngeneralize (@hb_trans G).\nbasic_solver.\n}\nassert (scb ⊆ hb ∪ co ∪ fr) as HBB.\n{\nunfold imm.scb.\narewrite (sb \\ same_loc ⊆ sb).\nrewrite sb_in_hb.\nrewrite HBA.\nunionL; eauto with hahn.\n}\nassert (scb ⊆ hb ∪ eco) as HBECO.\n{\nrewrite HBB.\nrewrite co_in_eco, fr_in_eco.\neauto with hahn.\n}\nunfold imm.psc_base.\nrewrite !crE.\nrewrite !seq_union_l, !seq_union_r, !seq_id_l, !seqA.\nassert (⦗Sc⦘ ⨾ ⦗F⦘ ⊆ ⦗MFENCE⦘) as SCFM by basic_solver.\nsin_rewrite !SCFM.\nassert (⦗F⦘ ⨾ ⦗Sc⦘ ⊆ ⦗MFENCE⦘) as FSC by basic_solver.\nsin_rewrite !FSC.\nunionL.\n4: {\nrewrite HBECO.\narewrite (hb ⨾ (hb ∪ eco) ⨾ hb ⊆ hb ⨾ (eco ⨾ hb)^?).\n{\nrewrite !seq_union_l, !seq_union_r.\nrewrite HBA.\nbasic_solver 10.\n}\napply psc_f_in_ehbt.\n}\n{\nunfold imm.scb.\nrewrite !seq_union_l, !seq_union_r.\nunionL; auto.\n{\narewrite (sb \\ same_loc ⊆ sb).\nrewrite sb_in_hb.\nsin_rewrite HBA.\nauto.\n}\n{\nby arewrite (hb ∩ same_loc ⊆ hb).\n}\narewrite (co ⊆ hbt).\n2: arewrite (fr ⊆ hbt).\nall: arewrite (hbt ⊆ ehbt); rewrite <- ct_step; basic_solver.\n}\n{\nrewrite HBB.\nrewrite unionA.\narewrite (co ∪ fr ⊆ hbt ⨾ ⦗ W ⦘).\n{\nrewrite (dom_r (wf_coD WF)).\nrewrite (dom_r (wf_frD WF)).\narewrite (co ⊆ hbt).\narewrite (fr ⊆ hbt).\neauto with hahn.\n}\nrewrite !seq_union_l, !seq_union_r, !seqA.\narewrite (hb ⨾ hb ⊆ hb).\nunionL.\n{\napply sc_hb_fsc_in_ehbt.\n}\narewrite (W ⊆₁ RW) at 1.\nrewrite rw_hb_fsc_in_ehbt.\narewrite (hbt ⊆ ehbt⁺).\nrewrite ct_ct.\nbasic_solver.\n}\nrewrite HBB.\nrewrite unionA.\narewrite (co ∪ fr ⊆ ⦗ RW ⦘ ⨾ hbt).\n{\nrewrite (dom_l (wf_coD WF)).\nrewrite (dom_l (wf_frD WF)).\narewrite (co ⊆ hbt).\narewrite (fr ⊆ hbt).\nbasic_solver.\n}\nrewrite !seq_union_l, !seq_union_r, !seqA.\narewrite (hb ⨾ hb ⊆ hb).\nunionL.\n{\napply fsc_hb_sc_in_ehbt.\n}\nsin_rewrite fsc_hb_rw_in_ehbt.\narewrite (hbt ⊆ ehbt⁺).\nsin_rewrite ct_ct.\nbasic_solver.\n"},{"statement":"Lemma C_SC (SCF : ⦗ W∩₁Sc ⦘ ⨾ sb ⨾ ⦗ R∩₁Sc⦘ ⊆\n                  sb ⨾ ⦗MFENCE⦘ ⨾ sb) :\n  acyclic (psc_f ∪ psc_base).","proof":"rewrite psc_f_in_ehbt.\nrewrite psc_base_in_ehbt; auto.\nrewrite unionK.\nred.\nrewrite ct_of_ct.\napply ehbt_ac.\n"},{"statement":"Lemma IMM_consistent\n      (SCF : ⦗ W∩₁Sc ⦘ ⨾ sb ⨾ ⦗ R∩₁Sc⦘ ⊆ sb ⨾ ⦗MFENCE⦘ ⨾ sb):\n  imm_consistent G.","proof":"cdes CON.\nred; splits; eauto.\napply Coherence.\napply C_EXT.\nby apply C_SC.\n"},{"statement":"Lemma TSO_fsupp_ar_ct\n      (SCF : E ∩₁ MFENCE ⊆₁ ∅)\n      (TB: fin_threads G):\n  imm_fair G.","proof":"red.\nunfold ar.\narewrite (psc ⊆ ∅₂); [| rewrite union_false_l].\n{\nrewrite (dom_l (wf_pscE WF)).\nrewrite (dom_l (wf_pscD G)).\nrewrite <- seqA, <- id_inter.\nrewrite SCF.\nclear; basic_solver 1.\n}\npose proof WF as WF.\nrewrite rfe_in_rf.\nrewrite ar_int_in_sb; auto.\neapply thread_bounds_fsupp_ninit_ct; eauto; try apply WF.\n{\nbasic_solver.\n}\n{\nrewrite unionC.\nby apply TSO_sb_rf_acyclic.\n}\n{\nrewrite no_rf_to_init, no_sb_to_init; auto.\nbasic_solver.\n}\n{\nrewrite wf_rfE, wf_sbE; auto.\nbasic_solver.\n}\nrewrite seq_union_r.\napply fsupp_union.\n{\nrewrite inclusion_seq_eqv_l.\nby apply fsupp_rf.\n}\nby apply fsupp_sb.\n"}]