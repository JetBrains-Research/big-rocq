{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/basic/FinThreads.v","fileSamples":[{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (FIN : exists findom : list thread_id,\n  forall x : thread_id, threads_set G x -> In x findom) : exists b : thread_id, threads_bound G b.","proofString":"desf.\nunfold threads_bound.\nenough (exists b, forall t, List.In t findom -> BinPos.Pos.lt t b) as [b HH].\nexists b.\nins.\napply HH.\napply FIN.\nnow apply ACTS.\nclear.\ninduction findom.\nexists BinPos.xH.\nins.\ndesf.\nexists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) : exists b : thread_id, threads_bound G b.","proofString":"unfold threads_bound.\nenough (exists b, forall t, List.In t findom -> BinPos.Pos.lt t b) as [b HH].\nexists b.\nins.\napply HH.\napply FIN.\nnow apply ACTS.\nclear.\ninduction findom.\nexists BinPos.xH.\nins.\ndesf.\nexists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) : exists b : thread_id,\n  forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b.","proofString":"enough (exists b, forall t, List.In t findom -> BinPos.Pos.lt t b) as [b HH].\nexists b.\nins.\napply HH.\napply FIN.\nnow apply ACTS.\nclear.\ninduction findom.\nexists BinPos.xH.\nins.\ndesf.\nexists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) (b : BinNums.positive) (HH : forall t : thread_id, In t findom -> BinPos.Pos.lt t b) : exists b0 : thread_id,\n  forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b0.","proofString":"exists b.\nins.\napply HH.\napply FIN.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) (b : BinNums.positive) (HH : forall t : thread_id, In t findom -> BinPos.Pos.lt t b) : forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b.","proofString":"ins.\napply HH.\napply FIN.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e0 : actid, acts_set G e0 -> threads_set G (tid e0)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) (b : BinNums.positive) (HH : forall t : thread_id, In t findom -> BinPos.Pos.lt t b) (e : actid) (Ge : acts_set G e) : BinPos.Pos.lt (tid e) b.","proofString":"apply HH.\napply FIN.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e0 : actid, acts_set G e0 -> threads_set G (tid e0)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) (b : BinNums.positive) (HH : forall t : thread_id, In t findom -> BinPos.Pos.lt t b) (e : actid) (Ge : acts_set G e) : In (tid e) findom.","proofString":"apply FIN.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e0 : actid, acts_set G e0 -> threads_set G (tid e0)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) (b : BinNums.positive) (HH : forall t : thread_id, In t findom -> BinPos.Pos.lt t b) (e : actid) (Ge : acts_set G e) : threads_set G (tid e).","proofString":"now apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (findom : list thread_id) (FIN : forall x : thread_id, threads_set G x -> In x findom) : exists b : BinNums.positive,\n  forall t : thread_id, In t findom -> BinPos.Pos.lt t b.","proofString":"clear.\ninduction findom.\nexists BinPos.xH.\nins.\ndesf.\nexists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(findom : list thread_id) : exists b : BinNums.positive,\n  forall t : thread_id, In t findom -> BinPos.Pos.lt t b.","proofString":"induction findom.\nexists BinPos.xH.\nins.\ndesf.\nexists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"exists b : BinNums.positive,\n  forall t : thread_id, In t [] -> BinPos.Pos.lt t b.","proofString":"exists BinPos.xH.\nins."},{"statement":"forall t : thread_id, In t [] -> BinPos.Pos.lt t BinNums.xH.","proofString":"ins."},{"statement":"(a : thread_id) (findom : list thread_id) (IHfindom : exists b : BinNums.positive,\n  forall t : thread_id, In t findom -> BinPos.Pos.lt t b) : exists b : BinNums.positive,\n  forall t : thread_id, In t (a :: findom) -> BinPos.Pos.lt t b.","proofString":"desf.\nexists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(a : thread_id) (findom : list thread_id) (b : BinNums.positive) (IHfindom : forall t : thread_id, In t findom -> BinPos.Pos.lt t b) : exists b0 : BinNums.positive,\n  forall t : thread_id, In t (a :: findom) -> BinPos.Pos.lt t b0.","proofString":"exists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(a : thread_id) (findom : list thread_id) (b : BinNums.positive) (IHfindom : forall t : thread_id, In t findom -> BinPos.Pos.lt t b) : forall t : thread_id,\nIn t (a :: findom) ->\nBinPos.Pos.lt t (Basic.Ident.add (BinPos.Pos.max a b) BinNums.xH).","proofString":"ins.\ndesf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(a : thread_id) (findom : list thread_id) (b : BinNums.positive) (IHfindom : forall t0 : thread_id, In t0 findom -> BinPos.Pos.lt t0 b) (t : thread_id) (H : a = t \\/ In t findom) : BinPos.Pos.lt t (Basic.Ident.add (BinPos.Pos.max a b) BinNums.xH).","proofString":"desf.\nlia.\netransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(findom : list thread_id) (b : BinNums.positive) (IHfindom : forall t0 : thread_id, In t0 findom -> BinPos.Pos.lt t0 b) (t : thread_id) : BinPos.Pos.lt t (Basic.Ident.add (BinPos.Pos.max t b) BinNums.xH).","proofString":"lia."},{"statement":"(a : thread_id) (findom : list thread_id) (b : BinNums.positive) (IHfindom : forall t0 : thread_id, In t0 findom -> BinPos.Pos.lt t0 b) (t : thread_id) (H : In t findom) : BinPos.Pos.lt t (Basic.Ident.add (BinPos.Pos.max a b) BinNums.xH).","proofString":"etransitivity.\nnow apply IHfindom.\nlia."},{"statement":"(b x : BinNums.positive) (IN : BinPos.Pos.lt x b) : In x (map BinPos.Pos.of_nat (List.seq 0 (BinPos.Pos.to_nat b))).","proofString":"apply Pnat.Pos2Nat.inj_lt in IN.\napply in_map_iff.\neexists.\nsplits.\nby apply Pnat.Pos2Nat.id.\napply in_seq.\nlia."},{"statement":"(b x : BinNums.positive) (IN : BinPos.Pos.to_nat x < BinPos.Pos.to_nat b) : In x (map BinPos.Pos.of_nat (List.seq 0 (BinPos.Pos.to_nat b))).","proofString":"apply in_map_iff.\neexists.\nsplits.\nby apply Pnat.Pos2Nat.id.\napply in_seq.\nlia."},{"statement":"(b x : BinNums.positive) (IN : BinPos.Pos.to_nat x < BinPos.Pos.to_nat b) : exists x0 : nat,\n  BinPos.Pos.of_nat x0 = x /\\ In x0 (List.seq 0 (BinPos.Pos.to_nat b)).","proofString":"eexists.\nsplits.\nby apply Pnat.Pos2Nat.id.\napply in_seq.\nlia."},{"statement":"(b x : BinNums.positive) (IN : BinPos.Pos.to_nat x < BinPos.Pos.to_nat b) : 0 <= BinPos.Pos.to_nat x < 0 + BinPos.Pos.to_nat b.","proofString":"lia."},{"statement":"(A : Type) (a : A) (l : list A) (DUP : ~ NoDup (a :: l)) (IHl : ~ NoDup l ->\nexists (l1 : list A) (a0 : A) (l2 l3 : list A),\n  l = l1 ++ a0 :: l2 ++ a0 :: l3) : exists (l1 : list A) (a0 : A) (l2 l3 : list A),\n  a :: l = l1 ++ a0 :: l2 ++ a0 :: l3.","proofString":"rewrite nodup_cons in *; clarify_not.\nby apply in_split in DUP; desf; exists nil; ins; eauto.\nspecialize (IHl DUP); desf; eexists (_ :: _); ins; eauto."},{"statement":"(A : Type) (a : A) (l : list A) (DUP : In a l) (IHl : ~ NoDup l ->\nexists (l1 : list A) (a0 : A) (l2 l3 : list A),\n  l = l1 ++ a0 :: l2 ++ a0 :: l3) : exists (l1 : list A) (a0 : A) (l2 l3 : list A),\n  a :: l = l1 ++ a0 :: l2 ++ a0 :: l3.","proofString":"by apply in_split in DUP; desf; exists nil; ins; eauto."},{"statement":"(A : Type) (a : A) (l : list A) (DUP : ~ NoDup l) (IHl : ~ NoDup l ->\nexists (l1 : list A) (a0 : A) (l2 l3 : list A),\n  l = l1 ++ a0 :: l2 ++ a0 :: l3) : exists (l1 : list A) (a0 : A) (l2 l3 : list A),\n  a :: l = l1 ++ a0 :: l2 ++ a0 :: l3.","proofString":"specialize (IHl DUP); desf; eexists (_ :: _); ins; eauto."},{"statement":"(G : execution) (r : relation actid) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (TB : fin_threads G) (SB_R : sb G ⊆ r) (AC_R : acyclic r) (R_NI : domb r (set_compl (fun a : actid => is_init a))) (E_R : doma r (acts_set G)) (FS_R : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r)) : acyclic (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r).","proofString":"eapply acyclic_mori; eauto.\nred.\nbasic_solver."},{"statement":"(G : execution) (r : relation actid) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (TB : fin_threads G) (SB_R : sb G ⊆ r) (AC_R : acyclic r) (R_NI : domb r (set_compl (fun a : actid => is_init a))) (E_R : doma r (acts_set G)) (FS_R : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r)) : flip inclusion r (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r).","proofString":"red.\nbasic_solver."},{"statement":"(G : execution) (r : relation actid) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (TB : fin_threads G) (SB_R : sb G ⊆ r) (AC_R : acyclic r) (R_NI : domb r (set_compl (fun a : actid => is_init a))) (E_R : doma r (acts_set G)) (FS_R : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r)) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r ⊆ r.","proofString":"basic_solver."},{"statement":"(G : execution) (r : relation actid) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (TB : fin_threads G) (SB_R : sb G ⊆ r) (AC_R : acyclic r) (R_NI : domb r (set_compl (fun a : actid => is_init a))) (E_R : doma r (acts_set G)) (FS_R : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r)) : doma (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r)\n  (acts_set G \\₁ (fun a : actid => is_init a)).","proofString":"erewrite doma_rewrite with (r := r); eauto.\nbasic_solver."},{"statement":"(G : execution) (r : relation actid) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (TB : fin_threads G) (SB_R : sb G ⊆ r) (AC_R : acyclic r) (R_NI : domb r (set_compl (fun a : actid => is_init a))) (E_R : doma r (acts_set G)) (FS_R : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r)) : doma (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗acts_set G⦘ ⨾ r)\n  (acts_set G \\₁ (fun a : actid => is_init a)).","proofString":"basic_solver."}]}