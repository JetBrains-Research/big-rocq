{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/x86/Op.v","fileSamples":[{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"assert (forall (x y: comparison), {x=y}+{x<>y}).\ndecide equality.\ndecide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}.","proofString":"decide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(x y : addressing) (H : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : Z, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(F : Type) (V : Type) (genv : Genv.t F V) (sp : val) (id : ident) (ofs : ptrofs) : eval_addressing genv sp (Aglobal id ofs) nil =\nSome (Genv.symbol_address genv id ofs).","proofString":"unfold eval_addressing, eval_addressing32, eval_addressing64; destruct Archi.ptr64; auto."},{"statement":"(F : Type) (V : Type) (genv : Genv.t F V) (sp : val) (ofs : ptrofs) : eval_addressing genv sp (Ainstack ofs) nil = Some (Val.offset_ptr sp ofs).","proofString":"unfold eval_addressing, eval_addressing32, eval_addressing64; destruct Archi.ptr64; auto."},{"statement":"(v1 v2 : val) : Val.has_type (Val.add v1 v2) Tint.","proofString":"unfold Val.has_type, Val.add.\ndestruct Archi.ptr64, v1, v2; auto."},{"statement":"(v1 v2 : val) : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend.","proofString":"destruct Archi.ptr64, v1, v2; auto."},{"statement":"(v1 v2 : val) : Val.has_type (Val.addl v1 v2) Tlong.","proofString":"unfold Val.has_type, Val.addl.\ndestruct Archi.ptr64, v1, v2; auto."},{"statement":"(v1 v2 : val) : match\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend.","proofString":"destruct Archi.ptr64, v1, v2; auto."},{"statement":"(addr : addressing) (vl : list val) (sp v : val) (H : eval_addressing64 genv sp addr vl = Some v) : Val.has_type v Tlong.","proofString":"destruct addr; simpl in H; FuncInv; subst; simpl; auto using type_addl.\nunfold Genv.symbol_address; destruct (Genv.find_symbol genv i); simpl; auto.\ndestruct sp; simpl; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp : val) (Heqb : Archi.ptr64 = true) : Val.has_type (Genv.symbol_address genv i i0) Tlong.","proofString":"unfold Genv.symbol_address; destruct (Genv.find_symbol genv i); simpl; auto."},{"statement":"(i : ptrofs) (sp : val) (Heqb : Archi.ptr64 = true) : Val.has_type (Val.offset_ptr sp i) Tlong.","proofString":"destruct sp; simpl; auto."},{"statement":"(addr : addressing) (vl : list val) (sp v : val) (H : eval_addressing32 genv sp addr vl = Some v) : Val.has_type v Tint.","proofString":"destruct addr; simpl in H; FuncInv; subst; simpl; auto using type_add.\nunfold Genv.symbol_address; destruct (Genv.find_symbol genv i); simpl; auto.\ndestruct sp; simpl; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp : val) (Heqb : Archi.ptr64 = false) : Val.has_type (Genv.symbol_address genv i i0) Tint.","proofString":"unfold Genv.symbol_address; destruct (Genv.find_symbol genv i); simpl; auto."},{"statement":"(i : ptrofs) (sp : val) (Heqb : Archi.ptr64 = false) : Val.has_type (Val.offset_ptr sp i) Tint.","proofString":"destruct sp; simpl; auto."},{"statement":"(addr : addressing) (vl : list val) (sp v : val) (H : (if Archi.ptr64\n then eval_addressing64 genv sp addr vl\n else eval_addressing32 genv sp addr vl) = Some v) : Val.has_type v (if Archi.ptr64 then Tlong else Tint).","proofString":"destruct Archi.ptr64; eauto using type_of_addressing64_sound, type_of_addressing32_sound."},{"statement":"(sp v : val) (m : mem) (H : Omove <> Omove) : Val.has_type v Tint.","proofString":"congruence."},{"statement":"(n : int) (sp : val) (m : mem) (H : Ointconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(n : int64) (sp : val) (m : mem) (H : Olongconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(n : float) (sp : val) (m : mem) (H : Ofloatconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(n : float32) (sp : val) (m : mem) (H : Osingleconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(a : addressing) (vl : list val) (sp v : val) (m : mem) (H : Olea a <> Omove) (H0 : eval_addressing32 genv sp a vl = Some v) : Val.has_type v Tint.","proofString":"eapply type_of_addressing32_sound; eauto."},{"statement":"(a : addressing) (vl : list val) (sp v : val) (m : mem) (H : Oleal a <> Omove) (H0 : eval_addressing64 genv sp a vl = Some v) : Val.has_type v Tlong.","proofString":"eapply type_of_addressing64_sound; eauto."},{"statement":"(c : condition) (t : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel c t <> Omove) : Val.has_type (Val.select (eval_condition c vl m) v0 v1 t) t.","proofString":"unfold Val.select.\ndestruct (eval_condition c vl m).\napply Val.normalize_type.\nexact I."},{"statement":"(c : condition) (t : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel c t <> Omove) : Val.has_type\n  match eval_condition c vl m with\n  | Some b => Val.normalize (if b then v0 else v1) t\n  | None => Vundef\n  end t.","proofString":"destruct (eval_condition c vl m).\napply Val.normalize_type.\nexact I."},{"statement":"(c : condition) (t : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel c t <> Omove) (b : bool) : Val.has_type (Val.normalize (if b then v0 else v1) t) t.","proofString":"apply Val.normalize_type."},{"statement":"(c : condition) (t : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel c t <> Omove) : Val.has_type Vundef t.","proofString":"exact I."},{"statement":"(A : Type) (op : operation) (args : list A) (a : A) : is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil.","proofString":"unfold is_move_operation; destruct op;  try (intros; discriminate).\ndestruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (args : list A) (a : A) : match args with\n| nil => None\n| arg :: nil => Some arg\n| arg :: _ :: _ => None\nend = Some a -> Omove = Omove /\\ args = a :: nil.","proofString":"destruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a : A) : None = Some a -> Omove = Omove /\\ nil = a :: nil.","proofString":"intros; discriminate."},{"statement":"(A : Type) (a0 : A) (args : list A) (a : A) : match args with\n| nil => Some a0\n| _ :: _ => None\nend = Some a -> Omove = Omove /\\ a0 :: args = a :: nil.","proofString":"destruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a0 a : A) : Some a0 = Some a -> Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intros.\nintuition congruence."},{"statement":"(A : Type) (a0 a : A) (H : Some a0 = Some a) : Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intuition congruence."},{"statement":"(A : Type) (a0 a1 : A) (args : list A) (a : A) : None = Some a -> Omove = Omove /\\ a0 :: a1 :: args = a :: nil.","proofString":"intros; discriminate."},{"statement":"(cond : condition) (vl : list val) (m : mem) : eval_condition (negate_condition cond) vl m =\noption_map negb (eval_condition cond vl m).","proofString":"destruct cond; simpl.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0) as [[]|]; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0) as [[]|]; auto.\ndestruct vl; auto.\ndestruct vl; auto.\ndestruct vl; auto.\ndestruct vl; auto.\ndestruct (Val.maskzero_bool v n) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmp_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmp_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmp_bool c v v0).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v v0).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (n : int) (v : val) (m : mem) : Val.cmp_bool (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmp_bool c v (Vint n)).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (n : int) (v : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (Vint n)).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpl_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpl_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmpl_bool c v v0).","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v v0).","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpl_bool (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpl_bool c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (n : int64) (v : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmpl_bool c v (Vlong n)).","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (n : int64) (v : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v (Vlong n)).","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpf_bool c v v0 =\noption_map negb (option_map negb (Val.cmpf_bool c v v0)).","proofString":"destruct (Val.cmpf_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpfs_bool c v v0 =\noption_map negb (option_map negb (Val.cmpfs_bool c v v0)).","proofString":"destruct (Val.cmpfs_bool c v v0) as [[]|]; auto."},{"statement":"(n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => option_map negb (Val.maskzero_bool v1 n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.maskzero_bool v1 n\n  | v1 :: _ :: _ => None\n  end.","proofString":"destruct vl; auto.\ndestruct vl; auto."},{"statement":"(n : int) (v : val) (vl : list val) (m : mem) : match vl with\n| nil => option_map negb (Val.maskzero_bool v n)\n| _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => Val.maskzero_bool v n\n  | _ :: _ => None\n  end.","proofString":"destruct vl; auto."},{"statement":"(n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.maskzero_bool v1 n\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => option_map negb (Val.maskzero_bool v1 n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"destruct vl; auto.\ndestruct vl; auto.\ndestruct (Val.maskzero_bool v n) as [[]|]; auto."},{"statement":"(n : int) (v : val) (vl : list val) (m : mem) : match vl with\n| nil => Val.maskzero_bool v n\n| _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => option_map negb (Val.maskzero_bool v n)\n  | _ :: _ => None\n  end.","proofString":"destruct vl; auto.\ndestruct (Val.maskzero_bool v n) as [[]|]; auto."},{"statement":"(n : int) (v : val) (m : mem) : Val.maskzero_bool v n =\noption_map negb (option_map negb (Val.maskzero_bool v n)).","proofString":"destruct (Val.maskzero_bool v n) as [[]|]; auto."},{"statement":"(delta : Z) (addr : addressing) : type_of_addressing (shift_stack_addressing delta addr) =\ntype_of_addressing addr.","proofString":"destruct addr; auto."},{"statement":"(delta : Z) (op : operation) : type_of_operation (shift_stack_operation delta op) = type_of_operation op.","proofString":"destruct op; auto; simpl; decEq; destruct a; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : eval_addressing32 ge (Vptr sp Ptrofs.zero)\n  (shift_stack_addressing delta addr) vl =\neval_addressing32 ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"assert (A: forall i, Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) = Ptrofs.add (Ptrofs.repr delta) i).\nintros.\nrewrite Ptrofs.add_zero_l.\napply Ptrofs.add_commut.\ndestruct addr; simpl; rewrite ?A; reflexivity."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : forall i : ptrofs,\nPtrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) =\nPtrofs.add (Ptrofs.repr delta) i.","proofString":"intros.\nrewrite Ptrofs.add_zero_l.\napply Ptrofs.add_commut."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) (i : ptrofs) : Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) =\nPtrofs.add (Ptrofs.repr delta) i.","proofString":"rewrite Ptrofs.add_zero_l.\napply Ptrofs.add_commut."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) (i : ptrofs) : Ptrofs.add i (Ptrofs.repr delta) = Ptrofs.add (Ptrofs.repr delta) i.","proofString":"apply Ptrofs.add_commut."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) (A : forall i : ptrofs,\nPtrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) =\nPtrofs.add (Ptrofs.repr delta) i) : eval_addressing32 ge (Vptr sp Ptrofs.zero)\n  (shift_stack_addressing delta addr) vl =\neval_addressing32 ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"destruct addr; simpl; rewrite ?A; reflexivity."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : eval_addressing64 ge (Vptr sp Ptrofs.zero)\n  (shift_stack_addressing delta addr) vl =\neval_addressing64 ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"assert (A: forall i, Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) = Ptrofs.add (Ptrofs.repr delta) i).\nintros.\nrewrite Ptrofs.add_zero_l.\napply Ptrofs.add_commut.\ndestruct addr; simpl; rewrite ?A; reflexivity."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : forall i : ptrofs,\nPtrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) =\nPtrofs.add (Ptrofs.repr delta) i.","proofString":"intros.\nrewrite Ptrofs.add_zero_l.\napply Ptrofs.add_commut."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) (i : ptrofs) : Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) =\nPtrofs.add (Ptrofs.repr delta) i.","proofString":"rewrite Ptrofs.add_zero_l.\napply Ptrofs.add_commut."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) (i : ptrofs) : Ptrofs.add i (Ptrofs.repr delta) = Ptrofs.add (Ptrofs.repr delta) i.","proofString":"apply Ptrofs.add_commut."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) (A : forall i : ptrofs,\nPtrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)) =\nPtrofs.add (Ptrofs.repr delta) i) : eval_addressing64 ge (Vptr sp Ptrofs.zero)\n  (shift_stack_addressing delta addr) vl =\neval_addressing64 ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"destruct addr; simpl; rewrite ?A; reflexivity."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : eval_addressing ge (Vptr sp Ptrofs.zero) (shift_stack_addressing delta addr)\n  vl = eval_addressing ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"unfold eval_addressing.\ndestruct Archi.ptr64; auto using eval_shift_stack_addressing32, eval_shift_stack_addressing64."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : (if Archi.ptr64\n then\n  eval_addressing64 ge (Vptr sp Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl\n else\n  eval_addressing32 ge (Vptr sp Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl) =\n(if Archi.ptr64\n then eval_addressing64 ge (Vptr sp (Ptrofs.repr delta)) addr vl\n else eval_addressing32 ge (Vptr sp (Ptrofs.repr delta)) addr vl).","proofString":"destruct Archi.ptr64; auto using eval_shift_stack_addressing32, eval_shift_stack_addressing64."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (op : operation) (vl : list val) (m : mem) (delta : Z) : eval_operation ge (Vptr sp Ptrofs.zero) (shift_stack_operation delta op) vl m =\neval_operation ge (Vptr sp (Ptrofs.repr delta)) op vl m.","proofString":"destruct op; simpl; auto using eval_shift_stack_addressing32, eval_shift_stack_addressing64."},{"statement":"forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y).","proofString":"intros.\napply Int.eqm_samerepr; auto with ints."},{"statement":"(x y : Z) : Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y).","proofString":"apply Int.eqm_samerepr; auto with ints."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) : forall (F V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing)\n  (args : list val) (delta : Z) (v : val),\neval_addressing32 ge sp addr args = Some v ->\neval_addressing32 ge sp (offset_addressing_total addr delta) args =\nSome (Val.add v (Vint (Int.repr delta))).","proofString":"assert (B: forall delta, Archi.ptr64 = false -> Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta)).\nintros; symmetry; auto with ptrofs.\nintros.\ndestruct addr; simpl in *; FuncInv; subst; simpl.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nauto.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut.\ndestruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) : forall delta : Z,\nArchi.ptr64 = false -> Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta).","proofString":"intros; symmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (B : forall delta : Z,\nArchi.ptr64 = false -> Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta)) : forall (F V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing)\n  (args : list val) (delta : Z) (v : val),\neval_addressing32 ge sp addr args = Some v ->\neval_addressing32 ge sp (offset_addressing_total addr delta) args =\nSome (Val.add v (Vint (Int.repr delta))).","proofString":"intros.\ndestruct addr; simpl in *; FuncInv; subst; simpl.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nauto.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut.\ndestruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (v : val) (H : eval_addressing32 ge sp addr args = Some v) : eval_addressing32 ge sp (offset_addressing_total addr delta) args =\nSome (Val.add v (Vint (Int.repr delta))).","proofString":"destruct addr; simpl in *; FuncInv; subst; simpl.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite <- A, ! Val.add_assoc; auto.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nauto.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut.\nrewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut.\ndestruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (v0 : val) (delta : Z) : Some (Val.add v0 (Vint (Int.repr (z + delta)))) =\nSome (Val.add (Val.add v0 (Vint (Int.repr z))) (Vint (Int.repr delta))).","proofString":"rewrite <- A, ! Val.add_assoc; auto."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (v0 v1 : val) (delta : Z) : Some (Val.add (Val.add v0 v1) (Vint (Int.repr (z + delta)))) =\nSome\n  (Val.add (Val.add (Val.add v0 v1) (Vint (Int.repr z)))\n     (Vint (Int.repr delta))).","proofString":"rewrite <- A, ! Val.add_assoc; auto."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z z0 : Z) (v0 : val) (delta : Z) : Some\n  (Val.add (Val.mul v0 (Vint (Int.repr z))) (Vint (Int.repr (z0 + delta)))) =\nSome\n  (Val.add (Val.add (Val.mul v0 (Vint (Int.repr z))) (Vint (Int.repr z0)))\n     (Vint (Int.repr delta))).","proofString":"rewrite <- A, ! Val.add_assoc; auto."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z z0 : Z) (v0 v1 : val) (delta : Z) : Some\n  (Val.add v0\n     (Val.add (Val.mul v1 (Vint (Int.repr z))) (Vint (Int.repr (z0 + delta))))) =\nSome\n  (Val.add\n     (Val.add v0\n        (Val.add (Val.mul v1 (Vint (Int.repr z))) (Vint (Int.repr z0))))\n     (Vint (Int.repr delta))).","proofString":"rewrite <- A, ! Val.add_assoc; auto."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) : Some (Genv.symbol_address ge i (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Val.add (Genv.symbol_address ge i i0) (Vint (Int.repr delta))).","proofString":"rewrite B, Genv.shift_symbol_address_32 by auto.\nauto."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) : Some (Val.add (Genv.symbol_address ge i i0) (Vint (Int.repr delta))) =\nSome (Val.add (Genv.symbol_address ge i i0) (Vint (Int.repr delta))).","proofString":"auto."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Some\n  (Val.add (Genv.symbol_address ge i (Ptrofs.add i0 (Ptrofs.repr delta))) v0) =\nSome\n  (Val.add (Val.add (Genv.symbol_address ge i i0) v0) (Vint (Int.repr delta))).","proofString":"rewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Some\n  (Val.add (Val.add (Genv.symbol_address ge i i0) (Vint (Int.repr delta))) v0) =\nSome\n  (Val.add (Val.add (Genv.symbol_address ge i i0) v0) (Vint (Int.repr delta))).","proofString":"rewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Some\n  (Val.add (Genv.symbol_address ge i i0) (Val.add (Vint (Int.repr delta)) v0)) =\nSome\n  (Val.add (Genv.symbol_address ge i i0) (Val.add v0 (Vint (Int.repr delta)))).","proofString":"do 2 f_equal.\napply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Val.add (Vint (Int.repr delta)) v0 = Val.add v0 (Vint (Int.repr delta)).","proofString":"apply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Some\n  (Val.add (Genv.symbol_address ge i (Ptrofs.add i0 (Ptrofs.repr delta)))\n     (Val.mul v0 (Vint (Int.repr z)))) =\nSome\n  (Val.add\n     (Val.add (Genv.symbol_address ge i i0) (Val.mul v0 (Vint (Int.repr z))))\n     (Vint (Int.repr delta))).","proofString":"rewrite B, Genv.shift_symbol_address_32 by auto.\nrewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Some\n  (Val.add (Val.add (Genv.symbol_address ge i i0) (Vint (Int.repr delta)))\n     (Val.mul v0 (Vint (Int.repr z)))) =\nSome\n  (Val.add\n     (Val.add (Genv.symbol_address ge i i0) (Val.mul v0 (Vint (Int.repr z))))\n     (Vint (Int.repr delta))).","proofString":"rewrite ! Val.add_assoc.\ndo 2 f_equal.\napply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Some\n  (Val.add (Genv.symbol_address ge i i0)\n     (Val.add (Vint (Int.repr delta)) (Val.mul v0 (Vint (Int.repr z))))) =\nSome\n  (Val.add (Genv.symbol_address ge i i0)\n     (Val.add (Val.mul v0 (Vint (Int.repr z))) (Vint (Int.repr delta)))).","proofString":"do 2 f_equal.\napply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) : Val.add (Vint (Int.repr delta)) (Val.mul v0 (Vint (Int.repr z))) =\nVal.add (Val.mul v0 (Vint (Int.repr z))) (Vint (Int.repr delta)).","proofString":"apply Val.add_commut."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ptrofs) (delta : Z) : Some (Val.offset_ptr sp (Ptrofs.add i (Ptrofs.repr delta))) =\nSome (Val.add (Val.offset_ptr sp i) (Vint (Int.repr delta))).","proofString":"destruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b (Ptrofs.add (Ptrofs.add i0 i) (Ptrofs.of_int (Int.repr delta)))).","proofString":"rewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome (Vptr b (Ptrofs.add (Ptrofs.add i0 i) (Ptrofs.of_int (Int.repr delta)))).","proofString":"rewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.of_int (Int.repr delta))))).","proofString":"do 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int.add (Int.repr x) (Int.repr y) = Int.repr (x + y)) (Heqb : Archi.ptr64 = false) (B : forall delta0 : Z,\nfalse = false -> Ptrofs.repr delta0 = Ptrofs.of_int (Int.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta).","proofString":"symmetry; auto with ptrofs."},{"statement":"forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y).","proofString":"intros.\napply Int64.eqm_samerepr; auto with ints."},{"statement":"(x y : Z) : Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y).","proofString":"apply Int64.eqm_samerepr; auto with ints."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) : forall (F V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing)\n  (args : list val) (delta : Z) (v : val),\neval_addressing64 ge sp addr args = Some v ->\neval_addressing64 ge sp (offset_addressing_total addr delta) args =\nSome (Val.addl v (Vlong (Int64.repr delta))).","proofString":"assert (B: forall delta, Archi.ptr64 = true -> Ptrofs.repr delta = Ptrofs.of_int64 (Int64.repr delta)).\nintros; symmetry; auto with ptrofs.\nintros.\ndestruct addr; simpl in *; FuncInv; subst; simpl.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite B, Genv.shift_symbol_address_64 by auto.\nauto.\ndestruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) : forall delta : Z,\nArchi.ptr64 = true -> Ptrofs.repr delta = Ptrofs.of_int64 (Int64.repr delta).","proofString":"intros; symmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (B : forall delta : Z,\nArchi.ptr64 = true -> Ptrofs.repr delta = Ptrofs.of_int64 (Int64.repr delta)) : forall (F V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing)\n  (args : list val) (delta : Z) (v : val),\neval_addressing64 ge sp addr args = Some v ->\neval_addressing64 ge sp (offset_addressing_total addr delta) args =\nSome (Val.addl v (Vlong (Int64.repr delta))).","proofString":"intros.\ndestruct addr; simpl in *; FuncInv; subst; simpl.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite B, Genv.shift_symbol_address_64 by auto.\nauto.\ndestruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = true ->\nPtrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (v : val) (H : eval_addressing64 ge sp addr args = Some v) : eval_addressing64 ge sp (offset_addressing_total addr delta) args =\nSome (Val.addl v (Vlong (Int64.repr delta))).","proofString":"destruct addr; simpl in *; FuncInv; subst; simpl.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite <- A, ! Val.addl_assoc; auto.\nrewrite B, Genv.shift_symbol_address_64 by auto.\nauto.\ndestruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = true ->\nPtrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (v0 : val) (delta : Z) : Some (Val.addl v0 (Vlong (Int64.repr (z + delta)))) =\nSome\n  (Val.addl (Val.addl v0 (Vlong (Int64.repr z))) (Vlong (Int64.repr delta))).","proofString":"rewrite <- A, ! Val.addl_assoc; auto."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = true ->\nPtrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z : Z) (v0 v1 : val) (delta : Z) : Some (Val.addl (Val.addl v0 v1) (Vlong (Int64.repr (z + delta)))) =\nSome\n  (Val.addl (Val.addl (Val.addl v0 v1) (Vlong (Int64.repr z)))\n     (Vlong (Int64.repr delta))).","proofString":"rewrite <- A, ! Val.addl_assoc; auto."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = true ->\nPtrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z z0 : Z) (v0 : val) (delta : Z) : Some\n  (Val.addl (Val.mull v0 (Vlong (Int64.repr z)))\n     (Vlong (Int64.repr (z0 + delta)))) =\nSome\n  (Val.addl\n     (Val.addl (Val.mull v0 (Vlong (Int64.repr z))) (Vlong (Int64.repr z0)))\n     (Vlong (Int64.repr delta))).","proofString":"rewrite <- A, ! Val.addl_assoc; auto."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (B : forall delta0 : Z,\nArchi.ptr64 = true ->\nPtrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (z z0 : Z) (v0 v1 : val) (delta : Z) : Some\n  (Val.addl v0\n     (Val.addl (Val.mull v1 (Vlong (Int64.repr z)))\n        (Vlong (Int64.repr (z0 + delta))))) =\nSome\n  (Val.addl\n     (Val.addl v0\n        (Val.addl (Val.mull v1 (Vlong (Int64.repr z)))\n           (Vlong (Int64.repr z0)))) (Vlong (Int64.repr delta))).","proofString":"rewrite <- A, ! Val.addl_assoc; auto."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (Heqb : Archi.ptr64 = true) (B : forall delta0 : Z,\ntrue = true -> Ptrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) : Some (Genv.symbol_address ge i (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Val.addl (Genv.symbol_address ge i i0) (Vlong (Int64.repr delta))).","proofString":"rewrite B, Genv.shift_symbol_address_64 by auto.\nauto."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (Heqb : Archi.ptr64 = true) (B : forall delta0 : Z,\ntrue = true -> Ptrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) : Some (Val.addl (Genv.symbol_address ge i i0) (Vlong (Int64.repr delta))) =\nSome (Val.addl (Genv.symbol_address ge i i0) (Vlong (Int64.repr delta))).","proofString":"auto."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (Heqb : Archi.ptr64 = true) (B : forall delta0 : Z,\ntrue = true -> Ptrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ptrofs) (delta : Z) : Some (Val.offset_ptr sp (Ptrofs.add i (Ptrofs.repr delta))) =\nSome (Val.addl (Val.offset_ptr sp i) (Vlong (Int64.repr delta))).","proofString":"destruct sp; simpl; auto.\nrewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (Heqb : Archi.ptr64 = true) (B : forall delta0 : Z,\ntrue = true -> Ptrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome\n  (if Archi.ptr64\n   then\n    Vptr b\n      (Ptrofs.add (Ptrofs.add i0 i) (Ptrofs.of_int64 (Int64.repr delta)))\n   else Vundef).","proofString":"rewrite Heqb.\nrewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (Heqb : Archi.ptr64 = true) (B : forall delta0 : Z,\ntrue = true -> Ptrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome\n  (Vptr b (Ptrofs.add (Ptrofs.add i0 i) (Ptrofs.of_int64 (Int64.repr delta)))).","proofString":"rewrite Ptrofs.add_assoc.\ndo 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (Heqb : Archi.ptr64 = true) (B : forall delta0 : Z,\ntrue = true -> Ptrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome\n  (Vptr b (Ptrofs.add i0 (Ptrofs.add i (Ptrofs.of_int64 (Int64.repr delta))))).","proofString":"do 4 f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(A : forall x y : Z, Int64.add (Int64.repr x) (Int64.repr y) = Int64.repr (x + y)) (Heqb : Archi.ptr64 = true) (B : forall delta0 : Z,\ntrue = true -> Ptrofs.repr delta0 = Ptrofs.of_int64 (Int64.repr delta0)) (F : Type) (V : Type) (ge : Genv.t F V) (b : block) (i0 i : ptrofs) (delta : Z) : Ptrofs.repr delta = Ptrofs.of_int64 (Int64.repr delta).","proofString":"symmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) : eval_addressing ge sp addr' args = Some (Val.add v (Vint (Int.repr delta))).","proofString":"unfold offset_addressing in H.\ndestruct (addressing_valid (offset_addressing_total addr delta)); inv H.\nunfold eval_addressing in *; rewrite H1 in *.\napply eval_offset_addressing_total_32; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : (if addressing_valid (offset_addressing_total addr delta)\n then Some (offset_addressing_total addr delta)\n else None) = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) : eval_addressing ge sp addr' args = Some (Val.add v (Vint (Int.repr delta))).","proofString":"destruct (addressing_valid (offset_addressing_total addr delta)); inv H.\nunfold eval_addressing in *; rewrite H1 in *.\napply eval_offset_addressing_total_32; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (v : val) (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) : eval_addressing ge sp (offset_addressing_total addr delta) args =\nSome (Val.add v (Vint (Int.repr delta))).","proofString":"unfold eval_addressing in *; rewrite H1 in *.\napply eval_offset_addressing_total_32; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (v : val) (H0 : eval_addressing32 ge sp addr args = Some v) (H1 : Archi.ptr64 = false) : eval_addressing32 ge sp (offset_addressing_total addr delta) args =\nSome (Val.add v (Vint (Int.repr delta))).","proofString":"apply eval_offset_addressing_total_32; auto."},{"statement":"(c : condition) (args : list val) (m1 m2 : mem) : condition_depends_on_memory c = false ->\neval_condition c args m1 = eval_condition c args m2.","proofString":"destruct c; simpl; intros SF; auto; rewrite ? negb_false_iff in SF;  unfold Val.cmpu_bool, Val.cmplu_bool; rewrite SF; reflexivity."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (op : operation) (args : list val) (m1 m2 : mem) : op_depends_on_memory op = false ->\neval_operation ge sp op args m1 = eval_operation ge sp op args m2.","proofString":"destruct op; simpl; try congruence; intros C.\nf_equal; f_equal; apply condition_depends_on_memory_correct; auto.\ndestruct args; auto.\ndestruct args; auto.\nrewrite (condition_depends_on_memory_correct c args m1 m2 C).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (args : list val) (m1 m2 : mem) (C : condition_depends_on_memory cond = false) : Some (Val.of_optbool (eval_condition cond args m1)) =\nSome (Val.of_optbool (eval_condition cond args m2)).","proofString":"f_equal; f_equal; apply condition_depends_on_memory_correct; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (c : condition) (t : typ) (args : list val) (m1 m2 : mem) (C : condition_depends_on_memory c = false) : match args with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: vl => Some (Val.select (eval_condition c vl m1) v1 v2 t)\nend =\nmatch args with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: vl => Some (Val.select (eval_condition c vl m2) v1 v2 t)\nend.","proofString":"destruct args; auto.\ndestruct args; auto.\nrewrite (condition_depends_on_memory_correct c args m1 m2 C).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (c : condition) (t : typ) (v : val) (args : list val) (m1 m2 : mem) (C : condition_depends_on_memory c = false) : match args with\n| nil => None\n| v2 :: vl => Some (Val.select (eval_condition c vl m1) v v2 t)\nend =\nmatch args with\n| nil => None\n| v2 :: vl => Some (Val.select (eval_condition c vl m2) v v2 t)\nend.","proofString":"destruct args; auto.\nrewrite (condition_depends_on_memory_correct c args m1 m2 C).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (c : condition) (t : typ) (v v0 : val) (args : list val) (m1 m2 : mem) (C : condition_depends_on_memory c = false) : Some (Val.select (eval_condition c args m1) v v0 t) =\nSome (Val.select (eval_condition c args m2) v v0 t).","proofString":"rewrite (condition_depends_on_memory_correct c args m1 m2 C).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (c : condition) (t : typ) (v v0 : val) (args : list val) (m1 m2 : mem) (C : condition_depends_on_memory c = false) : Some (Val.select (eval_condition c args m2) v v0 t) =\nSome (Val.select (eval_condition c args m2) v v0 t).","proofString":"auto."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : eval_addressing32 ge2 sp addr vl = eval_addressing32 ge1 sp addr vl.","proofString":"unfold eval_addressing32, Genv.symbol_address; destruct addr; try rewrite agree_on_symbols;  reflexivity."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : eval_addressing64 ge2 sp addr vl = eval_addressing64 ge1 sp addr vl.","proofString":"unfold eval_addressing64, Genv.symbol_address; destruct addr; try rewrite agree_on_symbols;  reflexivity."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.","proofString":"unfold eval_addressing; destruct Archi.ptr64; auto using eval_addressing32_preserved, eval_addressing64_preserved."},{"statement":"(sp : val) (op : operation) (vl : list val) (m : mem) : eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.","proofString":"unfold eval_operation; destruct op; auto using eval_addressing32_preserved, eval_addressing64_preserved.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols.\nauto."},{"statement":"(sp : val) (id : ident) (vl : list val) (m : mem) : match vl with\n| nil => Some (Genv.symbol_address ge2 id Ptrofs.zero)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 id Ptrofs.zero)\n| _ :: _ => None\nend.","proofString":"unfold Genv.symbol_address.\nrewrite agree_on_symbols.\nauto."},{"statement":"(sp : val) (id : ident) (vl : list val) (m : mem) : match vl with\n| nil =>\n    Some\n      match Genv.find_symbol ge2 id with\n      | Some b => Vptr b Ptrofs.zero\n      | None => Vundef\n      end\n| _ :: _ => None\nend =\nmatch vl with\n| nil =>\n    Some\n      match Genv.find_symbol ge1 id with\n      | Some b => Vptr b Ptrofs.zero\n      | None => Vundef\n      end\n| _ :: _ => None\nend.","proofString":"rewrite agree_on_symbols.\nauto."},{"statement":"(sp : val) (id : ident) (vl : list val) (m : mem) : match vl with\n| nil =>\n    Some\n      match Genv.find_symbol ge1 id with\n      | Some b => Vptr b Ptrofs.zero\n      | None => Vundef\n      end\n| _ :: _ => None\nend =\nmatch vl with\n| nil =>\n    Some\n      match Genv.find_symbol ge1 id with\n      | Some b => Vptr b Ptrofs.zero\n      | None => Vundef\n      end\n| _ :: _ => None\nend.","proofString":"auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (H : Val.inject_list f vl1 vl2) (H0 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"destruct cond; simpl in H0; FuncInv; InvInject; simpl; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\neauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\ninv H3; simpl in H0; inv H0; auto.\neauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\ninv H3; inv H2; simpl in H0; inv H0; auto.\neauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies.\ninv H3; simpl in H0; inv H0; auto.\neauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; try discriminate; auto.\ninv H3; try discriminate; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmp_bool c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmp_bool c v' (Vint n) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpu_bool (Mem.valid_pointer m2) c v' (Vint n) = Some b.","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpl_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpl_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmplu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","proofString":"eauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmpl_bool c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpl_bool c v' (Vlong n) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmplu_bool (Mem.valid_pointer m2) c v' (Vlong n) = Some b.","proofString":"eauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpf_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpf_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpf_bool c v' v'0) = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpfs_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpfs_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpfs_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpfs_bool c v' v'0) = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(n : int) (v : val) (b : bool) (H0 : Val.maskzero_bool v n = Some b) (v' : val) (H3 : Val.inject f v v') : Val.maskzero_bool v' n = Some b.","proofString":"inv H3; try discriminate; auto."},{"statement":"(n : int) (v : val) (b : bool) (H0 : option_map negb (Val.maskzero_bool v n) = Some b) (v' : val) (H3 : Val.inject f v v') : option_map negb (Val.maskzero_bool v' n) = Some b.","proofString":"inv H3; try discriminate; auto."},{"statement":"forall v1 v2 v1' v2' : val,\nVal.inject f v1 v1' ->\nVal.inject f v2 v2' -> Val.inject f (Val.mul v1 v2) (Val.mul v1' v2').","proofString":"intros.\ninv H; simpl; auto.\ninv H0; auto."},{"statement":"(v1 v2 v1' v2' : val) (H : Val.inject f v1 v1') (H0 : Val.inject f v2 v2') : Val.inject f (Val.mul v1 v2) (Val.mul v1' v2').","proofString":"inv H; simpl; auto.\ninv H0; auto."},{"statement":"(v2 v2' : val) (H0 : Val.inject f v2 v2') (i : int) : Val.inject f match v2 with\n             | Vint n2 => Vint (Int.mul i n2)\n             | _ => Vundef\n             end\n  match v2' with\n  | Vint n2 => Vint (Int.mul i n2)\n  | _ => Vundef\n  end.","proofString":"inv H0; auto."},{"statement":"(A : forall v1 v2 v1' v2' : val,\nVal.inject f v1 v1' ->\nVal.inject f v2 v2' -> Val.inject f (Val.mul v1 v2) (Val.mul v1' v2')) : forall (addr : addressing) (sp1 : val) (vl1 : list val) \n  (sp2 : val) (vl2 : list val) (v1 : val),\n(forall (id : ident) (ofs : ptrofs),\n In id (globals_addressing addr) ->\n Val.inject f (Genv.symbol_address ge1 id ofs)\n   (Genv.symbol_address ge2 id ofs)) ->\nVal.inject f sp1 sp2 ->\nVal.inject_list f vl1 vl2 ->\neval_addressing32 ge1 sp1 addr vl1 = Some v1 ->\nexists v2 : val,\n  eval_addressing32 ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"intros.\ndestruct addr; simpl in *; FuncInv; InvInject; TrivialExists; eauto using Val.add_inject, Val.offset_ptr_inject with coqlib."},{"statement":"(A : forall v0 v2 v1' v2' : val,\nVal.inject f v0 v1' ->\nVal.inject f v2 v2' -> Val.inject f (Val.mul v0 v2) (Val.mul v1' v2')) (addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : eval_addressing32 ge1 sp1 addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing32 ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct addr; simpl in *; FuncInv; InvInject; TrivialExists; eauto using Val.add_inject, Val.offset_ptr_inject with coqlib."},{"statement":"forall v1 v2 v1' v2' : val,\nVal.inject f v1 v1' ->\nVal.inject f v2 v2' -> Val.inject f (Val.mull v1 v2) (Val.mull v1' v2').","proofString":"intros.\ninv H; simpl; auto.\ninv H0; auto."},{"statement":"(v1 v2 v1' v2' : val) (H : Val.inject f v1 v1') (H0 : Val.inject f v2 v2') : Val.inject f (Val.mull v1 v2) (Val.mull v1' v2').","proofString":"inv H; simpl; auto.\ninv H0; auto."},{"statement":"(v2 v2' : val) (H0 : Val.inject f v2 v2') (i : int64) : Val.inject f\n  match v2 with\n  | Vlong n2 => Vlong (Int64.mul i n2)\n  | _ => Vundef\n  end match v2' with\n      | Vlong n2 => Vlong (Int64.mul i n2)\n      | _ => Vundef\n      end.","proofString":"inv H0; auto."},{"statement":"(A : forall v1 v2 v1' v2' : val,\nVal.inject f v1 v1' ->\nVal.inject f v2 v2' -> Val.inject f (Val.mull v1 v2) (Val.mull v1' v2')) : forall (addr : addressing) (sp1 : val) (vl1 : list val) \n  (sp2 : val) (vl2 : list val) (v1 : val),\n(forall (id : ident) (ofs : ptrofs),\n In id (globals_addressing addr) ->\n Val.inject f (Genv.symbol_address ge1 id ofs)\n   (Genv.symbol_address ge2 id ofs)) ->\nVal.inject f sp1 sp2 ->\nVal.inject_list f vl1 vl2 ->\neval_addressing64 ge1 sp1 addr vl1 = Some v1 ->\nexists v2 : val,\n  eval_addressing64 ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"intros.\ndestruct addr; simpl in *; FuncInv; InvInject; TrivialExists; eauto using Val.addl_inject, Val.offset_ptr_inject with coqlib."},{"statement":"(A : forall v0 v2 v1' v2' : val,\nVal.inject f v0 v1' ->\nVal.inject f v2 v2' -> Val.inject f (Val.mull v0 v2) (Val.mull v1' v2')) (addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : eval_addressing64 ge1 sp1 addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing64 ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct addr; simpl in *; FuncInv; InvInject; TrivialExists; eauto using Val.addl_inject, Val.offset_ptr_inject with coqlib."},{"statement":"(addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : (if Archi.ptr64\n then eval_addressing64 ge1 sp1 addr vl1\n else eval_addressing32 ge1 sp1 addr vl1) = Some v1) : exists v2 : val,\n  (if Archi.ptr64\n   then eval_addressing64 ge2 sp2 addr vl2\n   else eval_addressing32 ge2 sp2 addr vl2) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct Archi.ptr64; eauto using eval_addressing32_inj, eval_addressing64_inj."},{"statement":"(op : operation) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H1 : eval_operation ge1 sp1 op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation ge2 sp2 op vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct op; simpl in H1; simpl; FuncInv; InvInject; TrivialExists.\napply GL; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\napply Val.sub_inject; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H2; simpl; auto.\ndestruct (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize); auto.\neapply eval_addressing32_inj; eauto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\napply Val.addl_inject; auto.\napply Val.subl_inject; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\ninv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\ninv H4; simpl; auto.\neapply eval_addressing64_inj; eauto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\nsubst v1.\ndestruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor.\napply Val.select_inject; auto.\ndestruct (eval_condition c vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(id : ident) (sp1 sp2 : val) (GL : forall (id0 : ident) (ofs : ptrofs),\nIn id0 (globals_operation (Oindirectsymbol id)) ->\nVal.inject f (Genv.symbol_address ge1 id0 ofs)\n  (Genv.symbol_address ge2 id0 ofs)) (H : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 id Ptrofs.zero)\n  (Genv.symbol_address ge2 id Ptrofs.zero).","proofString":"apply GL; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast8signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 8 v) (Val.sign_ext 8 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast8unsigned) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.zero_ext 8 v) (Val.zero_ext 8 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast16signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 16 v) (Val.sign_ext 16 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast16unsigned) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.zero_ext 16 v) (Val.zero_ext 16 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oneg) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.neg v) (Val.neg v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub v v0) (Val.sub v' v'0).","proofString":"apply Val.sub_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omul) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mul v v0) (Val.mul v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Omulimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.mul v (Vint n)) (Val.mul v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhs v v0) (Val.mulhs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhu v v0) (Val.mulhu v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divs v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divs v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val, Val.divs (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divs i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divs i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val, Val.divu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.mods v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.mods v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some v1) : exists v2 : val, Val.mods (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.mods i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.mods i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.mods i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.modu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some v1) : exists v2 : val, Val.modu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some v1) : exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.modu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.modu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oand) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v v0) (Val.and v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.and v (Vint n)) (Val.and v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v v0) (Val.or v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.or v (Vint n)) (Val.or v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v v0) (Val.xor v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xor v (Vint n)) (Val.xor v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onot) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notint v) (Val.notint v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shl v v0) (Val.shl v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shl v (Vint n)) (Val.shl v' (Vint n)).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : Val.inject f (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef).","proofString":"destruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shr v v0) (Val.shr v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shr v (Vint n)) (Val.shr v' (Vint n)).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : Val.inject f (if Int.ltu n Int.iwordsize then Vint (Int.shr i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shr i n) else Vundef).","proofString":"destruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrx v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrx v' (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1) : exists v2 : val, Val.shrx (Vint i) (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vint (Int.shrx i n)) = Some v2 /\\\n  Val.inject f (Vint (Int.shrx i n)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shru v v0) (Val.shru v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshruimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shru v (Vint n)) (Val.shru v' (Vint n)).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshruimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : Val.inject f\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru i n) else Vundef).","proofString":"destruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ororimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.ror v (Vint n)) (Val.ror v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(n : int) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshldimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f\n  (Val.or (Val.shl v (Vint n)) (Val.shru v0 (Vint (Int.sub Int.iwordsize n))))\n  (Val.or (Val.shl v' (Vint n))\n     (Val.shru v'0 (Vint (Int.sub Int.iwordsize n)))).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H2; simpl; auto.\ndestruct (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshldimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v'0 : val) (H2 : Val.inject f v0 v'0) (i : int) : Val.inject f\n  (Val.or (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef)\n     (Val.shru v0 (Vint (Int.sub Int.iwordsize n))))\n  (Val.or (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef)\n     (Val.shru v'0 (Vint (Int.sub Int.iwordsize n)))).","proofString":"destruct (Int.ltu n Int.iwordsize); auto.\ninv H2; simpl; auto.\ndestruct (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshldimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v'0 : val) (H2 : Val.inject f v0 v'0) (i : int) : Val.inject f\n  (Val.or (Vint (Int.shl i n)) (Val.shru v0 (Vint (Int.sub Int.iwordsize n))))\n  (Val.or (Vint (Int.shl i n))\n     (Val.shru v'0 (Vint (Int.sub Int.iwordsize n)))).","proofString":"inv H2; simpl; auto.\ndestruct (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshldimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  match\n    (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n     then Vint (Int.shru i0 (Int.sub Int.iwordsize n))\n     else Vundef)\n  with\n  | Vint n2 => Vint (Int.or (Int.shl i n) n2)\n  | _ => Vundef\n  end\n  match\n    (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n     then Vint (Int.shru i0 (Int.sub Int.iwordsize n))\n     else Vundef)\n  with\n  | Vint n2 => Vint (Int.or (Int.shl i n) n2)\n  | _ => Vundef\n  end.","proofString":"destruct (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize); auto."},{"statement":"(a : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Olea a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H1 : eval_addressing32 ge1 sp1 a vl1 = Some v1) : exists v2 : val,\n  eval_addressing32 ge2 sp2 a vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"eapply eval_addressing32_inj; eauto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omakelong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.longofwords v v0) (Val.longofwords v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olowlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.loword v) (Val.loword v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ohighlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.hiword v) (Val.hiword v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.longofint v) (Val.longofint v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32unsigned) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.longofintu v) (Val.longofintu v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negl v) (Val.negl v').","proofString":"inv H4; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.addl v (Vlong n)) (Val.addl v' (Vlong n)).","proofString":"apply Val.addl_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subl v v0) (Val.subl v' v'0).","proofString":"apply Val.subl_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omull) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mull v v0) (Val.mull v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Omullimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.mull v (Vlong n)) (Val.mull v' (Vlong n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mullhs v v0) (Val.mullhs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mullhu v v0) (Val.mullhu v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divls v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divls v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1) : exists v2 : val,\n  Val.divls (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.divs i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divs i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divlu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divlu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1) : exists v2 : val,\n  Val.divlu (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1) : exists v2 : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.divu i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modls v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.modls v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some v1) : exists v2 : val,\n  Val.modls (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.mods i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int64.eq i0 Int64.zero || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.mods i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.mods i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modlu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.modlu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome v1) : exists v2 : val,\n  Val.modlu (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome v1) : exists v2 : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.modu i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.modu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oandl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.andl v v0) (Val.andl v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.andl v (Vlong n)) (Val.andl v' (Vlong n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.orl v v0) (Val.orl v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.orl v (Vlong n)) (Val.orl v' (Vlong n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xorl v v0) (Val.xorl v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xorl v (Vlong n)) (Val.xorl v' (Vlong n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onotl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notl v) (Val.notl v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shll v v0) (Val.shll v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shll v (Vint n)) (Val.shll v' (Vint n)).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef).","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shrl v v0) (Val.shrl v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shrl v (Vint n)) (Val.shrl v' (Vint n)).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef).","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrxl v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrxl v' (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1) : exists v2 : val, Val.shrxl (Vlong i) (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vlong (Int64.shrx' i n)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.shrx' i n)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shrlu v v0) (Val.shrlu v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrluimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shrlu v (Vint n)) (Val.shrlu v' (Vint n)).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrluimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef).","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ororlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.rorl v (Vint n)) (Val.rorl v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(a : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oleal a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H1 : eval_addressing64 ge1 sp1 a vl1 = Some v1) : exists v2 : val,\n  eval_addressing64 ge2 sp2 a vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"eapply eval_addressing64_inj; eauto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negf v) (Val.negf v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absf v) (Val.absf v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addf v v0) (Val.addf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subf v v0) (Val.subf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulf v v0) (Val.mulf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divf v v0) (Val.divf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omaxf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (maxf v v0) (maxf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ominf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (minf v v0) (minf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negfs v) (Val.negfs v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absfs v) (Val.absfs v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addfs v v0) (Val.addfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subfs v v0) (Val.subfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulfs v v0) (Val.mulfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divfs v v0) (Val.divfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.singleoffloat v) (Val.singleoffloat v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.floatofsingle v) (Val.floatofsingle v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val, Val.intoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatofint v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.floatofint (Vint i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vfloat (Float.of_int i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val, Val.intofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float32.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleofint v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.singleofint (Vint i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vsingle (Float32.of_int i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1) : exists v2 : val, Val.longoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float.to_long f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatoflong v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatoflong v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.floatoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vfloat (Float.of_long i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1) : exists v2 : val,\n  Val.longofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float32.to_long f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleoflong v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleoflong v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.singleoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vsingle (Float32.of_long i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2.","proofString":"TrivialExists."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H2 : Val.of_optbool (eval_condition cond vl1 m1) = v1) : Val.inject f v1 (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"subst v1.\ndestruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) : Val.inject f (Val.of_optbool (eval_condition cond vl1 m1))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"destruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) : Val.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"exploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b ->\nVal.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"intros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) (EQ : eval_condition cond vl2 m2 = Some b) : Val.inject f (Val.of_optbool (Some b)) (Val.of_optbool (Some b)).","proofString":"destruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (Heqo : eval_condition cond vl1 m1 = None) : Val.inject f (Val.of_optbool None)\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"simpl; constructor."},{"statement":"(c : condition) (t : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel c t)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) : Val.inject f (Val.select (eval_condition c vl1 m1) v v0 t)\n  (Val.select (eval_condition c vl'0 m2) v' v'0 t).","proofString":"apply Val.select_inject; auto.\ndestruct (eval_condition c vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(c : condition) (t : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel c t)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) : eval_condition c vl1 m1 = None \\/\neval_condition c vl1 m1 = eval_condition c vl'0 m2.","proofString":"destruct (eval_condition c vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(c : condition) (t : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel c t)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) (b : bool) (Heqo : eval_condition c vl1 m1 = Some b) : Some b = None \\/ Some b = eval_condition c vl'0 m2.","proofString":"right; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) =\ntrue.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) = true.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 : mem) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"inv H.\nrewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr 0) <=\nPtrofs.max_unsigned.","proofString":"rewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned.","proofString":"apply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : b1 <> b2) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true) (H2 : Some (b1, 0) = Some (b1', delta1)) (H3 : Some (b2, 0) = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"inv H2; inv H3.\nauto."},{"statement":"(m1 : mem) (ofs1 ofs2 : ptrofs) (b1' b2' : block) (H0 : Mem.valid_pointer m1 b1' (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2' (Ptrofs.unsigned ofs2) = true) (H : b1' <> b2') : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr 0)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr 0)).","proofString":"auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"eapply eval_condition_inj with (f := fun b => Some(b, 0)) (m1 := m1).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nrewrite <- val_inject_list_lessdef.\neauto.\nauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"apply val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (H2 : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_operation genv sp op vl2 m2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.lessdef_list vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"rewrite <- val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (H1 : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_addressing genv sp addr vl2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"exploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : f b = Some (b, 0) -> Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"intros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"eapply eval_condition_inj with (f := f) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl2 = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_addressing.\neapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 (Ptrofs.repr delta)) addr vl2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros.\napply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) (id : ident) (ofs : ptrofs) (H1 : In id (globals_addressing addr)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"apply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op)\n    vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_operation.\nsimpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"simpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros.\napply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) (id : ident) (ofs : ptrofs) (H2 : In id (globals_operation op)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"apply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."}]}