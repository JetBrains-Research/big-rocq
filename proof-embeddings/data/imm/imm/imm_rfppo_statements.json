{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/imm/imm_rfppo.v","fileSamples":[{"statement":"(psc G ∪ rfe G ∪ ar_int G) ⨾ rf G ⨾ ppo G ∩ same_loc (lab G)\n⊆ (psc G ∪ rfe G ∪ ar_int G)⁺.","proofString":"rewrite unionA, seq_union_l.\nunionL.\nrewrite wf_pscD, wf_rfD; auto.\ntype_solver.\nrewrite IMM_ar_int_rfe_rf_ppo_loc_in_ar_int_rfe_ct.\napply clos_trans_mori.\neauto with hahn."},{"statement":"psc G ⨾ rf G ⨾ ppo G ∩ same_loc (lab G)\n∪ (rfe G ∪ ar_int G) ⨾ rf G ⨾ ppo G ∩ same_loc (lab G)\n⊆ (psc G ∪ (rfe G ∪ ar_int G))⁺.","proofString":"unionL.\nrewrite wf_pscD, wf_rfD; auto.\ntype_solver.\nrewrite IMM_ar_int_rfe_rf_ppo_loc_in_ar_int_rfe_ct.\napply clos_trans_mori.\neauto with hahn."},{"statement":"psc G ⨾ rf G ⨾ ppo G ∩ same_loc (lab G) ⊆ (psc G ∪ (rfe G ∪ ar_int G))⁺.","proofString":"rewrite wf_pscD, wf_rfD; auto.\ntype_solver."},{"statement":"(⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ psc G\n   ⨾ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘)\n⨾ (⦗fun a : actid => is_w (lab G) a⦘\n   ⨾ rf G ⨾ ⦗fun a : actid => is_r (lab G) a⦘) ⨾ ppo G ∩ same_loc (lab G)\n⊆ (⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n   ⨾ psc G\n     ⨾ ⦗(fun a : actid => is_f (lab G) a)\n        ∩₁ (fun a : actid => is_sc (lab G) a)⦘ ∪ (rfe G ∪ ar_int G))⁺.","proofString":"type_solver."},{"statement":"(rfe G ∪ ar_int G) ⨾ rf G ⨾ ppo G ∩ same_loc (lab G)\n⊆ (psc G ∪ (rfe G ∪ ar_int G))⁺.","proofString":"rewrite IMM_ar_int_rfe_rf_ppo_loc_in_ar_int_rfe_ct.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(rfe G ∪ ar_int G)⁺ ⊆ (psc G ∪ (rfe G ∪ ar_int G))⁺.","proofString":"apply clos_trans_mori.\neauto with hahn."},{"statement":"rfe G ∪ ar_int G ⊆ psc G ∪ (rfe G ∪ ar_int G).","proofString":"eauto with hahn."},{"statement":"((ar G)＊ ⨾ ar G) ⨾ rf G ⨾ ppo G ∩ same_loc (lab G) ⊆ (ar G)⁺.","proofString":"rewrite !seqA.\nrewrite IMM_ar_rf_ppo_loc_in_ar_ct.\napply rt_ct."},{"statement":"(ar G)＊ ⨾ ar G ⨾ rf G ⨾ ppo G ∩ same_loc (lab G) ⊆ (ar G)⁺.","proofString":"rewrite IMM_ar_rf_ppo_loc_in_ar_ct.\napply rt_ct."},{"statement":"(ar G)＊ ⨾ (ar G)⁺ ⊆ (ar G)⁺.","proofString":"apply rt_ct."},{"statement":"(ar G)⁺ ⨾ (rf G ⨾ ppo G ∩ same_loc (lab G))⁺ ⊆ (ar G)⁺.","proofString":"by apply IMM_ar_ct_rf_ppo_loc_ct_in_ar_ct."},{"statement":"(SPL : sc_per_loc G) : (⦗fun a : actid => is_r (lab G) a⦘\n ⨾ ppo G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ∩ same_loc (lab G) ⊆ \nfr G.","proofString":"rewrite (ppo_in_sb WF).\nrewrite seq_eqv_inter_ll.\nrewrite seq_eqv_inter_lr.\nrewrite r_sb_loc_w_in_fri; auto.\napply fri_in_fr."},{"statement":"(SPL : sc_per_loc G) : (⦗fun a : actid => is_r (lab G) a⦘ ⨾ sb G ⨾ ⦗fun a : actid => is_w (lab G) a⦘)\n∩ same_loc (lab G) ⊆ fr G.","proofString":"rewrite seq_eqv_inter_ll.\nrewrite seq_eqv_inter_lr.\nrewrite r_sb_loc_w_in_fri; auto.\napply fri_in_fr."},{"statement":"(SPL : sc_per_loc G) : ⦗fun a : actid => is_r (lab G) a⦘\n⨾ (sb G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ∩ same_loc (lab G) ⊆ \nfr G.","proofString":"rewrite seq_eqv_inter_lr.\nrewrite r_sb_loc_w_in_fri; auto.\napply fri_in_fr."},{"statement":"(SPL : sc_per_loc G) : ⦗fun a : actid => is_r (lab G) a⦘\n⨾ sb G ∩ same_loc (lab G) ⨾ ⦗fun a : actid => is_w (lab G) a⦘ ⊆ \nfr G.","proofString":"rewrite r_sb_loc_w_in_fri; auto.\napply fri_in_fr."},{"statement":"(SPL : sc_per_loc G) : fri G ⊆ fr G.","proofString":"apply fri_in_fr."},{"statement":"(CONS : imm_consistent G) : (ar G)⁺ ⨾ rf G ⨾ ppo G ∩ same_loc (lab G) ⊆ rf G ⨾ ppo G ∩ same_loc (lab G) \\/\n(ar G)⁺ ⨾ rf G ⨾ ppo G ∩ same_loc (lab G) ⊆ (ar G)⁺.","proofString":"right.\napply IMM_ar_ct_rf_ppo_loc_in_ar_ct."},{"statement":"(CONS : imm_consistent G) : (ar G)⁺ ⨾ rf G ⨾ ppo G ∩ same_loc (lab G) ⊆ (ar G)⁺.","proofString":"apply IMM_ar_ct_rf_ppo_loc_in_ar_ct."},{"statement":"(CONS : imm_consistent G) : irreflexive ((ar G)⁺)⁺.","proofString":"rewrite ct_of_ct.\napply CONS."},{"statement":"(CONS : imm_consistent G) : irreflexive (ar G)⁺.","proofString":"apply CONS."},{"statement":"(CONS : imm_consistent G) : coherence G.","proofString":"by apply CONS."},{"statement":"(CONS : imm_consistent G) : acyclic (co G).","proofString":"by apply co_acyclic."},{"statement":"ar G ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"unfold ar.\nrewrite (ar_int_in_sb WF).\nrewrite no_sb_to_init.\nrewrite wf_pscD.\nrewrite (wf_rfeD WF).\nrewrite seq_union_l.\nunionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10."},{"statement":"(psc G ∪ rfe G ∪ ar_int G) ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite (ar_int_in_sb WF).\nrewrite no_sb_to_init.\nrewrite wf_pscD.\nrewrite (wf_rfeD WF).\nrewrite seq_union_l.\nunionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10."},{"statement":"(psc G ∪ rfe G ∪ sb G) ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite no_sb_to_init.\nrewrite wf_pscD.\nrewrite (wf_rfeD WF).\nrewrite seq_union_l.\nunionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10."},{"statement":"(psc G ∪ rfe G ∪ sb G ⨾ ⦗fun x : actid => ~ is_init x⦘)\n⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite wf_pscD.\nrewrite (wf_rfeD WF).\nrewrite seq_union_l.\nunionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10."},{"statement":"(⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ psc G\n   ⨾ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ∪ rfe G ∪ sb G ⨾ ⦗fun x : actid => ~ is_init x⦘)\n⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite (wf_rfeD WF).\nrewrite seq_union_l.\nunionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10."},{"statement":"(⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ psc G\n   ⨾ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ∪ ⦗fun a : actid => is_w (lab G) a⦘\n   ⨾ rfe G ⨾ ⦗fun a : actid => is_r (lab G) a⦘\n ∪ sb G ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite seq_union_l.\nunionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10."},{"statement":"(⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ psc G\n   ⨾ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ∪ ⦗fun a : actid => is_w (lab G) a⦘\n   ⨾ rfe G ⨾ ⦗fun a : actid => is_r (lab G) a⦘)\n⨾ ⦗fun a : actid => is_init a⦘\n∪ (sb G ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"unionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10."},{"statement":"(⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ psc G\n   ⨾ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ∪ ⦗fun a : actid => is_w (lab G) a⦘\n   ⨾ rfe G ⨾ ⦗fun a : actid => is_r (lab G) a⦘)\n⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite (init_w WF).\ntype_solver 10."},{"statement":"(⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ⨾ psc G\n   ⨾ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n ∪ ⦗fun a : actid => is_w (lab G) a⦘\n   ⨾ rfe G ⨾ ⦗fun a : actid => is_r (lab G) a⦘)\n⨾ ⦗fun a : actid => is_w (lab G) a⦘ ⊆ ∅₂.","proofString":"type_solver 10."},{"statement":"(ar G ∪ rf G ⨾ ppo G ∩ same_loc (lab G)) ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite seq_union_l, seqA, IMM_no_ar_to_init; auto.\narewrite (ppo G ∩ same_loc (lab G) ⊆ ppo G).\nrewrite (ppo_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver."},{"statement":"∅₂ ∪ rf G ⨾ ppo G ∩ same_loc (lab G) ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"arewrite (ppo G ∩ same_loc (lab G) ⊆ ppo G).\nrewrite (ppo_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver."},{"statement":"∅₂ ∪ rf G ⨾ ppo G ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite (ppo_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver."},{"statement":"∅₂ ∪ rf G ⨾ sb G ⨾ ⦗fun a : actid => is_init a⦘ ⊆ ∅₂.","proofString":"rewrite no_sb_to_init.\nbasic_solver."},{"statement":"∅₂\n∪ rf G\n  ⨾ (sb G ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗fun a : actid => is_init a⦘\n⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(IMM_CONS : imm_consistent G) (IMM_FAIR : imm_fair G) (FAIR : mem_fair G) : acyclic (ar G ∪ rf G ⨾ ppo G ∩ same_loc (lab G)).","proofString":"by apply IMM_ar_rf_ppo_loc_acyclic."},{"statement":"(IMM_CONS : imm_consistent G) (IMM_FAIR : imm_fair G) (FAIR : mem_fair G) : (ar G ∪ rf G ⨾ ppo G ∩ same_loc (lab G)) ⨾ ⦗fun a : actid => is_init a⦘ ≡ ∅₂.","proofString":"by apply IMM_no_ar_rf_ppo_loc_to_init."},{"statement":"(IMM_CONS : imm_consistent G) (IMM_FAIR : imm_fair G) (FAIR : mem_fair G) : ppo G ⊆ sb G.","proofString":"by apply ppo_in_sb."},{"statement":"(IMM_CONS : imm_consistent G) (IMM_FAIR : imm_fair G) (FAIR : mem_fair G) : ar G ⨾ (rf G ⨾ ppo G ∩ same_loc (lab G))⁺ ⊆ (ar G)⁺.","proofString":"by apply IMM_ar_rf_ppo_loc_ct_in_ar_ct."},{"statement":"(IMM_CONS : imm_consistent G) (IMM_FAIR : imm_fair G) (FAIR : mem_fair G) : sc_per_loc G.","proofString":"cdes IMM_CONS.\nby apply coherence_sc_per_loc."},{"statement":"(IMM_CONS : imm_consistent G) (IMM_FAIR : imm_fair G) (FAIR : mem_fair G) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G) (Cpsc : acyclic (psc_f G ∪ psc_base G)) (Cat : rmw_atomicity G) : sc_per_loc G.","proofString":"by apply coherence_sc_per_loc."}]}