{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/ext_traversal/FinTravConfigs.v","fileSamples":[{"statement":"(T1 T2 : trav_label -> Prop) (FIN1 : set_finite (T1 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a))) (FIN2 : set_finite (T2 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a))) : set_finite ((T1 ∪₁ T2) ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite set_inter_union_l.\napply set_finite_union.\nsplit; auto."},{"statement":"(T1 T2 : trav_label -> Prop) (FIN1 : set_finite (T1 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a))) (FIN2 : set_finite (T2 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a))) : set_finite\n  (T1 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)\n   ∪₁ T2 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"apply set_finite_union.\nsplit; auto."},{"statement":"(T1 T2 : trav_label -> Prop) (FIN1 : set_finite (T1 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a))) (FIN2 : set_finite (T2 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a))) : set_finite (T1 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)) /\\\nset_finite (T2 ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"split; auto."},{"statement":"(T : trav_label -> Prop) (FIN : set_finite T) : set_finite (T ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"eapply set_finite_mori; eauto.\nred.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FIN : set_finite T) : Basics.flip set_subset T\n  (T ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"red.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FIN : set_finite T) : T ∩₁ event ↓₁ set_compl (fun a : actid => is_init a) ⊆₁ T.","proofString":"basic_solver 10."},{"statement":"set_finite\n  ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (acts_set G ∩₁ (fun a : actid => is_init a))\n   ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite set_pair_alt.\nexists [].\nbasic_solver 10."},{"statement":"set_finite\n  (fst\n   ↓₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n   ∩₁ snd ↓₁ (acts_set G ∩₁ (fun a : actid => is_init a))\n   ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"exists [].\nbasic_solver 10."},{"statement":"forall x : trav_label,\n(fst\n ↓₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n ∩₁ snd ↓₁ (acts_set G ∩₁ (fun a : actid => is_init a))\n ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)) x -> \nIn x [].","proofString":"basic_solver 10."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x -> In x ts) : set_finite (event ↑₁ (T ∩₁ action ↓₁ eq a) \\₁ (fun a0 : actid => is_init a0)).","proofString":"exists (map event ts).\nins.\napply in_map_iff.\nexists (mkTL a x).\nsplit; auto.\ndestruct IN.\napply TFIN.\nsplit; [| done].\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x0 : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x0 -> In x0 ts) (x : actid) (IN : (event ↑₁ (T ∩₁ action ↓₁ eq a) \\₁ (fun a0 : actid => is_init a0)) x) : In x (map event ts).","proofString":"apply in_map_iff.\nexists (mkTL a x).\nsplit; auto.\ndestruct IN.\napply TFIN.\nsplit; [| done].\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x0 : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x0 -> In x0 ts) (x : actid) (IN : (event ↑₁ (T ∩₁ action ↓₁ eq a) \\₁ (fun a0 : actid => is_init a0)) x) : exists x0 : trav_label, event x0 = x /\\ In x0 ts.","proofString":"exists (mkTL a x).\nsplit; auto.\ndestruct IN.\napply TFIN.\nsplit; [| done].\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x0 : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x0 -> In x0 ts) (x : actid) (IN : (event ↑₁ (T ∩₁ action ↓₁ eq a) \\₁ (fun a0 : actid => is_init a0)) x) : event (mkTL a x) = x /\\ In (mkTL a x) ts.","proofString":"split; auto.\ndestruct IN.\napply TFIN.\nsplit; [| done].\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x0 : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x0 -> In x0 ts) (x : actid) (IN : (event ↑₁ (T ∩₁ action ↓₁ eq a) \\₁ (fun a0 : actid => is_init a0)) x) : In (mkTL a x) ts.","proofString":"destruct IN.\napply TFIN.\nsplit; [| done].\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x0 : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x0 -> In x0 ts) (x : actid) (H : (event ↑₁ (T ∩₁ action ↓₁ eq a)) x) (H0 : ~ is_init x) : In (mkTL a x) ts.","proofString":"apply TFIN.\nsplit; [| done].\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x0 : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x0 -> In x0 ts) (x : actid) (H : (event ↑₁ (T ∩₁ action ↓₁ eq a)) x) (H0 : ~ is_init x) : (T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) (mkTL a x).","proofString":"split; [| done].\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (ts : list trav_label) (TFIN : forall x0 : trav_label,\n(T ∩₁ event ↓₁ set_compl (fun a0 : actid => is_init a0)) x0 -> In x0 ts) (x : actid) (H : (event ↑₁ (T ∩₁ action ↓₁ eq a)) x) (H0 : ~ is_init x) : T (mkTL a x).","proofString":"by apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite (dom_rel (sb G ⨾ ⦗reserved T⦘) ∩₁ codom_rel (⦗M⦘ ⨾ rrf ⨾ rmw G)).","proofString":"rewrite rmw_non_init_lr; eauto.\nrewrite !codom_seq, codom_eqv.\nrewrite set_interC, <- dom_eqv1.\nrewrite no_sb_to_init, seqA, <- id_inter.\nrewrite <- seqA.\napply fin_dom_rel_fsupp.\neapply fsupp_sb; auto.\nrewrite set_interC.\nby apply tls_fin_event_set."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite\n  (dom_rel (sb G ⨾ ⦗reserved T⦘)\n   ∩₁ codom_rel\n        (⦗M⦘\n         ⨾ rrf\n           ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n             ⨾ rmw G ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)).","proofString":"rewrite !codom_seq, codom_eqv.\nrewrite set_interC, <- dom_eqv1.\nrewrite no_sb_to_init, seqA, <- id_inter.\nrewrite <- seqA.\napply fin_dom_rel_fsupp.\neapply fsupp_sb; auto.\nrewrite set_interC.\nby apply tls_fin_event_set."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite\n  (dom_rel (sb G ⨾ ⦗reserved T⦘) ∩₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite set_interC, <- dom_eqv1.\nrewrite no_sb_to_init, seqA, <- id_inter.\nrewrite <- seqA.\napply fin_dom_rel_fsupp.\neapply fsupp_sb; auto.\nrewrite set_interC.\nby apply tls_fin_event_set."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite\n  (dom_rel (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G ⨾ ⦗reserved T⦘)).","proofString":"rewrite no_sb_to_init, seqA, <- id_inter.\nrewrite <- seqA.\napply fin_dom_rel_fsupp.\neapply fsupp_sb; auto.\nrewrite set_interC.\nby apply tls_fin_event_set."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite\n  (dom_rel\n     (⦗set_compl (fun a : actid => is_init a)⦘\n      ⨾ sb G ⨾ ⦗(fun x : actid => ~ is_init x) ∩₁ reserved T⦘)).","proofString":"rewrite <- seqA.\napply fin_dom_rel_fsupp.\neapply fsupp_sb; auto.\nrewrite set_interC.\nby apply tls_fin_event_set."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite\n  (dom_rel\n     ((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G)\n      ⨾ ⦗(fun x : actid => ~ is_init x) ∩₁ reserved T⦘)).","proofString":"apply fin_dom_rel_fsupp.\neapply fsupp_sb; auto.\nrewrite set_interC.\nby apply tls_fin_event_set."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G).","proofString":"eapply fsupp_sb; auto."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite ((fun x : actid => ~ is_init x) ∩₁ reserved T).","proofString":"rewrite set_interC.\nby apply tls_fin_event_set."},{"statement":"(T : trav_label -> Prop) (rrf : relation actid) (M : actid -> Prop) (TFIN : tls_fin T) : set_finite (reserved T ∩₁ (fun x : actid => ~ is_init x)).","proofString":"by apply tls_fin_event_set."},{"statement":"(a : trav_action) (M : actid -> Prop) (es : list actid) (EFIN : forall x : actid, M x -> In x es) : set_finite (eq a <*> M).","proofString":"exists (map (mkTL a) es).\nintros [? e] [<- Me].\napply in_map_iff.\nexists e.\nsplit; auto."},{"statement":"(a : trav_action) (M : actid -> Prop) (es : list actid) (EFIN : forall x : actid, M x -> In x es) : forall x : trav_action * actid, (eq a <*> M) x -> In x (map (mkTL a) es).","proofString":"intros [? e] [<- Me].\napply in_map_iff.\nexists e.\nsplit; auto."},{"statement":"(a : trav_action) (M : actid -> Prop) (es : list actid) (EFIN : forall x : actid, M x -> In x es) (e : actid) (Me : M e) : In (a, e) (map (mkTL a) es).","proofString":"apply in_map_iff.\nexists e.\nsplit; auto."},{"statement":"(a : trav_action) (M : actid -> Prop) (es : list actid) (EFIN : forall x : actid, M x -> In x es) (e : actid) (Me : M e) : exists x : actid, mkTL a x = (a, e) /\\ In x es.","proofString":"exists e.\nsplit; auto."},{"statement":"(a : trav_action) (M : actid -> Prop) (es : list actid) (EFIN : forall x : actid, M x -> In x es) (e : actid) (Me : M e) : mkTL a e = (a, e) /\\ In e es.","proofString":"split; auto."},{"statement":"(rrf : relation actid) (P : actid -> Prop) (T1 T2 : trav_label -> Prop) (SAME_RES : reserved T1 ≡₁ reserved T2) : dom_rel (sb G ⨾ ⦗reserved T1⦘) ∩₁ codom_rel (⦗P⦘ ⨾ rrf ⨾ rmw G)\n≡₁ dom_rel (sb G ⨾ ⦗reserved T2⦘) ∩₁ codom_rel (⦗P⦘ ⨾ rrf ⨾ rmw G).","proofString":"by rewrite SAME_RES."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (f : actid) (STEP : ext_isim_trav_step G sc (tid f) T T') (FF : is_f (lab G) f) (TS : ext_itrav_step G sc (mkTL ta_cover f) T T') : tls_fin T'.","proofString":"inversion TS.\nrewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (f : actid) (STEP : ext_isim_trav_step G sc (tid f) T T') (FF : is_f (lab G) f) (TS : ext_itrav_step G sc (mkTL ta_cover f) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover f)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover f)) ->\naction (mkTL ta_cover f) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover f))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T) : tls_fin T'.","proofString":"rewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (f : actid) (STEP : ext_isim_trav_step G sc (tid f) T T') (FF : is_f (lab G) f) (TS : ext_itrav_step G sc (mkTL ta_cover f) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover f)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover f)) ->\naction (mkTL ta_cover f) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover f))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T) : tls_fin\n  (T ∪₁ eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T).","proofString":"rewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (f : actid) (STEP : ext_isim_trav_step G sc (tid f) T T') (FF : is_f (lab G) f) (TS : ext_itrav_step G sc (mkTL ta_cover f) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover f)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover f)) ->\naction (mkTL ta_cover f) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover f))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T) : tls_fin\n  (T\n   ∪₁ (eq (mkTL ta_cover f)\n       ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T)).","proofString":"apply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (f : actid) (STEP : ext_isim_trav_step G sc (tid f) T T') (FF : is_f (lab G) f) (TS : ext_itrav_step G sc (mkTL ta_cover f) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover f)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover f)) ->\naction (mkTL ta_cover f) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover f))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T) : tls_fin\n  (eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T).","proofString":"simpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (f : actid) (STEP : ext_isim_trav_step G sc (tid f) T T') (FF : is_f (lab G) f) (TS : ext_itrav_step G sc (mkTL ta_cover f) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover f)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover f)) ->\naction (mkTL ta_cover f) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover f))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T) : tls_fin (eq (mkTL ta_cover f) ∪₁ eq ta_reserve <*> ∅).","proofString":"simpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (f : actid) (STEP : ext_isim_trav_step G sc (tid f) T T') (FF : is_f (lab G) f) (TS : ext_itrav_step G sc (mkTL ta_cover f) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover f)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover f)) ->\naction (mkTL ta_cover f) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover f))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover f)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover f) T) : tls_fin (eq (mkTL ta_cover f)).","proofString":"apply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (RR : is_r (lab G) r) (NRMW : ~ dom_rel (rmw G) r) (TS : ext_itrav_step G sc (mkTL ta_cover r) T T') : tls_fin T'.","proofString":"inversion TS.\nrewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (RR : is_r (lab G) r) (NRMW : ~ dom_rel (rmw G) r) (TS : ext_itrav_step G sc (mkTL ta_cover r) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) : tls_fin T'.","proofString":"rewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (RR : is_r (lab G) r) (NRMW : ~ dom_rel (rmw G) r) (TS : ext_itrav_step G sc (mkTL ta_cover r) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) : tls_fin\n  (T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T).","proofString":"rewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (RR : is_r (lab G) r) (NRMW : ~ dom_rel (rmw G) r) (TS : ext_itrav_step G sc (mkTL ta_cover r) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) : tls_fin\n  (T\n   ∪₁ (eq (mkTL ta_cover r)\n       ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T)).","proofString":"apply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (RR : is_r (lab G) r) (NRMW : ~ dom_rel (rmw G) r) (TS : ext_itrav_step G sc (mkTL ta_cover r) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) : tls_fin\n  (eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T).","proofString":"simpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (RR : is_r (lab G) r) (NRMW : ~ dom_rel (rmw G) r) (TS : ext_itrav_step G sc (mkTL ta_cover r) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) : tls_fin (eq (mkTL ta_cover r) ∪₁ eq ta_reserve <*> ∅).","proofString":"simpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (RR : is_r (lab G) r) (NRMW : ~ dom_rel (rmw G) r) (TS : ext_itrav_step G sc (mkTL ta_cover r) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) : tls_fin (eq (mkTL ta_cover r)).","proofString":"apply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (TS : ext_itrav_step G sc (mkTL ta_reserve w) T T') : tls_fin T'.","proofString":"inversion TS.\nrewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (TS : ext_itrav_step G sc (mkTL ta_reserve w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_reserve w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_reserve w)) ->\naction (mkTL ta_reserve w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_reserve w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T) : tls_fin T'.","proofString":"rewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (TS : ext_itrav_step G sc (mkTL ta_reserve w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_reserve w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_reserve w)) ->\naction (mkTL ta_reserve w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_reserve w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T) : tls_fin\n  (T ∪₁ eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T).","proofString":"rewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (TS : ext_itrav_step G sc (mkTL ta_reserve w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_reserve w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_reserve w)) ->\naction (mkTL ta_reserve w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_reserve w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T) : tls_fin\n  (T\n   ∪₁ (eq (mkTL ta_reserve w)\n       ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T)).","proofString":"apply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (TS : ext_itrav_step G sc (mkTL ta_reserve w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_reserve w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_reserve w)) ->\naction (mkTL ta_reserve w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_reserve w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T) : tls_fin\n  (eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T).","proofString":"simpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (TS : ext_itrav_step G sc (mkTL ta_reserve w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_reserve w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_reserve w)) ->\naction (mkTL ta_reserve w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_reserve w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T) : tls_fin (eq (mkTL ta_reserve w) ∪₁ eq ta_reserve <*> ∅).","proofString":"simpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (TS : ext_itrav_step G sc (mkTL ta_reserve w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_reserve w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_reserve w)) ->\naction (mkTL ta_reserve w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_reserve w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_reserve w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_reserve w) T) : tls_fin (eq (mkTL ta_reserve w)).","proofString":"apply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') : tls_fin T'.","proofString":"inversion TS.\nrewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin, set_finite_union.\nsplit.\napply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : tls_fin T'.","proofString":"rewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin, set_finite_union.\nsplit.\napply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : tls_fin\n  (T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T).","proofString":"rewrite set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin, set_finite_union.\nsplit.\napply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : tls_fin\n  (T\n   ∪₁ (eq (mkTL ta_issue w)\n       ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T)).","proofString":"apply tls_fin_union; auto.\napply tls_fin_T_fin, set_finite_union.\nsplit.\napply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : tls_fin\n  (eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T).","proofString":"apply tls_fin_T_fin, set_finite_union.\nsplit.\napply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : set_finite (eq (mkTL ta_issue w)) /\\\nset_finite (eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T).","proofString":"split.\napply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : set_finite (eq (mkTL ta_issue w)).","proofString":"apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : set_finite (eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T).","proofString":"apply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : set_finite (ets_upd_reserve G (mkTL ta_issue w) T).","proofString":"simpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : set_finite (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"apply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NISS : ~ issued T w) (TS : ext_itrav_step G sc (mkTL ta_issue w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : set_finite (eq w) /\\ set_finite (dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"split; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (ISS : issued T w) (TS : ext_itrav_step G sc (mkTL ta_cover w) T T') : tls_fin T'.","proofString":"inversion TS.\nrewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (ISS : issued T w) (TS : ext_itrav_step G sc (mkTL ta_cover w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T) : tls_fin T'.","proofString":"rewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (ISS : issued T w) (TS : ext_itrav_step G sc (mkTL ta_cover w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T) : tls_fin\n  (T ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T).","proofString":"rewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (ISS : issued T w) (TS : ext_itrav_step G sc (mkTL ta_cover w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T) : tls_fin\n  (T\n   ∪₁ (eq (mkTL ta_cover w)\n       ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T)).","proofString":"apply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (ISS : issued T w) (TS : ext_itrav_step G sc (mkTL ta_cover w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T) : tls_fin\n  (eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T).","proofString":"simpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (ISS : issued T w) (TS : ext_itrav_step G sc (mkTL ta_cover w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T) : tls_fin (eq (mkTL ta_cover w) ∪₁ eq ta_reserve <*> ∅).","proofString":"simpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (WW : is_w (lab G) w) (NREL : ~ is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (ISS : issued T w) (TS : ext_itrav_step G sc (mkTL ta_cover w) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL ta_cover w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover w))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T) : tls_fin (eq (mkTL ta_cover w)).","proofString":"apply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') : tls_fin T'.","proofString":"inversion TS1.\ninversion TS2.\nrewrite ets_upd0, ets_upd.\nsimpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) : tls_fin T'.","proofString":"inversion TS2.\nrewrite ets_upd0, ets_upd.\nsimpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin T'.","proofString":"rewrite ets_upd0, ets_upd.\nsimpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin\n  (T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T\n   ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*>\n      ets_upd_reserve G (mkTL ta_cover w)\n        (T ∪₁ eq (mkTL ta_issue w)\n         ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T)).","proofString":"simpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin\n  (T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n   ∪₁ eq (mkTL ta_cover w) ∪₁ eq ta_reserve <*> ∅).","proofString":"simpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin\n  (T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n   ∪₁ eq (mkTL ta_cover w)).","proofString":"rewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin\n  (T\n   ∪₁ (eq (mkTL ta_issue w)\n       ∪₁ (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n           ∪₁ eq (mkTL ta_cover w)))).","proofString":"apply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin\n  (eq (mkTL ta_issue w)\n   ∪₁ (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n       ∪₁ eq (mkTL ta_cover w))).","proofString":"apply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : set_finite\n  (eq (mkTL ta_issue w)\n   ∪₁ (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n       ∪₁ eq (mkTL ta_cover w))).","proofString":"repeat (apply set_finite_union; split); try by (apply set_finite_eq).\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : set_finite (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))).","proofString":"apply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : set_finite (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"simpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : set_finite (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"apply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (w : actid) (STEP : ext_isim_trav_step G sc (tid w) T T') (T'0 : trav_label -> Prop) (WW : is_w (lab G) w) (REL : is_rel (lab G) w) (NRMW : ~ codom_rel (rmw G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_issue w) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_issue w)) (ets_issue_W_ex : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT (ta_reserve, event (mkTL ta_issue w))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : set_finite (eq w) /\\ set_finite (dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"split; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') : tls_fin T'.","proofString":"inversion TS1.\ninversion TS2.\nrewrite ets_upd0, ets_upd.\nsimpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) : tls_fin T'.","proofString":"inversion TS2.\nrewrite ets_upd0, ets_upd.\nsimpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin T'.","proofString":"rewrite ets_upd0, ets_upd.\nsimpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin\n  (T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T\n   ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*>\n      ets_upd_reserve G (mkTL ta_cover w)\n        (T ∪₁ eq (mkTL ta_cover r)\n         ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T)).","proofString":"simpl.\nsimpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin\n  (T ∪₁ eq (mkTL ta_cover r) ∪₁ eq ta_reserve <*> ∅ ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ∅).","proofString":"simpl_sets.\nrewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin (T ∪₁ eq (mkTL ta_cover r) ∪₁ eq (mkTL ta_cover w)).","proofString":"rewrite !set_unionA.\napply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin (T ∪₁ (eq (mkTL ta_cover r) ∪₁ eq (mkTL ta_cover w))).","proofString":"apply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : tls_fin (eq (mkTL ta_cover r) ∪₁ eq (mkTL ta_cover w)).","proofString":"apply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (NREL : ~ is_rel (lab G) w) (ISS : issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_cover w) T'0 T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T') (ets_iord_coh0 : iord_coherent G sc T') (ets_reserve_coh0 : reserve_coherent G T') (ets_new_ta0 : ~ T'0 (mkTL ta_cover w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_cover w))) (ets_upd0 : T'\n≡₁ T'0 ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'0) : set_finite (eq (mkTL ta_cover r) ∪₁ eq (mkTL ta_cover w)).","proofString":"repeat (apply set_finite_union; split); apply set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (t : thread_id) (FIN : tls_fin T) (STEP : ext_isim_trav_step G sc t T T') (e : actid) (TS : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL (ta_propagate t) e)) (ets_issue_W_ex : W_ex G (event (mkTL (ta_propagate t) e)) ->\naction (mkTL (ta_propagate t) e) = ta_issue ->\nT (ta_reserve, event (mkTL (ta_propagate t) e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T) : tls_fin T'.","proofString":"rewrite ets_upd.\nrewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (t : thread_id) (FIN : tls_fin T) (STEP : ext_isim_trav_step G sc t T T') (e : actid) (TS : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL (ta_propagate t) e)) (ets_issue_W_ex : W_ex G (event (mkTL (ta_propagate t) e)) ->\naction (mkTL (ta_propagate t) e) = ta_issue ->\nT (ta_reserve, event (mkTL (ta_propagate t) e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T) : tls_fin\n  (T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T).","proofString":"rewrite set_unionA.\napply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (t : thread_id) (FIN : tls_fin T) (STEP : ext_isim_trav_step G sc t T T') (e : actid) (TS : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL (ta_propagate t) e)) (ets_issue_W_ex : W_ex G (event (mkTL (ta_propagate t) e)) ->\naction (mkTL (ta_propagate t) e) = ta_issue ->\nT (ta_reserve, event (mkTL (ta_propagate t) e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T) : tls_fin\n  (T\n   ∪₁ (eq (mkTL (ta_propagate t) e)\n       ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T)).","proofString":"apply tls_fin_union; auto.\nsimpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (t : thread_id) (FIN : tls_fin T) (STEP : ext_isim_trav_step G sc t T T') (e : actid) (TS : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL (ta_propagate t) e)) (ets_issue_W_ex : W_ex G (event (mkTL (ta_propagate t) e)) ->\naction (mkTL (ta_propagate t) e) = ta_issue ->\nT (ta_reserve, event (mkTL (ta_propagate t) e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T) : tls_fin\n  (eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T).","proofString":"simpl.\nsimpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (t : thread_id) (FIN : tls_fin T) (STEP : ext_isim_trav_step G sc t T T') (e : actid) (TS : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL (ta_propagate t) e)) (ets_issue_W_ex : W_ex G (event (mkTL (ta_propagate t) e)) ->\naction (mkTL (ta_propagate t) e) = ta_issue ->\nT (ta_reserve, event (mkTL (ta_propagate t) e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T) : tls_fin (eq (mkTL (ta_propagate t) e) ∪₁ eq ta_reserve <*> ∅).","proofString":"simpl_sets.\napply tls_fin_T_fin, set_finite_eq."},{"statement":"(T T' : trav_label -> Prop) (t : thread_id) (FIN : tls_fin T) (STEP : ext_isim_trav_step G sc t T T') (e : actid) (TS : ext_itrav_step G sc (mkTL (ta_propagate t) e) T T') (ets_tls_coh : tls_coherent G T') (ets_iord_coh : iord_coherent G sc T') (ets_reserve_coh : reserve_coherent G T') (ets_new_ta : ~ T (mkTL (ta_propagate t) e)) (ets_issue_W_ex : W_ex G (event (mkTL (ta_propagate t) e)) ->\naction (mkTL (ta_propagate t) e) = ta_issue ->\nT (ta_reserve, event (mkTL (ta_propagate t) e))) (ets_upd : T'\n≡₁ T ∪₁ eq (mkTL (ta_propagate t) e)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL (ta_propagate t) e) T) : tls_fin (eq (mkTL (ta_propagate t) e)).","proofString":"apply tls_fin_T_fin, set_finite_eq."},{"statement":"(T : trav_label -> Prop) (r : actid) : reserved (T ∪₁ eq (mkTL ta_cover r)) ≡₁ reserved T.","proofString":"by simplify_tls_events."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 T'' : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (REL : is_rel (lab G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_issue w) T'0 T'') (TS3 : ext_itrav_step G sc (mkTL ta_cover w) T'' T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T'') (ets_iord_coh0 : iord_coherent G sc T'') (ets_reserve_coh0 : reserve_coherent G T'') (ets_new_ta0 : ~ T'0 (mkTL ta_issue w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_issue w))) (ets_upd0 : T''\n≡₁ T'0 ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T'0) (ets_tls_coh1 : tls_coherent G T') (ets_iord_coh1 : iord_coherent G sc T') (ets_reserve_coh1 : reserve_coherent G T') (ets_new_ta1 : ~ T'' (mkTL ta_cover w)) (ets_issue_W_ex1 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'' (ta_reserve, event (mkTL ta_cover w))) (ets_upd1 : T'\n≡₁ T'' ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'') : tls_fin\n  (T\n   ∪₁ (eq (mkTL ta_cover r)\n       ∪₁ (eq (mkTL ta_issue w)\n           ∪₁ (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n               ∪₁ eq (mkTL ta_cover w))))).","proofString":"apply tls_fin_union; auto.\napply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by apply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 T'' : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (REL : is_rel (lab G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_issue w) T'0 T'') (TS3 : ext_itrav_step G sc (mkTL ta_cover w) T'' T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T'') (ets_iord_coh0 : iord_coherent G sc T'') (ets_reserve_coh0 : reserve_coherent G T'') (ets_new_ta0 : ~ T'0 (mkTL ta_issue w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_issue w))) (ets_upd0 : T''\n≡₁ T'0 ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T'0) (ets_tls_coh1 : tls_coherent G T') (ets_iord_coh1 : iord_coherent G sc T') (ets_reserve_coh1 : reserve_coherent G T') (ets_new_ta1 : ~ T'' (mkTL ta_cover w)) (ets_issue_W_ex1 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'' (ta_reserve, event (mkTL ta_cover w))) (ets_upd1 : T'\n≡₁ T'' ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'') : tls_fin\n  (eq (mkTL ta_cover r)\n   ∪₁ (eq (mkTL ta_issue w)\n       ∪₁ (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n           ∪₁ eq (mkTL ta_cover w)))).","proofString":"apply tls_fin_T_fin.\nrepeat (apply set_finite_union; split); try by apply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 T'' : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (REL : is_rel (lab G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_issue w) T'0 T'') (TS3 : ext_itrav_step G sc (mkTL ta_cover w) T'' T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T'') (ets_iord_coh0 : iord_coherent G sc T'') (ets_reserve_coh0 : reserve_coherent G T'') (ets_new_ta0 : ~ T'0 (mkTL ta_issue w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_issue w))) (ets_upd0 : T''\n≡₁ T'0 ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T'0) (ets_tls_coh1 : tls_coherent G T') (ets_iord_coh1 : iord_coherent G sc T') (ets_reserve_coh1 : reserve_coherent G T') (ets_new_ta1 : ~ T'' (mkTL ta_cover w)) (ets_issue_W_ex1 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'' (ta_reserve, event (mkTL ta_cover w))) (ets_upd1 : T'\n≡₁ T'' ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'') : set_finite\n  (eq (mkTL ta_cover r)\n   ∪₁ (eq (mkTL ta_issue w)\n       ∪₁ (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))\n           ∪₁ eq (mkTL ta_cover w)))).","proofString":"repeat (apply set_finite_union; split); try by apply set_finite_eq.\napply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 T'' : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (REL : is_rel (lab G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_issue w) T'0 T'') (TS3 : ext_itrav_step G sc (mkTL ta_cover w) T'' T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T'') (ets_iord_coh0 : iord_coherent G sc T'') (ets_reserve_coh0 : reserve_coherent G T'') (ets_new_ta0 : ~ T'0 (mkTL ta_issue w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_issue w))) (ets_upd0 : T''\n≡₁ T'0 ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T'0) (ets_tls_coh1 : tls_coherent G T') (ets_iord_coh1 : iord_coherent G sc T') (ets_reserve_coh1 : reserve_coherent G T') (ets_new_ta1 : ~ T'' (mkTL ta_cover w)) (ets_issue_W_ex1 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'' (ta_reserve, event (mkTL ta_cover w))) (ets_upd1 : T'\n≡₁ T'' ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'') : set_finite (eq ta_reserve <*> (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w))).","proofString":"apply tls_set_fin_events_fin.\nsimpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 T'' : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (REL : is_rel (lab G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_issue w) T'0 T'') (TS3 : ext_itrav_step G sc (mkTL ta_cover w) T'' T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T'') (ets_iord_coh0 : iord_coherent G sc T'') (ets_reserve_coh0 : reserve_coherent G T'') (ets_new_ta0 : ~ T'0 (mkTL ta_issue w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_issue w))) (ets_upd0 : T''\n≡₁ T'0 ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T'0) (ets_tls_coh1 : tls_coherent G T') (ets_iord_coh1 : iord_coherent G sc T') (ets_reserve_coh1 : reserve_coherent G T') (ets_new_ta1 : ~ T'' (mkTL ta_cover w)) (ets_issue_W_ex1 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'' (ta_reserve, event (mkTL ta_cover w))) (ets_upd1 : T'\n≡₁ T'' ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'') : set_finite (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"simpl.\napply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 T'' : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (REL : is_rel (lab G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_issue w) T'0 T'') (TS3 : ext_itrav_step G sc (mkTL ta_cover w) T'' T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T'') (ets_iord_coh0 : iord_coherent G sc T'') (ets_reserve_coh0 : reserve_coherent G T'') (ets_new_ta0 : ~ T'0 (mkTL ta_issue w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_issue w))) (ets_upd0 : T''\n≡₁ T'0 ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T'0) (ets_tls_coh1 : tls_coherent G T') (ets_iord_coh1 : iord_coherent G sc T') (ets_reserve_coh1 : reserve_coherent G T') (ets_new_ta1 : ~ T'' (mkTL ta_cover w)) (ets_issue_W_ex1 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'' (ta_reserve, event (mkTL ta_cover w))) (ets_upd1 : T'\n≡₁ T'' ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'') : set_finite (eq w ∪₁ dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"apply set_finite_union.\nsplit; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (FIN : tls_fin T) (r : actid) (STEP : ext_isim_trav_step G sc (tid r) T T') (T'0 T'' : trav_label -> Prop) (w : actid) (RMW : rmw G r w) (REL : is_rel (lab G) w) (NISS : ~ issued T w) (TS1 : ext_itrav_step G sc (mkTL ta_cover r) T T'0) (TS2 : ext_itrav_step G sc (mkTL ta_issue w) T'0 T'') (TS3 : ext_itrav_step G sc (mkTL ta_cover w) T'' T') (ets_tls_coh : tls_coherent G T'0) (ets_iord_coh : iord_coherent G sc T'0) (ets_reserve_coh : reserve_coherent G T'0) (ets_new_ta : ~ T (mkTL ta_cover r)) (ets_issue_W_ex : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT (ta_reserve, event (mkTL ta_cover r))) (ets_upd : T'0\n≡₁ T ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T) (ets_tls_coh0 : tls_coherent G T'') (ets_iord_coh0 : iord_coherent G sc T'') (ets_reserve_coh0 : reserve_coherent G T'') (ets_new_ta0 : ~ T'0 (mkTL ta_issue w)) (ets_issue_W_ex0 : W_ex G (event (mkTL ta_issue w)) ->\naction (mkTL ta_issue w) = ta_issue ->\nT'0 (ta_reserve, event (mkTL ta_issue w))) (ets_upd0 : T''\n≡₁ T'0 ∪₁ eq (mkTL ta_issue w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_issue w) T'0) (ets_tls_coh1 : tls_coherent G T') (ets_iord_coh1 : iord_coherent G sc T') (ets_reserve_coh1 : reserve_coherent G T') (ets_new_ta1 : ~ T'' (mkTL ta_cover w)) (ets_issue_W_ex1 : W_ex G (event (mkTL ta_cover w)) ->\naction (mkTL ta_cover w) = ta_issue ->\nT'' (ta_reserve, event (mkTL ta_cover w))) (ets_upd1 : T'\n≡₁ T'' ∪₁ eq (mkTL ta_cover w)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover w) T'') : set_finite (eq w) /\\ set_finite (dom_sb_S_rfrmw G T (rfi G) (eq w)).","proofString":"split; auto using set_finite_eq, dom_sb_S_rfrmw_tls_fin."},{"statement":"(T T' : trav_label -> Prop) (n : nat) (STEPS : (ext_sim_trav_step G sc) ^^ n T T') (FIN : tls_fin T) : tls_fin T'.","proofString":"generalize dependent T'.\ninduction n.\nins.\nred in STEPS.\ndesc.\ncongruence.\nintros T'' [T' [STEPS' STEP]].\napply IHn in STEPS'.\ninversion_clear STEP as [t ISTEP].\neapply isim_step_preserves_fin; eauto."},{"statement":"(T : trav_label -> Prop) (FIN : tls_fin T) (T' : trav_label -> Prop) (STEPS : ⦗fun _ : trav_label -> Prop => True⦘ T T') : tls_fin T'.","proofString":"red in STEPS.\ndesc.\ncongruence."},{"statement":"(T : trav_label -> Prop) (FIN : tls_fin T) (T' : trav_label -> Prop) (STEPS : T = T' /\\ True) : tls_fin T'.","proofString":"desc.\ncongruence."},{"statement":"(T : trav_label -> Prop) (FIN : tls_fin T) (T' : trav_label -> Prop) (STEPS : T = T') (STEPS0 : True) : tls_fin T'.","proofString":"congruence."},{"statement":"(T : trav_label -> Prop) (n : nat) (FIN : tls_fin T) (IHn : forall T' : trav_label -> Prop,\n(ext_sim_trav_step G sc) ^^ n T T' -> tls_fin T') : forall T' : trav_label -> Prop,\n(ext_sim_trav_step G sc) ^^ (S n) T T' -> tls_fin T'.","proofString":"intros T'' [T' [STEPS' STEP]].\napply IHn in STEPS'.\ninversion_clear STEP as [t ISTEP].\neapply isim_step_preserves_fin; eauto."},{"statement":"(T : trav_label -> Prop) (n : nat) (FIN : tls_fin T) (IHn : forall T'0 : trav_label -> Prop,\n(ext_sim_trav_step G sc) ^^ n T T'0 -> tls_fin T'0) (T'' T' : trav_label -> Prop) (STEPS' : (ext_sim_trav_step G sc) ^^ n T T') (STEP : ext_sim_trav_step G sc T' T'') : tls_fin T''.","proofString":"apply IHn in STEPS'.\ninversion_clear STEP as [t ISTEP].\neapply isim_step_preserves_fin; eauto."},{"statement":"(T : trav_label -> Prop) (n : nat) (FIN : tls_fin T) (IHn : forall T'0 : trav_label -> Prop,\n(ext_sim_trav_step G sc) ^^ n T T'0 -> tls_fin T'0) (T'' T' : trav_label -> Prop) (STEPS' : tls_fin T') (STEP : ext_sim_trav_step G sc T' T'') : tls_fin T''.","proofString":"inversion_clear STEP as [t ISTEP].\neapply isim_step_preserves_fin; eauto."},{"statement":"(T : trav_label -> Prop) (n : nat) (FIN : tls_fin T) (IHn : forall T'0 : trav_label -> Prop,\n(ext_sim_trav_step G sc) ^^ n T T'0 -> tls_fin T'0) (T'' T' : trav_label -> Prop) (STEPS' : tls_fin T') (t : thread_id) (ISTEP : ext_isim_trav_step G sc t T' T'') : tls_fin T''.","proofString":"eapply isim_step_preserves_fin; eauto."},{"statement":"(FIN : fin_exec G) (FIN_THREADS : fin_threads G) : set_finite\n  (eq ta_cover <*> (acts_set G \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((acts_set G \\₁ (fun a : actid => is_init a))\n       ∩₁ (fun a : actid => is_w (lab G) a))).","proofString":"destruct FIN as [acts ACTS].\ndestruct FIN_THREADS as [threads THREADS].\narewrite ((acts_set G \\₁ is_init) ∩₁ is_w (lab G) ⊆₁ acts_set G \\₁is_init) by basic_solver.\nrewrite !set_pair_alt.\nrewrite <- set_inter_union_l.\nexists (flat_map (fun e => map (fun a => mkTL a e) [ta_cover; ta_issue; ta_reserve]                       ++ map (fun t => mkTL (ta_propagate t) e) threads) acts).\nunfolder.\nins.\napply in_flat_map.\nexists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid, (acts_set G \\₁ (fun a : actid => is_init a)) x -> In x acts) (FIN_THREADS : fin_threads G) : set_finite\n  (eq ta_cover <*> (acts_set G \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((acts_set G \\₁ (fun a : actid => is_init a))\n       ∩₁ (fun a : actid => is_w (lab G) a))).","proofString":"destruct FIN_THREADS as [threads THREADS].\narewrite ((acts_set G \\₁ is_init) ∩₁ is_w (lab G) ⊆₁ acts_set G \\₁is_init) by basic_solver.\nrewrite !set_pair_alt.\nrewrite <- set_inter_union_l.\nexists (flat_map (fun e => map (fun a => mkTL a e) [ta_cover; ta_issue; ta_reserve]                       ++ map (fun t => mkTL (ta_propagate t) e) threads) acts).\nunfolder.\nins.\napply in_flat_map.\nexists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid, (acts_set G \\₁ (fun a : actid => is_init a)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) : set_finite\n  (eq ta_cover <*> (acts_set G \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((acts_set G \\₁ (fun a : actid => is_init a))\n       ∩₁ (fun a : actid => is_w (lab G) a))).","proofString":"arewrite ((acts_set G \\₁ is_init) ∩₁ is_w (lab G) ⊆₁ acts_set G \\₁is_init) by basic_solver.\nrewrite !set_pair_alt.\nrewrite <- set_inter_union_l.\nexists (flat_map (fun e => map (fun a => mkTL a e) [ta_cover; ta_issue; ta_reserve]                       ++ map (fun t => mkTL (ta_propagate t) e) threads) acts).\nunfolder.\nins.\napply in_flat_map.\nexists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid, (acts_set G \\₁ (fun a : actid => is_init a)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) : set_finite\n  (eq ta_cover <*> (acts_set G \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      (acts_set G \\₁ (fun a : actid => is_init a))).","proofString":"rewrite !set_pair_alt.\nrewrite <- set_inter_union_l.\nexists (flat_map (fun e => map (fun a => mkTL a e) [ta_cover; ta_issue; ta_reserve]                       ++ map (fun t => mkTL (ta_propagate t) e) threads) acts).\nunfolder.\nins.\napply in_flat_map.\nexists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid, (acts_set G \\₁ (fun a : actid => is_init a)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) : set_finite\n  (fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (acts_set G \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ (acts_set G \\₁ (fun a : actid => is_init a))).","proofString":"rewrite <- set_inter_union_l.\nexists (flat_map (fun e => map (fun a => mkTL a e) [ta_cover; ta_issue; ta_reserve]                       ++ map (fun t => mkTL (ta_propagate t) e) threads) acts).\nunfolder.\nins.\napply in_flat_map.\nexists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid, (acts_set G \\₁ (fun a : actid => is_init a)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) : set_finite\n  ((fst ↓₁ eq ta_cover\n    ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G))\n   ∩₁ snd ↓₁ (acts_set G \\₁ (fun a : actid => is_init a))).","proofString":"exists (flat_map (fun e => map (fun a => mkTL a e) [ta_cover; ta_issue; ta_reserve]                       ++ map (fun t => mkTL (ta_propagate t) e) threads) acts).\nunfolder.\nins.\napply in_flat_map.\nexists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x0 : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x0 -> In x0 acts) (threads : list thread_id) (THREADS : forall x0 : thread_id, threads_set G x0 -> In x0 threads) (x : trav_label) (IN : (ta_cover = fst x \\/\n (ta_issue = fst x \\/ ta_reserve = fst x) \\/ is_ta_propagate_to_G G (fst x)) /\\\nacts_set G (snd x) /\\ ~ is_init (snd x)) : In x\n  (flat_map\n     (fun e : actid =>\n      mkTL ta_cover e\n      :: mkTL ta_issue e\n         :: mkTL ta_reserve e\n            :: map (fun t : thread_id => mkTL (ta_propagate t) e) threads)\n     acts).","proofString":"apply in_flat_map.\nexists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x0 : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x0 -> In x0 acts) (threads : list thread_id) (THREADS : forall x0 : thread_id, threads_set G x0 -> In x0 threads) (x : trav_label) (IN : (ta_cover = fst x \\/\n (ta_issue = fst x \\/ ta_reserve = fst x) \\/ is_ta_propagate_to_G G (fst x)) /\\\nacts_set G (snd x) /\\ ~ is_init (snd x)) : exists x0 : actid,\n  In x0 acts /\\\n  In x\n    (mkTL ta_cover x0\n     :: mkTL ta_issue x0\n        :: mkTL ta_reserve x0\n           :: map (fun t : thread_id => mkTL (ta_propagate t) x0) threads).","proofString":"exists (event x).\nsplit.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x0 : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x0 -> In x0 acts) (threads : list thread_id) (THREADS : forall x0 : thread_id, threads_set G x0 -> In x0 threads) (x : trav_label) (IN : (ta_cover = fst x \\/\n (ta_issue = fst x \\/ ta_reserve = fst x) \\/ is_ta_propagate_to_G G (fst x)) /\\\nacts_set G (snd x) /\\ ~ is_init (snd x)) : In (event x) acts /\\\nIn x\n  (mkTL ta_cover (event x)\n   :: mkTL ta_issue (event x)\n      :: mkTL ta_reserve (event x)\n         :: map (fun t : thread_id => mkTL (ta_propagate t) (event x))\n              threads).","proofString":"split.\napply ACTS, IN.\ndestruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x0 : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x0 -> In x0 acts) (threads : list thread_id) (THREADS : forall x0 : thread_id, threads_set G x0 -> In x0 threads) (x : trav_label) (IN : (ta_cover = fst x \\/\n (ta_issue = fst x \\/ ta_reserve = fst x) \\/ is_ta_propagate_to_G G (fst x)) /\\\nacts_set G (snd x) /\\ ~ is_init (snd x)) : In (event x) acts.","proofString":"apply ACTS, IN."},{"statement":"(acts : list actid) (ACTS : forall x0 : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x0 -> In x0 acts) (threads : list thread_id) (THREADS : forall x0 : thread_id, threads_set G x0 -> In x0 threads) (x : trav_label) (IN : (ta_cover = fst x \\/\n (ta_issue = fst x \\/ ta_reserve = fst x) \\/ is_ta_propagate_to_G G (fst x)) /\\\nacts_set G (snd x) /\\ ~ is_init (snd x)) : In x\n  (mkTL ta_cover (event x)\n   :: mkTL ta_issue (event x)\n      :: mkTL ta_reserve (event x)\n         :: map (fun t : thread_id => mkTL (ta_propagate t) (event x))\n              threads).","proofString":"destruct x; des; ins; subst; try by tauto.\nrepeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid,\n(acts_set G \\₁ (fun a0 : actid => is_init a0)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) (t : trav_action) (a : actid) (IN : is_ta_propagate_to_G G t) (IN0 : acts_set G a) (IN1 : ~ is_init a) : mkTL ta_cover a = (t, a) \\/\nmkTL ta_issue a = (t, a) \\/\nmkTL ta_reserve a = (t, a) \\/\nIn (t, a) (map (fun t0 : thread_id => mkTL (ta_propagate t0) a) threads).","proofString":"repeat right.\napply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid,\n(acts_set G \\₁ (fun a0 : actid => is_init a0)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) (t : trav_action) (a : actid) (IN : is_ta_propagate_to_G G t) (IN0 : acts_set G a) (IN1 : ~ is_init a) : In (t, a) (map (fun t0 : thread_id => mkTL (ta_propagate t0) a) threads).","proofString":"apply in_map_iff.\ndo 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid,\n(acts_set G \\₁ (fun a0 : actid => is_init a0)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) (t : trav_action) (a : actid) (IN : is_ta_propagate_to_G G t) (IN0 : acts_set G a) (IN1 : ~ is_init a) : exists x : thread_id, mkTL (ta_propagate x) a = (t, a) /\\ In x threads.","proofString":"do 2 red in IN.\ndesc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid,\n(acts_set G \\₁ (fun a0 : actid => is_init a0)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) (t : trav_action) (a : actid) (IN : exists y : thread_id, (threads_set G \\₁ eq tid_init) y /\\ ta_propagate y = t) (IN0 : acts_set G a) (IN1 : ~ is_init a) : exists x : thread_id, mkTL (ta_propagate x) a = (t, a) /\\ In x threads.","proofString":"desc.\neexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid,\n(acts_set G \\₁ (fun a0 : actid => is_init a0)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) (t : trav_action) (a : actid) (y : thread_id) (IN : (threads_set G \\₁ eq tid_init) y) (IN2 : ta_propagate y = t) (IN0 : acts_set G a) (IN1 : ~ is_init a) : exists x : thread_id, mkTL (ta_propagate x) a = (t, a) /\\ In x threads.","proofString":"eexists.\nsplits; vauto.\napply THREADS, IN."},{"statement":"(acts : list actid) (ACTS : forall x : actid,\n(acts_set G \\₁ (fun a0 : actid => is_init a0)) x -> In x acts) (threads : list thread_id) (THREADS : forall x : thread_id, threads_set G x -> In x threads) (a : actid) (y : thread_id) (IN : (threads_set G \\₁ eq tid_init) y) (IN0 : acts_set G a) (IN1 : ~ is_init a) : In y threads.","proofString":"apply THREADS, IN."},{"statement":"(T : trav_label -> Prop) (FIN : fin_exec G) (FIN_THREADS : fin_threads G) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : set_finite (init_tls G ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite init_tls_EI.\nvauto.\nexists [].\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FIN : fin_exec G) (FIN_THREADS : fin_threads G) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : set_finite\n  (event ↓₁ (acts_set G ∩₁ (fun a : actid => is_init a))\n   ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"vauto.\nexists [].\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FIN : fin_exec G) (FIN_THREADS : fin_threads G) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : set_finite\n  (event ↓₁ (acts_set G ∩₁ (fun a : actid => is_init a))\n   ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"exists [].\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FIN : fin_exec G) (FIN_THREADS : fin_threads G) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : forall x : trav_label,\n(event ↓₁ (acts_set G ∩₁ (fun a : actid => is_init a))\n ∩₁ event ↓₁ set_compl (fun a : actid => is_init a)) x -> \nIn x [].","proofString":"basic_solver."},{"statement":"(T : trav_label -> Prop) (FIN : fin_exec G) (FIN_THREADS : fin_threads G) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : exec_tls G ∩₁ event ↓₁ set_compl (fun a : actid => is_init a) ⊆₁ exec_tls G.","proofString":"basic_solver."}]}