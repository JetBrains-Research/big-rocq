{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/RTLgen.v","fileSamples":[{"statement":"(s : state) : state_incr s s.","proofString":"apply state_incr_intro.\napply Ple_refl.\napply Ple_refl.\nintros; auto."},{"statement":"(s : state) : Ple (st_nextnode s) (st_nextnode s).","proofString":"apply Ple_refl."},{"statement":"(s : state) : Ple (st_nextreg s) (st_nextreg s).","proofString":"apply Ple_refl."},{"statement":"(s : state) : forall pc : positive,\n(st_code s) ! pc = None \\/ (st_code s) ! pc = (st_code s) ! pc.","proofString":"intros; auto."},{"statement":"(s1 s2 s3 : state) (H : state_incr s1 s2) (H0 : state_incr s2 s3) : state_incr s1 s3.","proofString":"inv H; inv H0.\napply state_incr_intro.\napply Ple_trans with (st_nextnode s2); assumption.\napply Ple_trans with (st_nextreg s2); assumption.\nintros.\ngeneralize (H3 pc) (H5 pc).\nintuition congruence."},{"statement":"(s1 s2 s3 : state) (H1 : Ple (st_nextnode s1) (st_nextnode s2)) (H2 : Ple (st_nextreg s1) (st_nextreg s2)) (H3 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H : Ple (st_nextnode s2) (st_nextnode s3)) (H4 : Ple (st_nextreg s2) (st_nextreg s3)) (H5 : forall pc : positive,\n(st_code s2) ! pc = None \\/ (st_code s3) ! pc = (st_code s2) ! pc) : state_incr s1 s3.","proofString":"apply state_incr_intro.\napply Ple_trans with (st_nextnode s2); assumption.\napply Ple_trans with (st_nextreg s2); assumption.\nintros.\ngeneralize (H3 pc) (H5 pc).\nintuition congruence."},{"statement":"(s1 s2 s3 : state) (H1 : Ple (st_nextnode s1) (st_nextnode s2)) (H2 : Ple (st_nextreg s1) (st_nextreg s2)) (H3 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H : Ple (st_nextnode s2) (st_nextnode s3)) (H4 : Ple (st_nextreg s2) (st_nextreg s3)) (H5 : forall pc : positive,\n(st_code s2) ! pc = None \\/ (st_code s3) ! pc = (st_code s2) ! pc) : Ple (st_nextnode s1) (st_nextnode s3).","proofString":"apply Ple_trans with (st_nextnode s2); assumption."},{"statement":"(s1 s2 s3 : state) (H1 : Ple (st_nextnode s1) (st_nextnode s2)) (H2 : Ple (st_nextreg s1) (st_nextreg s2)) (H3 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H : Ple (st_nextnode s2) (st_nextnode s3)) (H4 : Ple (st_nextreg s2) (st_nextreg s3)) (H5 : forall pc : positive,\n(st_code s2) ! pc = None \\/ (st_code s3) ! pc = (st_code s2) ! pc) : Ple (st_nextreg s1) (st_nextreg s3).","proofString":"apply Ple_trans with (st_nextreg s2); assumption."},{"statement":"(s1 s2 s3 : state) (H1 : Ple (st_nextnode s1) (st_nextnode s2)) (H2 : Ple (st_nextreg s1) (st_nextreg s2)) (H3 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H : Ple (st_nextnode s2) (st_nextnode s3)) (H4 : Ple (st_nextreg s2) (st_nextreg s3)) (H5 : forall pc : positive,\n(st_code s2) ! pc = None \\/ (st_code s3) ! pc = (st_code s2) ! pc) : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s3) ! pc = (st_code s1) ! pc.","proofString":"intros.\ngeneralize (H3 pc) (H5 pc).\nintuition congruence."},{"statement":"(s1 s2 s3 : state) (H1 : Ple (st_nextnode s1) (st_nextnode s2)) (H2 : Ple (st_nextreg s1) (st_nextreg s2)) (H3 : forall pc0 : positive,\n(st_code s1) ! pc0 = None \\/ (st_code s2) ! pc0 = (st_code s1) ! pc0) (H : Ple (st_nextnode s2) (st_nextnode s3)) (H4 : Ple (st_nextreg s2) (st_nextreg s3)) (H5 : forall pc0 : positive,\n(st_code s2) ! pc0 = None \\/ (st_code s3) ! pc0 = (st_code s2) ! pc0) (pc : positive) : (st_code s1) ! pc = None \\/ (st_code s3) ! pc = (st_code s1) ! pc.","proofString":"generalize (H3 pc) (H5 pc).\nintuition congruence."},{"statement":"(s1 s2 s3 : state) (H1 : Ple (st_nextnode s1) (st_nextnode s2)) (H2 : Ple (st_nextreg s1) (st_nextreg s2)) (H3 : forall pc0 : positive,\n(st_code s1) ! pc0 = None \\/ (st_code s2) ! pc0 = (st_code s1) ! pc0) (H : Ple (st_nextnode s2) (st_nextnode s3)) (H4 : Ple (st_nextreg s2) (st_nextreg s3)) (H5 : forall pc0 : positive,\n(st_code s2) ! pc0 = None \\/ (st_code s3) ! pc0 = (st_code s2) ! pc0) (pc : positive) : (st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc ->\n(st_code s2) ! pc = None \\/ (st_code s3) ! pc = (st_code s2) ! pc ->\n(st_code s1) ! pc = None \\/ (st_code s3) ! pc = (st_code s1) ! pc.","proofString":"intuition congruence."},{"statement":"(s : state) (i : instruction) (pc : positive) (n : positive) (e : pc = n) : Plt pc (Pos.succ n) \\/ (PTree.set n i (st_code s)) ! pc = None.","proofString":"subst pc; left; apply Plt_succ."},{"statement":"(s : state) (i : instruction) (pc : positive) (n : positive) (n0 : pc <> n) (H : (st_code s) ! pc = None) : Plt pc (Pos.succ n) \\/ (st_code s) ! pc = None.","proofString":"right; assumption."},{"statement":"(s : state) (i : instruction) : Ple (st_nextnode s) (Pos.succ (st_nextnode s)).","proofString":"apply Ple_succ."},{"statement":"(s : state) (i : instruction) : Ple (st_nextreg s) (st_nextreg s).","proofString":"apply Ple_refl."},{"statement":"(s : state) (i : instruction) : forall pc : positive,\n(st_code s) ! pc = None \\/\n(PTree.set (st_nextnode s) i (st_code s)) ! pc = (st_code s) ! pc.","proofString":"intros.\ndestruct (st_wf s pc).\nright.\napply PTree.gso.\napply Plt_ne; auto.\nauto."},{"statement":"(s : state) (i : instruction) (pc : positive) : (st_code s) ! pc = None \\/\n(PTree.set (st_nextnode s) i (st_code s)) ! pc = (st_code s) ! pc.","proofString":"destruct (st_wf s pc).\nright.\napply PTree.gso.\napply Plt_ne; auto.\nauto."},{"statement":"(s : state) (i : instruction) (pc : positive) (H : Plt pc (st_nextnode s)) : (st_code s) ! pc = None \\/\n(PTree.set (st_nextnode s) i (st_code s)) ! pc = (st_code s) ! pc.","proofString":"right.\napply PTree.gso.\napply Plt_ne; auto."},{"statement":"(s : state) (i : instruction) (pc : positive) (H : Plt pc (st_nextnode s)) : (PTree.set (st_nextnode s) i (st_code s)) ! pc = (st_code s) ! pc.","proofString":"apply PTree.gso.\napply Plt_ne; auto."},{"statement":"(s : state) (i : instruction) (pc : positive) (H : Plt pc (st_nextnode s)) : pc <> st_nextnode s.","proofString":"apply Plt_ne; auto."},{"statement":"(s : state) (i : instruction) (pc : positive) (H : (st_code s) ! pc = None) : (st_code s) ! pc = None \\/\n(PTree.set (st_nextnode s) i (st_code s)) ! pc = (st_code s) ! pc.","proofString":"auto."},{"statement":"(s : state) (pc : positive) : Plt pc (Pos.succ (st_nextnode s)) \\/ (st_code s) ! pc = None.","proofString":"elim (st_wf s pc); intro.\nleft; apply Plt_trans_succ; auto.\nright; auto."},{"statement":"(s : state) (pc : positive) (H : Plt pc (st_nextnode s)) : Plt pc (Pos.succ (st_nextnode s)) \\/ (st_code s) ! pc = None.","proofString":"left; apply Plt_trans_succ; auto."},{"statement":"(s : state) (pc : positive) (H : (st_code s) ! pc = None) : Plt pc (Pos.succ (st_nextnode s)) \\/ (st_code s) ! pc = None.","proofString":"right; auto."},{"statement":"(s : state) (n : positive) : Ple (st_nextreg s) (st_nextreg s).","proofString":"apply Ple_refl."},{"statement":"(s : state) (n : positive) : forall pc : positive,\n(st_code s) ! pc = None \\/ (st_code s) ! pc = (st_code s) ! pc.","proofString":"auto."},{"statement":"(s : state) (n : positive) (i : instruction) (H : Plt n (st_nextnode s)) (pc : positive) : Plt pc (st_nextnode s) \\/ (PTree.set n i (st_code s)) ! pc = None.","proofString":"case (peq pc n); intro.\nsubst pc; left; assumption.\nrewrite PTree.gso; auto.\nexact (st_wf s pc)."},{"statement":"(s : state) (n : positive) (i : instruction) (H : Plt n (st_nextnode s)) (pc : positive) (e : pc = n) : Plt pc (st_nextnode s) \\/ (PTree.set n i (st_code s)) ! pc = None.","proofString":"subst pc; left; assumption."},{"statement":"(s : state) (n : positive) (i : instruction) (H : Plt n (st_nextnode s)) (pc : positive) (n0 : pc <> n) : Plt pc (st_nextnode s) \\/ (PTree.set n i (st_code s)) ! pc = None.","proofString":"rewrite PTree.gso; auto.\nexact (st_wf s pc)."},{"statement":"(s : state) (n : positive) (i : instruction) (H : Plt n (st_nextnode s)) (pc : positive) (n0 : pc <> n) : Plt pc (st_nextnode s) \\/ (st_code s) ! pc = None.","proofString":"exact (st_wf s pc)."},{"statement":"(s : state) (n : positive) (i : instruction) (LT : Plt n (st_nextnode s)) (H : (st_code s) ! n = None) : state_incr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := PTree.set n i (st_code s);\n    st_wf := update_instr_wf s n i LT\n  |}.","proofString":"constructor; simpl; intros.\napply Ple_refl.\napply Ple_refl.\nrewrite PTree.gsspec.\ndestruct (peq pc n).\nleft; congruence.\nright; auto."},{"statement":"(s : state) (n : positive) (i : instruction) (LT : Plt n (st_nextnode s)) (H : (st_code s) ! n = None) : Ple (st_nextnode s) (st_nextnode s).","proofString":"apply Ple_refl."},{"statement":"(s : state) (n : positive) (i : instruction) (LT : Plt n (st_nextnode s)) (H : (st_code s) ! n = None) : Ple (st_nextreg s) (st_nextreg s).","proofString":"apply Ple_refl."},{"statement":"(s : state) (n : positive) (i : instruction) (LT : Plt n (st_nextnode s)) (H : (st_code s) ! n = None) (pc : positive) : (st_code s) ! pc = None \\/\n(PTree.set n i (st_code s)) ! pc = (st_code s) ! pc.","proofString":"rewrite PTree.gsspec.\ndestruct (peq pc n).\nleft; congruence.\nright; auto."},{"statement":"(s : state) (n : positive) (i : instruction) (LT : Plt n (st_nextnode s)) (H : (st_code s) ! n = None) (pc : positive) : (st_code s) ! pc = None \\/\n(if peq pc n then Some i else (st_code s) ! pc) = (st_code s) ! pc.","proofString":"destruct (peq pc n).\nleft; congruence.\nright; auto."},{"statement":"(s : state) (n : positive) (i : instruction) (LT : Plt n (st_nextnode s)) (H : (st_code s) ! n = None) (pc : positive) (e : pc = n) : (st_code s) ! pc = None \\/ Some i = (st_code s) ! pc.","proofString":"left; congruence."},{"statement":"(s : state) (n : positive) (i : instruction) (LT : Plt n (st_nextnode s)) (H : (st_code s) ! n = None) (pc : positive) (n0 : pc <> n) : (st_code s) ! pc = None \\/ (st_code s) ! pc = (st_code s) ! pc.","proofString":"right; auto."},{"statement":"(s : state) (n : node) : {(st_code s) ! n = None} + {True}.","proofString":"case (s.(st_code)!n); intros.\nright; auto.\nleft; auto."},{"statement":"(s : state) (n : node) (i : instruction) : {Some i = None} + {True}.","proofString":"right; auto."},{"statement":"(s : state) : Ple (st_nextnode s) (st_nextnode s).","proofString":"apply Ple_refl."},{"statement":"(s : state) : Ple (st_nextreg s) (Pos.succ (st_nextreg s)).","proofString":"apply Ple_succ."},{"statement":"(s : state) : forall pc : positive,\n(st_code s) ! pc = None \\/ (st_code s) ! pc = (st_code s) ! pc.","proofString":"auto."}]}