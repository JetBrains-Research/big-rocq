{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Csem.v","fileSamples":[{"statement":"(v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v3 : val) (ty3 ty : type) (m : mem) (b : bool) (v2' v3' : val) (H : ty <> Tvoid) (H0 : bool_val v1 ty1 m = Some b) (H1 : sem_cast v2 ty2 ty m = Some v2') (H2 : sem_cast v3 ty3 ty m = Some v3') : rred (Eselection (Eval v1 ty1) (Eval v2 ty2) (Eval v3 ty3) ty) m E0\n  (Eval (if b then v2' else v3') ty) m.","conclusion":"rred (Eselection (Eval v1 ty1) (Eval v2 ty2) (Eval v3 ty3) ty) m E0\n  (Eval (if b then v2' else v3') ty) m","hypotheses":"(v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v3 : val) (ty3 ty : type) (m : mem) (b : bool) (v2' v3' : val) (H : ty <> Tvoid) (H0 : bool_val v1 ty1 m = Some b) (H1 : sem_cast v2 ty2 ty m = Some v2') (H2 : sem_cast v3 ty3 ty m = Some v3')","proofString":"unfold Eselection.\nset (t := typ_of_type ty).\nset (x := inj_type t).\nset (sg := [Xint; x; x ---> x]%asttyp).\nassert (LK: lookup_builtin_function \"__builtin_sel\"%string sg = Some (BI_standard (BI_select t))).\nunfold sg, x, t; destruct ty as [ | ? ? ? | ? | [] ? | ? ? | ? ? ? | ? ? ? | ? ? | ? ? ];    simpl; unfold Tptr; destruct Archi.ptr64; reflexivity.\nset (v' := if b then v2' else v3').\nassert (C: val_casted v' ty).\nunfold v'; destruct b; eapply cast_val_is_casted; eauto.\nassert (EQ: Val.normalize v' t = v').\napply Val.normalize_idem.\napply val_casted_has_type; auto.\neconstructor.\nconstructor.\nrewrite cast_bool_bool_val, H0.\neauto.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\nred.\nred.\nrewrite LK.\nconstructor.\nsimpl.\nrewrite <- EQ.\ndestruct b; auto."},{"statement":"(v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v3 : val) (ty3 ty : type) (m : mem) (b : bool) (v2' v3' : val) (H : ty <> Tvoid) (H0 : bool_val v1 ty1 m = Some b) (H1 : sem_cast v2 ty2 ty m = Some v2') (H2 : sem_cast v3 ty3 ty m = Some v3') : rred\n  (Ebuiltin\n     (EF_builtin \"__builtin_sel\"\n        [Xint; inj_type (typ_of_type ty); inj_type (typ_of_type ty) --->\n        inj_type (typ_of_type ty)]%asttyp) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v1 ty1) (Econs (Eval v2 ty2) (Econs (Eval v3 ty3) Enil)))\n     ty) m E0 (Eval (if b then v2' else v3') ty) m.","conclusion":"rred\n  (Ebuiltin\n     (EF_builtin \"__builtin_sel\"\n        [Xint; inj_type (typ_of_type ty); inj_type (typ_of_type ty) --->\n        inj_type (typ_of_type ty)]%asttyp) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v1 ty1) (Econs (Eval v2 ty2) (Econs (Eval v3 ty3) Enil)))\n     ty) m E0 (Eval (if b then v2' else v3') ty) m","hypotheses":"(v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (v3 : val) (ty3 ty : type) (m : mem) (b : bool) (v2' v3' : val) (H : ty <> Tvoid) (H0 : bool_val v1 ty1 m = Some b) (H1 : sem_cast v2 ty2 ty m = Some v2') (H2 : sem_cast v3 ty3 ty m = Some v3')","proofString":"set (t := typ_of_type ty).\nset (x := inj_type t).\nset (sg := [Xint; x; x ---> x]%asttyp).\nassert (LK: lookup_builtin_function \"__builtin_sel\"%string sg = Some (BI_standard (BI_select t))).\nunfold sg, x, t; destruct ty as [ | ? ? ? | ? | [] ? | ? ? | ? ? ? | ? ? ? | ? ? | ? ? ];    simpl; unfold Tptr; destruct Archi.ptr64; reflexivity.\nset (v' := if b then v2' else v3').\nassert (C: val_casted v' ty).\nunfold v'; destruct b; eapply cast_val_is_casted; eauto.\nassert (EQ: Val.normalize v' t = v').\napply Val.normalize_idem.\napply val_casted_has_type; auto.\neconstructor.\nconstructor.\nrewrite cast_bool_bool_val, H0.\neauto.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\nred.\nred.\nrewrite LK.\nconstructor.\nsimpl.\nrewrite <- EQ.\ndestruct b; auto."},{"statement":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) : context k RV (fun x : expr => Eselection (C x) r2 r3 ty).","conclusion":"context k RV (fun x : expr => Eselection (C x) r2 r3 ty)","hypotheses":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C)","proofString":"apply ctx_builtin.\nconstructor; auto."},{"statement":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) : contextlist k (fun x : expr => Econs (C x) (Econs r2 (Econs r3 Enil))).","conclusion":"contextlist k (fun x : expr => Econs (C x) (Econs r2 (Econs r3 Enil)))","hypotheses":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C)","proofString":"constructor; auto."},{"statement":"(k : kind) (r1 : expr) (C : expr -> expr) (r3 : expr) (ty : type) (H : context k RV C) : context k RV (fun x : expr => Eselection r1 (C x) r3 ty).","conclusion":"context k RV (fun x : expr => Eselection r1 (C x) r3 ty)","hypotheses":"(k : kind) (r1 : expr) (C : expr -> expr) (r3 : expr) (ty : type) (H : context k RV C)","proofString":"apply ctx_builtin.\nconstructor; constructor; auto."},{"statement":"(k : kind) (r1 : expr) (C : expr -> expr) (r3 : expr) (ty : type) (H : context k RV C) : contextlist k (fun x : expr => Econs r1 (Econs (C x) (Econs r3 Enil))).","conclusion":"contextlist k (fun x : expr => Econs r1 (Econs (C x) (Econs r3 Enil)))","hypotheses":"(k : kind) (r1 : expr) (C : expr -> expr) (r3 : expr) (ty : type) (H : context k RV C)","proofString":"constructor; constructor; auto."},{"statement":"(k : kind) (r1 r2 : expr) (C : expr -> expr) (ty : type) (H : context k RV C) : context k RV (fun x : expr => Eselection r1 r2 (C x) ty).","conclusion":"context k RV (fun x : expr => Eselection r1 r2 (C x) ty)","hypotheses":"(k : kind) (r1 r2 : expr) (C : expr -> expr) (ty : type) (H : context k RV C)","proofString":"apply ctx_builtin.\nconstructor; constructor; constructor; auto."},{"statement":"(k : kind) (r1 r2 : expr) (C : expr -> expr) (ty : type) (H : context k RV C) : contextlist k (fun x : expr => Econs r1 (Econs r2 (Econs (C x) Enil))).","conclusion":"contextlist k (fun x : expr => Econs r1 (Econs r2 (Econs (C x) Enil)))","hypotheses":"(k : kind) (r1 r2 : expr) (C : expr -> expr) (ty : type) (H : context k RV C)","proofString":"constructor; constructor; constructor; auto."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (H : step (globalenv p) s t s') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (H : step (globalenv p) s t s')","proofString":"set (ge := globalenv p) in *.\nassert (DEREF: forall chunk m b ofs bf t v, deref_loc ge chunk m b ofs bf t v -> (length t <= 1)%nat).\nintros.\ninv H0; simpl; try lia.\ninv H3; simpl; try lia.\nassert (ASSIGN: forall chunk m b ofs bf t v m' v', assign_loc ge chunk m b ofs bf v t m' v' -> (length t <= 1)%nat).\nintros.\ninv H0; simpl; try lia.\ninv H3; simpl; try lia.\ndestruct H.\ninv H; simpl; try lia.\ninv H0; eauto; simpl; try lia.\neapply external_call_trace_length; eauto.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s')","proofString":"assert (DEREF: forall chunk m b ofs bf t v, deref_loc ge chunk m b ofs bf t v -> (length t <= 1)%nat).\nintros.\ninv H0; simpl; try lia.\ninv H3; simpl; try lia.\nassert (ASSIGN: forall chunk m b ofs bf t v m' v', assign_loc ge chunk m b ofs bf v t m' v' -> (length t <= 1)%nat).\nintros.\ninv H0; simpl; try lia.\ninv H3; simpl; try lia.\ndestruct H.\ninv H; simpl; try lia.\ninv H0; eauto; simpl; try lia.\neapply external_call_trace_length; eauto.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat.","conclusion":"forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s')","proofString":"intros.\ninv H0; simpl; try lia.\ninv H3; simpl; try lia."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t0 : trace) (v : val) (H0 : deref_loc ge chunk m b ofs bf t0 v) : (Datatypes.length t0 <= 1)%nat.","conclusion":"(Datatypes.length t0 <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t0 : trace) (v : val) (H0 : deref_loc ge chunk m b ofs bf t0 v)","proofString":"inv H0; simpl; try lia.\ninv H3; simpl; try lia."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (t0 : trace) (v : val) (chunk0 : memory_chunk) (H1 : access_mode chunk = By_value chunk0) (H2 : type_is_volatile chunk = true) (H3 : volatile_load ge chunk0 m b ofs t0 v) : (Datatypes.length t0 <= 1)%nat.","conclusion":"(Datatypes.length t0 <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (t0 : trace) (v : val) (chunk0 : memory_chunk) (H1 : access_mode chunk = By_value chunk0) (H2 : type_is_volatile chunk = true) (H3 : volatile_load ge chunk0 m b ofs t0 v)","proofString":"inv H3; simpl; try lia."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat)","proofString":"assert (ASSIGN: forall chunk m b ofs bf t v m' v', assign_loc ge chunk m b ofs bf v t m' v' -> (length t <= 1)%nat).\nintros.\ninv H0; simpl; try lia.\ninv H3; simpl; try lia.\ndestruct H.\ninv H; simpl; try lia.\ninv H0; eauto; simpl; try lia.\neapply external_call_trace_length; eauto.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat.","conclusion":"forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat)","proofString":"intros.\ninv H0; simpl; try lia.\ninv H3; simpl; try lia."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk0 : type) (m0 : mem) (b0 : block) (ofs0 : ptrofs)\n  (bf0 : bitfield) (t1 : trace) (v0 : val),\nderef_loc ge chunk0 m0 b0 ofs0 bf0 t1 v0 -> (Datatypes.length t1 <= 1)%nat) (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t0 : trace) (v : val) (m' : mem) (v' : val) (H0 : assign_loc ge chunk m b ofs bf v t0 m' v') : (Datatypes.length t0 <= 1)%nat.","conclusion":"(Datatypes.length t0 <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk0 : type) (m0 : mem) (b0 : block) (ofs0 : ptrofs)\n  (bf0 : bitfield) (t1 : trace) (v0 : val),\nderef_loc ge chunk0 m0 b0 ofs0 bf0 t1 v0 -> (Datatypes.length t1 <= 1)%nat) (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t0 : trace) (v : val) (m' : mem) (v' : val) (H0 : assign_loc ge chunk m b ofs bf v t0 m' v')","proofString":"inv H0; simpl; try lia.\ninv H3; simpl; try lia."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk1 : type) (m0 : mem) (b0 : block) (ofs0 : ptrofs)\n  (bf : bitfield) (t1 : trace) (v : val),\nderef_loc ge chunk1 m0 b0 ofs0 bf t1 v -> (Datatypes.length t1 <= 1)%nat) (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (t0 : trace) (m' : mem) (v' : val) (chunk0 : memory_chunk) (H1 : access_mode chunk = By_value chunk0) (H2 : type_is_volatile chunk = true) (H3 : volatile_store ge chunk0 m b ofs v' t0 m') : (Datatypes.length t0 <= 1)%nat.","conclusion":"(Datatypes.length t0 <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk1 : type) (m0 : mem) (b0 : block) (ofs0 : ptrofs)\n  (bf : bitfield) (t1 : trace) (v : val),\nderef_loc ge chunk1 m0 b0 ofs0 bf t1 v -> (Datatypes.length t1 <= 1)%nat) (chunk : type) (m : mem) (b : block) (ofs : ptrofs) (t0 : trace) (m' : mem) (v' : val) (chunk0 : memory_chunk) (H1 : access_mode chunk = By_value chunk0) (H2 : type_is_volatile chunk = true) (H3 : volatile_store ge chunk0 m b ofs v' t0 m')","proofString":"inv H3; simpl; try lia."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat) : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : step ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat)","proofString":"destruct H.\ninv H; simpl; try lia.\ninv H0; eauto; simpl; try lia.\neapply external_call_trace_length; eauto.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : estep ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat) : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : estep ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat)","proofString":"inv H; simpl; try lia.\ninv H0; eauto; simpl; try lia.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (t : trace) (ge : genv) (DEREF : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m0 b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m'0 : mem) \n  (v' : val),\nassign_loc ge chunk m0 b ofs bf v t0 m'0 v' -> (Datatypes.length t0 <= 1)%nat) (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H0 : rred ge a m t a' m') (H1 : context RV RV C) : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (t : trace) (ge : genv) (DEREF : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m0 b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m'0 : mem) \n  (v' : val),\nassign_loc ge chunk m0 b ofs bf v t0 m'0 v' -> (Datatypes.length t0 <= 1)%nat) (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H0 : rred ge a m t a' m') (H1 : context RV RV C)","proofString":"inv H0; eauto; simpl; try lia.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (t : trace) (ge : genv) (DEREF : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m0 b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m'0 : mem) \n  (v' : val),\nassign_loc ge chunk m0 b ofs bf v t0 m'0 v' -> (Datatypes.length t0 <= 1)%nat) (C : expr -> expr) (f : function) (k : cont) (e : env) (m m' : mem) (H1 : context RV RV C) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (vargs : list val) (vres : val) (H : cast_arguments m el tyargs vargs) (H2 : external_call ef ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (t : trace) (ge : genv) (DEREF : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m0 b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m'0 : mem) \n  (v' : val),\nassign_loc ge chunk m0 b ofs bf v t0 m'0 v' -> (Datatypes.length t0 <= 1)%nat) (C : expr -> expr) (f : function) (k : cont) (e : env) (m m' : mem) (H1 : context RV RV C) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (vargs : list val) (vres : val) (H : cast_arguments m el tyargs vargs) (H2 : external_call ef ge vargs m t vres m')","proofString":"eapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : sstep ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat) : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (s : state) (t : trace) (s' : state) (ge : genv) (H : sstep ge s t s') (DEREF : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m' : mem) \n  (v' : val),\nassign_loc ge chunk m b ofs bf v t0 m' v' -> (Datatypes.length t0 <= 1)%nat)","proofString":"inv H; simpl; try lia.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (t : trace) (ge : genv) (DEREF : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m0 b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m'0 : mem) \n  (v' : val),\nassign_loc ge chunk m0 b ofs bf v t0 m'0 v' -> (Datatypes.length t0 <= 1)%nat) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H0 : external_call ef ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (t : trace) (ge : genv) (DEREF : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val),\nderef_loc ge chunk m0 b ofs bf t0 v -> (Datatypes.length t0 <= 1)%nat) (ASSIGN : forall (chunk : type) (m0 : mem) (b : block) (ofs : ptrofs) \n  (bf : bitfield) (t0 : trace) (v : val) (m'0 : mem) \n  (v' : val),\nassign_loc ge chunk m0 b ofs bf v t0 m'0 v' -> (Datatypes.length t0 <= 1)%nat) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H0 : external_call ef ge vargs m t vres m')","proofString":"eapply external_call_trace_length; eauto."}]}