{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/RTLtyping.v","fileSamples":[{"statement":"(e : S.typenv) (ros : reg + ident) (e' : S.typenv) (te : S.typassign) (H : match ros with\n| inl r => S.set e r Tptr\n| inr _ => OK e\nend = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"destruct ros.\neauto with ty.\ninv H; auto with ty."},{"statement":"(e : S.typenv) (r : reg) (e' : S.typenv) (te : S.typassign) (H : S.set e r Tptr = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (i : ident) (e' : S.typenv) (te : S.typassign) (H : OK e = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"inv H; auto with ty."},{"statement":"(e : S.typenv) (ros : reg + ident) (e' : S.typenv) (te : S.typassign) (H : match ros with\n| inl r => S.set e r Tptr\n| inr _ => OK e\nend = OK e') (H0 : S.satisf te e') : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend.","proofString":"destruct ros.\neapply S.set_sound; eauto.\nauto."},{"statement":"(e : S.typenv) (r : reg) (e' : S.typenv) (te : S.typassign) (H : S.set e r Tptr = OK e') (H0 : S.satisf te e') : te r = Tptr.","proofString":"eapply S.set_sound; eauto."},{"statement":"(e : S.typenv) (i : ident) (e' : S.typenv) (te : S.typassign) (H : OK e = OK e') (H0 : S.satisf te e') : True.","proofString":"auto."},{"statement":"(s : node) (x : unit) (H : match (fn_code f) ! s with\n| Some _ => OK tt\n| None => Error (MSG \"bad successor \" :: POS s :: nil)\nend = OK x) : exists i : instruction, (fn_code f) ! s = Some i.","proofString":"destruct (fn_code f)!s; inv H.\nexists i; auto."},{"statement":"(s : node) (i : instruction) : exists i0 : instruction, Some i = Some i0.","proofString":"exists i; auto."},{"statement":"(x : unit) (H : OK tt = OK x) (s : node) (H0 : False) : valid_successor f s.","proofString":"contradiction."},{"statement":"(a : node) (sl : list node) (IHsl : forall x0 : unit,\ncheck_successors sl = OK x0 ->\nforall s0 : node, In s0 sl -> valid_successor f s0) (x : unit) (H : (do _ <- check_successor a; check_successors sl) = OK x) (s : node) (H0 : a = s \\/ In s sl) : valid_successor f s.","proofString":"monadInv H.\ndestruct H0.\nsubst a; eauto with ty.\neauto."},{"statement":"(a : node) (sl : list node) (IHsl : forall x1 : unit,\ncheck_successors sl = OK x1 ->\nforall s0 : node, In s0 sl -> valid_successor f s0) (x : unit) (s : node) (H0 : a = s \\/ In s sl) (x0 : unit) (EQ : check_successor a = OK x0) (EQ0 : check_successors sl = OK x) : valid_successor f s.","proofString":"destruct H0.\nsubst a; eauto with ty.\neauto."},{"statement":"(a : node) (sl : list node) (IHsl : forall x1 : unit,\ncheck_successors sl = OK x1 ->\nforall s0 : node, In s0 sl -> valid_successor f s0) (x : unit) (s : node) (H : a = s) (x0 : unit) (EQ : check_successor a = OK x0) (EQ0 : check_successors sl = OK x) : valid_successor f s.","proofString":"subst a; eauto with ty."},{"statement":"(a : node) (sl : list node) (IHsl : forall x1 : unit,\ncheck_successors sl = OK x1 ->\nforall s0 : node, In s0 sl -> valid_successor f s0) (x : unit) (s : node) (H : In s sl) (x0 : unit) (EQ : check_successor a = OK x0) (EQ0 : check_successors sl = OK x) : valid_successor f s.","proofString":"eauto."},{"statement":"(e : S.typenv) (ty1 ty2 : typ) (e' : S.typenv) (te : S.typassign) (H : (if typ_eq ty1 ty2 then OK e else Error (msg \"unexpected type\")) = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"destruct (typ_eq ty1 ty2); inv H.\nauto."},{"statement":"(ty2 : typ) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') : S.satisf te e'.","proofString":"auto."},{"statement":"(e : S.typenv) (ty1 ty2 : typ) (e' : S.typenv) (H : (if typ_eq ty1 ty2 then OK e else Error (msg \"unexpected type\")) = OK e') : ty1 = ty2.","proofString":"destruct (typ_eq ty1 ty2); inv H.\nauto."},{"statement":"(ty2 : typ) (e' : S.typenv) : ty2 = ty2.","proofString":"auto."},{"statement":"(e e' : S.typenv) (te : S.typassign) (H : OK e = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"inv H; auto."},{"statement":"(a : builtin_arg reg) (a0 : list (builtin_arg reg)) (IHa : forall (ty0 : list typ) (e0 e'0 : S.typenv) (te0 : S.typassign),\ntype_builtin_args e0 a0 ty0 = OK e'0 -> S.satisf te0 e'0 -> S.satisf te0 e0) (t : typ) (ty : list typ) (e e' : S.typenv) (te : S.typassign) (H : (do e1 <- type_builtin_arg e a t; type_builtin_args e1 a0 ty) = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"monadInv H.\neapply type_builtin_arg_incr; eauto."},{"statement":"(a : builtin_arg reg) (a0 : list (builtin_arg reg)) (IHa : forall (ty0 : list typ) (e0 e'0 : S.typenv) (te0 : S.typassign),\ntype_builtin_args e0 a0 ty0 = OK e'0 -> S.satisf te0 e'0 -> S.satisf te0 e0) (t : typ) (ty : list typ) (e e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_builtin_arg e a t = OK x) (EQ0 : type_builtin_args x a0 ty = OK e') : S.satisf te e.","proofString":"eapply type_builtin_arg_incr; eauto."},{"statement":"(e : S.typenv) (a : builtin_arg reg) (ty : typ) (e' : S.typenv) (te : S.typassign) (H : type_builtin_arg e a ty = OK e') (H0 : S.satisf te e') : type_of_builtin_arg te a = ty.","proofString":"destruct a; simpl in *; try (symmetry; eapply type_expect_sound; eassumption).\neapply S.set_sound; eauto."},{"statement":"(e : S.typenv) (x : reg) (ty : typ) (e' : S.typenv) (te : S.typassign) (H : S.set e x ty = OK e') (H0 : S.satisf te e') : te x = ty.","proofString":"eapply S.set_sound; eauto."},{"statement":"(a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall (tyl0 : list typ) (e0 e'0 : S.typenv) (te0 : S.typassign),\ntype_builtin_args e0 al tyl0 = OK e'0 ->\nS.satisf te0 e'0 -> map (type_of_builtin_arg te0) al = tyl0) (ty : typ) (tyl : list typ) (e e' : S.typenv) (te : S.typassign) (H : (do e1 <- type_builtin_arg e a ty; type_builtin_args e1 al tyl) = OK e') (H0 : S.satisf te e') : type_of_builtin_arg te a :: map (type_of_builtin_arg te) al = ty :: tyl.","proofString":"monadInv H.\nf_equal.\neapply type_builtin_arg_sound; eauto with ty.\neauto."},{"statement":"(a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall (tyl0 : list typ) (e0 e'0 : S.typenv) (te0 : S.typassign),\ntype_builtin_args e0 al tyl0 = OK e'0 ->\nS.satisf te0 e'0 -> map (type_of_builtin_arg te0) al = tyl0) (ty : typ) (tyl : list typ) (e e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_builtin_arg e a ty = OK x) (EQ0 : type_builtin_args x al tyl = OK e') : type_of_builtin_arg te a :: map (type_of_builtin_arg te) al = ty :: tyl.","proofString":"f_equal.\neapply type_builtin_arg_sound; eauto with ty.\neauto."},{"statement":"(a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall (tyl0 : list typ) (e0 e'0 : S.typenv) (te0 : S.typassign),\ntype_builtin_args e0 al tyl0 = OK e'0 ->\nS.satisf te0 e'0 -> map (type_of_builtin_arg te0) al = tyl0) (ty : typ) (tyl : list typ) (e e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_builtin_arg e a ty = OK x) (EQ0 : type_builtin_args x al tyl = OK e') : type_of_builtin_arg te a = ty.","proofString":"eapply type_builtin_arg_sound; eauto with ty."},{"statement":"(a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall (tyl0 : list typ) (e0 e'0 : S.typenv) (te0 : S.typassign),\ntype_builtin_args e0 al tyl0 = OK e'0 ->\nS.satisf te0 e'0 -> map (type_of_builtin_arg te0) al = tyl0) (ty : typ) (tyl : list typ) (e e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_builtin_arg e a ty = OK x) (EQ0 : type_builtin_args x al tyl = OK e') : map (type_of_builtin_arg te) al = tyl.","proofString":"eauto."},{"statement":"(e : S.typenv) (a : builtin_res reg) (ty : typ) (e' : S.typenv) (te : S.typassign) (H : type_builtin_res e a ty = OK e') (H0 : S.satisf te e') : type_of_builtin_res te a = ty.","proofString":"destruct a; simpl in *.\neapply S.set_sound; eauto.\nsymmetry; eapply type_expect_sound; eauto.\nsymmetry; eapply type_expect_sound; eauto."},{"statement":"(e : S.typenv) (x : reg) (ty : typ) (e' : S.typenv) (te : S.typassign) (H : S.set e x ty = OK e') (H0 : S.satisf te e') : te x = ty.","proofString":"eapply S.set_sound; eauto."},{"statement":"(e : S.typenv) (ty : typ) (e' : S.typenv) (te : S.typassign) (H : type_expect e ty Tint = OK e') (H0 : S.satisf te e') : Tint = ty.","proofString":"symmetry; eapply type_expect_sound; eauto."},{"statement":"(e : S.typenv) (a1 a2 : builtin_res reg) (ty : typ) (e' : S.typenv) (te : S.typassign) (H : type_expect e ty Tint = OK e') (H0 : S.satisf te e') : Tint = ty.","proofString":"symmetry; eapply type_expect_sound; eauto."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (EQ0 : (if is_move o\n then\n  match l with\n  | nil => Error (msg \"ill-formed move\")\n  | arg :: nil => do (_, e'0)<- S.move e r arg; OK e'0\n  | arg :: _ :: _ => Error (msg \"ill-formed move\")\n  end\n else\n  let (targs, tres) := type_of_operation o in\n  do e1 <- S.set_list e l targs; S.set e1 r tres) = \nOK e') : S.satisf te e.","proofString":"destruct (is_move o) eqn:ISMOVE.\ndestruct l; try discriminate.\ndestruct l; monadInv EQ0.\neauto with ty.\ndestruct (type_of_operation o) as [targs tres] eqn:TYOP.\nmonadInv EQ0.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = true) (EQ0 : match l with\n| nil => Error (msg \"ill-formed move\")\n| arg :: nil => do (_, e'0)<- S.move e r arg; OK e'0\n| arg :: _ :: _ => Error (msg \"ill-formed move\")\nend = OK e') : S.satisf te e.","proofString":"destruct l; try discriminate.\ndestruct l; monadInv EQ0.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (r0 : reg) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = true) (EQ0 : match l with\n| nil => do (_, e'0)<- S.move e r r0; OK e'0\n| _ :: _ => Error (msg \"ill-formed move\")\nend = OK e') : S.satisf te e.","proofString":"destruct l; monadInv EQ0.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (r0 r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = true) (x0 : bool) (EQ1 : S.move e r r0 = OK (x0, e')) : S.satisf te e.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (EQ0 : (let (targs, tres) := type_of_operation o in\n do e1 <- S.set_list e l targs; S.set e1 r tres) = \nOK e') : S.satisf te e.","proofString":"destruct (type_of_operation o) as [targs tres] eqn:TYOP.\nmonadInv EQ0.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (EQ0 : (do e1 <- S.set_list e l targs; S.set e1 r tres) = OK e') : S.satisf te e.","proofString":"monadInv EQ0.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : S.satisf te e.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (x0 : S.typenv) (EQ1 : S.set_list x l (proj_sig_args s) = OK x0) (EQ2 : (if xtype_eq (sig_res s) (sig_res (fn_sig f))\n then\n  if tailcall_is_possible s\n  then OK x0\n  else Error (msg \"tailcall not possible\")\n else Error (msg \"bad return type in tailcall\")) = \nOK e') : S.satisf te e.","proofString":"destruct (xtype_eq (sig_res s) (sig_res (fn_sig f))); try discriminate.\ndestruct (tailcall_is_possible s) eqn:TCIP; inv EQ2.\neauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (x0 : S.typenv) (EQ1 : S.set_list x l (proj_sig_args s) = OK x0) (e0 : sig_res s = sig_res (fn_sig f)) (EQ2 : (if tailcall_is_possible s\n then OK x0\n else Error (msg \"tailcall not possible\")) = OK e') : S.satisf te e.","proofString":"destruct (tailcall_is_possible s) eqn:TCIP; inv EQ2.\neauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (EQ1 : S.set_list x l (proj_sig_args s) = OK e') (e0 : sig_res s = sig_res (fn_sig f)) (TCIP : tailcall_is_possible s = true) : S.satisf te e.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (e0 : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : match e0 with\n| EF_annot _ _ _ | EF_debug _ _ _ => OK e\n| _ => type_builtin_args e l (proj_sig_args (ef_sig e0))\nend = OK x0) (EQ2 : type_builtin_res x0 b (proj_sig_res (ef_sig e0)) = OK e') : S.satisf te e.","proofString":"destruct e0; try monadInv EQ1; eauto with ty."},{"statement":"(e : S.typenv) (r : reg) (l : list node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successors l = OK x) (x0 : S.typenv) (EQ1 : S.set e r Tint = OK x0) (EQ2 : (if zle (list_length_z l * 4) Int.max_unsigned\n then OK x0\n else Error (msg \"jumptable too big\")) = OK e') : S.satisf te e.","proofString":"destruct (zle (list_length_z l * 4) Int.max_unsigned); inv EQ2.\neauto with ty."},{"statement":"(e : S.typenv) (r : reg) (l : list node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successors l = OK x) (EQ1 : S.set e r Tint = OK e') (l0 : list_length_z l * 4 <= Int.max_unsigned) : S.satisf te e.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (H : type_instr e (Ireturn o) = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"simpl in H.\ndestruct o as [r|] eqn: RET; destruct (xtype_eq (sig_res (fn_sig f)) Xvoid); try discriminate.\neauto with ty.\ninv H; auto with ty."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (H : match o with\n| Some r =>\n    if xtype_eq (sig_res (fn_sig f)) Xvoid\n    then Error (msg \"bad return\")\n    else S.set e r (proj_sig_res (fn_sig f))\n| None =>\n    if xtype_eq (sig_res (fn_sig f)) Xvoid\n    then OK e\n    else Error (msg \"bad return\")\nend = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"destruct o as [r|] eqn: RET; destruct (xtype_eq (sig_res (fn_sig f)) Xvoid); try discriminate.\neauto with ty.\ninv H; auto with ty."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (r : reg) (RET : o = Some r) (n : sig_res (fn_sig f) <> Xvoid) (H : S.set e r (proj_sig_res (fn_sig f)) = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (RET : o = None) (e0 : sig_res (fn_sig f) = Xvoid) (H : OK e = OK e') (H0 : S.satisf te e') : S.satisf te e.","proofString":"inv H; auto with ty."},{"statement":"(n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) : wt_instr f te (Inop n).","proofString":"constructor; eauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (EQ0 : (if is_move o\n then\n  match l with\n  | nil => Error (msg \"ill-formed move\")\n  | arg :: nil => do (_, e'0)<- S.move e r arg; OK e'0\n  | arg :: _ :: _ => Error (msg \"ill-formed move\")\n  end\n else\n  let (targs, tres) := type_of_operation o in\n  do e1 <- S.set_list e l targs; S.set e1 r tres) = \nOK e') : wt_instr f te (Iop o l r n).","proofString":"destruct (is_move o) eqn:ISMOVE.\nassert (o = Omove) by (unfold is_move in ISMOVE; destruct o; congruence).\nsubst o.\ndestruct l; try discriminate.\ndestruct l; monadInv EQ0.\nconstructor.\neapply S.move_sound; eauto.\neauto with ty.\ndestruct (type_of_operation o) as [targs tres] eqn:TYOP.\nmonadInv EQ0.\napply wt_Iop.\nunfold is_move in ISMOVE; destruct o; congruence.\nrewrite TYOP.\neapply S.set_list_sound; eauto with ty.\nrewrite TYOP.\neapply S.set_sound; eauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = true) (EQ0 : match l with\n| nil => Error (msg \"ill-formed move\")\n| arg :: nil => do (_, e'0)<- S.move e r arg; OK e'0\n| arg :: _ :: _ => Error (msg \"ill-formed move\")\nend = OK e') : wt_instr f te (Iop o l r n).","proofString":"assert (o = Omove) by (unfold is_move in ISMOVE; destruct o; congruence).\nsubst o.\ndestruct l; try discriminate.\ndestruct l; monadInv EQ0.\nconstructor.\neapply S.move_sound; eauto.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = true) (EQ0 : match l with\n| nil => Error (msg \"ill-formed move\")\n| arg :: nil => do (_, e'0)<- S.move e r arg; OK e'0\n| arg :: _ :: _ => Error (msg \"ill-formed move\")\nend = OK e') (H : o = Omove) : wt_instr f te (Iop o l r n).","proofString":"subst o.\ndestruct l; try discriminate.\ndestruct l; monadInv EQ0.\nconstructor.\neapply S.move_sound; eauto.\neauto with ty."},{"statement":"(e : S.typenv) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move Omove = true) (EQ0 : match l with\n| nil => Error (msg \"ill-formed move\")\n| arg :: nil => do (_, e'0)<- S.move e r arg; OK e'0\n| arg :: _ :: _ => Error (msg \"ill-formed move\")\nend = OK e') : wt_instr f te (Iop Omove l r n).","proofString":"destruct l; try discriminate.\ndestruct l; monadInv EQ0.\nconstructor.\neapply S.move_sound; eauto.\neauto with ty."},{"statement":"(e : S.typenv) (r0 : reg) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move Omove = true) (EQ0 : match l with\n| nil => do (_, e'0)<- S.move e r r0; OK e'0\n| _ :: _ => Error (msg \"ill-formed move\")\nend = OK e') : wt_instr f te (Iop Omove (r0 :: l) r n).","proofString":"destruct l; monadInv EQ0.\nconstructor.\neapply S.move_sound; eauto.\neauto with ty."},{"statement":"(e : S.typenv) (r0 r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move Omove = true) (x0 : bool) (EQ1 : S.move e r r0 = OK (x0, e')) : wt_instr f te (Iop Omove (r0 :: nil) r n).","proofString":"constructor.\neapply S.move_sound; eauto.\neauto with ty."},{"statement":"(e : S.typenv) (r0 r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move Omove = true) (x0 : bool) (EQ1 : S.move e r r0 = OK (x0, e')) : te r = te r0.","proofString":"eapply S.move_sound; eauto."},{"statement":"(e : S.typenv) (r0 r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move Omove = true) (x0 : bool) (EQ1 : S.move e r r0 = OK (x0, e')) : valid_successor f n.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (EQ0 : (let (targs, tres) := type_of_operation o in\n do e1 <- S.set_list e l targs; S.set e1 r tres) = \nOK e') : wt_instr f te (Iop o l r n).","proofString":"destruct (type_of_operation o) as [targs tres] eqn:TYOP.\nmonadInv EQ0.\napply wt_Iop.\nunfold is_move in ISMOVE; destruct o; congruence.\nrewrite TYOP.\neapply S.set_list_sound; eauto with ty.\nrewrite TYOP.\neapply S.set_sound; eauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (EQ0 : (do e1 <- S.set_list e l targs; S.set e1 r tres) = OK e') : wt_instr f te (Iop o l r n).","proofString":"monadInv EQ0.\napply wt_Iop.\nunfold is_move in ISMOVE; destruct o; congruence.\nrewrite TYOP.\neapply S.set_list_sound; eauto with ty.\nrewrite TYOP.\neapply S.set_sound; eauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : wt_instr f te (Iop o l r n).","proofString":"apply wt_Iop.\nunfold is_move in ISMOVE; destruct o; congruence.\nrewrite TYOP.\neapply S.set_list_sound; eauto with ty.\nrewrite TYOP.\neapply S.set_sound; eauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : o <> Omove.","proofString":"unfold is_move in ISMOVE; destruct o; congruence."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : map te l = fst (type_of_operation o).","proofString":"rewrite TYOP.\neapply S.set_list_sound; eauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : map te l = fst (targs, tres).","proofString":"eapply S.set_list_sound; eauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : te r = snd (type_of_operation o).","proofString":"rewrite TYOP.\neapply S.set_sound; eauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : te r = snd (targs, tres).","proofString":"eapply S.set_sound; eauto with ty."},{"statement":"(e : S.typenv) (o : operation) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (ISMOVE : is_move o = false) (targs : list typ) (tres : typ) (TYOP : type_of_operation o = (targs, tres)) (x0 : S.typenv) (EQ1 : S.set_list e l targs = OK x0) (EQ2 : S.set x0 r tres = OK e') : valid_successor f n.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : wt_instr f te (Iload m a l r n).","proofString":"constructor.\neapply S.set_list_sound; eauto with ty.\neapply S.set_sound; eauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : map te l = type_of_addressing a.","proofString":"eapply S.set_list_sound; eauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : te r = type_of_chunk m.","proofString":"eapply S.set_sound; eauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : valid_successor f n.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : wt_instr f te (Istore m a l r n).","proofString":"constructor.\neapply S.set_list_sound; eauto with ty.\neapply S.set_sound; eauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : map te l = type_of_addressing a.","proofString":"eapply S.set_list_sound; eauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : te r = type_of_chunk m.","proofString":"eapply S.set_sound; eauto with ty."},{"statement":"(e : S.typenv) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : S.set_list e l (type_of_addressing a) = OK x0) (EQ2 : S.set x0 r (type_of_chunk m) = OK e') : valid_successor f n.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : type_ros e s0 = OK x0) (x1 : S.typenv) (EQ0 : S.set_list x0 l (proj_sig_args s) = OK x1) (EQ3 : S.set x1 r (proj_sig_res s) = OK e') : wt_instr f te (Icall s s0 l r n).","proofString":"constructor.\neapply type_ros_sound; eauto with ty.\neapply S.set_list_sound; eauto with ty.\neapply S.set_sound; eauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : type_ros e s0 = OK x0) (x1 : S.typenv) (EQ0 : S.set_list x0 l (proj_sig_args s) = OK x1) (EQ3 : S.set x1 r (proj_sig_res s) = OK e') : match s0 with\n| inl r0 => te r0 = Tptr\n| inr _ => True\nend.","proofString":"eapply type_ros_sound; eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : type_ros e s0 = OK x0) (x1 : S.typenv) (EQ0 : S.set_list x0 l (proj_sig_args s) = OK x1) (EQ3 : S.set x1 r (proj_sig_res s) = OK e') : map te l = proj_sig_args s.","proofString":"eapply S.set_list_sound; eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : type_ros e s0 = OK x0) (x1 : S.typenv) (EQ0 : S.set_list x0 l (proj_sig_args s) = OK x1) (EQ3 : S.set x1 r (proj_sig_res s) = OK e') : te r = proj_sig_res s.","proofString":"eapply S.set_sound; eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : type_ros e s0 = OK x0) (x1 : S.typenv) (EQ0 : S.set_list x0 l (proj_sig_args s) = OK x1) (EQ3 : S.set x1 r (proj_sig_res s) = OK e') : valid_successor f n.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (x0 : S.typenv) (EQ1 : S.set_list x l (proj_sig_args s) = OK x0) (EQ2 : (if xtype_eq (sig_res s) (sig_res (fn_sig f))\n then\n  if tailcall_is_possible s\n  then OK x0\n  else Error (msg \"tailcall not possible\")\n else Error (msg \"bad return type in tailcall\")) = \nOK e') : wt_instr f te (Itailcall s s0 l).","proofString":"destruct (xtype_eq (sig_res s) (sig_res (fn_sig f))); try discriminate.\ndestruct (tailcall_is_possible s) eqn:TCIP; inv EQ2.\nconstructor.\neapply type_ros_sound; eauto with ty.\neapply S.set_list_sound; eauto with ty.\nauto.\napply tailcall_is_possible_correct; auto."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (x0 : S.typenv) (EQ1 : S.set_list x l (proj_sig_args s) = OK x0) (e0 : sig_res s = sig_res (fn_sig f)) (EQ2 : (if tailcall_is_possible s\n then OK x0\n else Error (msg \"tailcall not possible\")) = OK e') : wt_instr f te (Itailcall s s0 l).","proofString":"destruct (tailcall_is_possible s) eqn:TCIP; inv EQ2.\nconstructor.\neapply type_ros_sound; eauto with ty.\neapply S.set_list_sound; eauto with ty.\nauto.\napply tailcall_is_possible_correct; auto."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (EQ1 : S.set_list x l (proj_sig_args s) = OK e') (e0 : sig_res s = sig_res (fn_sig f)) (TCIP : tailcall_is_possible s = true) : wt_instr f te (Itailcall s s0 l).","proofString":"constructor.\neapply type_ros_sound; eauto with ty.\neapply S.set_list_sound; eauto with ty.\nauto.\napply tailcall_is_possible_correct; auto."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (EQ1 : S.set_list x l (proj_sig_args s) = OK e') (e0 : sig_res s = sig_res (fn_sig f)) (TCIP : tailcall_is_possible s = true) : match s0 with\n| inl r => te r = Tptr\n| inr _ => True\nend.","proofString":"eapply type_ros_sound; eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (EQ1 : S.set_list x l (proj_sig_args s) = OK e') (e0 : sig_res s = sig_res (fn_sig f)) (TCIP : tailcall_is_possible s = true) : map te l = proj_sig_args s.","proofString":"eapply S.set_list_sound; eauto with ty."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (EQ1 : S.set_list x l (proj_sig_args s) = OK e') (e0 : sig_res s = sig_res (fn_sig f)) (TCIP : tailcall_is_possible s = true) : sig_res s = sig_res (fn_sig f).","proofString":"auto."},{"statement":"(e : S.typenv) (s : signature) (s0 : reg + ident) (l : list reg) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : S.typenv) (EQ : type_ros e s0 = OK x) (EQ1 : S.set_list x l (proj_sig_args s) = OK e') (e0 : sig_res s = sig_res (fn_sig f)) (TCIP : tailcall_is_possible s = true) : tailcall_possible s.","proofString":"apply tailcall_is_possible_correct; auto."},{"statement":"(e : S.typenv) (e0 : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : match e0 with\n| EF_annot _ _ _ | EF_debug _ _ _ => OK e\n| _ => type_builtin_args e l (proj_sig_args (ef_sig e0))\nend = OK x0) (EQ2 : type_builtin_res x0 b (proj_sig_res (ef_sig e0)) = OK e') : wt_instr f te (Ibuiltin e0 l b n).","proofString":"constructor.\ndestruct e0; auto; eapply type_builtin_args_sound; eauto with ty.\neapply type_builtin_res_sound; eauto.\neauto with ty."},{"statement":"(e : S.typenv) (e0 : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : match e0 with\n| EF_annot _ _ _ | EF_debug _ _ _ => OK e\n| _ => type_builtin_args e l (proj_sig_args (ef_sig e0))\nend = OK x0) (EQ2 : type_builtin_res x0 b (proj_sig_res (ef_sig e0)) = OK e') : match e0 with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) l = proj_sig_args (ef_sig e0)\nend.","proofString":"destruct e0; auto; eapply type_builtin_args_sound; eauto with ty."},{"statement":"(e : S.typenv) (e0 : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : match e0 with\n| EF_annot _ _ _ | EF_debug _ _ _ => OK e\n| _ => type_builtin_args e l (proj_sig_args (ef_sig e0))\nend = OK x0) (EQ2 : type_builtin_res x0 b (proj_sig_res (ef_sig e0)) = OK e') : type_of_builtin_res te b = proj_sig_res (ef_sig e0).","proofString":"eapply type_builtin_res_sound; eauto."},{"statement":"(e : S.typenv) (e0 : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : S.typenv) (EQ1 : match e0 with\n| EF_annot _ _ _ | EF_debug _ _ _ => OK e\n| _ => type_builtin_args e l (proj_sig_args (ef_sig e0))\nend = OK x0) (EQ2 : type_builtin_res x0 b (proj_sig_res (ef_sig e0)) = OK e') : valid_successor f n.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (c : condition) (l : list reg) (n n0 : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : unit) (EQ1 : check_successor n0 = OK x0) (EQ2 : S.set_list e l (type_of_condition c) = OK e') : wt_instr f te (Icond c l n n0).","proofString":"constructor.\neapply S.set_list_sound; eauto with ty.\neauto with ty.\neauto with ty."},{"statement":"(e : S.typenv) (c : condition) (l : list reg) (n n0 : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : unit) (EQ1 : check_successor n0 = OK x0) (EQ2 : S.set_list e l (type_of_condition c) = OK e') : map te l = type_of_condition c.","proofString":"eapply S.set_list_sound; eauto with ty."},{"statement":"(e : S.typenv) (c : condition) (l : list reg) (n n0 : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : unit) (EQ1 : check_successor n0 = OK x0) (EQ2 : S.set_list e l (type_of_condition c) = OK e') : valid_successor f n.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (c : condition) (l : list reg) (n n0 : node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successor n = OK x) (x0 : unit) (EQ1 : check_successor n0 = OK x0) (EQ2 : S.set_list e l (type_of_condition c) = OK e') : valid_successor f n0.","proofString":"eauto with ty."},{"statement":"(e : S.typenv) (r : reg) (l : list node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successors l = OK x) (x0 : S.typenv) (EQ1 : S.set e r Tint = OK x0) (EQ2 : (if zle (list_length_z l * 4) Int.max_unsigned\n then OK x0\n else Error (msg \"jumptable too big\")) = OK e') : wt_instr f te (Ijumptable r l).","proofString":"destruct (zle (list_length_z l * 4) Int.max_unsigned); inv EQ2.\nconstructor.\neapply S.set_sound; eauto.\neapply check_successors_sound; eauto.\nauto."},{"statement":"(e : S.typenv) (r : reg) (l : list node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successors l = OK x) (EQ1 : S.set e r Tint = OK e') (l0 : list_length_z l * 4 <= Int.max_unsigned) : wt_instr f te (Ijumptable r l).","proofString":"constructor.\neapply S.set_sound; eauto.\neapply check_successors_sound; eauto.\nauto."},{"statement":"(e : S.typenv) (r : reg) (l : list node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successors l = OK x) (EQ1 : S.set e r Tint = OK e') (l0 : list_length_z l * 4 <= Int.max_unsigned) : te r = Tint.","proofString":"eapply S.set_sound; eauto."},{"statement":"(e : S.typenv) (r : reg) (l : list node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successors l = OK x) (EQ1 : S.set e r Tint = OK e') (l0 : list_length_z l * 4 <= Int.max_unsigned) : forall s : node, In s l -> valid_successor f s.","proofString":"eapply check_successors_sound; eauto."},{"statement":"(e : S.typenv) (r : reg) (l : list node) (e' : S.typenv) (te : S.typassign) (H0 : S.satisf te e') (x : unit) (EQ : check_successors l = OK x) (EQ1 : S.set e r Tint = OK e') (l0 : list_length_z l * 4 <= Int.max_unsigned) : list_length_z l * 4 <= Int.max_unsigned.","proofString":"auto."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (H : type_instr e (Ireturn o) = OK e') (H0 : S.satisf te e') : wt_instr f te (Ireturn o).","proofString":"simpl in H.\ndestruct o as [r|] eqn: RET; destruct (xtype_eq (sig_res (fn_sig f)) Xvoid); try discriminate.\neconstructor.\nauto.\neapply S.set_sound; eauto with ty.\neauto.\ninv H.\nconstructor.\nauto."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (H : match o with\n| Some r =>\n    if xtype_eq (sig_res (fn_sig f)) Xvoid\n    then Error (msg \"bad return\")\n    else S.set e r (proj_sig_res (fn_sig f))\n| None =>\n    if xtype_eq (sig_res (fn_sig f)) Xvoid\n    then OK e\n    else Error (msg \"bad return\")\nend = OK e') (H0 : S.satisf te e') : wt_instr f te (Ireturn o).","proofString":"destruct o as [r|] eqn: RET; destruct (xtype_eq (sig_res (fn_sig f)) Xvoid); try discriminate.\neconstructor.\nauto.\neapply S.set_sound; eauto with ty.\neauto.\ninv H.\nconstructor.\nauto."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (r : reg) (RET : o = Some r) (n : sig_res (fn_sig f) <> Xvoid) (H : S.set e r (proj_sig_res (fn_sig f)) = OK e') (H0 : S.satisf te e') : wt_instr f te (Ireturn (Some r)).","proofString":"econstructor.\nauto.\neapply S.set_sound; eauto with ty.\neauto."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (r : reg) (RET : o = Some r) (n : sig_res (fn_sig f) <> Xvoid) (H : S.set e r (proj_sig_res (fn_sig f)) = OK e') (H0 : S.satisf te e') : sig_res (fn_sig f) <> Xvoid.","proofString":"auto."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (r : reg) (RET : o = Some r) (n : sig_res (fn_sig f) <> Xvoid) (H : S.set e r (proj_sig_res (fn_sig f)) = OK e') (H0 : S.satisf te e') : te r = proj_sig_res (fn_sig f).","proofString":"eapply S.set_sound; eauto with ty."},{"statement":"(e : S.typenv) (o : option reg) (e' : S.typenv) (te : S.typassign) (RET : o = None) (e0 : sig_res (fn_sig f) = Xvoid) (H : OK e = OK e') (H0 : S.satisf te e') : wt_instr f te (Ireturn None).","proofString":"inv H.\nconstructor.\nauto."},{"statement":"(e' : S.typenv) (te : S.typassign) (e0 : sig_res (fn_sig f) = Xvoid) (H0 : S.satisf te e') : wt_instr f te (Ireturn None).","proofString":"constructor.\nauto."},{"statement":"(e' : S.typenv) (te : S.typassign) (e0 : sig_res (fn_sig f) = Xvoid) (H0 : S.satisf te e') : sig_res (fn_sig f) = Xvoid.","proofString":"auto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) : (fn_code f) ! pc = Some i -> S.satisf te e1 -> wt_instr f te i.","proofString":"set (P := fun c opte =>         match opte with         | Error _ => True         | OK e' => c!pc = Some i -> S.satisf te e' -> wt_instr f te i         end).\nchange (P f.(fn_code) (OK e1)).\nrewrite <- TCODE.\nunfold type_code.\napply PTree_Properties.fold_rec; unfold P; intros.\ndestruct a; auto; intros.\nrewrite <- H in H1.\neapply H0; eauto.\nrewrite PTree.gempty in H; discriminate.\ndestruct a as [e|?]; auto.\ndestruct (type_instr e v) as [e'|?] eqn:TYINSTR; auto.\nintros.\nrewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\neapply type_instr_sound; eauto.\neapply H1; eauto.\neapply type_instr_incr; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m m' : PTree.t instruction) (a : res S.typenv) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : match a with\n| OK e' => m ! pc = Some i -> S.satisf te e' -> wt_instr f te i\n| Error _ => True\nend) : match a with\n| OK e' => m' ! pc = Some i -> S.satisf te e' -> wt_instr f te i\n| Error _ => True\nend.","proofString":"destruct a; auto; intros.\nrewrite <- H in H1.\neapply H0; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m m' : PTree.t instruction) (t : S.typenv) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! pc = Some i -> S.satisf te t -> wt_instr f te i) (H1 : m' ! pc = Some i) (H2 : S.satisf te t) : wt_instr f te i.","proofString":"rewrite <- H in H1.\neapply H0; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m m' : PTree.t instruction) (t : S.typenv) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! pc = Some i -> S.satisf te t -> wt_instr f te i) (H1 : m ! pc = Some i) (H2 : S.satisf te t) : wt_instr f te i.","proofString":"eapply H0; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (H : (PTree.empty instruction) ! pc = Some i) (H0 : S.satisf te e0) : wt_instr f te i.","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (a : res S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : match a with\n| OK e' => m ! pc = Some i -> S.satisf te e' -> wt_instr f te i\n| Error _ => True\nend) : match\n  match a with\n  | OK e =>\n      match type_instr e v with\n      | OK e' => OK e'\n      | Error msg => Error (MSG \"At PC \" :: POS k :: MSG \": \" :: msg)\n      end\n  | Error _ => a\n  end\nwith\n| OK e' =>\n    (PTree.set k v m) ! pc = Some i -> S.satisf te e' -> wt_instr f te i\n| Error _ => True\nend.","proofString":"destruct a as [e|?]; auto.\ndestruct (type_instr e v) as [e'|?] eqn:TYINSTR; auto.\nintros.\nrewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\neapply type_instr_sound; eauto.\neapply H1; eauto.\neapply type_instr_incr; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> S.satisf te e -> wt_instr f te i) : match\n  match type_instr e v with\n  | OK e' => OK e'\n  | Error msg => Error (MSG \"At PC \" :: POS k :: MSG \": \" :: msg)\n  end\nwith\n| OK e' =>\n    (PTree.set k v m) ! pc = Some i -> S.satisf te e' -> wt_instr f te i\n| Error _ => True\nend.","proofString":"destruct (type_instr e v) as [e'|?] eqn:TYINSTR; auto.\nintros.\nrewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\neapply type_instr_sound; eauto.\neapply H1; eauto.\neapply type_instr_incr; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> S.satisf te e -> wt_instr f te i) (e' : S.typenv) (TYINSTR : type_instr e v = OK e') : (PTree.set k v m) ! pc = Some i -> S.satisf te e' -> wt_instr f te i.","proofString":"intros.\nrewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\neapply type_instr_sound; eauto.\neapply H1; eauto.\neapply type_instr_incr; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> S.satisf te e -> wt_instr f te i) (e' : S.typenv) (TYINSTR : type_instr e v = OK e') (H2 : (PTree.set k v m) ! pc = Some i) (H3 : S.satisf te e') : wt_instr f te i.","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\neapply type_instr_sound; eauto.\neapply H1; eauto.\neapply type_instr_incr; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> S.satisf te e -> wt_instr f te i) (e' : S.typenv) (TYINSTR : type_instr e v = OK e') (H2 : (if peq pc k then Some v else m ! pc) = Some i) (H3 : S.satisf te e') : wt_instr f te i.","proofString":"destruct (peq pc k).\ninv H2.\neapply type_instr_sound; eauto.\neapply H1; eauto.\neapply type_instr_incr; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> S.satisf te e -> wt_instr f te i) (e' : S.typenv) (TYINSTR : type_instr e v = OK e') (e2 : pc = k) (H2 : Some v = Some i) (H3 : S.satisf te e') : wt_instr f te i.","proofString":"inv H2.\neapply type_instr_sound; eauto."},{"statement":"(i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (k : PTree.elt) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (H : m ! k = None) (H0 : (fn_code f) ! k = Some i) (H1 : m ! k = Some i -> S.satisf te e -> wt_instr f te i) (e' : S.typenv) (TYINSTR : type_instr e i = OK e') (H3 : S.satisf te e') : wt_instr f te i.","proofString":"eapply type_instr_sound; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> S.satisf te e -> wt_instr f te i) (e' : S.typenv) (TYINSTR : type_instr e v = OK e') (n : pc <> k) (H2 : m ! pc = Some i) (H3 : S.satisf te e') : wt_instr f te i.","proofString":"eapply H1; eauto.\neapply type_instr_incr; eauto."},{"statement":"(pc : positive) (i : instruction) (e0 e1 : S.typenv) (te : S.typassign) (TCODE : type_code e0 = OK e1) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (e : S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> S.satisf te e -> wt_instr f te i) (e' : S.typenv) (TYINSTR : type_instr e v = OK e') (n : pc <> k) (H2 : m ! pc = Some i) (H3 : S.satisf te e') : S.satisf te e.","proofString":"eapply type_instr_incr; eauto."},{"statement":"(env : regenv) (H : (do e1 <- type_code S.initial;\n do e2 <- S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f));\n do te <- S.solve e2;\n do _ <- check_params_norepet (fn_params f);\n do _ <- check_successor (fn_entrypoint f); OK te) = \nOK env) : wt_function f env.","proofString":"monadInv H.\nassert (SAT0: S.satisf env x0) by (eapply S.solve_sound; eauto).\nassert (SAT1: S.satisf env x) by (eauto with ty).\nconstructor.\neapply S.set_list_sound; eauto.\nunfold check_params_norepet in EQ2.\ndestruct (list_norepet_dec Reg.eq (fn_params f)); inv EQ2; auto.\nintros.\neapply type_code_sound; eauto.\neauto with ty."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) : wt_function f env.","proofString":"assert (SAT0: S.satisf env x0) by (eapply S.solve_sound; eauto).\nassert (SAT1: S.satisf env x) by (eauto with ty).\nconstructor.\neapply S.set_list_sound; eauto.\nunfold check_params_norepet in EQ2.\ndestruct (list_norepet_dec Reg.eq (fn_params f)); inv EQ2; auto.\nintros.\neapply type_code_sound; eauto.\neauto with ty."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) : wt_function f env.","proofString":"assert (SAT1: S.satisf env x) by (eauto with ty).\nconstructor.\neapply S.set_list_sound; eauto.\nunfold check_params_norepet in EQ2.\ndestruct (list_norepet_dec Reg.eq (fn_params f)); inv EQ2; auto.\nintros.\neapply type_code_sound; eauto.\neauto with ty."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) (SAT1 : S.satisf env x) : wt_function f env.","proofString":"constructor.\neapply S.set_list_sound; eauto.\nunfold check_params_norepet in EQ2.\ndestruct (list_norepet_dec Reg.eq (fn_params f)); inv EQ2; auto.\nintros.\neapply type_code_sound; eauto.\neauto with ty."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) (SAT1 : S.satisf env x) : map env (fn_params f) = proj_sig_args (fn_sig f).","proofString":"eapply S.set_list_sound; eauto."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) (SAT1 : S.satisf env x) : list_norepet (fn_params f).","proofString":"unfold check_params_norepet in EQ2.\ndestruct (list_norepet_dec Reg.eq (fn_params f)); inv EQ2; auto."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : (if list_norepet_dec Reg.eq (fn_params f)\n then OK tt\n else Error (msg \"duplicate parameters\")) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) (SAT1 : S.satisf env x) : list_norepet (fn_params f).","proofString":"destruct (list_norepet_dec Reg.eq (fn_params f)); inv EQ2; auto."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) (SAT1 : S.satisf env x) : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f env instr.","proofString":"intros.\neapply type_code_sound; eauto."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) (SAT1 : S.satisf env x) (pc : positive) (instr : instruction) (H : (fn_code f) ! pc = Some instr) : wt_instr f env instr.","proofString":"eapply type_code_sound; eauto."},{"statement":"(env : regenv) (x : S.typenv) (EQ : type_code S.initial = OK x) (x0 : S.typenv) (EQ1 : S.set_list x (fn_params f) (proj_sig_args (fn_sig f)) = OK x0) (EQ0 : S.solve x0 = OK env) (x2 : unit) (EQ2 : check_params_norepet (fn_params f) = OK x2) (x3 : unit) (EQ3 : check_successor (fn_entrypoint f) = OK x3) (SAT0 : S.satisf env x0) (SAT1 : S.satisf env x) : valid_successor f (fn_entrypoint f).","proofString":"eauto with ty."},{"statement":"(te : S.typassign) (p : positive) (e : S.typenv) (H : S.satisf te e) (H0 : te p = Tptr) : exists e' : S.typenv, S.set e p Tptr = OK e' /\\ S.satisf te e'.","proofString":"eapply S.set_complete; eauto."},{"statement":"(te : S.typassign) (i : ident) (e : S.typenv) (H : S.satisf te e) (H0 : True) : exists e' : S.typenv, OK e = OK e' /\\ S.satisf te e'.","proofString":"exists e; auto."},{"statement":"(s : node) (H : exists i : instruction, (fn_code f) ! s = Some i) : match (fn_code f) ! s with\n| Some _ => OK tt\n| None => Error (MSG \"bad successor \" :: POS s :: nil)\nend = OK tt.","proofString":"destruct H as [i EQ]; rewrite EQ; auto."},{"statement":"(e : S.typenv) (ty : typ) : (if typ_eq ty ty then OK e else Error (msg \"unexpected type\")) = OK e.","proofString":"rewrite dec_eq_true; auto."},{"statement":"(te : S.typassign) (a : builtin_arg reg) (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv,\n  type_builtin_arg e a (type_of_builtin_arg te a) = OK e' /\\ S.satisf te e'.","proofString":"destruct a; simpl; try (exists e; split; [apply type_expect_complete|assumption]).\napply S.set_complete; auto."},{"statement":"(te : S.typassign) (x : reg) (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv, S.set e x (te x) = OK e' /\\ S.satisf te e'.","proofString":"apply S.set_complete; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv, OK e = OK e' /\\ S.satisf te e'.","proofString":"exists e; auto."},{"statement":"(te : S.typassign) (a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall e0 : S.typenv,\nS.satisf te e0 ->\nexists e' : S.typenv,\n  type_builtin_args e0 al (map (type_of_builtin_arg te) al) = OK e' /\\\n  S.satisf te e') (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv,\n  (do e1 <- type_builtin_arg e a (type_of_builtin_arg te a);\n   type_builtin_args e1 al (map (type_of_builtin_arg te) al)) = \n  OK e' /\\ S.satisf te e'.","proofString":"destruct (type_builtin_arg_complete te a e) as (e1 & A & B); auto.\ndestruct (IHal e1) as (e2 & C & D); auto.\nexists e2; split; auto.\nrewrite A.\nauto."},{"statement":"(te : S.typassign) (a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall e0 : S.typenv,\nS.satisf te e0 ->\nexists e' : S.typenv,\n  type_builtin_args e0 al (map (type_of_builtin_arg te) al) = OK e' /\\\n  S.satisf te e') (e : S.typenv) (H : S.satisf te e) (e1 : S.typenv) (A : type_builtin_arg e a (type_of_builtin_arg te a) = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do e0 <- type_builtin_arg e a (type_of_builtin_arg te a);\n   type_builtin_args e0 al (map (type_of_builtin_arg te) al)) = \n  OK e' /\\ S.satisf te e'.","proofString":"destruct (IHal e1) as (e2 & C & D); auto.\nexists e2; split; auto.\nrewrite A.\nauto."},{"statement":"(te : S.typassign) (a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall e0 : S.typenv,\nS.satisf te e0 ->\nexists e' : S.typenv,\n  type_builtin_args e0 al (map (type_of_builtin_arg te) al) = OK e' /\\\n  S.satisf te e') (e : S.typenv) (H : S.satisf te e) (e1 : S.typenv) (A : type_builtin_arg e a (type_of_builtin_arg te a) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_args e1 al (map (type_of_builtin_arg te) al) = OK e2) (D : S.satisf te e2) : exists e' : S.typenv,\n  (do e0 <- type_builtin_arg e a (type_of_builtin_arg te a);\n   type_builtin_args e0 al (map (type_of_builtin_arg te) al)) = \n  OK e' /\\ S.satisf te e'.","proofString":"exists e2; split; auto.\nrewrite A.\nauto."},{"statement":"(te : S.typassign) (a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall e0 : S.typenv,\nS.satisf te e0 ->\nexists e' : S.typenv,\n  type_builtin_args e0 al (map (type_of_builtin_arg te) al) = OK e' /\\\n  S.satisf te e') (e : S.typenv) (H : S.satisf te e) (e1 : S.typenv) (A : type_builtin_arg e a (type_of_builtin_arg te a) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_args e1 al (map (type_of_builtin_arg te) al) = OK e2) (D : S.satisf te e2) : (do e0 <- type_builtin_arg e a (type_of_builtin_arg te a);\n type_builtin_args e0 al (map (type_of_builtin_arg te) al)) = \nOK e2.","proofString":"rewrite A.\nauto."},{"statement":"(te : S.typassign) (a : builtin_arg reg) (al : list (builtin_arg reg)) (IHal : forall e0 : S.typenv,\nS.satisf te e0 ->\nexists e' : S.typenv,\n  type_builtin_args e0 al (map (type_of_builtin_arg te) al) = OK e' /\\\n  S.satisf te e') (e : S.typenv) (H : S.satisf te e) (e1 : S.typenv) (A : type_builtin_arg e a (type_of_builtin_arg te a) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_args e1 al (map (type_of_builtin_arg te) al) = OK e2) (D : S.satisf te e2) : (do e0 <- OK e1; type_builtin_args e0 al (map (type_of_builtin_arg te) al)) =\nOK e2.","proofString":"auto."},{"statement":"(te : S.typassign) (a : builtin_res reg) (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv,\n  type_builtin_res e a (type_of_builtin_res te a) = OK e' /\\ S.satisf te e'.","proofString":"destruct a; simpl.\napply S.set_complete; auto.\nexists e; auto.\nexists e; auto."},{"statement":"(te : S.typassign) (x : reg) (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv, S.set e x (te x) = OK e' /\\ S.satisf te e'.","proofString":"apply S.set_complete; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv, type_expect e Tint Tint = OK e' /\\ S.satisf te e'.","proofString":"exists e; auto."},{"statement":"(te : S.typassign) (a1 a2 : builtin_res reg) (e : S.typenv) (H : S.satisf te e) : exists e' : S.typenv, type_expect e Tint Tint = OK e' /\\ S.satisf te e'.","proofString":"exists e; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (s : node) (H0 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s; OK e) = OK e' /\\ S.satisf te e'.","proofString":"econstructor; split.\nrewrite check_successor_complete; simpl; eauto.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (r1 r : reg) (s : node) (H0 : te r = te r1) (H1 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s; do (_, e'0)<- S.move e r r1; OK e'0) = OK e' /\\\n  S.satisf te e'.","proofString":"exploit S.move_complete; eauto.\nintros (changed & e' & A & B).\nexists e'; split.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; auto.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (r1 r : reg) (s : node) (H0 : te r = te r1) (H1 : valid_successor f s) : (exists (changed : bool) (e' : S.typenv),\n   S.move e r r1 = OK (changed, e') /\\ S.satisf te e') ->\nexists e' : S.typenv,\n  (do _ <- check_successor s; do (_, e'0)<- S.move e r r1; OK e'0) = OK e' /\\\n  S.satisf te e'.","proofString":"intros (changed & e' & A & B).\nexists e'; split.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; auto.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (r1 r : reg) (s : node) (H0 : te r = te r1) (H1 : valid_successor f s) (changed : bool) (e' : S.typenv) (A : S.move e r r1 = OK (changed, e')) (B : S.satisf te e') : exists e'0 : S.typenv,\n  (do _ <- check_successor s; do (_, e'1)<- S.move e r r1; OK e'1) = OK e'0 /\\\n  S.satisf te e'0.","proofString":"exists e'; split.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; auto.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (r1 r : reg) (s : node) (H0 : te r = te r1) (H1 : valid_successor f s) (changed : bool) (e' : S.typenv) (A : S.move e r r1 = OK (changed, e')) (B : S.satisf te e') : (do _ <- check_successor s; do (_, e'0)<- S.move e r r1; OK e'0) = OK e'.","proofString":"rewrite check_successor_complete by auto; simpl.\nrewrite A; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (r1 r : reg) (s : node) (H0 : te r = te r1) (H1 : valid_successor f s) (changed : bool) (e' : S.typenv) (A : S.move e r r1 = OK (changed, e')) (B : S.satisf te e') : (do (_, e'0)<- S.move e r r1; OK e'0) = OK e'.","proofString":"rewrite A; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (r1 r : reg) (s : node) (H0 : te r = te r1) (H1 : valid_successor f s) (changed : bool) (e' : S.typenv) (A : S.move e r r1 = OK (changed, e')) (B : S.satisf te e') : S.satisf te e'.","proofString":"auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (H1 : map te args = fst (type_of_operation op)) (H2 : te res = snd (type_of_operation op)) (H3 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   if is_move op\n   then\n    match args with\n    | nil => Error (msg \"ill-formed move\")\n    | arg :: nil => do (_, e'0)<- S.move e res arg; OK e'0\n    | arg :: _ :: _ => Error (msg \"ill-formed move\")\n    end\n   else\n    let (targs, tres) := type_of_operation op in\n    do e1 <- S.set_list e args targs; S.set e1 res tres) = \n  OK e' /\\ S.satisf te e'.","proofString":"destruct (type_of_operation op) as [targ tres].\nsimpl in *.\nexploit S.set_list_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nreplace (is_move op) with false.\nrewrite A; simpl; rewrite C; auto.\ndestruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = fst (targ, tres)) (H2 : te res = snd (targ, tres)) (H3 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   if is_move op\n   then\n    match args with\n    | nil => Error (msg \"ill-formed move\")\n    | arg :: nil => do (_, e'0)<- S.move e res arg; OK e'0\n    | arg :: _ :: _ => Error (msg \"ill-formed move\")\n    end\n   else do e1 <- S.set_list e args targ; S.set e1 res tres) = \n  OK e' /\\ S.satisf te e'.","proofString":"simpl in *.\nexploit S.set_list_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nreplace (is_move op) with false.\nrewrite A; simpl; rewrite C; auto.\ndestruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = targ) (H2 : te res = tres) (H3 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   if is_move op\n   then\n    match args with\n    | nil => Error (msg \"ill-formed move\")\n    | arg :: nil => do (_, e'0)<- S.move e res arg; OK e'0\n    | arg :: _ :: _ => Error (msg \"ill-formed move\")\n    end\n   else do e1 <- S.set_list e args targ; S.set e1 res tres) = \n  OK e' /\\ S.satisf te e'.","proofString":"exploit S.set_list_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nreplace (is_move op) with false.\nrewrite A; simpl; rewrite C; auto.\ndestruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = targ) (H2 : te res = tres) (H3 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args targ = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   if is_move op\n   then\n    match args with\n    | nil => Error (msg \"ill-formed move\")\n    | arg :: nil => do (_, e'0)<- S.move e res arg; OK e'0\n    | arg :: _ :: _ => Error (msg \"ill-formed move\")\n    end\n   else do e0 <- S.set_list e args targ; S.set e0 res tres) = \n  OK e' /\\ S.satisf te e'.","proofString":"exploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nreplace (is_move op) with false.\nrewrite A; simpl; rewrite C; auto.\ndestruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = targ) (H2 : te res = tres) (H3 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args targ = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 res tres = OK e2) (D : S.satisf te e2) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   if is_move op\n   then\n    match args with\n    | nil => Error (msg \"ill-formed move\")\n    | arg :: nil => do (_, e'0)<- S.move e res arg; OK e'0\n    | arg :: _ :: _ => Error (msg \"ill-formed move\")\n    end\n   else do e0 <- S.set_list e args targ; S.set e0 res tres) = \n  OK e' /\\ S.satisf te e'.","proofString":"exists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nreplace (is_move op) with false.\nrewrite A; simpl; rewrite C; auto.\ndestruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = targ) (H2 : te res = tres) (H3 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args targ = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 res tres = OK e2) (D : S.satisf te e2) : (do _ <- check_successor s;\n if is_move op\n then\n  match args with\n  | nil => Error (msg \"ill-formed move\")\n  | arg :: nil => do (_, e')<- S.move e res arg; OK e'\n  | arg :: _ :: _ => Error (msg \"ill-formed move\")\n  end\n else do e0 <- S.set_list e args targ; S.set e0 res tres) = \nOK e2.","proofString":"rewrite check_successor_complete by auto; simpl.\nreplace (is_move op) with false.\nrewrite A; simpl; rewrite C; auto.\ndestruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = targ) (H2 : te res = tres) (H3 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args targ = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 res tres = OK e2) (D : S.satisf te e2) : (if is_move op\n then\n  match args with\n  | nil => Error (msg \"ill-formed move\")\n  | arg :: nil => do (_, e')<- S.move e res arg; OK e'\n  | arg :: _ :: _ => Error (msg \"ill-formed move\")\n  end\n else do e0 <- S.set_list e args targ; S.set e0 res tres) = \nOK e2.","proofString":"replace (is_move op) with false.\nrewrite A; simpl; rewrite C; auto.\ndestruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = targ) (H2 : te res = tres) (H3 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args targ = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 res tres = OK e2) (D : S.satisf te e2) : (do e0 <- S.set_list e args targ; S.set e0 res tres) = OK e2.","proofString":"rewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (op : operation) (args : list reg) (res : reg) (s : node) (H0 : op <> Omove) (targ : list typ) (tres : typ) (H1 : map te args = targ) (H2 : te res = tres) (H3 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args targ = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 res tres = OK e2) (D : S.satisf te e2) : false = is_move op.","proofString":"destruct op; reflexivity || congruence."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te dst = type_of_chunk chunk) (H2 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e1 <- S.set_list e args (type_of_addressing addr);\n   S.set e1 dst (type_of_chunk chunk)) = OK e' /\\ \n  S.satisf te e'.","proofString":"exploit S.set_list_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te dst = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <- S.set_list e args (type_of_addressing addr);\n   S.set e0 dst (type_of_chunk chunk)) = OK e' /\\ \n  S.satisf te e'.","proofString":"exploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te dst = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 dst (type_of_chunk chunk) = OK e2) (D : S.satisf te e2) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <- S.set_list e args (type_of_addressing addr);\n   S.set e0 dst (type_of_chunk chunk)) = OK e' /\\ \n  S.satisf te e'.","proofString":"exists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te dst = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 dst (type_of_chunk chunk) = OK e2) (D : S.satisf te e2) : (do _ <- check_successor s;\n do e0 <- S.set_list e args (type_of_addressing addr);\n S.set e0 dst (type_of_chunk chunk)) = OK e2.","proofString":"rewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te dst = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 dst (type_of_chunk chunk) = OK e2) (D : S.satisf te e2) : (do e0 <- S.set_list e args (type_of_addressing addr);\n S.set e0 dst (type_of_chunk chunk)) = OK e2.","proofString":"rewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te src = type_of_chunk chunk) (H2 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e1 <- S.set_list e args (type_of_addressing addr);\n   S.set e1 src (type_of_chunk chunk)) = OK e' /\\ \n  S.satisf te e'.","proofString":"exploit S.set_list_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te src = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <- S.set_list e args (type_of_addressing addr);\n   S.set e0 src (type_of_chunk chunk)) = OK e' /\\ \n  S.satisf te e'.","proofString":"exploit S.set_complete.\neexact B.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te src = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 src (type_of_chunk chunk) = OK e2) (D : S.satisf te e2) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <- S.set_list e args (type_of_addressing addr);\n   S.set e0 src (type_of_chunk chunk)) = OK e' /\\ \n  S.satisf te e'.","proofString":"exists e2; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te src = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 src (type_of_chunk chunk) = OK e2) (D : S.satisf te e2) : (do _ <- check_successor s;\n do e0 <- S.set_list e args (type_of_addressing addr);\n S.set e0 src (type_of_chunk chunk)) = OK e2.","proofString":"rewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (s : node) (H0 : map te args = type_of_addressing addr) (H1 : te src = type_of_chunk chunk) (H2 : valid_successor f s) (e1 : S.typenv) (A : S.set_list e args (type_of_addressing addr) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set e1 src (type_of_chunk chunk) = OK e2) (D : S.satisf te e2) : (do e0 <- S.set_list e args (type_of_addressing addr);\n S.set e0 src (type_of_chunk chunk)) = OK e2.","proofString":"rewrite A; simpl; rewrite C; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (res : reg) (s : node) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : te res = proj_sig_res sig) (H3 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e1 <- type_ros e ros;\n   do e2 <- S.set_list e1 args (proj_sig_args sig);\n   S.set e2 res (proj_sig_res sig)) = OK e' /\\ S.satisf te e'.","proofString":"exploit type_ros_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexploit S.set_list_complete.\neauto.\neauto.\nintros [e2 [C D]].\nexploit S.set_complete.\neexact D.\neauto.\nintros [e3 [E F]].\nexists e3; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; simpl; rewrite E; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (res : reg) (s : node) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : te res = proj_sig_res sig) (H3 : valid_successor f s) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <- type_ros e ros;\n   do e2 <- S.set_list e0 args (proj_sig_args sig);\n   S.set e2 res (proj_sig_res sig)) = OK e' /\\ S.satisf te e'.","proofString":"exploit S.set_list_complete.\neauto.\neauto.\nintros [e2 [C D]].\nexploit S.set_complete.\neexact D.\neauto.\nintros [e3 [E F]].\nexists e3; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; simpl; rewrite E; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (res : reg) (s : node) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : te res = proj_sig_res sig) (H3 : valid_successor f s) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <- type_ros e ros;\n   do e3 <- S.set_list e0 args (proj_sig_args sig);\n   S.set e3 res (proj_sig_res sig)) = OK e' /\\ S.satisf te e'.","proofString":"exploit S.set_complete.\neexact D.\neauto.\nintros [e3 [E F]].\nexists e3; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; simpl; rewrite E; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (res : reg) (s : node) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : te res = proj_sig_res sig) (H3 : valid_successor f s) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : S.set e2 res (proj_sig_res sig) = OK e3) (F : S.satisf te e3) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <- type_ros e ros;\n   do e4 <- S.set_list e0 args (proj_sig_args sig);\n   S.set e4 res (proj_sig_res sig)) = OK e' /\\ S.satisf te e'.","proofString":"exists e3; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; simpl; rewrite E; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (res : reg) (s : node) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : te res = proj_sig_res sig) (H3 : valid_successor f s) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : S.set e2 res (proj_sig_res sig) = OK e3) (F : S.satisf te e3) : (do _ <- check_successor s;\n do e0 <- type_ros e ros;\n do e4 <- S.set_list e0 args (proj_sig_args sig);\n S.set e4 res (proj_sig_res sig)) = OK e3.","proofString":"rewrite check_successor_complete by auto; simpl.\nrewrite A; simpl; rewrite C; simpl; rewrite E; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (res : reg) (s : node) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : te res = proj_sig_res sig) (H3 : valid_successor f s) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : S.set e2 res (proj_sig_res sig) = OK e3) (F : S.satisf te e3) : (do e0 <- type_ros e ros;\n do e4 <- S.set_list e0 args (proj_sig_args sig);\n S.set e4 res (proj_sig_res sig)) = OK e3.","proofString":"rewrite A; simpl; rewrite C; simpl; rewrite E; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) : exists e' : S.typenv,\n  (do e1 <- type_ros e ros;\n   do e2 <- S.set_list e1 args (proj_sig_args sig);\n   if xtype_eq (sig_res sig) (sig_res (fn_sig f))\n   then\n    if tailcall_is_possible sig\n    then OK e2\n    else Error (msg \"tailcall not possible\")\n   else Error (msg \"bad return type in tailcall\")) = \n  OK e' /\\ S.satisf te e'.","proofString":"exploit type_ros_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexploit S.set_list_complete.\neauto.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite A; simpl; rewrite C; simpl.\nrewrite H2; rewrite dec_eq_true.\nreplace (tailcall_is_possible sig) with true; auto.\nsymmetry.\nunfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do e0 <- type_ros e ros;\n   do e2 <- S.set_list e0 args (proj_sig_args sig);\n   if xtype_eq (sig_res sig) (sig_res (fn_sig f))\n   then\n    if tailcall_is_possible sig\n    then OK e2\n    else Error (msg \"tailcall not possible\")\n   else Error (msg \"bad return type in tailcall\")) = \n  OK e' /\\ S.satisf te e'.","proofString":"exploit S.set_list_complete.\neauto.\neauto.\nintros [e2 [C D]].\nexists e2; split; auto.\nrewrite A; simpl; rewrite C; simpl.\nrewrite H2; rewrite dec_eq_true.\nreplace (tailcall_is_possible sig) with true; auto.\nsymmetry.\nunfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : exists e' : S.typenv,\n  (do e0 <- type_ros e ros;\n   do e3 <- S.set_list e0 args (proj_sig_args sig);\n   if xtype_eq (sig_res sig) (sig_res (fn_sig f))\n   then\n    if tailcall_is_possible sig\n    then OK e3\n    else Error (msg \"tailcall not possible\")\n   else Error (msg \"bad return type in tailcall\")) = \n  OK e' /\\ S.satisf te e'.","proofString":"exists e2; split; auto.\nrewrite A; simpl; rewrite C; simpl.\nrewrite H2; rewrite dec_eq_true.\nreplace (tailcall_is_possible sig) with true; auto.\nsymmetry.\nunfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : (do e0 <- type_ros e ros;\n do e3 <- S.set_list e0 args (proj_sig_args sig);\n if xtype_eq (sig_res sig) (sig_res (fn_sig f))\n then\n  if tailcall_is_possible sig\n  then OK e3\n  else Error (msg \"tailcall not possible\")\n else Error (msg \"bad return type in tailcall\")) = \nOK e2.","proofString":"rewrite A; simpl; rewrite C; simpl.\nrewrite H2; rewrite dec_eq_true.\nreplace (tailcall_is_possible sig) with true; auto.\nsymmetry.\nunfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : (if xtype_eq (sig_res sig) (sig_res (fn_sig f))\n then\n  if tailcall_is_possible sig\n  then OK e2\n  else Error (msg \"tailcall not possible\")\n else Error (msg \"bad return type in tailcall\")) = \nOK e2.","proofString":"rewrite H2; rewrite dec_eq_true.\nreplace (tailcall_is_possible sig) with true; auto.\nsymmetry.\nunfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : (if tailcall_is_possible sig\n then OK e2\n else Error (msg \"tailcall not possible\")) = OK e2.","proofString":"replace (tailcall_is_possible sig) with true; auto.\nsymmetry.\nunfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : true = tailcall_is_possible sig.","proofString":"symmetry.\nunfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : tailcall_is_possible sig = true.","proofString":"unfold tailcall_is_possible.\napply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : forallb\n  (fun l : Locations.loc =>\n   match l with\n   | Locations.R _ => true\n   | Locations.S _ _ _ => false\n   end) (regs_of_rpairs (loc_arguments sig)) = true.","proofString":"apply forallb_forall.\nintros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) : forall x : Locations.loc,\nIn x (regs_of_rpairs (loc_arguments sig)) ->\nmatch x with\n| Locations.R _ => true\n| Locations.S _ _ _ => false\nend = true.","proofString":"intros.\napply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) (x : Locations.loc) (H4 : In x (regs_of_rpairs (loc_arguments sig))) : match x with\n| Locations.R _ => true\n| Locations.S _ _ _ => false\nend = true.","proofString":"apply H3 in H4.\ndestruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (sig : signature) (ros : reg + ident) (args : list reg) (H0 : match ros with\n| inl r => te r = Tptr\n| inr _ => True\nend) (H1 : map te args = proj_sig_args sig) (H2 : sig_res sig = sig_res (fn_sig f)) (H3 : tailcall_possible sig) (e1 : S.typenv) (A : type_ros e ros = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 args (proj_sig_args sig) = OK e2) (D : S.satisf te e2) (x : Locations.loc) (H4 : match x with\n| Locations.R _ => True\n| Locations.S _ _ _ => False\nend) : match x with\n| Locations.R _ => true\n| Locations.S _ _ _ => false\nend = true.","proofString":"destruct x; intuition auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e1 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e1 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"exploit type_builtin_args_complete; eauto.\ninstantiate (1 := args).\nintros [e1 [A B]].\nexploit type_builtin_res_complete; eauto.\ninstantiate (1 := res).\nintros [e2 [C D]].\nexploit type_builtin_res_complete.\neexact H.\ninstantiate (1 := res).\nintros [e3 [E F]].\nrewrite check_successor_complete by auto.\nsimpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) : (exists e' : S.typenv,\n   type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e' /\\\n   S.satisf te e') ->\nexists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e1 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e1 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"intros [e1 [A B]].\nexploit type_builtin_res_complete; eauto.\ninstantiate (1 := res).\nintros [e2 [C D]].\nexploit type_builtin_res_complete.\neexact H.\ninstantiate (1 := res).\nintros [e3 [E F]].\nrewrite check_successor_complete by auto.\nsimpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"exploit type_builtin_res_complete; eauto.\ninstantiate (1 := res).\nintros [e2 [C D]].\nexploit type_builtin_res_complete.\neexact H.\ninstantiate (1 := res).\nintros [e3 [E F]].\nrewrite check_successor_complete by auto.\nsimpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) : (exists e' : S.typenv,\n   type_builtin_res e1 res (type_of_builtin_res te res) = OK e' /\\\n   S.satisf te e') ->\nexists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"intros [e2 [C D]].\nexploit type_builtin_res_complete.\neexact H.\ninstantiate (1 := res).\nintros [e3 [E F]].\nrewrite check_successor_complete by auto.\nsimpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (type_of_builtin_res te res) = OK e2) (D : S.satisf te e2) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"exploit type_builtin_res_complete.\neexact H.\ninstantiate (1 := res).\nintros [e3 [E F]].\nrewrite check_successor_complete by auto.\nsimpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (type_of_builtin_res te res) = OK e2) (D : S.satisf te e2) : (exists e' : S.typenv,\n   type_builtin_res e res (type_of_builtin_res te res) = OK e' /\\\n   S.satisf te e') ->\nexists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"intros [e3 [E F]].\nrewrite check_successor_complete by auto.\nsimpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (type_of_builtin_res te res) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : type_builtin_res e res (type_of_builtin_res te res) = OK e3) (F : S.satisf te e3) : exists e' : S.typenv,\n  (do _ <- check_successor s;\n   do e0 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"rewrite check_successor_complete by auto.\nsimpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (type_of_builtin_res te res) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : type_builtin_res e res (type_of_builtin_res te res) = OK e3) (F : S.satisf te e3) : exists e' : S.typenv,\n  (do _ <- OK tt;\n   do e0 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"simpl.\nexists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (type_of_builtin_res te res) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : type_builtin_res e res (type_of_builtin_res te res) = OK e3) (F : S.satisf te e3) : exists e' : S.typenv,\n  (do e0 <-\n   match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n   | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n   end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) = \n  OK e' /\\ S.satisf te e'.","proofString":"exists (match ef with EF_annot _ _ _ | EF_debug _ _ _ => e3 | _ => e2 end); split.\nrewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto.\ndestruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (type_of_builtin_res te res) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : type_builtin_res e res (type_of_builtin_res te res) = OK e3) (F : S.satisf te e3) : (do e0 <-\n match ef with\n | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) =\nOK match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => e3\n   | _ => e2\n   end.","proofString":"rewrite H1 in C, E.\ndestruct ef; try (rewrite <- H0; rewrite A); simpl; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (proj_sig_res (ef_sig ef)) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : type_builtin_res e res (proj_sig_res (ef_sig ef)) = OK e3) (F : S.satisf te e3) : (do e0 <-\n match ef with\n | EF_annot _ _ _ | EF_debug _ _ _ => OK e\n | _ => type_builtin_args e args (proj_sig_args (ef_sig ef))\n end; type_builtin_res e0 res (proj_sig_res (ef_sig ef))) =\nOK match ef with\n   | EF_annot _ _ _ | EF_debug _ _ _ => e3\n   | _ => e2\n   end.","proofString":"destruct ef; try (rewrite <- H0; rewrite A); simpl; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (H0 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg te) args = proj_sig_args (ef_sig ef)\nend) (H1 : type_of_builtin_res te res = proj_sig_res (ef_sig ef)) (H2 : valid_successor f s) (e1 : S.typenv) (A : type_builtin_args e args (map (type_of_builtin_arg te) args) = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : type_builtin_res e1 res (type_of_builtin_res te res) = OK e2) (D : S.satisf te e2) (e3 : S.typenv) (E : type_builtin_res e res (type_of_builtin_res te res) = OK e3) (F : S.satisf te e3) : S.satisf te\n  match ef with\n  | EF_annot _ _ _ | EF_debug _ _ _ => e3\n  | _ => e2\n  end.","proofString":"destruct ef; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (cond : condition) (args : list reg) (s1 s2 : node) (H0 : map te args = type_of_condition cond) (H1 : valid_successor f s1) (H2 : valid_successor f s2) : exists e' : S.typenv,\n  (do _ <- check_successor s1;\n   do _ <- check_successor s2; S.set_list e args (type_of_condition cond)) =\n  OK e' /\\ S.satisf te e'.","proofString":"exploit S.set_list_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexists e1; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite check_successor_complete by auto; simpl.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (cond : condition) (args : list reg) (s1 s2 : node) (H0 : map te args = type_of_condition cond) (H1 : valid_successor f s1) (H2 : valid_successor f s2) (e1 : S.typenv) (A : S.set_list e args (type_of_condition cond) = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do _ <- check_successor s1;\n   do _ <- check_successor s2; S.set_list e args (type_of_condition cond)) =\n  OK e' /\\ S.satisf te e'.","proofString":"exists e1; split; auto.\nrewrite check_successor_complete by auto; simpl.\nrewrite check_successor_complete by auto; simpl.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (cond : condition) (args : list reg) (s1 s2 : node) (H0 : map te args = type_of_condition cond) (H1 : valid_successor f s1) (H2 : valid_successor f s2) (e1 : S.typenv) (A : S.set_list e args (type_of_condition cond) = OK e1) (B : S.satisf te e1) : (do _ <- check_successor s1;\n do _ <- check_successor s2; S.set_list e args (type_of_condition cond)) =\nOK e1.","proofString":"rewrite check_successor_complete by auto; simpl.\nrewrite check_successor_complete by auto; simpl.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (cond : condition) (args : list reg) (s1 s2 : node) (H0 : map te args = type_of_condition cond) (H1 : valid_successor f s1) (H2 : valid_successor f s2) (e1 : S.typenv) (A : S.set_list e args (type_of_condition cond) = OK e1) (B : S.satisf te e1) : (do _ <- check_successor s2; S.set_list e args (type_of_condition cond)) =\nOK e1.","proofString":"rewrite check_successor_complete by auto; simpl.\nauto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (cond : condition) (args : list reg) (s1 s2 : node) (H0 : map te args = type_of_condition cond) (H1 : valid_successor f s1) (H2 : valid_successor f s2) (e1 : S.typenv) (A : S.set_list e args (type_of_condition cond) = OK e1) (B : S.satisf te e1) : S.set_list e args (type_of_condition cond) = OK e1.","proofString":"auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H1 : forall s : node, In s tbl -> valid_successor f s) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) : exists e' : S.typenv,\n  (do _ <- check_successors tbl;\n   do e1 <- S.set e arg Tint;\n   if zle (list_length_z tbl * 4) Int.max_unsigned\n   then OK e1\n   else Error (msg \"jumptable too big\")) = OK e' /\\ \n  S.satisf te e'.","proofString":"exploit S.set_complete.\neauto.\neauto.\nintros [e1 [A B]].\nexists e1; split; auto.\nreplace (check_successors tbl) with (OK tt).\nsimpl.\nrewrite A; simpl.\napply zle_true; auto.\nrevert H1.\ngeneralize tbl.\ninduction tbl0; simpl; intros.\nauto.\nrewrite check_successor_complete by auto; simpl.\napply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H1 : forall s : node, In s tbl -> valid_successor f s) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : exists e' : S.typenv,\n  (do _ <- check_successors tbl;\n   do e0 <- S.set e arg Tint;\n   if zle (list_length_z tbl * 4) Int.max_unsigned\n   then OK e0\n   else Error (msg \"jumptable too big\")) = OK e' /\\ \n  S.satisf te e'.","proofString":"exists e1; split; auto.\nreplace (check_successors tbl) with (OK tt).\nsimpl.\nrewrite A; simpl.\napply zle_true; auto.\nrevert H1.\ngeneralize tbl.\ninduction tbl0; simpl; intros.\nauto.\nrewrite check_successor_complete by auto; simpl.\napply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H1 : forall s : node, In s tbl -> valid_successor f s) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : (do _ <- check_successors tbl;\n do e0 <- S.set e arg Tint;\n if zle (list_length_z tbl * 4) Int.max_unsigned\n then OK e0\n else Error (msg \"jumptable too big\")) = OK e1.","proofString":"replace (check_successors tbl) with (OK tt).\nsimpl.\nrewrite A; simpl.\napply zle_true; auto.\nrevert H1.\ngeneralize tbl.\ninduction tbl0; simpl; intros.\nauto.\nrewrite check_successor_complete by auto; simpl.\napply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H1 : forall s : node, In s tbl -> valid_successor f s) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : (do _ <- OK tt;\n do e0 <- S.set e arg Tint;\n if zle (list_length_z tbl * 4) Int.max_unsigned\n then OK e0\n else Error (msg \"jumptable too big\")) = OK e1.","proofString":"simpl.\nrewrite A; simpl.\napply zle_true; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H1 : forall s : node, In s tbl -> valid_successor f s) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : (do e0 <- S.set e arg Tint;\n if zle (list_length_z tbl * 4) Int.max_unsigned\n then OK e0\n else Error (msg \"jumptable too big\")) = OK e1.","proofString":"rewrite A; simpl.\napply zle_true; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H1 : forall s : node, In s tbl -> valid_successor f s) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : (if zle (list_length_z tbl * 4) Int.max_unsigned\n then OK e1\n else Error (msg \"jumptable too big\")) = OK e1.","proofString":"apply zle_true; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H1 : forall s : node, In s tbl -> valid_successor f s) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : OK tt = check_successors tbl.","proofString":"revert H1.\ngeneralize tbl.\ninduction tbl0; simpl; intros.\nauto.\nrewrite check_successor_complete by auto; simpl.\napply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : (forall s : node, In s tbl -> valid_successor f s) ->\nOK tt = check_successors tbl.","proofString":"generalize tbl.\ninduction tbl0; simpl; intros.\nauto.\nrewrite check_successor_complete by auto; simpl.\napply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) : forall tbl0 : list node,\n(forall s : node, In s tbl0 -> valid_successor f s) ->\nOK tt = check_successors tbl0.","proofString":"induction tbl0; simpl; intros.\nauto.\nrewrite check_successor_complete by auto; simpl.\napply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) (H1 : forall s : node, False -> valid_successor f s) : OK tt = OK tt.","proofString":"auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) (a : node) (tbl0 : list node) (IHtbl0 : (forall s : node, In s tbl0 -> valid_successor f s) ->\nOK tt = check_successors tbl0) (H1 : forall s : node, a = s \\/ In s tbl0 -> valid_successor f s) : OK tt = (do _ <- check_successor a; check_successors tbl0).","proofString":"rewrite check_successor_complete by auto; simpl.\napply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (tbl : list node) (H0 : te arg = Tint) (H2 : list_length_z tbl * 4 <= Int.max_unsigned) (e1 : S.typenv) (A : S.set e arg Tint = OK e1) (B : S.satisf te e1) (a : node) (tbl0 : list node) (IHtbl0 : (forall s : node, In s tbl0 -> valid_successor f s) ->\nOK tt = check_successors tbl0) (H1 : forall s : node, a = s \\/ In s tbl0 -> valid_successor f s) : OK tt = check_successors tbl0.","proofString":"apply IHtbl0; intros; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (H0 : sig_res (fn_sig f) = Xvoid) : exists e' : S.typenv,\n  (if xtype_eq (sig_res (fn_sig f)) Xvoid\n   then OK e\n   else Error (msg \"bad return\")) = OK e' /\\ S.satisf te e'.","proofString":"rewrite H0, dec_eq_true.\nexists e; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (H0 : sig_res (fn_sig f) = Xvoid) : exists e' : S.typenv, OK e = OK e' /\\ S.satisf te e'.","proofString":"exists e; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (ty : typ) (H0 : sig_res (fn_sig f) <> Xvoid) (H1 : te arg = proj_sig_res (fn_sig f)) (H2 : te arg = ty) : exists e' : S.typenv,\n  (if xtype_eq (sig_res (fn_sig f)) Xvoid\n   then Error (msg \"bad return\")\n   else S.set e arg (proj_sig_res (fn_sig f))) = OK e' /\\ \n  S.satisf te e'.","proofString":"rewrite dec_eq_false by auto.\napply S.set_complete; auto."},{"statement":"(te : S.typassign) (e : S.typenv) (H : S.satisf te e) (arg : reg) (ty : typ) (H0 : sig_res (fn_sig f) <> Xvoid) (H1 : te arg = proj_sig_res (fn_sig f)) (H2 : te arg = ty) : exists e' : S.typenv,\n  S.set e arg (proj_sig_res (fn_sig f)) = OK e' /\\ S.satisf te e'.","proofString":"apply S.set_complete; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) : exists e' : S.typenv, type_code e0 = OK e' /\\ S.satisf te e'.","proofString":"set (P := fun c res =>        (forall pc i, c!pc = Some i -> wt_instr f te i) ->        exists e', res = OK e' /\\ S.satisf te e').\nassert (P f.(fn_code) (type_code e0)).\nunfold type_code.\napply PTree_Properties.fold_rec; unfold P; intros.\napply H0.\nintros.\napply H1 with pc.\nrewrite <- H; auto.\nexists e0; auto.\ndestruct H1 as [e [A B]].\nintros.\napply H2 with pc.\nrewrite PTree.gso; auto.\ncongruence.\nsubst a.\ndestruct (type_instr_complete te e v) as [e' [C D]].\nauto.\napply H2 with k.\napply PTree.gss.\nexists e'; split; auto.\nrewrite C; auto.\napply H; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m m' : PTree.t instruction) (a : res S.typenv) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (forall (pc : positive) (i : instruction), m ! pc = Some i -> wt_instr f te i) ->\nexists e' : S.typenv, a = OK e' /\\ S.satisf te e') (H1 : forall (pc : positive) (i : instruction), m' ! pc = Some i -> wt_instr f te i) : exists e' : S.typenv, a = OK e' /\\ S.satisf te e'.","proofString":"apply H0.\nintros.\napply H1 with pc.\nrewrite <- H; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m m' : PTree.t instruction) (a : res S.typenv) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (forall (pc : positive) (i : instruction), m ! pc = Some i -> wt_instr f te i) ->\nexists e' : S.typenv, a = OK e' /\\ S.satisf te e') (H1 : forall (pc : positive) (i : instruction), m' ! pc = Some i -> wt_instr f te i) : forall (pc : positive) (i : instruction), m ! pc = Some i -> wt_instr f te i.","proofString":"intros.\napply H1 with pc.\nrewrite <- H; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc0 : positive) (instr : instruction),\n(fn_code f) ! pc0 = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m m' : PTree.t instruction) (a : res S.typenv) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (forall (pc0 : positive) (i0 : instruction),\n m ! pc0 = Some i0 -> wt_instr f te i0) ->\nexists e' : S.typenv, a = OK e' /\\ S.satisf te e') (H1 : forall (pc0 : positive) (i0 : instruction),\nm' ! pc0 = Some i0 -> wt_instr f te i0) (pc : positive) (i : instruction) (H2 : m ! pc = Some i) : wt_instr f te i.","proofString":"apply H1 with pc.\nrewrite <- H; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc0 : positive) (instr : instruction),\n(fn_code f) ! pc0 = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m m' : PTree.t instruction) (a : res S.typenv) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (forall (pc0 : positive) (i0 : instruction),\n m ! pc0 = Some i0 -> wt_instr f te i0) ->\nexists e' : S.typenv, a = OK e' /\\ S.satisf te e') (H1 : forall (pc0 : positive) (i0 : instruction),\nm' ! pc0 = Some i0 -> wt_instr f te i0) (pc : positive) (i : instruction) (H2 : m ! pc = Some i) : m' ! pc = Some i.","proofString":"rewrite <- H; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (H : forall (pc : positive) (i : instruction),\n(PTree.empty instruction) ! pc = Some i -> wt_instr f te i) : exists e' : S.typenv, OK e0 = OK e' /\\ S.satisf te e'.","proofString":"exists e0; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (a : res S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (forall (pc : positive) (i : instruction), m ! pc = Some i -> wt_instr f te i) ->\nexists e' : S.typenv, a = OK e' /\\ S.satisf te e') (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) : exists e' : S.typenv,\n  match a with\n  | OK e =>\n      match type_instr e v with\n      | OK e'0 => OK e'0\n      | Error msg => Error (MSG \"At PC \" :: POS k :: MSG \": \" :: msg)\n      end\n  | Error _ => a\n  end = OK e' /\\ S.satisf te e'.","proofString":"destruct H1 as [e [A B]].\nintros.\napply H2 with pc.\nrewrite PTree.gso; auto.\ncongruence.\nsubst a.\ndestruct (type_instr_complete te e v) as [e' [C D]].\nauto.\napply H2 with k.\napply PTree.gss.\nexists e'; split; auto.\nrewrite C; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (a : res S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) : forall (pc : positive) (i : instruction), m ! pc = Some i -> wt_instr f te i.","proofString":"intros.\napply H2 with pc.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc0 : positive) (instr : instruction),\n(fn_code f) ! pc0 = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (a : res S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc0 : positive) (i0 : instruction),\n(PTree.set k v m) ! pc0 = Some i0 -> wt_instr f te i0) (pc : positive) (i : instruction) (H1 : m ! pc = Some i) : wt_instr f te i.","proofString":"apply H2 with pc.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc0 : positive) (instr : instruction),\n(fn_code f) ! pc0 = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (a : res S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc0 : positive) (i0 : instruction),\n(PTree.set k v m) ! pc0 = Some i0 -> wt_instr f te i0) (pc : positive) (i : instruction) (H1 : m ! pc = Some i) : (PTree.set k v m) ! pc = Some i.","proofString":"rewrite PTree.gso; auto.\ncongruence."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc0 : positive) (instr : instruction),\n(fn_code f) ! pc0 = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (a : res S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc0 : positive) (i0 : instruction),\n(PTree.set k v m) ! pc0 = Some i0 -> wt_instr f te i0) (pc : positive) (i : instruction) (H1 : m ! pc = Some i) : pc <> k.","proofString":"congruence."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (a : res S.typenv) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) (e : S.typenv) (A : a = OK e) (B : S.satisf te e) : exists e' : S.typenv,\n  match a with\n  | OK e1 =>\n      match type_instr e1 v with\n      | OK e'0 => OK e'0\n      | Error msg => Error (MSG \"At PC \" :: POS k :: MSG \": \" :: msg)\n      end\n  | Error _ => a\n  end = OK e' /\\ S.satisf te e'.","proofString":"subst a.\ndestruct (type_instr_complete te e v) as [e' [C D]].\nauto.\napply H2 with k.\napply PTree.gss.\nexists e'; split; auto.\nrewrite C; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) (e : S.typenv) (B : S.satisf te e) : exists e' : S.typenv,\n  match type_instr e v with\n  | OK e'0 => OK e'0\n  | Error msg => Error (MSG \"At PC \" :: POS k :: MSG \": \" :: msg)\n  end = OK e' /\\ S.satisf te e'.","proofString":"destruct (type_instr_complete te e v) as [e' [C D]].\nauto.\napply H2 with k.\napply PTree.gss.\nexists e'; split; auto.\nrewrite C; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) (e : S.typenv) (B : S.satisf te e) : S.satisf te e.","proofString":"auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) (e : S.typenv) (B : S.satisf te e) : wt_instr f te v.","proofString":"apply H2 with k.\napply PTree.gss."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) (e : S.typenv) (B : S.satisf te e) : (PTree.set k v m) ! k = Some v.","proofString":"apply PTree.gss."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) (e : S.typenv) (B : S.satisf te e) (e' : S.typenv) (C : type_instr e v = OK e') (D : S.satisf te e') : exists e'0 : S.typenv,\n  match type_instr e v with\n  | OK e'1 => OK e'1\n  | Error msg => Error (MSG \"At PC \" :: POS k :: MSG \": \" :: msg)\n  end = OK e'0 /\\ S.satisf te e'0.","proofString":"exists e'; split; auto.\nrewrite C; auto."},{"statement":"(te : regenv) (e0 : S.typenv) (WTC : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (SAT0 : S.satisf te e0) (P : PTree.tree instruction -> res S.typenv -> Prop) (m : PTree.t instruction) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H2 : forall (pc : positive) (i : instruction),\n(PTree.set k v m) ! pc = Some i -> wt_instr f te i) (e : S.typenv) (B : S.satisf te e) (e' : S.typenv) (C : type_instr e v = OK e') (D : S.satisf te e') : match type_instr e v with\n| OK e'0 => OK e'0\n| Error msg => Error (MSG \"At PC \" :: POS k :: MSG \": \" :: msg)\nend = OK e'.","proofString":"rewrite C; auto."},{"statement":"(te : regenv) (H : wt_function f te) : exists te0 : regenv, type_function = OK te0.","proofString":"destruct H.\ndestruct (type_code_complete te S.initial) as (e1 & A & B).\nauto.\napply S.satisf_initial.\ndestruct (S.set_list_complete te f.(fn_params) (proj_sig_args f.(fn_sig)) e1) as (e2 & C & D); auto.\ndestruct (S.solve_complete te e2) as (te' & E); auto.\nexists te'; unfold type_function.\nrewrite A; simpl.\nrewrite C; simpl.\nrewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : exists te0 : regenv, type_function = OK te0.","proofString":"destruct (type_code_complete te S.initial) as (e1 & A & B).\nauto.\napply S.satisf_initial.\ndestruct (S.set_list_complete te f.(fn_params) (proj_sig_args f.(fn_sig)) e1) as (e2 & C & D); auto.\ndestruct (S.solve_complete te e2) as (te' & E); auto.\nexists te'; unfold type_function.\nrewrite A; simpl.\nrewrite C; simpl.\nrewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr.","proofString":"auto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : S.satisf te S.initial.","proofString":"apply S.satisf_initial."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) : exists te0 : regenv, type_function = OK te0.","proofString":"destruct (S.set_list_complete te f.(fn_params) (proj_sig_args f.(fn_sig)) e1) as (e2 & C & D); auto.\ndestruct (S.solve_complete te e2) as (te' & E); auto.\nexists te'; unfold type_function.\nrewrite A; simpl.\nrewrite C; simpl.\nrewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) : exists te0 : regenv, type_function = OK te0.","proofString":"destruct (S.solve_complete te e2) as (te' & E); auto.\nexists te'; unfold type_function.\nrewrite A; simpl.\nrewrite C; simpl.\nrewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : exists te0 : regenv, type_function = OK te0.","proofString":"exists te'; unfold type_function.\nrewrite A; simpl.\nrewrite C; simpl.\nrewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do e0 <- type_code S.initial;\n do e3 <- S.set_list e0 (fn_params f) (proj_sig_args (fn_sig f));\n do te0 <- S.solve e3;\n do _ <- check_params_norepet (fn_params f);\n do _ <- check_successor (fn_entrypoint f); OK te0) = \nOK te'.","proofString":"rewrite A; simpl.\nrewrite C; simpl.\nrewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do e0 <- S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f));\n do te0 <- S.solve e0;\n do _ <- check_params_norepet (fn_params f);\n do _ <- check_successor (fn_entrypoint f); OK te0) = \nOK te'.","proofString":"rewrite C; simpl.\nrewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do te0 <- S.solve e2;\n do _ <- check_params_norepet (fn_params f);\n do _ <- check_successor (fn_entrypoint f); OK te0) = \nOK te'.","proofString":"rewrite E; simpl.\nunfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do _ <- check_params_norepet (fn_params f);\n do _ <- check_successor (fn_entrypoint f); OK te') = \nOK te'.","proofString":"unfold check_params_norepet.\nrewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do _ <-\n (if list_norepet_dec Reg.eq (fn_params f)\n  then OK tt\n  else Error (msg \"duplicate parameters\"));\n do _ <- check_successor (fn_entrypoint f); OK te') = \nOK te'.","proofString":"rewrite pred_dec_true; auto.\nsimpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do _ <- OK tt; do _ <- check_successor (fn_entrypoint f); OK te') = OK te'.","proofString":"simpl.\nrewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do _ <- check_successor (fn_entrypoint f); OK te') = OK te'.","proofString":"rewrite check_successor_complete by auto.\nauto."},{"statement":"(te : regenv) (wt_params0 : map te (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f te instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) (e1 : S.typenv) (A : type_code S.initial = OK e1) (B : S.satisf te e1) (e2 : S.typenv) (C : S.set_list e1 (fn_params f) (proj_sig_args (fn_sig f)) = OK e2) (D : S.satisf te e2) (te' : S.typassign) (E : S.solve e2 = OK te') : (do _ <- OK tt; OK te') = OK te'.","proofString":"auto."},{"statement":"(env : regenv) (rs : regset) (v : val) (r : reg) (H : wt_regset env rs) (H0 : Val.has_type v (env r)) (r0 : positive) : Val.has_type (rs # r <- v) # r0 (env r0).","proofString":"rewrite Regmap.gsspec.\ncase (peq r0 r); intro.\nsubst r0.\nassumption.\napply H."},{"statement":"(env : regenv) (rs : regset) (v : val) (r : reg) (H : wt_regset env rs) (H0 : Val.has_type v (env r)) (r0 : positive) : Val.has_type (if peq r0 r then v else rs # r0) (env r0).","proofString":"case (peq r0 r); intro.\nsubst r0.\nassumption.\napply H."},{"statement":"(env : regenv) (rs : regset) (v : val) (r : reg) (H : wt_regset env rs) (H0 : Val.has_type v (env r)) (r0 : positive) (e : r0 = r) : Val.has_type v (env r0).","proofString":"subst r0.\nassumption."},{"statement":"(env : regenv) (rs : regset) (v : val) (r : reg) (H : wt_regset env rs) (H0 : Val.has_type v (env r)) : Val.has_type v (env r).","proofString":"assumption."},{"statement":"(env : regenv) (rs : regset) (v : val) (r : reg) (H : wt_regset env rs) (H0 : Val.has_type v (env r)) (r0 : positive) (n : r0 <> r) : Val.has_type rs # r0 (env r0).","proofString":"apply H."},{"statement":"(env : regenv) (rs : regset) (H : wt_regset env rs) : True.","proofString":"auto."},{"statement":"(env : regenv) (rs : regset) (H : wt_regset env rs) (a : positive) (rl : list positive) (IHrl : Val.has_type_list rs ## rl (map env rl)) : Val.has_type rs # a (env a) /\\ Val.has_type_list rs ## rl (map env rl).","proofString":"split.\napply H.\napply IHrl."},{"statement":"(env : regenv) (rs : regset) (H : wt_regset env rs) (a : positive) (rl : list positive) (IHrl : Val.has_type_list rs ## rl (map env rl)) : Val.has_type rs # a (env a).","proofString":"apply H."},{"statement":"(env : regenv) (rs : regset) (H : wt_regset env rs) (a : positive) (rl : list positive) (IHrl : Val.has_type_list rs ## rl (map env rl)) : Val.has_type_list rs ## rl (map env rl).","proofString":"apply IHrl."},{"statement":"(env : regenv) (rs : regset) (v : val) (res : builtin_res reg) (H : wt_regset env rs) (H0 : Val.has_type v (type_of_builtin_res env res)) : wt_regset env (regmap_setres res v rs).","proofString":"destruct res; simpl in *; auto.\napply wt_regset_assign; auto."},{"statement":"(env : regenv) (rs : regset) (v : val) (x : reg) (H : wt_regset env rs) (H0 : Val.has_type v (env x)) : wt_regset env rs # x <- v.","proofString":"apply wt_regset_assign; auto."},{"statement":"(env : reg -> typ) (H : True) : wt_regset env (Regmap.init Vundef).","proofString":"red; intros.\nrewrite Regmap.gi.\nsimpl; auto."},{"statement":"(env : reg -> typ) (H : True) (r : positive) : Val.has_type (Regmap.init Vundef) # r (env r).","proofString":"rewrite Regmap.gi.\nsimpl; auto."},{"statement":"(env : reg -> typ) (H : True) (r : positive) : Val.has_type Vundef (env r).","proofString":"simpl; auto."},{"statement":"(env : reg -> typ) (a : reg) (rl : list reg) (IHrl : forall args0 : list val,\nVal.has_type_list args0 (map env rl) -> wt_regset env (init_regs args0 rl)) (v : val) (args : list val) (H0 : Val.has_type v (env a)) (H1 : Val.has_type_list args (map env rl)) : wt_regset env (init_regs args rl) # a <- v.","proofString":"apply wt_regset_assign; auto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (op : operation) (args : list reg) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (v : val) (H : wt_instr f env (Iop op args res s)) (H0 : eval_operation ge sp op rs ## args m = Some v) (H1 : wt_regset env rs) : wt_regset env rs # res <- v.","proofString":"inv H.\nsimpl in H0.\ninv H0.\napply wt_regset_assign; auto.\nrewrite H4; auto.\neapply wt_regset_assign; auto.\nrewrite H8.\neapply type_of_operation_sound; eauto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (v : val) (r1 : reg) (H0 : eval_operation ge sp Omove rs ## (r1 :: nil) m = Some v) (H1 : wt_regset env rs) (H4 : env res = env r1) (H7 : valid_successor f s) : wt_regset env rs # res <- v.","proofString":"simpl in H0.\ninv H0.\napply wt_regset_assign; auto.\nrewrite H4; auto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (v : val) (r1 : reg) (H0 : Some rs # r1 = Some v) (H1 : wt_regset env rs) (H4 : env res = env r1) (H7 : valid_successor f s) : wt_regset env rs # res <- v.","proofString":"inv H0.\napply wt_regset_assign; auto.\nrewrite H4; auto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (r1 : reg) (H1 : wt_regset env rs) (H4 : env res = env r1) (H7 : valid_successor f s) : wt_regset env rs # res <- (rs # r1).","proofString":"apply wt_regset_assign; auto.\nrewrite H4; auto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (r1 : reg) (H1 : wt_regset env rs) (H4 : env res = env r1) (H7 : valid_successor f s) : Val.has_type rs # r1 (env res).","proofString":"rewrite H4; auto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (op : operation) (args : list reg) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (v : val) (H0 : eval_operation ge sp op rs ## args m = Some v) (H1 : wt_regset env rs) (H6 : op <> Omove) (H7 : map env args = fst (type_of_operation op)) (H8 : env res = snd (type_of_operation op)) (H9 : valid_successor f s) : wt_regset env rs # res <- v.","proofString":"eapply wt_regset_assign; auto.\nrewrite H8.\neapply type_of_operation_sound; eauto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (op : operation) (args : list reg) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (v : val) (H0 : eval_operation ge sp op rs ## args m = Some v) (H1 : wt_regset env rs) (H6 : op <> Omove) (H7 : map env args = fst (type_of_operation op)) (H8 : env res = snd (type_of_operation op)) (H9 : valid_successor f s) : Val.has_type v (env res).","proofString":"rewrite H8.\neapply type_of_operation_sound; eauto."},{"statement":"(ge : genv) (env : regenv) (f : function) (sp : val) (op : operation) (args : list reg) (res : reg) (s : node) (rs : Regmap.t val) (m : mem) (v : val) (H0 : eval_operation ge sp op rs ## args m = Some v) (H1 : wt_regset env rs) (H6 : op <> Omove) (H7 : map env args = fst (type_of_operation op)) (H8 : env res = snd (type_of_operation op)) (H9 : valid_successor f s) : Val.has_type v (snd (type_of_operation op)).","proofString":"eapply type_of_operation_sound; eauto."},{"statement":"(env : regenv) (f : function) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (m : mem) (a v : val) (rs : regset) (H : wt_instr f env (Iload chunk addr args dst s)) (H0 : Mem.loadv chunk m a = Some v) (H1 : wt_regset env rs) : wt_regset env rs # dst <- v.","proofString":"destruct a; simpl in H0; try discriminate.\ninv H.\neapply wt_regset_assign; eauto.\nrewrite H8; eapply Mem.load_type; eauto."},{"statement":"(env : regenv) (f : function) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (m : mem) (b : block) (i : ptrofs) (v : val) (rs : regset) (H : wt_instr f env (Iload chunk addr args dst s)) (H0 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H1 : wt_regset env rs) : wt_regset env rs # dst <- v.","proofString":"inv H.\neapply wt_regset_assign; eauto.\nrewrite H8; eapply Mem.load_type; eauto."},{"statement":"(env : regenv) (f : function) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (m : mem) (b : block) (i : ptrofs) (v : val) (rs : regset) (H0 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H1 : wt_regset env rs) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk chunk) (H9 : valid_successor f s) : wt_regset env rs # dst <- v.","proofString":"eapply wt_regset_assign; eauto.\nrewrite H8; eapply Mem.load_type; eauto."},{"statement":"(env : regenv) (f : function) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (s : node) (m : mem) (b : block) (i : ptrofs) (v : val) (rs : regset) (H0 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H1 : wt_regset env rs) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk chunk) (H9 : valid_successor f s) : Val.has_type v (env dst).","proofString":"rewrite H8; eapply Mem.load_type; eauto."},{"statement":"(env : regenv) (f : function) (ef : external_function) (ge : genv) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (rs : regset) (H : wt_instr f env (Ibuiltin ef args res s)) (H0 : external_call ef ge vargs m t vres m') (H1 : wt_regset env rs) : wt_regset env (regmap_setres res vres rs).","proofString":"inv H.\neapply wt_regset_setres; eauto.\nrewrite H7.\neapply external_call_well_typed; eauto."},{"statement":"(env : regenv) (f : function) (ef : external_function) (ge : genv) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (rs : regset) (H0 : external_call ef ge vargs m t vres m') (H1 : wt_regset env rs) (H5 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg env) args = proj_sig_args (ef_sig ef)\nend) (H7 : type_of_builtin_res env res = proj_sig_res (ef_sig ef)) (H8 : valid_successor f s) : wt_regset env (regmap_setres res vres rs).","proofString":"eapply wt_regset_setres; eauto.\nrewrite H7.\neapply external_call_well_typed; eauto."},{"statement":"(env : regenv) (f : function) (ef : external_function) (ge : genv) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (rs : regset) (H0 : external_call ef ge vargs m t vres m') (H1 : wt_regset env rs) (H5 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg env) args = proj_sig_args (ef_sig ef)\nend) (H7 : type_of_builtin_res env res = proj_sig_res (ef_sig ef)) (H8 : valid_successor f s) : Val.has_type vres (type_of_builtin_res env res).","proofString":"rewrite H7.\neapply external_call_well_typed; eauto."},{"statement":"(env : regenv) (f : function) (ef : external_function) (ge : genv) (args : list (builtin_arg reg)) (res : builtin_res reg) (s : node) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (rs : regset) (H0 : external_call ef ge vargs m t vres m') (H1 : wt_regset env rs) (H5 : match ef with\n| EF_annot _ _ _ | EF_debug _ _ _ => True\n| _ => map (type_of_builtin_arg env) args = proj_sig_args (ef_sig ef)\nend) (H7 : type_of_builtin_res env res = proj_sig_res (ef_sig ef)) (H8 : valid_successor f s) : Val.has_type vres (proj_sig_res (ef_sig ef)).","proofString":"eapply external_call_well_typed; eauto."},{"statement":"(f : function) (env : regenv) (pc : positive) (i : instruction) (H : wt_function f env) (H0 : (fn_code f) ! pc = Some i) : wt_instr f env i.","proofString":"inv H.\neauto."},{"statement":"(f : function) (env : regenv) (pc : positive) (i : instruction) (H0 : (fn_code f) ! pc = Some i) (wt_params0 : map env (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc0 : positive) (instr : instruction),\n(fn_code f) ! pc0 = Some instr -> wt_instr f env instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : wt_instr f env i.","proofString":"eauto."},{"statement":"(s : list stackframe) (sg1 sg2 : signature) (H : sig_res sg1 = sig_res sg2) (H0 : wt_stackframes s sg1) : wt_stackframes s sg2.","proofString":"inv H0.\nconstructor; congruence.\neconstructor; eauto.\nrewrite H3.\nunfold proj_sig_res.\nrewrite H.\nauto."},{"statement":"(sg1 sg2 : signature) (H : sig_res sg1 = sig_res sg2) (H1 : sig_res sg1 = Xint) : wt_stackframes nil sg2.","proofString":"constructor; congruence."},{"statement":"(sg1 sg2 : signature) (H : sig_res sg1 = sig_res sg2) (s0 : list stackframe) (res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (env : regenv) (H1 : wt_function f env) (H2 : wt_regset env rs) (H3 : env res = proj_sig_res sg1) (H4 : wt_stackframes s0 (fn_sig f)) : wt_stackframes (Stackframe res f sp pc rs :: s0) sg2.","proofString":"econstructor; eauto.\nrewrite H3.\nunfold proj_sig_res.\nrewrite H.\nauto."},{"statement":"(sg1 sg2 : signature) (H : sig_res sg1 = sig_res sg2) (s0 : list stackframe) (res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (env : regenv) (H1 : wt_function f env) (H2 : wt_regset env rs) (H3 : env res = proj_sig_res sg1) (H4 : wt_stackframes s0 (fn_sig f)) : env res = proj_sig_res sg2.","proofString":"rewrite H3.\nunfold proj_sig_res.\nrewrite H.\nauto."},{"statement":"(sg1 sg2 : signature) (H : sig_res sg1 = sig_res sg2) (s0 : list stackframe) (res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (env : regenv) (H1 : wt_function f env) (H2 : wt_regset env rs) (H3 : env res = proj_sig_res sg1) (H4 : wt_stackframes s0 (fn_sig f)) : proj_sig_res sg1 = proj_sig_res sg2.","proofString":"unfold proj_sig_res.\nrewrite H.\nauto."},{"statement":"(sg1 sg2 : signature) (H : sig_res sg1 = sig_res sg2) (s0 : list stackframe) (res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (env : regenv) (H1 : wt_function f env) (H2 : wt_regset env rs) (H3 : env res = proj_sig_res sg1) (H4 : wt_stackframes s0 (fn_sig f)) : proj_xtype (sig_res sg1) = proj_xtype (sig_res sg2).","proofString":"rewrite H.\nauto."},{"statement":"(sg1 sg2 : signature) (H : sig_res sg1 = sig_res sg2) (s0 : list stackframe) (res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (env : regenv) (H1 : wt_function f env) (H2 : wt_regset env rs) (H3 : env res = proj_sig_res sg1) (H4 : wt_stackframes s0 (fn_sig f)) : proj_xtype (sig_res sg2) = proj_xtype (sig_res sg2).","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Inop pc')) : wt_state (State s f sp pc' rs m).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Iop op args res pc')) : wt_state (State s f sp pc' rs # res <- v m).","proofString":"econstructor; eauto.\neapply wt_exec_Iop; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Iop op args res pc')) : wt_regset env rs # res <- v.","proofString":"eapply wt_exec_Iop; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Iload chunk addr args dst pc')) : wt_state (State s f sp pc' rs # dst <- v m).","proofString":"econstructor; eauto.\neapply wt_exec_Iload; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Iload chunk addr args dst pc')) : wt_regset env rs # dst <- v.","proofString":"eapply wt_exec_Iload; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Istore chunk addr args src pc')) : wt_state (State s f sp pc' rs m').","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) ros args res pc')) : wt_state (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m).","proofString":"assert (wt_fundef fd).\ndestruct ros; simpl in H0.\npattern fd.\napply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0.\ncaseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.\npattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0.\ndiscriminate.\neconstructor; eauto.\neconstructor; eauto.\ninv WTI; auto.\ninv WTI.\nrewrite <- H8.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) ros args res pc')) : wt_fundef fd.","proofString":"destruct ros; simpl in H0.\npattern fd.\napply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0.\ncaseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.\npattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0.\ndiscriminate."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inl r) args res pc')) (H0 : Genv.find_funct ge rs # r = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inl r) args res pc')) : wt_fundef fd.","proofString":"pattern fd.\napply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inl r) args res pc')) (H0 : Genv.find_funct ge rs # r = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inl r) args res pc')) : (fun f0 : fundef => wt_fundef f0) fd.","proofString":"apply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inl r) args res pc')) (H0 : Genv.find_funct ge rs # r = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inl r) args res pc')) : forall (id : ident) (f0 : fundef),\nIn (id, Gfun f0) (prog_defs p) -> wt_fundef f0.","proofString":"exact wt_p."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inl r) args res pc')) (H0 : Genv.find_funct ge rs # r = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inl r) args res pc')) : Genv.find_funct (Genv.globalenv p) rs # r = Some fd.","proofString":"exact H0."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr i) args res pc')) (H0 : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inr i) args res pc')) : wt_fundef fd.","proofString":"caseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.\npattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0.\ndiscriminate."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr i) args res pc')) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inr i) args res pc')) (H1 : Genv.find_symbol ge i = Some b) : wt_fundef fd.","proofString":"pattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr i) args res pc')) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inr i) args res pc')) (H1 : Genv.find_symbol ge i = Some b) : (fun f0 : fundef => wt_fundef f0) fd.","proofString":"apply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr i) args res pc')) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inr i) args res pc')) (H1 : Genv.find_symbol ge i = Some b) : forall (id : ident) (f0 : fundef),\nIn (id, Gfun f0) (prog_defs p) -> wt_fundef f0.","proofString":"exact wt_p."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr i) args res pc')) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inr i) args res pc')) (H1 : Genv.find_symbol ge i = Some b) : Genv.find_funct_ptr (Genv.globalenv p) b = Some fd.","proofString":"exact H0."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr i) args res pc')) (H0 : None = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) (inr i) args res pc')) (H1 : Genv.find_symbol ge i = None) : wt_fundef fd.","proofString":"discriminate."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) ros args res pc')) (H1 : wt_fundef fd) : wt_state (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m).","proofString":"econstructor; eauto.\neconstructor; eauto.\ninv WTI; auto.\ninv WTI.\nrewrite <- H8.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) ros args res pc')) (H1 : wt_fundef fd) : wt_stackframes (Stackframe res f sp pc' rs :: s) (funsig fd).","proofString":"econstructor; eauto.\ninv WTI; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) ros args res pc')) (H1 : wt_fundef fd) : env res = proj_sig_res (funsig fd).","proofString":"inv WTI; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icall (funsig fd) ros args res pc')) (H1 : wt_fundef fd) : Val.has_type_list rs ## args (proj_sig_args (funsig fd)).","proofString":"inv WTI.\nrewrite <- H8.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H1 : wt_fundef fd) (H6 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H8 : map env args = proj_sig_args (funsig fd)) (H9 : env res = proj_sig_res (funsig fd)) (H10 : valid_successor f pc') : Val.has_type_list rs ## args (proj_sig_args (funsig fd)).","proofString":"rewrite <- H8.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H1 : wt_fundef fd) (H6 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H8 : map env args = proj_sig_args (funsig fd)) (H9 : env res = proj_sig_res (funsig fd)) (H10 : valid_successor f pc') : Val.has_type_list rs ## args (map env args).","proofString":"apply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H1 : wt_fundef fd) (H6 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H8 : map env args = proj_sig_args (funsig fd)) (H9 : env res = proj_sig_res (funsig fd)) (H10 : valid_successor f pc') : wt_regset env rs.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) ros args)) : wt_state (Callstate s fd rs ## args m').","proofString":"assert (wt_fundef fd).\ndestruct ros; simpl in H0.\npattern fd.\napply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0.\ncaseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.\npattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0.\ndiscriminate.\neconstructor; eauto.\ninv WTI.\napply wt_stackframes_change_sig with (fn_sig f); auto.\ninv WTI.\nrewrite <- H7.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) ros args)) : wt_fundef fd.","proofString":"destruct ros; simpl in H0.\npattern fd.\napply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0.\ncaseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.\npattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0.\ndiscriminate."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inl r) args)) (H0 : Genv.find_funct ge rs # r = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inl r) args)) : wt_fundef fd.","proofString":"pattern fd.\napply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inl r) args)) (H0 : Genv.find_funct ge rs # r = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inl r) args)) : (fun f0 : fundef => wt_fundef f0) fd.","proofString":"apply Genv.find_funct_prop with fundef unit p (rs#r).\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inl r) args)) (H0 : Genv.find_funct ge rs # r = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inl r) args)) : forall (id : ident) (f0 : fundef),\nIn (id, Gfun f0) (prog_defs p) -> wt_fundef f0.","proofString":"exact wt_p."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inl r) args)) (H0 : Genv.find_funct ge rs # r = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inl r) args)) : Genv.find_funct (Genv.globalenv p) rs # r = Some fd.","proofString":"exact H0."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr i) args)) (H0 : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inr i) args)) : wt_fundef fd.","proofString":"caseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.\npattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0.\ndiscriminate."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr i) args)) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inr i) args)) (H1 : Genv.find_symbol ge i = Some b) : wt_fundef fd.","proofString":"pattern fd.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr i) args)) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inr i) args)) (H1 : Genv.find_symbol ge i = Some b) : (fun f0 : fundef => wt_fundef f0) fd.","proofString":"apply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H0."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr i) args)) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inr i) args)) (H1 : Genv.find_symbol ge i = Some b) : forall (id : ident) (f0 : fundef),\nIn (id, Gfun f0) (prog_defs p) -> wt_fundef f0.","proofString":"exact wt_p."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr i) args)) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inr i) args)) (H1 : Genv.find_symbol ge i = Some b) : Genv.find_funct_ptr (Genv.globalenv p) b = Some fd.","proofString":"exact H0."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (i : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr i) args)) (H0 : None = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) (inr i) args)) (H1 : Genv.find_symbol ge i = None) : wt_fundef fd.","proofString":"discriminate."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) ros args)) (H1 : wt_fundef fd) : wt_state (Callstate s fd rs ## args m').","proofString":"econstructor; eauto.\ninv WTI.\napply wt_stackframes_change_sig with (fn_sig f); auto.\ninv WTI.\nrewrite <- H7.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) ros args)) (H1 : wt_fundef fd) : wt_stackframes s (funsig fd).","proofString":"inv WTI.\napply wt_stackframes_change_sig with (fn_sig f); auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H1 : wt_fundef fd) (H6 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args (funsig fd)) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) (H9 : tailcall_possible (funsig fd)) : wt_stackframes s (funsig fd).","proofString":"apply wt_stackframes_change_sig with (fn_sig f); auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Itailcall (funsig fd) ros args)) (H1 : wt_fundef fd) : Val.has_type_list rs ## args (proj_sig_args (funsig fd)).","proofString":"inv WTI.\nrewrite <- H7.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H1 : wt_fundef fd) (H6 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args (funsig fd)) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) (H9 : tailcall_possible (funsig fd)) : Val.has_type_list rs ## args (proj_sig_args (funsig fd)).","proofString":"rewrite <- H7.\napply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H1 : wt_fundef fd) (H6 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args (funsig fd)) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) (H9 : tailcall_possible (funsig fd)) : Val.has_type_list rs ## args (map env args).","proofString":"apply wt_regset_list.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H1 : wt_fundef fd) (H6 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args (funsig fd)) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) (H9 : tailcall_possible (funsig fd)) : wt_regset env rs.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Ibuiltin ef args res pc')) : wt_state (State s f sp pc' (regmap_setres res vres rs) m').","proofString":"econstructor; eauto.\neapply wt_exec_Ibuiltin; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Ibuiltin ef args res pc')) : wt_regset env (regmap_setres res vres rs).","proofString":"eapply wt_exec_Ibuiltin; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Icond cond args ifso ifnot)) : wt_state (State s f sp (if b then ifso else ifnot) rs m).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Ijumptable arg tbl)) : wt_state (State s f sp pc' rs m).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Ireturn or)) : wt_state (Returnstate s (regmap_optget or Vundef rs) m').","proofString":"econstructor; eauto.\ninv WTI; simpl.\nauto.\nrewrite <- H3.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (WTI : wt_instr f env (Ireturn or)) : Val.has_type (regmap_optget or Vundef rs) (proj_sig_res (fn_sig f)).","proofString":"inv WTI; simpl.\nauto.\nrewrite <- H3.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H2 : sig_res (fn_sig f) = Xvoid) : True.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H2 : sig_res (fn_sig f) <> Xvoid) (H3 : env arg = proj_sig_res (fn_sig f)) : Val.has_type rs # arg (proj_sig_res (fn_sig f)).","proofString":"rewrite <- H3.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) (H2 : sig_res (fn_sig f) <> Xvoid) (H3 : env arg = proj_sig_res (fn_sig f)) : Val.has_type rs # arg (env arg).","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (H4 : wt_stackframes s (funsig (Internal f))) (H6 : wt_fundef (Internal f)) (H7 : Val.has_type_list args (proj_sig_args (funsig (Internal f)))) : wt_state\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"simpl in *.\ninv H6.\neconstructor; eauto.\ninv H2.\napply wt_init_regs; auto.\nrewrite wt_params0.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (H4 : wt_stackframes s (fn_sig f)) (H6 : wt_fundef (Internal f)) (H7 : Val.has_type_list args (proj_sig_args (fn_sig f))) : wt_state\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"inv H6.\neconstructor; eauto.\ninv H2.\napply wt_init_regs; auto.\nrewrite wt_params0.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (H4 : wt_stackframes s (fn_sig f)) (H7 : Val.has_type_list args (proj_sig_args (fn_sig f))) (env : regenv) (H2 : wt_function f env) : wt_state\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"econstructor; eauto.\ninv H2.\napply wt_init_regs; auto.\nrewrite wt_params0.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (H4 : wt_stackframes s (fn_sig f)) (H7 : Val.has_type_list args (proj_sig_args (fn_sig f))) (env : regenv) (H2 : wt_function f env) : wt_regset env (init_regs args (fn_params f)).","proofString":"inv H2.\napply wt_init_regs; auto.\nrewrite wt_params0.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (H4 : wt_stackframes s (fn_sig f)) (H7 : Val.has_type_list args (proj_sig_args (fn_sig f))) (env : regenv) (wt_params0 : map env (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : wt_regset env (init_regs args (fn_params f)).","proofString":"apply wt_init_regs; auto.\nrewrite wt_params0.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (H4 : wt_stackframes s (fn_sig f)) (H7 : Val.has_type_list args (proj_sig_args (fn_sig f))) (env : regenv) (wt_params0 : map env (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : Val.has_type_list args (map env (fn_params f)).","proofString":"rewrite wt_params0.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (H4 : wt_stackframes s (fn_sig f)) (H7 : Val.has_type_list args (proj_sig_args (fn_sig f))) (env : regenv) (wt_params0 : map env (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc : positive) (instr : instruction),\n(fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : Val.has_type_list args (proj_sig_args (fn_sig f)).","proofString":"auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (H3 : wt_stackframes s (funsig (External ef))) (H5 : wt_fundef (External ef)) (H6 : Val.has_type_list args (proj_sig_args (funsig (External ef)))) : wt_state (Returnstate s res m').","proofString":"econstructor; eauto.\neapply external_call_well_typed; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (H3 : wt_stackframes s (funsig (External ef))) (H5 : wt_fundef (External ef)) (H6 : Val.has_type_list args (proj_sig_args (funsig (External ef)))) : Val.has_type res (proj_sig_res (funsig (External ef))).","proofString":"eapply external_call_well_typed; eauto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (sg : signature) (H1 : wt_stackframes (Stackframe res f sp pc rs :: s) sg) (H3 : Val.has_type vres (proj_sig_res sg)) : wt_state (State s f sp pc rs # res <- vres m).","proofString":"inv H1.\neconstructor; eauto.\napply wt_regset_assign; auto.\nrewrite H10; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (sg : signature) (H3 : Val.has_type vres (proj_sig_res sg)) (env : regenv) (H8 : wt_function f env) (H9 : wt_regset env rs) (H10 : env res = proj_sig_res sg) (H11 : wt_stackframes s (fn_sig f)) : wt_state (State s f sp pc rs # res <- vres m).","proofString":"econstructor; eauto.\napply wt_regset_assign; auto.\nrewrite H10; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (sg : signature) (H3 : Val.has_type vres (proj_sig_res sg)) (env : regenv) (H8 : wt_function f env) (H9 : wt_regset env rs) (H10 : env res = proj_sig_res sg) (H11 : wt_stackframes s (fn_sig f)) : wt_regset env rs # res <- vres.","proofString":"apply wt_regset_assign; auto.\nrewrite H10; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (sg : signature) (H3 : Val.has_type vres (proj_sig_res sg)) (env : regenv) (H8 : wt_function f env) (H9 : wt_regset env rs) (H10 : env res = proj_sig_res sg) (H11 : wt_stackframes s (fn_sig f)) : Val.has_type vres (env res).","proofString":"rewrite H10; auto."},{"statement":"(S : state) (H : initial_state p S) : wt_state S.","proofString":"inv H.\nconstructor.\nconstructor.\nrewrite H3; auto.\npattern f.\napply Genv.find_funct_ptr_prop with fundef unit p b.\nexact wt_p.\nexact H2.\nrewrite H3.\nconstructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : wt_stackframes nil (funsig f).","proofString":"constructor.\nrewrite H3; auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : sig_res (funsig f) = Xint.","proofString":"rewrite H3; auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : forall (id : ident) (f0 : fundef),\nIn (id, Gfun f0) (prog_defs p) -> wt_fundef f0.","proofString":"exact wt_p."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : Val.has_type_list nil (proj_sig_args (funsig f)).","proofString":"rewrite H3.\nconstructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : Val.has_type_list nil (proj_sig_args signature_main).","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (rs : regset) (m : mem) (i : instruction) (H : wt_state (State s f sp pc rs m)) (H0 : (fn_code f) ! pc = Some i) : exists env : regenv, wt_instr f env i /\\ wt_regset env rs.","proofString":"inv H.\nexists env; split; auto.\ninv WT_FN.\neauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (rs : regset) (m : mem) (i : instruction) (H0 : (fn_code f) ! pc = Some i) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) : exists env0 : regenv, wt_instr f env0 i /\\ wt_regset env0 rs.","proofString":"exists env; split; auto.\ninv WT_FN.\neauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (rs : regset) (m : mem) (i : instruction) (H0 : (fn_code f) ! pc = Some i) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_FN : wt_function f env) (WT_RS : wt_regset env rs) : wt_instr f env i.","proofString":"inv WT_FN.\neauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (rs : regset) (m : mem) (i : instruction) (H0 : (fn_code f) ! pc = Some i) (env : regenv) (WT_STK : wt_stackframes s (fn_sig f)) (WT_RS : wt_regset env rs) (wt_params0 : map env (fn_params f) = proj_sig_args (fn_sig f)) (wt_norepet0 : list_norepet (fn_params f)) (wt_instrs0 : forall (pc0 : positive) (instr : instruction),\n(fn_code f) ! pc0 = Some instr -> wt_instr f env instr) (wt_entrypoint0 : valid_successor f (fn_entrypoint f)) : wt_instr f env i.","proofString":"eauto."}]}