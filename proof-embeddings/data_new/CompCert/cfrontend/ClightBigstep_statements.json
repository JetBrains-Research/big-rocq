{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/ClightBigstep.v","fileSamples":[{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T) : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T.","conclusion":"forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T)","proofString":"assert (forall e le m s T f k,          execinf_stmt ge e le m s T ->          forever_N step_fe order ge tt (State f s k e le m) T).\ncofix CIH_STMT.\nintros.\ninv H.\neapply forever_N_plus.\napply plus_one.\neapply step_call; eauto.\neapply CIH_FUN.\neauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]].\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\napply star_one.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neapply step_ifthenelse with (b := b); eauto.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\nconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\neapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).\neapply plus_left.\nconstructor.\neapply star_right.\neexact A1.\ninv H1; inv B1; constructor; auto.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].\neapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H1; inv B1; constructor; auto.\neapply star_right.\neexact A2.\ninv B2.\nconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\neapply step_switch; eauto.\napply CIH_STMT; eauto.\ntraceEq.\nintros.\ninv H0.\neapply forever_N_plus.\neapply plus_one.\neconstructor; eauto.\napply H; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T) : forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T.","conclusion":"forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T)","proofString":"cofix CIH_STMT.\nintros.\ninv H.\neapply forever_N_plus.\napply plus_one.\neapply step_call; eauto.\neapply CIH_FUN.\neauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]].\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\napply star_one.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neapply step_ifthenelse with (b := b); eauto.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\nconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\neapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).\neapply plus_left.\nconstructor.\neapply star_right.\neexact A1.\ninv H1; inv B1; constructor; auto.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].\neapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H1; inv B1; constructor; auto.\neapply star_right.\neexact A2.\ninv B2.\nconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\neapply step_switch; eauto.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T) (CIH_STMT : forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T) : forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T.","conclusion":"forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T) (CIH_STMT : forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T)","proofString":"intros.\ninv H.\neapply forever_N_plus.\napply plus_one.\neapply step_call; eauto.\neapply CIH_FUN.\neauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]].\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\napply star_one.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neapply step_ifthenelse with (b := b); eauto.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\nconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\neapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).\neapply plus_left.\nconstructor.\neapply star_right.\neexact A1.\ninv H1; inv B1; constructor; auto.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].\neapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H1; inv B1; constructor; auto.\neapply star_right.\neexact A2.\ninv B2.\nconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\neapply step_switch; eauto.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s0 : statement)\n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s0 T0 ->\nforever_N step_fe order ge tt (State f0 s0 k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (s : statement) (T : traceinf) (f : function) (k : cont) (H : execinf_stmt ge e le m s T) : forever_N step_fe order ge tt (State f s k e le m) T.","conclusion":"forever_N step_fe order ge tt (State f s k e le m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s0 : statement)\n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s0 T0 ->\nforever_N step_fe order ge tt (State f0 s0 k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (s : statement) (T : traceinf) (f : function) (k : cont) (H : execinf_stmt ge e le m s T)","proofString":"inv H.\neapply forever_N_plus.\napply plus_one.\neapply step_call; eauto.\neapply CIH_FUN.\neauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]].\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\napply star_one.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one.\neapply step_ifthenelse with (b := b); eauto.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\nconstructor.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\neapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).\neapply plus_left.\nconstructor.\neapply star_right.\neexact A1.\ninv H1; inv B1; constructor; auto.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].\neapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H1; inv B1; constructor; auto.\neapply star_right.\neexact A2.\ninv B2.\nconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq.\neapply forever_N_plus.\neapply plus_one.\neapply step_switch; eauto.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f1 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f1 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (optid : option ident) (a : expr) (al : list expr) (vf : val) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vargs : list val) (f0 : fundef) (H0 : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H1 : eval_expr ge e le m a vf) (H2 : eval_exprlist ge e le m al tyargs vargs) (H3 : Genv.find_funct ge vf = Some f0) (H4 : type_of_fundef f0 = Tfunction tyargs tyres cconv) (H5 : evalinf_funcall ge m f0 vargs T) : forever_N step_fe order ge tt (State f (Scall optid a al) k e le m) T.","conclusion":"forever_N step_fe order ge tt (State f (Scall optid a al) k e le m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f1 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f1 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (optid : option ident) (a : expr) (al : list expr) (vf : val) (tyargs : list type) (tyres : type) (cconv : calling_convention) (vargs : list val) (f0 : fundef) (H0 : classify_fun (typeof a) = fun_case_f tyargs tyres cconv) (H1 : eval_expr ge e le m a vf) (H2 : eval_exprlist ge e le m al tyargs vargs) (H3 : Genv.find_funct ge vf = Some f0) (H4 : type_of_fundef f0 = Tfunction tyargs tyres cconv) (H5 : evalinf_funcall ge m f0 vargs T)","proofString":"eapply forever_N_plus.\napply plus_one.\neapply step_call; eauto.\neapply CIH_FUN.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (s1 s2 : statement) (H0 : execinf_stmt ge e le m s1 T) : forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m) T.","conclusion":"forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (s1 s2 : statement) (H0 : execinf_stmt ge e le m s1 T)","proofString":"eapply forever_N_plus.\napply plus_one.\neconstructor.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 Out_normal) (H1 : execinf_stmt ge e le1 m1 s2 t2) : forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m)\n  (t1 *** t2).","conclusion":"forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m)\n  (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 Out_normal) (H1 : execinf_stmt ge e le1 m1 s2 t2)","proofString":"destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]].\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\napply star_one.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 Out_normal) (H1 : execinf_stmt ge e le1 m1 s2 t2) (S1 : state) (A1 : star step_fe ge (State f s1 (Kseq s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kseq s2 k) Out_normal S1) : forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m)\n  (t1 *** t2).","conclusion":"forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m)\n  (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 Out_normal) (H1 : execinf_stmt ge e le1 m1 s2 t2) (S1 : state) (A1 : star step_fe ge (State f s1 (Kseq s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kseq s2 k) Out_normal S1)","proofString":"inv B1.\neapply forever_N_plus.\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\napply star_one.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 Out_normal) (H1 : execinf_stmt ge e le1 m1 s2 t2) (A1 : star step_fe ge (State f s1 (Kseq s2 k) e le m) t1\n  (State f Sskip (Kseq s2 k) e le1 m1)) : forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m)\n  (t1 *** t2).","conclusion":"forever_N step_fe order ge tt (State f (Ssequence s1 s2) k e le m)\n  (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 Out_normal) (H1 : execinf_stmt ge e le1 m1 s2 t2) (A1 : star step_fe ge (State f s1 (Kseq s2 k) e le m) t1\n  (State f Sskip (Kseq s2 k) e le1 m1))","proofString":"eapply forever_N_plus.\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\napply star_one.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (v1 : val) (b : bool) (H0 : eval_expr ge e le m a v1) (H1 : bool_val v1 (typeof a) m = Some b) (H2 : execinf_stmt ge e le m (if b then s1 else s2) T) : forever_N step_fe order ge tt (State f (Sifthenelse a s1 s2) k e le m) T.","conclusion":"forever_N step_fe order ge tt (State f (Sifthenelse a s1 s2) k e le m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (v1 : val) (b : bool) (H0 : eval_expr ge e le m a v1) (H1 : bool_val v1 (typeof a) m = Some b) (H2 : execinf_stmt ge e le m (if b then s1 else s2) T)","proofString":"eapply forever_N_plus.\napply plus_one.\neapply step_ifthenelse with (b := b); eauto.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (s1 s2 : statement) (H0 : execinf_stmt ge e le m s1 T) : forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m) T.","conclusion":"forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (s1 s2 : statement) (H0 : execinf_stmt ge e le m s1 T)","proofString":"eapply forever_N_plus.\neapply plus_one.\nconstructor.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : execinf_stmt ge e le1 m1 s2 t2) : forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m) (t1 *** t2).","conclusion":"forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : execinf_stmt ge e le1 m1 s2 t2)","proofString":"destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\neapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).\neapply plus_left.\nconstructor.\neapply star_right.\neexact A1.\ninv H1; inv B1; constructor; auto.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : execinf_stmt ge e le1 m1 s2 t2) (S1 : state) (A1 : star step_fe ge (State f s1 (Kloop1 s1 s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kloop1 s1 s2 k) out1 S1) : forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m) (t1 *** t2).","conclusion":"forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : execinf_stmt ge e le1 m1 s2 t2) (S1 : state) (A1 : star step_fe ge (State f s1 (Kloop1 s1 s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kloop1 s1 s2 k) out1 S1)","proofString":"eapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).\neapply plus_left.\nconstructor.\neapply star_right.\neexact A1.\ninv H1; inv B1; constructor; auto.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : trace) (le2 : temp_env) (m2 : mem) (t3 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : exec_stmt ge e le1 m1 s2 t2 le2 m2 Out_normal) (H3 : execinf_stmt ge e le2 m2 (Sloop s1 s2) t3) : forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m)\n  (t1 *** t2 *** t3).","conclusion":"forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m)\n  (t1 *** t2 *** t3)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : trace) (le2 : temp_env) (m2 : mem) (t3 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : exec_stmt ge e le1 m1 s2 t2 le2 m2 Out_normal) (H3 : execinf_stmt ge e le2 m2 (Sloop s1 s2) t3)","proofString":"destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].\neapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H1; inv B1; constructor; auto.\neapply star_right.\neexact A2.\ninv B2.\nconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : trace) (le2 : temp_env) (m2 : mem) (t3 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : exec_stmt ge e le1 m1 s2 t2 le2 m2 Out_normal) (H3 : execinf_stmt ge e le2 m2 (Sloop s1 s2) t3) (S1 : state) (A1 : star step_fe ge (State f s1 (Kloop1 s1 s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kloop1 s1 s2 k) out1 S1) : forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m)\n  (t1 *** t2 *** t3).","conclusion":"forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m)\n  (t1 *** t2 *** t3)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : trace) (le2 : temp_env) (m2 : mem) (t3 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : exec_stmt ge e le1 m1 s2 t2 le2 m2 Out_normal) (H3 : execinf_stmt ge e le2 m2 (Sloop s1 s2) t3) (S1 : state) (A1 : star step_fe ge (State f s1 (Kloop1 s1 s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kloop1 s1 s2 k) out1 S1)","proofString":"destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].\neapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H1; inv B1; constructor; auto.\neapply star_right.\neexact A2.\ninv B2.\nconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : trace) (le2 : temp_env) (m2 : mem) (t3 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : exec_stmt ge e le1 m1 s2 t2 le2 m2 Out_normal) (H3 : execinf_stmt ge e le2 m2 (Sloop s1 s2) t3) (S1 : state) (A1 : star step_fe ge (State f s1 (Kloop1 s1 s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kloop1 s1 s2 k) out1 S1) (S2 : state) (A2 : star step_fe ge (State f s2 (Kloop2 s1 s2 k) e le1 m1) t2 S2) (B2 : outcome_state_match e le2 m2 f (Kloop2 s1 s2 k) Out_normal S2) : forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m)\n  (t1 *** t2 *** t3).","conclusion":"forever_N step_fe order ge tt (State f (Sloop s1 s2) k e le m)\n  (t1 *** t2 *** t3)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T) (e : env) (le : temp_env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (le1 : temp_env) (m1 : mem) (out1 : outcome) (t2 : trace) (le2 : temp_env) (m2 : mem) (t3 : traceinf) (H0 : exec_stmt ge e le m s1 t1 le1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : exec_stmt ge e le1 m1 s2 t2 le2 m2 Out_normal) (H3 : execinf_stmt ge e le2 m2 (Sloop s1 s2) t3) (S1 : state) (A1 : star step_fe ge (State f s1 (Kloop1 s1 s2 k) e le m) t1 S1) (B1 : outcome_state_match e le1 m1 f (Kloop1 s1 s2 k) out1 S1) (S2 : state) (A2 : star step_fe ge (State f s2 (Kloop2 s1 s2 k) e le1 m1) t2 S2) (B2 : outcome_state_match e le2 m2 f (Kloop2 s1 s2 k) Out_normal S2)","proofString":"eapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).\neapply plus_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H1; inv B1; constructor; auto.\neapply star_right.\neexact A2.\ninv B2.\nconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (a : expr) (v : val) (n : Z) (sl : labeled_statements) (H0 : eval_expr ge e le m a v) (H1 : sem_switch_arg v (typeof a) = Some n) (H2 : execinf_stmt ge e le m (seq_of_labeled_statement (select_switch n sl)) T) : forever_N step_fe order ge tt (State f (Sswitch a sl) k e le m) T.","conclusion":"forever_N step_fe order ge tt (State f (Sswitch a sl) k e le m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_N step_fe order ge tt (Callstate fd args k0 m0) T0) (CIH_STMT : forall (e0 : env) (le0 : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le0 m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le0 m0) T0) (e : env) (le : temp_env) (m : mem) (T : traceinf) (f : function) (k : cont) (a : expr) (v : val) (n : Z) (sl : labeled_statements) (H0 : eval_expr ge e le m a v) (H1 : sem_switch_arg v (typeof a) = Some n) (H2 : execinf_stmt ge e le m (seq_of_labeled_statement (select_switch n sl)) T)","proofString":"eapply forever_N_plus.\neapply plus_one.\neapply step_switch; eauto.\napply CIH_STMT; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T) (H : forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T) : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T.","conclusion":"forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_N step_fe order ge tt (Callstate fd args k m) T) (H : forall (e : env) (le : temp_env) (m : mem) (s : statement) \n  (T : traceinf) (f : function) (k : cont),\nexecinf_stmt ge e le m s T ->\nforever_N step_fe order ge tt (State f s k e le m) T)","proofString":"intros.\ninv H0.\neapply forever_N_plus.\neapply plus_one.\neconstructor; eauto.\napply H; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args0 T0 ->\nforever_N step_fe order ge tt (Callstate fd0 args0 k0 m0) T0) (H : forall (e : env) (le : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f : function) (k0 : cont),\nexecinf_stmt ge e le m0 s T0 ->\nforever_N step_fe order ge tt (State f s k0 e le m0) T0) (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont) (H0 : evalinf_funcall ge m fd args T) : forever_N step_fe order ge tt (Callstate fd args k m) T.","conclusion":"forever_N step_fe order ge tt (Callstate fd args k m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args0 T0 ->\nforever_N step_fe order ge tt (Callstate fd0 args0 k0 m0) T0) (H : forall (e : env) (le : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f : function) (k0 : cont),\nexecinf_stmt ge e le m0 s T0 ->\nforever_N step_fe order ge tt (State f s k0 e le m0) T0) (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont) (H0 : evalinf_funcall ge m fd args T)","proofString":"inv H0.\neapply forever_N_plus.\neapply plus_one.\neconstructor; eauto.\napply H; eauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args0 T0 ->\nforever_N step_fe order ge tt (Callstate fd args0 k0 m0) T0) (H : forall (e0 : env) (le : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le m0) T0) (m : mem) (args : list val) (T : traceinf) (k : cont) (f : function) (e : env) (m1 : mem) (le1 : temp_env) (H1 : function_entry ge f args m e le1 m1) (H2 : execinf_stmt ge e le1 m1 (fn_body f) T) : forever_N step_fe order ge tt (Callstate (Internal f) args k m) T.","conclusion":"forever_N step_fe order ge tt (Callstate (Internal f) args k m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args0 T0 ->\nforever_N step_fe order ge tt (Callstate fd args0 k0 m0) T0) (H : forall (e0 : env) (le : temp_env) (m0 : mem) (s : statement) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge e0 le m0 s T0 ->\nforever_N step_fe order ge tt (State f0 s k0 e0 le m0) T0) (m : mem) (args : list val) (T : traceinf) (k : cont) (f : function) (e : env) (m1 : mem) (le1 : temp_env) (H1 : function_entry ge f args m e le1 m1) (H2 : execinf_stmt ge e le1 m1 (fn_body f) T)","proofString":"eapply forever_N_plus.\neapply plus_one.\neconstructor; eauto.\napply H; eauto.\ntraceEq."},{"statement":"(t : trace) (r : int) (H : bigstep_program_terminates prog t r) : exists s1 s2 : state,\n  initial_state prog s1 /\\\n  star step_fe (globalenv prog) s1 t s2 /\\ final_state s2 r.","conclusion":"exists s1 s2 : state,\n  initial_state prog s1 /\\\n  star step_fe (globalenv prog) s1 t s2 /\\ final_state s2 r","hypotheses":"(t : trace) (r : int) (H : bigstep_program_terminates prog t r)","proofString":"inv H.\neconstructor; econstructor.\nsplit.\neconstructor; eauto.\nsplit.\neapply eval_funcall_steps.\neauto.\nred; auto.\neconstructor."},{"statement":"(t : trace) (r : int) (b : block) (f : fundef) (m0 m1 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : eval_funcall ge0 m0 f nil t m1 (Vint r)) : is_call_cont Kstop.","conclusion":"is_call_cont Kstop","hypotheses":"(t : trace) (r : int) (b : block) (f : fundef) (m0 m1 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : eval_funcall ge0 m0 f nil t m1 (Vint r))","proofString":"red; auto."},{"statement":"(T : traceinf) (H : bigstep_program_diverges prog T) : exists s1 : state,\n  initial_state prog s1 /\\ forever step_fe (globalenv prog) s1 T.","conclusion":"exists s1 : state,\n  initial_state prog s1 /\\ forever step_fe (globalenv prog) s1 T","hypotheses":"(T : traceinf) (H : bigstep_program_diverges prog T)","proofString":"inv H.\neconstructor.\nsplit.\neconstructor; eauto.\neapply forever_N_forever with (order := order).\nred; intros.\nconstructor; intros.\nred in H.\nelim H.\neapply evalinf_funcall_forever; eauto."},{"statement":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T) : well_founded order.","conclusion":"well_founded order","hypotheses":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T)","proofString":"red; intros.\nconstructor; intros.\nred in H.\nelim H."},{"statement":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T) (a : unit) : Acc order a.","conclusion":"Acc order a","hypotheses":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T) (a : unit)","proofString":"constructor; intros.\nred in H.\nelim H."},{"statement":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T) (a y : unit) (H : order y a) : Acc order y.","conclusion":"Acc order y","hypotheses":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T) (a y : unit) (H : order y a)","proofString":"red in H.\nelim H."},{"statement":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T) (a y : unit) (H : False) : Acc order y.","conclusion":"Acc order y","hypotheses":"(T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge0 m0 f nil T) (a y : unit) (H : False)","proofString":"elim H."}]}