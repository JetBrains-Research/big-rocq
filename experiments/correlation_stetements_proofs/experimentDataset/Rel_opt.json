[{"statement":"Lemma non_rmw_w_rel : (sb \\ rmw) ⨾ ⦗W ∩₁ Rel⦘ ⊆ sb^? ⨾ ⦗F∩₁Rel⦘ ⨾ sb.","proof":"unfolder; ins; desc.\nassert( (sb^? ⨾ ⦗F∩₁Rel⦘ ⨾ sb ∪ rmw) x y).\napply W_REL; basic_solver.\nclear W_REL.\nunfolder in *; desf; eauto 10.\n"},{"statement":"Lemma Rel_eq : Rel' ≡₁  Rel \\₁ W∩₁Rel.","proof":"unfold G', relax_release_labels, is_rel, is_w, Events.mod; ins.\nunfolder; splits; ins; desf.\nall: try (split; eauto; intro; desf; eauto).\nall: tauto.\n"},{"statement":"Lemma F_eq : F' ≡₁ F.","proof":"unfold G', relax_release_labels; type_solver 22.\n"},{"statement":"Lemma W_eq : W' ≡₁ W.","proof":"unfold G', relax_release_labels; type_solver 22.\n"},{"statement":"Lemma W_ex_acq_eq : W_ex_acq' ≡₁ W_ex_acq.","proof":"unfold G', relax_release_labels.\nunfold Execution.W_ex; mode_unfolder; ins; unfold xmod; basic_solver 22.\n"},{"statement":"Lemma R_ex_eq : R_ex' ≡₁ R_ex.","proof":"unfold G', relax_release_labels; type_solver.\n"},{"statement":"Lemma R_eq : R' ≡₁ R.","proof":"unfold G', relax_release_labels; type_solver 22.\n"},{"statement":"Lemma R_Acq_eq: R ∩₁ Acq' ≡₁ R ∩₁ Acq.","proof":"unfold G', relax_release_labels; ins.\nunfolder; ins; split; ins; desf; splits; eauto.\nall: type_unfolder; mode_unfolder; unfold Events.mod in *.\nall: by destruct (lab x); eauto; exfalso.\n"},{"statement":"Lemma FR_Acq_eq: FR ∩₁ Acq' ≡₁ FR ∩₁ Acq.","proof":"unfold G', relax_release_labels; ins.\nall: unfolder; ins; split; ins; desf; splits; eauto.\nall: type_unfolder; mode_unfolder; unfold Events.mod in *.\nall: by destruct (lab x); eauto; exfalso.\n"},{"statement":"Lemma F_AcqRel_eq : F ∩₁ Acq/Rel' ≡₁  F ∩₁ Acq/Rel.","proof":"unfold G', relax_release_labels, is_f, is_ra, is_rel, is_acq, Events.mod; ins.\nunfolder; ins; split; ins; desf; splits; eauto.\n"},{"statement":"Lemma F_Rel_eq : F'∩₁Rel' ≡₁ F∩₁Rel.","proof":"rewrite Rel_eq.\nrewrite F_eq.\nsplit; [basic_solver|].\nunfolder.\nins.\ndesf.\nsplits; auto.\nintros HH.\ntype_solver.\n"},{"statement":"Lemma FR_Rel_eq : FR'∩₁Rel' ≡₁ FR∩₁Rel.","proof":"rewrite Rel_eq.\nrewrite F_eq, R_eq.\nsplit; [basic_solver|].\nunfolder.\nins.\ndesf; splits; auto.\nall: intros HH; type_solver.\n"},{"statement":"Lemma F_Sc_eq : F'∩₁Sc' ≡₁  F∩₁Sc.","proof":"unfold G', relax_release_labels, is_f, is_sc, Events.mod; ins.\nunfolder; ins; split; ins; desf; splits; eauto.\n"},{"statement":"Lemma Acq_or_W_eq : Acq'∪₁W' ≡₁ Acq∪₁W.","proof":"arewrite (Acq'∪₁W' ≡₁ (FR'∩₁Acq')∪₁W').\n{\nsplit; [|basic_solver].\nunionL; [|eauto with hahn].\ntype_solver 10.\n}\narewrite (Acq∪₁W ≡₁ (FR∩₁Acq)∪₁W).\n{\nsplit; [|basic_solver].\nunionL; [|eauto with hahn].\ntype_solver 10.\n}\nrewrite <- FR_Acq_eq, <- R_eq, <- F_eq, <- W_eq.\ndone.\n"},{"statement":"Lemma same_loc_eq : same_loc' ≡ same_loc.","proof":"unfold G', relax_release_labels, Events.same_loc, Events.loc; ins.\ntype_solver 22.\n"},{"statement":"Lemma E_eq : E' ≡₁ E.","proof":"unfold G'; unfold acts_set; ins; basic_solver.\n"},{"statement":"Lemma sb_eq : sb' ≡ sb.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma rf_eq : rf' ≡ rf.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma rmw_eq : rmw' ≡ rmw.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma co_eq : co' ≡ co.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma fr_eq : fr' ≡ fr.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma eco_eq : eco' ≡ eco.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma data_eq : data' ≡ data.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma addr_eq : addr' ≡ addr.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma ctrl_eq : ctrl' ≡ ctrl.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma rfe_eq : rfe' ≡ rfe.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma rfi_eq : rfi' ≡ rfi.","proof":"by unfold G'; ins.\n"},{"statement":"Lemma W_ex_eq : W_ex' ≡₁ W_ex.","proof":"unfold G', relax_release_labels; type_solver 22.\n"},{"statement":"Lemma bob_eq : bob ⊆ bob'⁺ ∪ rmw' ∪ ⦗W ∩₁ Rel⦘ ⨾ sb' ∩ same_loc' ⨾ ⦗W'⦘.","proof":"unfold imm_bob.bob, imm_bob.fwbob.\nrewrite F_eq, R_eq, W_eq, Rel_eq, sb_eq, F_AcqRel_eq, R_Acq_eq, same_loc_eq.\nunionL.\n- rewrite W_REL; unionL.\n* arewrite (⦗F ∩₁ Rel⦘ ⊆ ⦗F ∩₁ Acq/Rel⦘) by mode_solver.\ncase_refl _.\nby unionR left -> left; unfolder; econs; eauto.\nunionR left -> left.\nunfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20.\n* rewrite rmw_eq; basic_solver.\n- basic_solver 12.\n- unionR left -> left; unfolder; ins; eapply t_step; basic_solver 12.\n- unionR left -> left; unfolder; ins; eapply t_step; basic_solver 12.\n- unionR left -> left; unfolder; ins; eapply t_step; basic_solver 12.\n"},{"statement":"Lemma ppo_eq: ppo' ≡ ppo.","proof":"unfold imm_ppo.ppo, Execution.rfi.\nby rewrite W_eq, R_eq, sb_eq, data_eq, addr_eq, ctrl_eq, rf_eq, R_ex_eq.\n"},{"statement":"Lemma detour_eq: detour' ≡ detour.","proof":"unfold Execution.detour; ie_unfolder.\nby rewrite sb_eq, rf_eq, co_eq.\n"},{"statement":"Lemma rs_eq : rs' ≡ rs.","proof":"by unfold imm_hb.rs; rewrite W_eq, same_loc_eq, sb_eq, rf_eq, rmw_eq.\n"},{"statement":"Lemma rmw_release_eq WF WFp: rmw ⨾ release ⊆ rmw' ⨾ rs'.","proof":"unfold imm_hb.release.\nrewrite (dom_r (wf_rmwD WF)), !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\nby type_solver.\nrewrite rmw_eq.\nrewrite rs_eq.\nbasic_solver.\n"},{"statement":"Lemma non_rmw_release_eq WF WFp: (sb \\ rmw) ⨾ release ⊆ sb'^? ⨾ release'.","proof":"rewrite (dom_l (wf_releaseD WF)).\nrewrite (dom_l (wf_releaseD WFp)).\nunfold imm_hb.release; rewrite sb_eq, rs_eq, F_eq, Rel_eq, W_eq.\narewrite (⦗FW ∩₁ Rel⦘ ⨾ ⦗Rel⦘ ≡ ⦗F ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘) by basic_solver 12.\narewrite (⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ≡ ⦗F ∩₁ Rel⦘).\n{\nunfolder; split; ins; desf; splits; eauto.\ntauto.\nintro; unfold is_w, is_f in *; desf.\nintro; unfold is_w, is_f in *; desf.\n}\nrelsf.\narewrite (⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗W ∩₁ Rel⦘) by type_solver 12.\nsin_rewrite non_rmw_w_rel; basic_solver 22.\n"},{"statement":"Lemma F_release_eq WF: ⦗F⦘ ⨾ release ⊆ release'.","proof":"unfold imm_hb.release; rewrite sb_eq, rs_eq, F_eq, Rel_eq.\nrewrite (dom_l (wf_rsD WF)).\ncase_refl _; [type_solver 12|].\narewrite (⦗F⦘ ⨾ ⦗Rel⦘ ⊆ ⦗Rel \\₁ W ∩₁ Rel⦘).\nby unfolder; ins; desf; splits; eauto; intro; desf; type_solver.\nbasic_solver 12.\n"},{"statement":"Lemma sw_eq_helper WF: \n  (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ \n  ⊆ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾  (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proof":"rewrite sb_eq, rfi_eq, rfe_eq, F_eq, same_loc_eq.\narewrite ((rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗R⦘).\nrewrite (dom_r (wf_rfeD WF)) at 1.\nrewrite (dom_r (wf_rfiD WF)) at 1.\nbasic_solver 12.\narewrite (⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆ ⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾  ⦗FR∩₁Acq⦘) by basic_solver 21.\nrewrite <- FR_Acq_eq; basic_solver 42.\n"},{"statement":"Lemma F_sw_eq WF: ⦗F⦘ ⨾ sw ⊆ sw'.","proof":"unfold imm_hb.sw.\nsin_rewrite (F_release_eq WF).\nby sin_rewrite (sw_eq_helper WF).\n"},{"statement":"Lemma rmw_sw_eq WF WFp: rmw ⨾ sw ⊆ rmw' ⨾ rs' ⨾  (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proof":"unfold imm_hb.sw.\nsin_rewrite !(rmw_release_eq WF WFp).\nsin_rewrite (sw_eq_helper WF).\nby relsf; rewrite !seqA.\n"},{"statement":"Lemma non_rmw_sw_eq WF WFp: (sb \\ rmw) ⨾ sw ⊆ sb'^? ⨾ sw'.","proof":"unfold imm_hb.sw.\nsin_rewrite !(non_rmw_release_eq WF WFp).\nsin_rewrite (sw_eq_helper WF).\nby relsf; rewrite !seqA.\n"},{"statement":"Lemma hb_eq1 WF WFp: \n  hb ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proof":"unfold imm_hb.hb at 1.\napply inclusion_t_ind_left.\nunionL.\n- rewrite <- sb_eq.\nunfold imm_hb.hb.\nrewrite <- ct_step.\nbasic_solver.\n- rewrite (dom_l (wf_swD WF)) at 1.\nunfold imm_hb.hb.\nrewrite <- ct_step.\ngeneralize (F_sw_eq WF).\nbasic_solver 21.\n- relsf; unionL.\n* rewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\n* rewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12.\n* arewrite (sb ⊆ rmw ∪ (sb \\ rmw)) by unfolder; ins; tauto.\nrelsf; unionL.\nbasic_solver 12.\narewrite_id ⦗W⦘; rels.\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12.\n* arewrite (sb ⨾ rmw ⊆ (sb \\ rmw)).\nrewrite (rmw_in_sb WF) at 1.\nunfolder; ins; desc; splits.\neapply (@sb_trans G); eauto.\nintro A; apply (wf_rmwi WF) in A.\nby red in A; desc; eapply (A0 z).\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12.\n* by rewrite (dom_r (wf_swD WF)) at 1; type_solver 12.\n* sin_rewrite (sw_rmw_sw WF).\nrewrite <- sb_eq, sb_in_hb.\nrewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12.\n"},{"statement":"Lemma psc_eq WF WFp SC_PER_LOC COMP COHp COMPp: \n  psc ⊆ psc'.","proof":"unfold imm.psc.\nrewrite (hb_eq1 WF WFp) at 1 2.\narewrite (⦗F ∩₁ Sc⦘ ⨾ (hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?) ⊆ ⦗F ∩₁ Sc⦘ ⨾ hb').\n{\nrewrite (dom_l (wf_rmwD WFp)).\ntype_solver 12.\n}\nset (X:= ⦗W⦘ ∪ rmw).\nrewrite F_Sc_eq.\nrelsf; unionL; [by rewrite eco_eq|].\nunfold X; clear X.\nsin_rewrite !(sw_in_sb_eco_sb WF SC_PER_LOC).\nrewrite !seqA.\narewrite ((⦗W⦘ ∪ rmw)  ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⊆ ⦗W⦘ ∪ rmw).\n{\nrewrite (dom_r (wf_rmwD WF)).\ntype_solver 12.\n}\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq.\nunfold imm_hb.hb.\narewrite (sb' ⊆ (sb' ∪ sw')) at 1; rels.\narewrite_id ⦗F ∩₁ Acq⦘.\nrelsf.\narewrite ((⦗W⦘ ∪ rmw) ⊆ eco^?).\n{\nrewrite (rmw_in_fr WF SC_PER_LOC COMP), fr_in_eco.\nbasic_solver.\n}\ngeneralize (eco_trans WF); ins; relsf.\narewrite (eco ⨾ hb'^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ eco ⨾ hb' ⨾ ⦗F ∩₁ Sc⦘).\n2: done.\nrewrite (dom_r (wf_ecoD WF)) at 1.\ntype_solver 12.\n"},{"statement":"Lemma psc_f_eq WF WFp SC_PER_LOC COMP COHp COMPp: \n  psc_f ⊆ psc_f'.","proof":"unfold imm.psc_f at 1.\nrewrite crE.\nrewrite !seq_union_l, !seq_union_r, seq_id_l, !seqA.\nunionL.\n2: {\nassert (psc' ⊆ psc_f') as HH.\n2: {\nrewrite <- HH.\nby apply psc_eq.\n}\nunfold imm.psc_f, imm.psc.\nassert (eco' ⨾ hb' ⊆ (eco' ⨾ hb')^?) as HH.\n2: by sin_rewrite HH.\neauto with hahn.\n}\nrewrite (hb_eq1 WF WFp).\narewrite (⦗F ∩₁ Sc⦘ ⨾ (hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?) ⊆ ⦗F ∩₁ Sc⦘ ⨾ hb').\n{\nrewrite (dom_l (wf_rmwD WFp)).\ntype_solver 12.\n}\nunfold imm.psc_f.\nrewrite F_Sc_eq.\nbasic_solver 10.\n"},{"statement":"Lemma wf_eq: Wf G' -> Wf G.","proof":"intros WF.\ndestruct WF.\neexists; rewrite <- ?sb_eq, <- ?W_eq, <- ?R_eq, <- ?same_loc_eq, <- ?R_ex_eq; try done.\n- clear -wf_rfv.\nunfold G', relax_release_labels, Events.val, funeq in *; intros a b H.\napply wf_rfv in H; destruct a,b; ins; desf.\n- ins.\nrewrite <- W_eq, <- E_eq.\narewrite ((fun x : actid => loc x = ol) ⊆₁ (fun x : actid => loc' x = ol)).\nunfolder; ins.\nunfold relax_release_labels, Events.loc in *; ins; destruct x; desf.\ndone.\n- clear -wf_init.\nintros l B; specialize (wf_init l); desc.\napply wf_init; eexists; splits; eauto.\nunfold G', relax_release_labels, Events.loc in *; ins; destruct b; ins; desf.\n- clear -wf_init_lab.\nintros l; specialize (wf_init_lab l).\nunfold G', relax_release_labels in *; ins; desf.\n"},{"statement":"Lemma complete_eq: complete G' -> complete G.","proof":"by unfold complete; rewrite E_eq, R_eq, rf_eq.\n"},{"statement":"Lemma sc_per_loc_eq: sc_per_loc G' -> sc_per_loc G.","proof":"by unfold sc_per_loc; rewrite sb_eq, eco_eq.\n"},{"statement":"Lemma coherence_eq WF SC_PER_LOC COMP WFp COMPp: coherence G' -> coherence G.","proof":"unfold coherence; intro COHp.\nrewrite <- eco_eq.\nrewrite (hb_eq1 WF WFp), (rmw_in_fr WFp (coherence_sc_per_loc COHp) COMPp).\nsin_rewrite !(sw_in_sb_eco_sb WF SC_PER_LOC).\nrewrite fr_in_eco.\nrewrite !seqA.\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\n- rewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\n- rewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\n"},{"statement":"Lemma acyc_ext_eq WF WFp SC_PER_LOC COMP COHp COMPp: acyc_ext G' -> acyc_ext G.","proof":"unfold acyc_ext.\nintros HH.\nunfold ar, ar_int in *.\nrewrite (psc_eq WF WFp SC_PER_LOC COMP COHp COMPp).\nrewrite <- ppo_eq.\nrewrite <- rfe_eq.\nrewrite <- detour_eq.\nrewrite bob_eq.\nrewrite <- sb_eq.\nrewrite <- W_ex_acq_eq.\nrewrite <- W_eq at 2.\nrewrite <- rfi_eq.\nrewrite <- W_ex_eq.\nrewrite <- R_Acq_eq.\nrewrite <- R_eq.\nrewrite (rmw_in_ppo WFp) at 1.\napply acyclic_mon with (r:= psc' ∪ ppo' ∪ rfe' ∪ detour'  ∪ ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘ ∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘  ∪ bob'⁺ ∪ ⦗W ∩₁ Rel⦘ ⨾ sb' ∩ same_loc' ⨾ ⦗W'⦘).\n2: basic_solver 30.\napply acyclic_union1.\n- red.\nrewrite ct_of_union_ct_r; eapply acyclic_mon; [edone|].\nbasic_solver 12.\n- apply acyclic_mon with (r:=sb').\nred; generalize (@sb_trans G'); ins; relsf; apply (@sb_irr G').\nbasic_solver.\n- arewrite (sb' ∩ same_loc' ⊆ sb').\nassert (transitive (⦗W ∩₁ Rel⦘ ⨾ sb' ⨾ ⦗W'⦘)).\n{\napply transitiveI; rewrite !seqA.\narewrite_id (⦗W'⦘ ⨾ ⦗W ∩₁ Rel⦘).\nbasic_solver.\nrelsf.\narewrite (sb' ⨾ sb' ⊆ sb').\napply transitiveI, (@sb_trans G').\ndone.\n}\nrelsf.\nrewrite ct_of_union_ct_r.\nrewrite ct_end, !seqA.\narewrite ((psc' ∪ ppo' ∪ rfe' ∪ detour' ∪   ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘ ∪   ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘ ∪ bob') ⨾ ⦗W ∩₁ Rel⦘ ⊆ sb' ⨾ ⦗W ∩₁ Rel⦘).\n{\nrelsf; unionL.\n- rewrite (dom_r (@wf_pscD G')).\nrewrite F_Sc_eq; type_solver 21.\n- by rewrite (ppo_in_sb WFp).\n- rewrite (dom_r (wf_rfeD WFp)).\nrewrite R_eq; type_solver 21.\n- by rewrite detour_in_sb.\n- by basic_solver.\n- unfold Execution.rfi; basic_solver.\n- by rewrite bob_in_sb.\n}\nrewrite sb_eq at 1.\nsin_rewrite W_REL.\nrewrite <- sb_eq, <- rmw_eq.\narewrite (⦗F ∩₁ Rel⦘ ⊆ ⦗F ∩₁ Acq/Rel⦘) by mode_solver.\nrewrite <- F_AcqRel_eq, <- F_eq.\narewrite ((sb'^? ⨾ ⦗F' ∩₁ Acq/Rel'⦘ ⨾ sb' ∪ rmw') ⨾ sb' ⨾ ⦗W'⦘ ⊆ (psc' ∪ ppo' ∪ rfe' ∪ detour' ∪ ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘ ∪ bob')⁺).\n{\nrelsf; unionL.\n- rewrite !seqA.\narewrite (sb' ⨾ sb' ⨾ ⦗W'⦘ ⊆ sb').\nby generalize (@sb_trans G'); basic_solver.\nunfold imm_bob.bob, imm_bob.fwbob.\ncase_refl _.\nunfolder; ins; eapply t_step; basic_solver 21.\nunfolder; ins; desf; eapply t_trans; eapply t_step; basic_solver 21.\n- rewrite rmw_sb_W_in_ppo; auto.\nby red; ins; eapply t_step; basic_solver 12.\n}\narewrite (psc' ∪ ppo' ∪ rfe' ∪ detour' ∪ ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘ ∪ bob' ⊆          psc' ∪ ppo' ∪ rfe' ∪ detour' ∪ ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘ ∪          ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘ ∪ bob').\nrelsf.\nred; rels.\neapply acyclic_mon; [edone|].\nbasic_solver 12.\n"},{"statement":"Lemma rmw_atomicity_eq: rmw_atomicity G' -> rmw_atomicity G.","proof":"by unfold rmw_atomicity; rewrite rmw_eq, fr_eq, sb_eq, co_eq.\n"},{"statement":"Lemma rel_opt WFp COMPp  (CONSp: imm_consistent G'): imm_consistent G.","proof":"cdes CONSp.\nassert (Wf G) as WF by (by apply wf_eq).\nassert (complete G) as COM by (by apply complete_eq).\nassert (sc_per_loc G) as SPL.\n{\napply sc_per_loc_eq.\nby apply coherence_sc_per_loc.\n}\nassert (coherence G) as COH by (by apply coherence_eq).\nassert (acyc_ext G) as CextG by (by apply acyc_ext_eq).\nred.\nsplits; auto.\nrewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone.\n"}]