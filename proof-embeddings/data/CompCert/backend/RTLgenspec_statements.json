{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/RTLgenspec.v","fileSamples":[{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3) : (do X <- f; g X) s1 = OK y s3 i ->\nexists (x : A) (s2 : state) (i1 : state_incr s1 s2) \n(i2 : state_incr s2 s3), f s1 = OK x s2 i1 /\\ g x s2 = OK y s3 i2.","proofString":"unfold bind.\ndestruct (f s1); intros.\ndiscriminate.\nexists a; exists s'; exists s.\ndestruct (g a s'); inv H.\nexists s0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3) : match f s1 with\n| Error msg => Error msg\n| OK a s' i0 =>\n    match g a s' with\n    | Error msg => Error msg\n    | OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' i0 i')\n    end\nend = OK y s3 i ->\nexists (x : A) (s2 : state) (i1 : state_incr s1 s2) \n(i2 : state_incr s2 s3), f s1 = OK x s2 i1 /\\ g x s2 = OK y s3 i2.","proofString":"destruct (f s1); intros.\ndiscriminate.\nexists a; exists s'; exists s.\ndestruct (g a s'); inv H.\nexists s0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3) (e : Errors.errmsg) (H : Error e = OK y s3 i) : exists (x : A) (s2 : state) (i1 : state_incr s1 s2) \n(i2 : state_incr s2 s3), Error e = OK x s2 i1 /\\ g x s2 = OK y s3 i2.","proofString":"discriminate."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3) (a : A) (s' : state) (s : state_incr s1 s') (H : match g a s' with\n| Error msg => Error msg\n| OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' s i')\nend = OK y s3 i) : exists (x : A) (s2 : state) (i1 : state_incr s1 s2) \n(i2 : state_incr s2 s3), OK a s' s = OK x s2 i1 /\\ g x s2 = OK y s3 i2.","proofString":"exists a; exists s'; exists s.\ndestruct (g a s'); inv H.\nexists s0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3) (a : A) (s' : state) (s : state_incr s1 s') (H : match g a s' with\n| Error msg => Error msg\n| OK b s'' i' => OK b s'' (state_incr_trans s1 s' s'' s i')\nend = OK y s3 i) : exists i2 : state_incr s' s3, OK a s' s = OK a s' s /\\ g a s' = OK y s3 i2.","proofString":"destruct (g a s'); inv H.\nexists s0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3) (a : A) (s' : state) (s : state_incr s1 s') (s0 : state_incr s' s3) : exists i2 : state_incr s' s3,\n  OK a s' s = OK a s' s /\\ OK y s3 s0 = OK y s3 i2.","proofString":"exists s0; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (f : mon (A * B)) (g : A -> B -> mon C) (z : C) (s1 s3 : state) (i : state_incr s1 s3) (H : (do xy <- f; g (fst xy) (snd xy)) s1 = OK z s3 i) : exists\n  (x : A) (y : B) (s2 : state) (i1 : state_incr s1 s2) \n(i2 : state_incr s2 s3), f s1 = OK (x, y) s2 i1 /\\ g x y s2 = OK z s3 i2.","proofString":"exploit bind_inversion; eauto.\nintros [[x y] [s2 [i1 [i2 [P Q]]]]].\nsimpl in Q.\nexists x; exists y; exists s2; exists i1; exists i2; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (f : mon (A * B)) (g : A -> B -> mon C) (z : C) (s1 s3 : state) (i : state_incr s1 s3) (H : (do xy <- f; g (fst xy) (snd xy)) s1 = OK z s3 i) : (exists\n   (x : A * B) (s2 : state) (i1 : state_incr s1 s2) \n (i2 : state_incr s2 s3),\n   f s1 = OK x s2 i1 /\\\n   (fun xy : A * B => g (fst xy) (snd xy)) x s2 = OK z s3 i2) ->\nexists\n  (x : A) (y : B) (s2 : state) (i1 : state_incr s1 s2) \n(i2 : state_incr s2 s3), f s1 = OK (x, y) s2 i1 /\\ g x y s2 = OK z s3 i2.","proofString":"intros [[x y] [s2 [i1 [i2 [P Q]]]]].\nsimpl in Q.\nexists x; exists y; exists s2; exists i1; exists i2; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (f : mon (A * B)) (g : A -> B -> mon C) (z : C) (s1 s3 : state) (i : state_incr s1 s3) (H : (do xy <- f; g (fst xy) (snd xy)) s1 = OK z s3 i) (x : A) (y : B) (s2 : state) (i1 : state_incr s1 s2) (i2 : state_incr s2 s3) (P : f s1 = OK (x, y) s2 i1) (Q : g (fst (x, y)) (snd (x, y)) s2 = OK z s3 i2) : exists\n  (x0 : A) (y0 : B) (s0 : state) (i0 : state_incr s1 s0) \n(i3 : state_incr s0 s3), f s1 = OK (x0, y0) s0 i0 /\\ g x0 y0 s0 = OK z s3 i3.","proofString":"simpl in Q.\nexists x; exists y; exists s2; exists i1; exists i2; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (f : mon (A * B)) (g : A -> B -> mon C) (z : C) (s1 s3 : state) (i : state_incr s1 s3) (H : (do xy <- f; g (fst xy) (snd xy)) s1 = OK z s3 i) (x : A) (y : B) (s2 : state) (i1 : state_incr s1 s2) (i2 : state_incr s2 s3) (P : f s1 = OK (x, y) s2 i1) (Q : g x y s2 = OK z s3 i2) : exists\n  (x0 : A) (y0 : B) (s0 : state) (i0 : state_incr s1 s0) \n(i3 : state_incr s0 s3), f s1 = OK (x0, y0) s0 i0 /\\ g x0 y0 s0 = OK z s3 i3.","proofString":"exists x; exists y; exists s2; exists i1; exists i2; auto."},{"statement":"(s1 s2 : state) (n : positive) (i : instruction) (H : state_incr s1 s2) (H0 : (st_code s1) ! n = Some i) : (st_code s2) ! n = Some i.","proofString":"inv H.\ndestruct (H3 n); congruence."},{"statement":"(s1 s2 : state) (n : positive) (i : instruction) (H0 : (st_code s1) ! n = Some i) (H1 : Ple (st_nextnode s1) (st_nextnode s2)) (H2 : Ple (st_nextreg s1) (st_nextreg s2)) (H3 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) : (st_code s2) ! n = Some i.","proofString":"destruct (H3 n); congruence."},{"statement":"(r : reg) (s : state) : reg_valid r s -> reg_fresh r s -> False.","proofString":"unfold reg_valid, reg_fresh; case r; tauto."},{"statement":"(r1 r2 : reg) (s : state) (H : reg_valid r1 s) (H0 : reg_fresh r2 s) (H1 : r1 = r2) : False.","proofString":"subst r2.\neauto with rtlg."},{"statement":"(r1 : reg) (s : state) (H : reg_valid r1 s) (H0 : reg_fresh r1 s) : False.","proofString":"eauto with rtlg."},{"statement":"(r : reg) (s1 s2 : state) (INCR : state_incr s1 s2) : reg_valid r s1 -> reg_valid r s2.","proofString":"inversion INCR.\nunfold reg_valid.\nintros; apply Plt_Ple_trans with (st_nextreg s1); auto."},{"statement":"(r : reg) (s1 s2 : state) (INCR : state_incr s1 s2) (s0 s3 : state) (H : Ple (st_nextnode s1) (st_nextnode s2)) (H0 : Ple (st_nextreg s1) (st_nextreg s2)) (H1 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H2 : s0 = s1) (H3 : s3 = s2) : reg_valid r s1 -> reg_valid r s2.","proofString":"unfold reg_valid.\nintros; apply Plt_Ple_trans with (st_nextreg s1); auto."},{"statement":"(r : reg) (s1 s2 : state) (INCR : state_incr s1 s2) (s0 s3 : state) (H : Ple (st_nextnode s1) (st_nextnode s2)) (H0 : Ple (st_nextreg s1) (st_nextreg s2)) (H1 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H2 : s0 = s1) (H3 : s3 = s2) : Plt r (st_nextreg s1) -> Plt r (st_nextreg s2).","proofString":"intros; apply Plt_Ple_trans with (st_nextreg s1); auto."},{"statement":"(r : reg) (s1 s2 : state) (INCR : state_incr s1 s2) : reg_fresh r s2 -> reg_fresh r s1.","proofString":"inversion INCR.\nunfold reg_fresh; unfold not; intros.\napply H4.\napply Plt_Ple_trans with (st_nextreg s1); auto."},{"statement":"(r : reg) (s1 s2 : state) (INCR : state_incr s1 s2) (s0 s3 : state) (H : Ple (st_nextnode s1) (st_nextnode s2)) (H0 : Ple (st_nextreg s1) (st_nextreg s2)) (H1 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H2 : s0 = s1) (H3 : s3 = s2) : reg_fresh r s2 -> reg_fresh r s1.","proofString":"unfold reg_fresh; unfold not; intros.\napply H4.\napply Plt_Ple_trans with (st_nextreg s1); auto."},{"statement":"(r : reg) (s1 s2 : state) (INCR : state_incr s1 s2) (s0 s3 : state) (H : Ple (st_nextnode s1) (st_nextnode s2)) (H0 : Ple (st_nextreg s1) (st_nextreg s2)) (H1 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H2 : s0 = s1) (H3 : s3 = s2) (H4 : Plt r (st_nextreg s2) -> False) (H5 : Plt r (st_nextreg s1)) : False.","proofString":"apply H4.\napply Plt_Ple_trans with (st_nextreg s1); auto."},{"statement":"(r : reg) (s1 s2 : state) (INCR : state_incr s1 s2) (s0 s3 : state) (H : Ple (st_nextnode s1) (st_nextnode s2)) (H0 : Ple (st_nextreg s1) (st_nextreg s2)) (H1 : forall pc : positive,\n(st_code s1) ! pc = None \\/ (st_code s2) ! pc = (st_code s1) ! pc) (H2 : s0 = s1) (H3 : s3 = s2) (H4 : Plt r (st_nextreg s2) -> False) (H5 : Plt r (st_nextreg s1)) : Plt r (st_nextreg s2).","proofString":"apply Plt_Ple_trans with (st_nextreg s1); auto."},{"statement":"(s : state) (r : reg) (H : In r nil) : reg_valid r s.","proofString":"elim H."},{"statement":"(r1 : reg) (rl : list reg) (s : state) (H : reg_valid r1 s) (H0 : regs_valid rl s) (r : reg) (H1 : In r (r1 :: rl)) : reg_valid r s.","proofString":"elim H1; intro.\nsubst r1; auto.\nauto."},{"statement":"(r1 : reg) (rl : list reg) (s : state) (H : reg_valid r1 s) (H0 : regs_valid rl s) (r : reg) (H1 : In r (r1 :: rl)) (H2 : r1 = r) : reg_valid r s.","proofString":"subst r1; auto."},{"statement":"(r1 : reg) (rl : list reg) (s : state) (H : reg_valid r1 s) (H0 : regs_valid rl s) (r : reg) (H1 : In r (r1 :: rl)) (H2 : In r rl) : reg_valid r s.","proofString":"auto."},{"statement":"(rl1 rl2 : list reg) (s : state) (H : regs_valid rl1 s) (H0 : regs_valid rl2 s) (r : reg) (H1 : In r (rl1 ++ rl2)) : reg_valid r s.","proofString":"apply in_app_iff in H1.\ndestruct H1; auto."},{"statement":"(rl1 rl2 : list reg) (s : state) (H : regs_valid rl1 s) (H0 : regs_valid rl2 s) (r : reg) (H1 : In r rl1 \\/ In r rl2) : reg_valid r s.","proofString":"destruct H1; auto."},{"statement":"(s1 s2 : state) (incr : state_incr s1 s2) (i : instruction) (n : node) (H : add_instr i s1 = OK n s2 incr) : (st_code s2) ! n = Some i.","proofString":"monadInv H.\nsimpl.\napply PTree.gss."},{"statement":"(s1 : state) (i : instruction) (incr : state_incr s1\n  {|\n    st_nextreg := st_nextreg s1;\n    st_nextnode := Pos.succ (st_nextnode s1);\n    st_code := PTree.set (st_nextnode s1) i (st_code s1);\n    st_wf := add_instr_wf s1 i\n  |}) : (st_code\n   {|\n     st_nextreg := st_nextreg s1;\n     st_nextnode := Pos.succ (st_nextnode s1);\n     st_code := PTree.set (st_nextnode s1) i (st_code s1);\n     st_wf := add_instr_wf s1 i\n   |}) ! (st_nextnode s1) = Some i.","proofString":"simpl.\napply PTree.gss."},{"statement":"(s1 : state) (i : instruction) (incr : state_incr s1\n  {|\n    st_nextreg := st_nextreg s1;\n    st_nextnode := Pos.succ (st_nextnode s1);\n    st_code := PTree.set (st_nextnode s1) i (st_code s1);\n    st_wf := add_instr_wf s1 i\n  |}) : (PTree.set (st_nextnode s1) i (st_code s1)) ! (st_nextnode s1) = Some i.","proofString":"apply PTree.gss."},{"statement":"(n : node) (i : instruction) (s1 s2 : state) (incr : state_incr s1 s2) (u : unit) (H : update_instr n i s1 = OK u s2 incr) : (st_code s2) ! n = Some i.","proofString":"unfold update_instr in H.\ndestruct (plt n (st_nextnode s1)); try discriminate.\ndestruct (check_empty_node s1 n); try discriminate.\ninv H.\nsimpl.\napply PTree.gss."},{"statement":"(n : node) (i : instruction) (s1 s2 : state) (incr : state_incr s1 s2) (u : unit) (H : match plt n (st_nextnode s1) with\n| left LT =>\n    match check_empty_node s1 n with\n    | left EMPTY =>\n        OK tt\n          {|\n            st_nextreg := st_nextreg s1;\n            st_nextnode := st_nextnode s1;\n            st_code := PTree.set n i (st_code s1);\n            st_wf := update_instr_wf s1 n i LT\n          |} (update_instr_incr s1 n i LT EMPTY)\n    | right _ => Error (Errors.msg \"RTLgen.update_instr\")\n    end\n| right _ => Error (Errors.msg \"RTLgen.update_instr\")\nend = OK u s2 incr) : (st_code s2) ! n = Some i.","proofString":"destruct (plt n (st_nextnode s1)); try discriminate.\ndestruct (check_empty_node s1 n); try discriminate.\ninv H.\nsimpl.\napply PTree.gss."},{"statement":"(n : node) (i : instruction) (s1 s2 : state) (incr : state_incr s1 s2) (u : unit) (p : Plt n (st_nextnode s1)) (H : match check_empty_node s1 n with\n| left EMPTY =>\n    OK tt\n      {|\n        st_nextreg := st_nextreg s1;\n        st_nextnode := st_nextnode s1;\n        st_code := PTree.set n i (st_code s1);\n        st_wf := update_instr_wf s1 n i p\n      |} (update_instr_incr s1 n i p EMPTY)\n| right _ => Error (Errors.msg \"RTLgen.update_instr\")\nend = OK u s2 incr) : (st_code s2) ! n = Some i.","proofString":"destruct (check_empty_node s1 n); try discriminate.\ninv H.\nsimpl.\napply PTree.gss."},{"statement":"(n : node) (i : instruction) (s1 s2 : state) (incr : state_incr s1 s2) (u : unit) (p : Plt n (st_nextnode s1)) (e : (st_code s1) ! n = None) (H : OK tt\n  {|\n    st_nextreg := st_nextreg s1;\n    st_nextnode := st_nextnode s1;\n    st_code := PTree.set n i (st_code s1);\n    st_wf := update_instr_wf s1 n i p\n  |} (update_instr_incr s1 n i p e) = OK u s2 incr) : (st_code s2) ! n = Some i.","proofString":"inv H.\nsimpl.\napply PTree.gss."},{"statement":"(n : node) (i : instruction) (s1 : state) (p : Plt n (st_nextnode s1)) (incr : state_incr s1\n  {|\n    st_nextreg := st_nextreg s1;\n    st_nextnode := st_nextnode s1;\n    st_code := PTree.set n i (st_code s1);\n    st_wf := update_instr_wf s1 n i p\n  |}) (e : (st_code s1) ! n = None) : (st_code\n   {|\n     st_nextreg := st_nextreg s1;\n     st_nextnode := st_nextnode s1;\n     st_code := PTree.set n i (st_code s1);\n     st_wf := update_instr_wf s1 n i p\n   |}) ! n = Some i.","proofString":"simpl.\napply PTree.gss."},{"statement":"(n : node) (i : instruction) (s1 : state) (p : Plt n (st_nextnode s1)) (incr : state_incr s1\n  {|\n    st_nextreg := st_nextreg s1;\n    st_nextnode := st_nextnode s1;\n    st_code := PTree.set n i (st_code s1);\n    st_wf := update_instr_wf s1 n i p\n  |}) (e : (st_code s1) ! n = None) : (PTree.set n i (st_code s1)) ! n = Some i.","proofString":"apply PTree.gss."},{"statement":"(s1 s2 : state) (r : reg) (i : state_incr s1 s2) (H : new_reg s1 = OK r s2 i) : reg_valid r s2.","proofString":"monadInv H.\nunfold reg_valid; simpl.\napply Plt_succ."},{"statement":"(s1 : state) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) : reg_valid (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"unfold reg_valid; simpl.\napply Plt_succ."},{"statement":"(s1 : state) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) : Plt (st_nextreg s1) (Pos.succ (st_nextreg s1)).","proofString":"apply Plt_succ."},{"statement":"(s1 s2 : state) (r : reg) (i : state_incr s1 s2) (H : new_reg s1 = OK r s2 i) : reg_fresh r s1.","proofString":"monadInv H.\nunfold reg_fresh; simpl.\nexact (Plt_strict _)."},{"statement":"(s1 : state) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) : reg_fresh (st_nextreg s1) s1.","proofString":"unfold reg_fresh; simpl.\nexact (Plt_strict _)."},{"statement":"(s1 : state) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) : ~ Plt (st_nextreg s1) (st_nextreg s1).","proofString":"exact (Plt_strict _)."},{"statement":"forall (s : state) (r : reg),\nreg_in_map {| map_vars := PTree.empty reg; map_letvars := nil |} r ->\nreg_valid r s.","proofString":"intros s r [[id A] | B].\nsimpl in A.\nrewrite PTree.gempty in A; discriminate.\nsimpl in B.\ntauto."},{"statement":"(s : state) (r : reg) (id : positive) (A : (map_vars {| map_vars := PTree.empty reg; map_letvars := nil |}) ! id =\nSome r) : reg_valid r s.","proofString":"simpl in A.\nrewrite PTree.gempty in A; discriminate."},{"statement":"(s : state) (r : reg) (id : positive) (A : (PTree.empty reg) ! id = Some r) : reg_valid r s.","proofString":"rewrite PTree.gempty in A; discriminate."},{"statement":"(s : state) (r : reg) (B : In r (map_letvars {| map_vars := PTree.empty reg; map_letvars := nil |})) : reg_valid r s.","proofString":"simpl in B.\ntauto."},{"statement":"(s : state) (r : reg) (B : False) : reg_valid r s.","proofString":"tauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) : forall i : state_incr s1 s2,\nfind_var map name s1 = OK r s2 i -> reg_in_map map r.","proofString":"unfold find_var; caseEq (map.(map_vars)!name).\nintros.\ninv H0.\nleft; exists name; auto.\nintros.\ninv H0."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) : forall r0 : reg,\n(map_vars map) ! name = Some r0 ->\nforall i : state_incr s1 s2, ret r0 s1 = OK r s2 i -> reg_in_map map r.","proofString":"intros.\ninv H0.\nleft; exists name; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r r0 : reg) (H : (map_vars map) ! name = Some r0) (i : state_incr s1 s2) (H0 : ret r0 s1 = OK r s2 i) : reg_in_map map r.","proofString":"inv H0.\nleft; exists name; auto."},{"statement":"(s2 : state) (map : mapping) (name : ident) (r : reg) (H : (map_vars map) ! name = Some r) (i : state_incr s2 s2) : reg_in_map map r.","proofString":"left; exists name; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) : (map_vars map) ! name = None ->\nforall i : state_incr s1 s2,\nerror (Errors.MSG \"RTLgen: unbound variable \" :: Errors.CTX name :: nil) s1 =\nOK r s2 i -> reg_in_map map r.","proofString":"intros.\ninv H0."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (H : (map_vars map) ! name = None) (i : state_incr s1 s2) (H0 : error (Errors.MSG \"RTLgen: unbound variable \" :: Errors.CTX name :: nil) s1 =\nOK r s2 i) : reg_in_map map r.","proofString":"inv H0."},{"statement":"(s1 s2 : state) (map : mapping) (idx : nat) (r : reg) : forall i : state_incr s1 s2,\nfind_letvar map idx s1 = OK r s2 i -> reg_in_map map r.","proofString":"unfold find_letvar.\ncaseEq (nth_error (map_letvars map) idx); intros; monadInv H0.\nright; apply nth_error_in with idx; auto."},{"statement":"(s1 s2 : state) (map : mapping) (idx : nat) (r : reg) : forall i : state_incr s1 s2,\nmatch nth_error (map_letvars map) idx with\n| Some r0 => ret r0\n| None => error (Errors.msg \"RTLgen: unbound let variable\")\nend s1 = OK r s2 i -> reg_in_map map r.","proofString":"caseEq (nth_error (map_letvars map) idx); intros; monadInv H0.\nright; apply nth_error_in with idx; auto."},{"statement":"(s2 : state) (map : mapping) (idx : nat) (r : reg) (H : nth_error (map_letvars map) idx = Some r) (i : state_incr s2 s2) : reg_in_map map r.","proofString":"right; apply nth_error_in with idx; auto."},{"statement":"(s1 s2 : state) (map1 map2 : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H : add_var map1 name s1 = OK (r, map2) s2 i) (H0 : map_valid map1 s1) : reg_valid r s2 /\\ map_valid map2 s2.","proofString":"monadInv H.\nsplit.\neauto with rtlg.\ninversion EQ.\nsubst.\nred.\nintros r' [[id A] | B].\nsimpl in A.\nrewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto.\nsimpl in B.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 s2 : state) (map1 : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : reg_valid r s2 /\\\nmap_valid\n  {|\n    map_vars := PTree.set name r (map_vars map1);\n    map_letvars := map_letvars map1\n  |} s2.","proofString":"split.\neauto with rtlg.\ninversion EQ.\nsubst.\nred.\nintros r' [[id A] | B].\nsimpl in A.\nrewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto.\nsimpl in B.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 s2 : state) (map1 : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : reg_valid r s2.","proofString":"eauto with rtlg."},{"statement":"(s1 s2 : state) (map1 : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : map_valid\n  {|\n    map_vars := PTree.set name r (map_vars map1);\n    map_letvars := map_letvars map1\n  |} s2.","proofString":"inversion EQ.\nsubst.\nred.\nintros r' [[id A] | B].\nsimpl in A.\nrewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto.\nsimpl in B.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 s2 : state) (map1 : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (H1 : st_nextreg s1 = r) (H2 : {|\n  st_nextreg := Pos.succ (st_nextreg s1);\n  st_nextnode := st_nextnode s1;\n  st_code := st_code s1;\n  st_wf := st_wf s1\n|} = s2) : map_valid\n  {|\n    map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n    map_letvars := map_letvars map1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"subst.\nred.\nintros r' [[id A] | B].\nsimpl in A.\nrewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto.\nsimpl in B.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) : map_valid\n  {|\n    map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n    map_letvars := map_letvars map1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"red.\nintros r' [[id A] | B].\nsimpl in A.\nrewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto.\nsimpl in B.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) : forall r : reg,\nreg_in_map\n  {|\n    map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n    map_letvars := map_letvars map1\n  |} r ->\nreg_valid r\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"intros r' [[id A] | B].\nsimpl in A.\nrewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto.\nsimpl in B.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (A : (map_vars\n   {|\n     map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n     map_letvars := map_letvars map1\n   |}) ! id = Some r') : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"simpl in A.\nrewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (A : (PTree.set name (st_nextreg s1) (map_vars map1)) ! id = Some r') : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"rewrite PTree.gsspec in A.\ndestruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (A : (if peq id name then Some (st_nextreg s1) else (map_vars map1) ! id) =\nSome r') : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"destruct (peq id name).\ninv A.\neauto with rtlg.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (e : id = name) (A : Some (st_nextreg s1) = Some r') : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"inv A.\neauto with rtlg."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) : reg_valid (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"eauto with rtlg."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (n : id <> name) (A : (map_vars map1) ! id = Some r') : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"apply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nleft; exists id; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (n : id <> name) (A : (map_vars map1) ! id = Some r') : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"eauto with rtlg."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (n : id <> name) (A : (map_vars map1) ! id = Some r') : reg_valid r' s1.","proofString":"apply H0.\nleft; exists id; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (id : positive) (n : id <> name) (A : (map_vars map1) ! id = Some r') : reg_in_map map1 r'.","proofString":"left; exists id; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (B : In r'\n  (map_letvars\n     {|\n       map_vars := PTree.set name (st_nextreg s1) (map_vars map1);\n       map_letvars := map_letvars map1\n     |})) : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"simpl in B.\napply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (B : In r' (map_letvars map1)) : reg_valid r'\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"apply reg_valid_incr with s1.\neauto with rtlg.\napply H0.\nright; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (B : In r' (map_letvars map1)) : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}.","proofString":"eauto with rtlg."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (B : In r' (map_letvars map1)) : reg_valid r' s1.","proofString":"apply H0.\nright; auto."},{"statement":"(s1 : state) (map1 : mapping) (name : ident) (i : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (H0 : map_valid map1 s1) (INCR0 : state_incr\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (INCR : state_incr s1\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |}) (EQ : new_reg s1 =\nOK (st_nextreg s1)\n  {|\n    st_nextreg := Pos.succ (st_nextreg s1);\n    st_nextnode := st_nextnode s1;\n    st_code := st_code s1;\n    st_wf := st_wf s1\n  |} INCR) (r' : reg) (B : In r' (map_letvars map1)) : reg_in_map map1 r'.","proofString":"right; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (map' : mapping) (i : state_incr s1 s2) (H : add_var map name s1 = OK (r, map') s2 i) : (map_vars map') ! name = Some r.","proofString":"monadInv H.\nsimpl.\napply PTree.gss."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : (map_vars\n   {|\n     map_vars := PTree.set name r (map_vars map);\n     map_letvars := map_letvars map\n   |}) ! name = Some r.","proofString":"simpl.\napply PTree.gss."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : (PTree.set name r (map_vars map)) ! name = Some r.","proofString":"apply PTree.gss."},{"statement":"(s2 : state) (map2 : mapping) (H0 : map_valid map2 s2) (i : state_incr s2 s2) : regs_valid nil s2 /\\ map_valid map2 s2.","proofString":"split.\nred; simpl; intros; tauto.\nauto."},{"statement":"(s2 : state) (map2 : mapping) (H0 : map_valid map2 s2) (i : state_incr s2 s2) : regs_valid nil s2.","proofString":"red; simpl; intros; tauto."},{"statement":"(s2 : state) (map2 : mapping) (H0 : map_valid map2 s2) (i : state_incr s2 s2) : map_valid map2 s2.","proofString":"auto."},{"statement":"(a : ident) (namel : list ident) (IHnamel : forall (s0 s3 : state) (map0 map3 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 namel s0 = OK (rl, map3) s3 i0 ->\nmap_valid map0 s0 -> regs_valid rl s3 /\\ map_valid map3 s3) (s1 s2 : state) (map1 map2 : mapping) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 namel s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : regs_valid (x1 :: x) s2 /\\ map_valid map2 s2.","proofString":"exploit IHnamel; eauto.\nintros [A B].\nexploit add_var_valid; eauto.\nintros [C D].\nsplit.\napply regs_valid_cons; eauto with rtlg.\nauto."},{"statement":"(a : ident) (namel : list ident) (IHnamel : forall (s0 s3 : state) (map0 map3 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 namel s0 = OK (rl, map3) s3 i0 ->\nmap_valid map0 s0 -> regs_valid rl s3 /\\ map_valid map3 s3) (s1 s2 : state) (map1 map2 : mapping) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 namel s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : regs_valid x s /\\ map_valid x0 s ->\nregs_valid (x1 :: x) s2 /\\ map_valid map2 s2.","proofString":"intros [A B].\nexploit add_var_valid; eauto.\nintros [C D].\nsplit.\napply regs_valid_cons; eauto with rtlg.\nauto."},{"statement":"(a : ident) (namel : list ident) (IHnamel : forall (s0 s3 : state) (map0 map3 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 namel s0 = OK (rl, map3) s3 i0 ->\nmap_valid map0 s0 -> regs_valid rl s3 /\\ map_valid map3 s3) (s1 s2 : state) (map1 map2 : mapping) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 namel s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) : regs_valid (x1 :: x) s2 /\\ map_valid map2 s2.","proofString":"exploit add_var_valid; eauto.\nintros [C D].\nsplit.\napply regs_valid_cons; eauto with rtlg.\nauto."},{"statement":"(a : ident) (namel : list ident) (IHnamel : forall (s0 s3 : state) (map0 map3 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 namel s0 = OK (rl, map3) s3 i0 ->\nmap_valid map0 s0 -> regs_valid rl s3 /\\ map_valid map3 s3) (s1 s2 : state) (map1 map2 : mapping) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 namel s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) : reg_valid x1 s2 /\\ map_valid map2 s2 ->\nregs_valid (x1 :: x) s2 /\\ map_valid map2 s2.","proofString":"intros [C D].\nsplit.\napply regs_valid_cons; eauto with rtlg.\nauto."},{"statement":"(a : ident) (namel : list ident) (IHnamel : forall (s0 s3 : state) (map0 map3 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 namel s0 = OK (rl, map3) s3 i0 ->\nmap_valid map0 s0 -> regs_valid rl s3 /\\ map_valid map3 s3) (s1 s2 : state) (map1 map2 : mapping) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 namel s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (C : reg_valid x1 s2) (D : map_valid map2 s2) : regs_valid (x1 :: x) s2 /\\ map_valid map2 s2.","proofString":"split.\napply regs_valid_cons; eauto with rtlg.\nauto."},{"statement":"(a : ident) (namel : list ident) (IHnamel : forall (s0 s3 : state) (map0 map3 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 namel s0 = OK (rl, map3) s3 i0 ->\nmap_valid map0 s0 -> regs_valid rl s3 /\\ map_valid map3 s3) (s1 s2 : state) (map1 map2 : mapping) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 namel s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (C : reg_valid x1 s2) (D : map_valid map2 s2) : regs_valid (x1 :: x) s2.","proofString":"apply regs_valid_cons; eauto with rtlg."},{"statement":"(a : ident) (namel : list ident) (IHnamel : forall (s0 s3 : state) (map0 map3 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 namel s0 = OK (rl, map3) s3 i0 ->\nmap_valid map0 s0 -> regs_valid rl s3 /\\ map_valid map3 s3) (s1 s2 : state) (map1 map2 : mapping) (i : state_incr s1 s2) (H0 : map_valid map1 s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 namel s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (C : reg_valid x1 s2) (D : map_valid map2 s2) : map_valid map2 s2.","proofString":"auto."},{"statement":"(map1 : mapping) (id : ident) (s1 : state) (r : reg) (s2 : state) (i INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : map_letvars\n  {|\n    map_vars := PTree.set id r (map_vars map1);\n    map_letvars := map_letvars map1\n  |} = map_letvars map1.","proofString":"reflexivity."},{"statement":"(map2 : mapping) (s2 : state) (i : state_incr s2 s2) : map_letvars map2 = map_letvars map2.","proofString":"reflexivity."},{"statement":"(a : ident) (il : list ident) (IHil : forall (map0 : mapping) (s0 : state) (rl : list reg) \n  (map3 : mapping) (s3 : state) (i0 : state_incr s0 s3),\nadd_vars map0 il s0 = OK (rl, map3) s3 i0 ->\nmap_letvars map3 = map_letvars map0) (map1 : mapping) (s1 : state) (map2 : mapping) (s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : map_letvars map2 = map_letvars map1.","proofString":"transitivity (map_letvars x0).\neapply add_var_letenv; eauto.\neauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (map0 : mapping) (s0 : state) (rl : list reg) \n  (map3 : mapping) (s3 : state) (i0 : state_incr s0 s3),\nadd_vars map0 il s0 = OK (rl, map3) s3 i0 ->\nmap_letvars map3 = map_letvars map0) (map1 : mapping) (s1 : state) (map2 : mapping) (s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : map_letvars map2 = map_letvars x0.","proofString":"eapply add_var_letenv; eauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (map0 : mapping) (s0 : state) (rl : list reg) \n  (map3 : mapping) (s3 : state) (i0 : state_incr s0 s3),\nadd_vars map0 il s0 = OK (rl, map3) s3 i0 ->\nmap_letvars map3 = map_letvars map0) (map1 : mapping) (s1 : state) (map2 : mapping) (s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : map_letvars x0 = map_letvars map1.","proofString":"eauto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (H1 : reg_in_map (add_letvar map r) r0) : reg_valid r0 s.","proofString":"destruct H1 as [[id A]|B].\nsimpl in A.\napply H.\nleft; exists id; auto.\nsimpl in B.\nelim B; intro.\nsubst r0; auto.\napply H.\nright; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (id : positive) (A : (map_vars (add_letvar map r)) ! id = Some r0) : reg_valid r0 s.","proofString":"simpl in A.\napply H.\nleft; exists id; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (id : positive) (A : (map_vars map) ! id = Some r0) : reg_valid r0 s.","proofString":"apply H.\nleft; exists id; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (id : positive) (A : (map_vars map) ! id = Some r0) : reg_in_map map r0.","proofString":"left; exists id; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (B : In r0 (map_letvars (add_letvar map r))) : reg_valid r0 s.","proofString":"simpl in B.\nelim B; intro.\nsubst r0; auto.\napply H.\nright; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (B : r = r0 \\/ In r0 (map_letvars map)) : reg_valid r0 s.","proofString":"elim B; intro.\nsubst r0; auto.\napply H.\nright; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (B : r = r0 \\/ In r0 (map_letvars map)) (H1 : r = r0) : reg_valid r0 s.","proofString":"subst r0; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (B : r = r0 \\/ In r0 (map_letvars map)) (H1 : In r0 (map_letvars map)) : reg_valid r0 s.","proofString":"apply H.\nright; auto."},{"statement":"(map : mapping) (s : state) (r : reg) (H : map_valid map s) (H0 : reg_valid r s) (r0 : reg) (B : r = r0 \\/ In r0 (map_letvars map)) (H1 : In r0 (map_letvars map)) : reg_in_map map r0.","proofString":"right; auto."},{"statement":"(a : expr) (s1 s2 : state) (map : mapping) (r : reg) : forall i : state_incr s1 s2,\nmap_valid map s1 -> alloc_reg map a s1 = OK r s2 i -> reg_valid r s2.","proofString":"unfold alloc_reg.\ncase a; eauto with rtlg."},{"statement":"(a : expr) (s1 s2 : state) (map : mapping) (r : reg) : forall i : state_incr s1 s2,\nmap_valid map s1 ->\nmatch a with\n| Evar id => find_var map id\n| Eletvar n => find_letvar map n\n| _ => new_reg\nend s1 = OK r s2 i -> reg_valid r s2.","proofString":"case a; eauto with rtlg."},{"statement":"(map : mapping) (a : expr) (s : state) (r : reg) (s' : state) : forall i : state_incr s s',\nmap_valid map s ->\nalloc_reg map a s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s.","proofString":"unfold alloc_reg.\ndestruct a; intros; try (right; eauto with rtlg; fail).\nleft; eauto with rtlg.\nleft; eauto with rtlg."},{"statement":"(map : mapping) (a : expr) (s : state) (r : reg) (s' : state) : forall i : state_incr s s',\nmap_valid map s ->\nmatch a with\n| Evar id => find_var map id\n| Eletvar n => find_letvar map n\n| _ => new_reg\nend s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s.","proofString":"destruct a; intros; try (right; eauto with rtlg; fail).\nleft; eauto with rtlg.\nleft; eauto with rtlg."},{"statement":"(map : mapping) (i : ident) (s : state) (r : reg) (s' : state) (i0 : state_incr s s') (H : map_valid map s) (H0 : find_var map i s = OK r s' i0) : reg_in_map map r \\/ reg_fresh r s.","proofString":"left; eauto with rtlg."},{"statement":"(map : mapping) (n : nat) (s : state) (r : reg) (s' : state) (i : state_incr s s') (H : map_valid map s) (H0 : find_letvar map n s = OK r s' i) : reg_in_map map r \\/ reg_fresh r s.","proofString":"left; eauto with rtlg."},{"statement":"(s2 : state) (map : mapping) (H : map_valid map s2) (i : state_incr s2 s2) : regs_valid nil s2.","proofString":"apply regs_valid_nil."},{"statement":"(e : expr) (al : exprlist) (IHal : forall (s0 s3 : state) (map0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nmap_valid map0 s0 -> alloc_regs map0 al s0 = OK rl s3 i0 -> regs_valid rl s3) (s1 s2 : state) (map : mapping) (i : state_incr s1 s2) (H : map_valid map s1) (x : reg) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : alloc_reg map e s1 = OK x s INCR) (x0 : list reg) (INCR1 : state_incr s s2) (EQ1 : alloc_regs map al s = OK x0 s2 INCR1) (INCR2 : state_incr s2 s2) : regs_valid (x :: x0) s2.","proofString":"apply regs_valid_cons.\neauto with rtlg.\neauto with rtlg."},{"statement":"(e : expr) (al : exprlist) (IHal : forall (s0 s3 : state) (map0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nmap_valid map0 s0 -> alloc_regs map0 al s0 = OK rl s3 i0 -> regs_valid rl s3) (s1 s2 : state) (map : mapping) (i : state_incr s1 s2) (H : map_valid map s1) (x : reg) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : alloc_reg map e s1 = OK x s INCR) (x0 : list reg) (INCR1 : state_incr s s2) (EQ1 : alloc_regs map al s = OK x0 s2 INCR1) (INCR2 : state_incr s2 s2) : reg_valid x s2.","proofString":"eauto with rtlg."},{"statement":"(e : expr) (al : exprlist) (IHal : forall (s0 s3 : state) (map0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nmap_valid map0 s0 -> alloc_regs map0 al s0 = OK rl s3 i0 -> regs_valid rl s3) (s1 s2 : state) (map : mapping) (i : state_incr s1 s2) (H : map_valid map s1) (x : reg) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : alloc_reg map e s1 = OK x s INCR) (x0 : list reg) (INCR1 : state_incr s s2) (EQ1 : alloc_regs map al s = OK x0 s2 INCR1) (INCR2 : state_incr s2 s2) : regs_valid x0 s2.","proofString":"eauto with rtlg."},{"statement":"(dest : option ident) (s1 s2 : state) (map : mapping) (r : reg) : forall i : state_incr s1 s2,\nmap_valid map s1 -> alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2.","proofString":"unfold alloc_reg.\ncase dest; eauto with rtlg."},{"statement":"(dest : option ident) (s1 s2 : state) (map : mapping) (r : reg) : forall i : state_incr s1 s2,\nmap_valid map s1 -> alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2.","proofString":"case dest; eauto with rtlg."},{"statement":"(map : mapping) (dest : option ident) (s : state) (r : reg) (s' : state) : forall i : state_incr s s',\nmap_valid map s ->\nalloc_optreg map dest s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s.","proofString":"unfold alloc_optreg.\ndestruct dest; intros.\nleft; eauto with rtlg.\nright; eauto with rtlg."},{"statement":"(map : mapping) (dest : option ident) (s : state) (r : reg) (s' : state) : forall i : state_incr s s',\nmap_valid map s ->\nmatch dest with\n| Some id => find_var map id\n| None => new_reg\nend s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s.","proofString":"destruct dest; intros.\nleft; eauto with rtlg.\nright; eauto with rtlg."},{"statement":"(map : mapping) (i : ident) (s : state) (r : reg) (s' : state) (i0 : state_incr s s') (H : map_valid map s) (H0 : find_var map i s = OK r s' i0) : reg_in_map map r \\/ reg_fresh r s.","proofString":"left; eauto with rtlg."},{"statement":"(map : mapping) (s : state) (r : reg) (s' : state) (i : state_incr s s') (H : map_valid map s) (H0 : new_reg s = OK r s' i) : reg_in_map map r \\/ reg_fresh r s.","proofString":"right; eauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (id : positive) (r : reg) (H : (map_vars map) ! id = Some r) (pr' : list reg) (H0 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) : target_reg_ok map (pr' ++ pr) (Evar id) r.","proofString":"constructor; auto."},{"statement":"(map : mapping) (pr : list reg) (idx : nat) (r : reg) (H : nth_error (map_letvars map) idx = Some r) (pr' : list reg) (H0 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) : target_reg_ok map (pr' ++ pr) (Eletvar idx) r.","proofString":"constructor; auto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : ~ reg_in_map map r) (H0 : ~ In r pr) (pr' : list reg) (H1 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) : target_reg_ok map (pr' ++ pr) a r.","proofString":"constructor; auto.\nred; intros.\nelim (in_app_or _ _ _ H2); intro.\ngeneralize (H1 _ H3).\ntauto.\ntauto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : ~ reg_in_map map r) (H0 : ~ In r pr) (pr' : list reg) (H1 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) : ~ In r (pr' ++ pr).","proofString":"red; intros.\nelim (in_app_or _ _ _ H2); intro.\ngeneralize (H1 _ H3).\ntauto.\ntauto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : ~ reg_in_map map r) (H0 : ~ In r pr) (pr' : list reg) (H1 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) (H2 : In r (pr' ++ pr)) : False.","proofString":"elim (in_app_or _ _ _ H2); intro.\ngeneralize (H1 _ H3).\ntauto.\ntauto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : ~ reg_in_map map r) (H0 : ~ In r pr) (pr' : list reg) (H1 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) (H2 : In r (pr' ++ pr)) (H3 : In r pr') : False.","proofString":"generalize (H1 _ H3).\ntauto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : ~ reg_in_map map r) (H0 : ~ In r pr) (pr' : list reg) (H1 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) (H2 : In r (pr' ++ pr)) (H3 : In r pr') : reg_in_map map r \\/ r <> r -> False.","proofString":"tauto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : ~ reg_in_map map r) (H0 : ~ In r pr) (pr' : list reg) (H1 : forall r' : reg, In r' pr' -> reg_in_map map r' \\/ r' <> r) (H2 : In r (pr' ++ pr)) (H3 : In r pr) : False.","proofString":"tauto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : target_reg_ok map pr a r) (r' : reg) (H0 : reg_in_map map r' \\/ r' <> r) : target_reg_ok map (r' :: pr) a r.","proofString":"change (r' :: pr) with ((r' :: nil) ++ pr).\napply target_reg_ok_append; auto.\nintros r'' [A|B].\nsubst r''; auto.\ncontradiction."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : target_reg_ok map pr a r) (r' : reg) (H0 : reg_in_map map r' \\/ r' <> r) : target_reg_ok map ((r' :: nil) ++ pr) a r.","proofString":"apply target_reg_ok_append; auto.\nintros r'' [A|B].\nsubst r''; auto.\ncontradiction."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : target_reg_ok map pr a r) (r' : reg) (H0 : reg_in_map map r' \\/ r' <> r) : forall r'0 : reg, In r'0 (r' :: nil) -> reg_in_map map r'0 \\/ r'0 <> r.","proofString":"intros r'' [A|B].\nsubst r''; auto.\ncontradiction."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : target_reg_ok map pr a r) (r' : reg) (H0 : reg_in_map map r' \\/ r' <> r) (r'' : reg) (A : r' = r'') : reg_in_map map r'' \\/ r'' <> r.","proofString":"subst r''; auto."},{"statement":"(map : mapping) (pr : list reg) (a : expr) (r : reg) (H : target_reg_ok map pr a r) (r' : reg) (H0 : reg_in_map map r' \\/ r' <> r) (r'' : reg) (B : In r'' nil) : reg_in_map map r'' \\/ r'' <> r.","proofString":"contradiction."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) : target_reg_ok map pr a r.","proofString":"constructor.\nred; intro.\napply valid_fresh_absurd with r s1.\neauto with rtlg.\neauto with rtlg.\nred; intro.\napply valid_fresh_absurd with r s1.\nauto.\neauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) : ~ reg_in_map map r.","proofString":"red; intro.\napply valid_fresh_absurd with r s1.\neauto with rtlg.\neauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) (H2 : reg_in_map map r) : False.","proofString":"apply valid_fresh_absurd with r s1.\neauto with rtlg.\neauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) (H2 : reg_in_map map r) : reg_valid r s1.","proofString":"eauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) (H2 : reg_in_map map r) : reg_fresh r s1.","proofString":"eauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) : ~ In r pr.","proofString":"red; intro.\napply valid_fresh_absurd with r s1.\nauto.\neauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) (H2 : In r pr) : False.","proofString":"apply valid_fresh_absurd with r s1.\nauto.\neauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) (H2 : In r pr) : reg_valid r s1.","proofString":"auto."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : new_reg s1 = OK r s2 i) (H2 : In r pr) : reg_fresh r s1.","proofString":"eauto with rtlg."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : alloc_reg map a s1 = OK r s2 i) : target_reg_ok map pr a r.","proofString":"unfold alloc_reg in H1.\ndestruct a;  try (eapply new_reg_target_ok; eauto; fail).\ngeneralize H1; unfold find_var.\ncaseEq (map_vars map)!i0; intros.\ninv H3.\nconstructor.\nauto.\ninv H3.\ngeneralize H1; unfold find_letvar.\ncaseEq (nth_error (map_letvars map) n); intros.\ninv H3.\nconstructor.\nauto.\ninv H3."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (a : expr) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : match a with\n| Evar id => find_var map id\n| Eletvar n => find_letvar map n\n| _ => new_reg\nend s1 = OK r s2 i) : target_reg_ok map pr a r.","proofString":"destruct a;  try (eapply new_reg_target_ok; eauto; fail).\ngeneralize H1; unfold find_var.\ncaseEq (map_vars map)!i0; intros.\ninv H3.\nconstructor.\nauto.\ninv H3.\ngeneralize H1; unfold find_letvar.\ncaseEq (nth_error (map_letvars map) n); intros.\ninv H3.\nconstructor.\nauto.\ninv H3."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (i0 : ident) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_var map i0 s1 = OK r s2 i) : target_reg_ok map pr (Evar i0) r.","proofString":"generalize H1; unfold find_var.\ncaseEq (map_vars map)!i0; intros.\ninv H3.\nconstructor.\nauto.\ninv H3."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (i0 : ident) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_var map i0 s1 = OK r s2 i) : match (map_vars map) ! i0 with\n| Some r0 => ret r0\n| None =>\n    error (Errors.MSG \"RTLgen: unbound variable \" :: Errors.CTX i0 :: nil)\nend s1 = OK r s2 i -> target_reg_ok map pr (Evar i0) r.","proofString":"caseEq (map_vars map)!i0; intros.\ninv H3.\nconstructor.\nauto.\ninv H3."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (i0 : ident) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_var map i0 s1 = OK r s2 i) (r0 : reg) (H2 : (map_vars map) ! i0 = Some r0) (H3 : ret r0 s1 = OK r s2 i) : target_reg_ok map pr (Evar i0) r.","proofString":"inv H3.\nconstructor.\nauto."},{"statement":"(map : mapping) (pr : list reg) (i0 : ident) (r : reg) (s2 : state) (i : state_incr s2 s2) (H1 : find_var map i0 s2 = OK r s2 i) (H0 : regs_valid pr s2) (H : map_valid map s2) (H2 : (map_vars map) ! i0 = Some r) : target_reg_ok map pr (Evar i0) r.","proofString":"constructor.\nauto."},{"statement":"(map : mapping) (pr : list reg) (i0 : ident) (r : reg) (s2 : state) (i : state_incr s2 s2) (H1 : find_var map i0 s2 = OK r s2 i) (H0 : regs_valid pr s2) (H : map_valid map s2) (H2 : (map_vars map) ! i0 = Some r) : (map_vars map) ! i0 = Some r.","proofString":"auto."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (i0 : ident) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_var map i0 s1 = OK r s2 i) (H2 : (map_vars map) ! i0 = None) (H3 : error (Errors.MSG \"RTLgen: unbound variable \" :: Errors.CTX i0 :: nil) s1 =\nOK r s2 i) : target_reg_ok map pr (Evar i0) r.","proofString":"inv H3."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (n : nat) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_letvar map n s1 = OK r s2 i) : target_reg_ok map pr (Eletvar n) r.","proofString":"generalize H1; unfold find_letvar.\ncaseEq (nth_error (map_letvars map) n); intros.\ninv H3.\nconstructor.\nauto.\ninv H3."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (n : nat) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_letvar map n s1 = OK r s2 i) : match nth_error (map_letvars map) n with\n| Some r0 => ret r0\n| None => error (Errors.msg \"RTLgen: unbound let variable\")\nend s1 = OK r s2 i -> target_reg_ok map pr (Eletvar n) r.","proofString":"caseEq (nth_error (map_letvars map) n); intros.\ninv H3.\nconstructor.\nauto.\ninv H3."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (n : nat) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_letvar map n s1 = OK r s2 i) (r0 : reg) (H2 : nth_error (map_letvars map) n = Some r0) (H3 : ret r0 s1 = OK r s2 i) : target_reg_ok map pr (Eletvar n) r.","proofString":"inv H3.\nconstructor.\nauto."},{"statement":"(map : mapping) (pr : list reg) (n : nat) (r : reg) (s2 : state) (i : state_incr s2 s2) (H1 : find_letvar map n s2 = OK r s2 i) (H0 : regs_valid pr s2) (H : map_valid map s2) (H2 : nth_error (map_letvars map) n = Some r) : target_reg_ok map pr (Eletvar n) r.","proofString":"constructor.\nauto."},{"statement":"(map : mapping) (pr : list reg) (n : nat) (r : reg) (s2 : state) (i : state_incr s2 s2) (H1 : find_letvar map n s2 = OK r s2 i) (H0 : regs_valid pr s2) (H : map_valid map s2) (H2 : nth_error (map_letvars map) n = Some r) : nth_error (map_letvars map) n = Some r.","proofString":"auto."},{"statement":"(map : mapping) (pr : list reg) (s1 : state) (n : nat) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (H1 : find_letvar map n s1 = OK r s2 i) (H2 : nth_error (map_letvars map) n = None) (H3 : error (Errors.msg \"RTLgen: unbound let variable\") s1 = OK r s2 i) : target_reg_ok map pr (Eletvar n) r.","proofString":"inv H3."},{"statement":"(map : mapping) (pr : list reg) (s2 : state) (H0 : regs_valid pr s2) (H : map_valid map s2) (i : state_incr s2 s2) : target_regs_ok map pr Enil nil.","proofString":"constructor."},{"statement":"(map : mapping) (e : expr) (al : exprlist) (IHal : forall (pr0 : list reg) (s0 : state) (rl : list reg) \n  (s3 : state) (i0 : state_incr s0 s3),\nmap_valid map s0 ->\nregs_valid pr0 s0 ->\nalloc_regs map al s0 = OK rl s3 i0 -> target_regs_ok map pr0 al rl) (pr : list reg) (s1 s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (x : reg) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : alloc_reg map e s1 = OK x s INCR) (x0 : list reg) (INCR1 : state_incr s s2) (EQ1 : alloc_regs map al s = OK x0 s2 INCR1) (INCR2 : state_incr s2 s2) : target_regs_ok map pr (Econs e al) (x :: x0).","proofString":"constructor.\neapply alloc_reg_target_ok; eauto.\napply IHal with s s2 INCR1; eauto with rtlg.\napply regs_valid_cons; eauto with rtlg."},{"statement":"(map : mapping) (e : expr) (al : exprlist) (IHal : forall (pr0 : list reg) (s0 : state) (rl : list reg) \n  (s3 : state) (i0 : state_incr s0 s3),\nmap_valid map s0 ->\nregs_valid pr0 s0 ->\nalloc_regs map al s0 = OK rl s3 i0 -> target_regs_ok map pr0 al rl) (pr : list reg) (s1 s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (x : reg) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : alloc_reg map e s1 = OK x s INCR) (x0 : list reg) (INCR1 : state_incr s s2) (EQ1 : alloc_regs map al s = OK x0 s2 INCR1) (INCR2 : state_incr s2 s2) : target_reg_ok map pr e x.","proofString":"eapply alloc_reg_target_ok; eauto."},{"statement":"(map : mapping) (e : expr) (al : exprlist) (IHal : forall (pr0 : list reg) (s0 : state) (rl : list reg) \n  (s3 : state) (i0 : state_incr s0 s3),\nmap_valid map s0 ->\nregs_valid pr0 s0 ->\nalloc_regs map al s0 = OK rl s3 i0 -> target_regs_ok map pr0 al rl) (pr : list reg) (s1 s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (x : reg) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : alloc_reg map e s1 = OK x s INCR) (x0 : list reg) (INCR1 : state_incr s s2) (EQ1 : alloc_regs map al s = OK x0 s2 INCR1) (INCR2 : state_incr s2 s2) : target_regs_ok map (x :: pr) al x0.","proofString":"apply IHal with s s2 INCR1; eauto with rtlg.\napply regs_valid_cons; eauto with rtlg."},{"statement":"(map : mapping) (e : expr) (al : exprlist) (IHal : forall (pr0 : list reg) (s0 : state) (rl : list reg) \n  (s3 : state) (i0 : state_incr s0 s3),\nmap_valid map s0 ->\nregs_valid pr0 s0 ->\nalloc_regs map al s0 = OK rl s3 i0 -> target_regs_ok map pr0 al rl) (pr : list reg) (s1 s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : regs_valid pr s1) (x : reg) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : alloc_reg map e s1 = OK x s INCR) (x0 : list reg) (INCR1 : state_incr s s2) (EQ1 : alloc_regs map al s = OK x0 s2 INCR1) (INCR2 : state_incr s2 s2) : regs_valid (x :: pr) s.","proofString":"apply regs_valid_cons; eauto with rtlg."},{"statement":"(s1 : state) (r : reg) (s2 : state) (map : mapping) (sig : signature) (i : state_incr s1 s2) (H : new_reg s1 = OK r s2 i) (H0 : map_valid map s1) : return_reg_ok s2 map (ret_reg sig r).","proofString":"unfold ret_reg.\ndestruct (xtype_eq (sig_res sig) Xvoid); constructor; eauto with rtlg."},{"statement":"(s1 : state) (r : reg) (s2 : state) (map : mapping) (sig : signature) (i : state_incr s1 s2) (H : new_reg s1 = OK r s2 i) (H0 : map_valid map s1) : return_reg_ok s2 map (if xtype_eq (sig_res sig) Xvoid then None else Some r).","proofString":"destruct (xtype_eq (sig_res sig) Xvoid); constructor; eauto with rtlg."},{"statement":"(s : state) (ns : node) (rs : reg) (nd : node) (rd : reg) (s' : state) (i : state_incr s s') (H : add_move rs rd nd s = OK ns s' i) : tr_move (st_code s') ns rs nd rd.","proofString":"unfold add_move in H.\ndestruct (Reg.eq rs rd).\ninv H.\nconstructor.\nconstructor.\neauto with rtlg."},{"statement":"(s : state) (ns : node) (rs : reg) (nd : node) (rd : reg) (s' : state) (i : state_incr s s') (H : (if Reg.eq rs rd then ret nd else add_instr (Iop Omove (rs :: nil) rd nd)) s =\nOK ns s' i) : tr_move (st_code s') ns rs nd rd.","proofString":"destruct (Reg.eq rs rd).\ninv H.\nconstructor.\nconstructor.\neauto with rtlg."},{"statement":"(s : state) (ns : node) (rs : reg) (nd : node) (rd : reg) (s' : state) (i : state_incr s s') (e : rs = rd) (H : ret nd s = OK ns s' i) : tr_move (st_code s') ns rs nd rd.","proofString":"inv H.\nconstructor."},{"statement":"(ns : node) (rd : reg) (s' : state) (i : state_incr s' s') : tr_move (st_code s') ns rd ns rd.","proofString":"constructor."},{"statement":"(s : state) (ns : node) (rs : reg) (nd : node) (rd : reg) (s' : state) (i : state_incr s s') (n : rs <> rd) (H : add_instr (Iop Omove (rs :: nil) rd nd) s = OK ns s' i) : tr_move (st_code s') ns rs nd rd.","proofString":"constructor.\neauto with rtlg."},{"statement":"(s : state) (ns : node) (rs : reg) (nd : node) (rd : reg) (s' : state) (i : state_incr s s') (n : rs <> rd) (H : add_instr (Iop Omove (rs :: nil) rd nd) s = OK ns s' i) : (st_code s') ! ns = Some (Iop Omove (rs :: nil) rd nd).","proofString":"eauto with rtlg."},{"statement":"(id i : ident) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : find_var map i s = RTLgen.OK x s0 INCR0) (EQ0 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id).","proofString":"generalize EQ; unfold find_var.\ncaseEq (map_vars map)!i; intros; inv EQ1.\neconstructor; eauto.\neapply add_move_charact; eauto."},{"statement":"(id i : ident) (map : mapping) (rd : reg) (nd ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (WF : map_valid map s0) (INCR : state_incr s0 s') (OK : reg_map_ok map rd (Some id)) (x : reg) (INCR1 : state_incr s0 s') (EQ : find_var map i s0 = RTLgen.OK x s0 INCR0) (EQ0 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) (H : (map_vars map) ! i = Some x) : tr_expr (st_code s') map nil (Evar i) ns nd rd (Some id).","proofString":"econstructor; eauto.\neapply add_move_charact; eauto."},{"statement":"(id i : ident) (map : mapping) (rd : reg) (nd ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (WF : map_valid map s0) (INCR : state_incr s0 s') (OK : reg_map_ok map rd (Some id)) (x : reg) (INCR1 : state_incr s0 s') (EQ : find_var map i s0 = RTLgen.OK x s0 INCR0) (EQ0 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) (H : (map_vars map) ! i = Some x) : tr_move (st_code s') ns x nd rd.","proofString":"eapply add_move_charact; eauto."},{"statement":"(id : ident) (o : operation) (e : exprlist) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : add_instr (Iop o x rd nd) s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_exprlist map e x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s') map nil (Eop o e) ns nd rd (Some id).","proofString":"econstructor; eauto with rtlg.\neapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(id : ident) (o : operation) (e : exprlist) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : add_instr (Iop o x rd nd) s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_exprlist map e x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_exprlist (st_code s') map nil e ns x0 x.","proofString":"eapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(id : ident) (m : memory_chunk) (a : addressing) (e : exprlist) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : add_instr (Iload m a x rd nd) s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_exprlist map e x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s') map nil (Eload m a e) ns nd rd (Some id).","proofString":"econstructor; eauto with rtlg.\neapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(id : ident) (m : memory_chunk) (a : addressing) (e : exprlist) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : add_instr (Iload m a x rd nd) s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_exprlist map e x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_exprlist (st_code s') map nil e ns x0 x.","proofString":"eapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(id : ident) (c : condexpr) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_expr map a2 rd nd s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr map a1 rd nd s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_condexpr map c x0 x s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s') map nil (Econdition c a1 a2) ns nd rd (Some id).","proofString":"econstructor; eauto with rtlg.\neapply transl_condexpr_charact; eauto with rtlg.\napply tr_expr_incr with s1; auto.\neapply IHa1; eauto 2 with rtlg.\napply tr_expr_incr with s0; auto.\neapply IHa2; eauto 2 with rtlg."},{"statement":"(id : ident) (c : condexpr) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_expr map a2 rd nd s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr map a1 rd nd s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_condexpr map c x0 x s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s1) map nil a1 x0 nd rd (Some id).","proofString":"eapply IHa1; eauto 2 with rtlg."},{"statement":"(id : ident) (c : condexpr) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_expr map a2 rd nd s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr map a1 rd nd s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_condexpr map c x0 x s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s0) map nil a2 x nd rd (Some id).","proofString":"eapply IHa2; eauto 2 with rtlg."},{"statement":"(id : ident) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr (add_letvar map x) a2 rd nd s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_expr map a1 x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s') map nil (Elet a1 a2) ns nd rd (Some id).","proofString":"econstructor.\neapply new_reg_not_in_map; eauto with rtlg.\neapply transl_expr_charact; eauto 3 with rtlg.\napply tr_expr_incr with s1; auto.\neapply IHa2; eauto.\napply add_letvar_valid; eauto with rtlg.\ninv OK.\nconstructor.\nauto."},{"statement":"(id : ident) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr (add_letvar map x) a2 rd nd s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_expr map a1 x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s1) (add_letvar map x) nil a2 x0 nd rd (Some id).","proofString":"eapply IHa2; eauto.\napply add_letvar_valid; eauto with rtlg.\ninv OK.\nconstructor.\nauto."},{"statement":"(id : ident) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr (add_letvar map x) a2 rd nd s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_expr map a1 x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : map_valid (add_letvar map x) s0.","proofString":"apply add_letvar_valid; eauto with rtlg."},{"statement":"(id : ident) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = RTLgen.OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr (add_letvar map x) a2 rd nd s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_expr map a1 x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : reg_map_ok (add_letvar map x) rd (Some id).","proofString":"inv OK.\nconstructor.\nauto."},{"statement":"(id : ident) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr (add_letvar map x) a2 rd nd s0 = OK x0 s1 INCR2) (EQ2 : transl_expr map a1 x x0 s1 = OK ns s' INCR3) (INCR4 : state_incr s s1) (H2 : (map_vars map) ! id = Some rd) : reg_map_ok (add_letvar map x) rd (Some id).","proofString":"constructor.\nauto."},{"statement":"(id : ident) (a1 a2 : expr) (IHa1 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a1 rd0 nd0 s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a1 ns0 nd0 rd0 (Some id)) (IHa2 : forall (map0 : mapping) (rd0 : reg) (nd0 : node) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_expr map0 a2 rd0 nd0 s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 ->\nreg_map_ok map0 rd0 (Some id) ->\ntr_expr (st_code s'0) map0 nil a2 ns0 nd0 rd0 (Some id)) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_expr (add_letvar map x) a2 rd nd s0 = OK x0 s1 INCR2) (EQ2 : transl_expr map a1 x x0 s1 = OK ns s' INCR3) (INCR4 : state_incr s s1) (H2 : (map_vars map) ! id = Some rd) : (map_vars (add_letvar map x)) ! id = Some rd.","proofString":"auto."},{"statement":"(id : ident) (n : nat) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : find_letvar map n s = RTLgen.OK x s0 INCR0) (EQ0 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id).","proofString":"generalize EQ; unfold find_letvar.\ncaseEq (nth_error (map_letvars map) n); intros; inv EQ0.\nmonadInv EQ1.\neconstructor; eauto with rtlg.\neapply add_move_charact; eauto.\nmonadInv EQ1."},{"statement":"(id : ident) (n : nat) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : find_letvar map n s = RTLgen.OK x s0 INCR0) (r : reg) (H : nth_error (map_letvars map) n = Some r) (EQ1 : ret r s = RTLgen.OK x s0 INCR0) (H1 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id).","proofString":"monadInv EQ1.\neconstructor; eauto with rtlg.\neapply add_move_charact; eauto."},{"statement":"(id : ident) (n : nat) (map : mapping) (rd : reg) (nd ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (WF : map_valid map s0) (INCR : state_incr s0 s') (OK : reg_map_ok map rd (Some id)) (x : reg) (INCR1 : state_incr s0 s') (EQ : find_letvar map n s0 = RTLgen.OK x s0 INCR0) (H : nth_error (map_letvars map) n = Some x) (H1 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id).","proofString":"econstructor; eauto with rtlg.\neapply add_move_charact; eauto."},{"statement":"(id : ident) (n : nat) (map : mapping) (rd : reg) (nd ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (WF : map_valid map s0) (INCR : state_incr s0 s') (OK : reg_map_ok map rd (Some id)) (x : reg) (INCR1 : state_incr s0 s') (EQ : find_letvar map n s0 = RTLgen.OK x s0 INCR0) (H : nth_error (map_letvars map) n = Some x) (H1 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) : tr_move (st_code s') ns x nd rd.","proofString":"eapply add_move_charact; eauto."},{"statement":"(id : ident) (n : nat) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : find_letvar map n s = RTLgen.OK x s0 INCR0) (H : nth_error (map_letvars map) n = None) (EQ1 : error (Errors.msg \"RTLgen: unbound let variable\") s = RTLgen.OK x s0 INCR0) (H1 : add_move x rd nd s0 = RTLgen.OK ns s' INCR1) : tr_expr (st_code s') map nil (Eletvar n) ns nd rd (Some id).","proofString":"monadInv EQ1."},{"statement":"(id : ident) (e : external_function) (e0 : exprlist) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e0 s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : add_instr (Ibuiltin e (List.map (BA (A:=reg)) x) (BR rd) nd) s0 =\nRTLgen.OK x0 s1 INCR2) (EQ2 : transl_exprlist map e0 x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_expr (st_code s') map nil (Ebuiltin e e0) ns nd rd (Some id).","proofString":"econstructor; eauto with rtlg.\neapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(id : ident) (e : external_function) (e0 : exprlist) (map : mapping) (rd : reg) (nd : node) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e0 s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : add_instr (Ibuiltin e (List.map (BA (A:=reg)) x) (BR rd) nd) s0 =\nRTLgen.OK x0 s1 INCR2) (EQ2 : transl_exprlist map e0 x x0 s1 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_exprlist (st_code s') map nil e0 ns x0 x.","proofString":"eapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(id i : ident) (s : signature) (e : exprlist) (map : mapping) (rd : reg) (nd : node) (s0 : state) (ns : node) (s' : state) (INCR : state_incr s0 s') (WF : map_valid map s0) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s1 : state) (INCR0 : state_incr s0 s1) (INCR1 : state_incr s1 s') (EQ : alloc_regs map e s0 = RTLgen.OK x s1 INCR0) (x0 : node) (s2 : state) (INCR2 : state_incr s1 s2) (INCR3 : state_incr s2 s') (EQ1 : add_instr (Icall s (inr i) x rd nd) s1 = RTLgen.OK x0 s2 INCR2) (EQ2 : transl_exprlist map e x x0 s2 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s0 s2) : tr_expr (st_code s') map nil (Eexternal i s e) ns nd rd (Some id).","proofString":"econstructor; eauto with rtlg.\neapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(id i : ident) (s : signature) (e : exprlist) (map : mapping) (rd : reg) (nd : node) (s0 : state) (ns : node) (s' : state) (INCR : state_incr s0 s') (WF : map_valid map s0) (OK : reg_map_ok map rd (Some id)) (x : list reg) (s1 : state) (INCR0 : state_incr s0 s1) (INCR1 : state_incr s1 s') (EQ : alloc_regs map e s0 = RTLgen.OK x s1 INCR0) (x0 : node) (s2 : state) (INCR2 : state_incr s1 s2) (INCR3 : state_incr s2 s') (EQ1 : add_instr (Icall s (inr i) x rd nd) s1 = RTLgen.OK x0 s2 INCR2) (EQ2 : transl_exprlist map e x x0 s2 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s0 s2) : tr_exprlist (st_code s') map nil e ns x0 x.","proofString":"eapply transl_exprlist_charact; eauto with rtlg."},{"statement":"(map : mapping) (optid : option ident) (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : match optid with\n| Some id => find_var map id\n| None => new_reg\nend s1 = OK r s2 i) : reg_map_ok map r optid.","proofString":"destruct optid.\nconstructor.\nunfold find_var in H0.\ndestruct (map_vars map)!i0; monadInv H0.\nauto.\nconstructor.\neapply new_reg_not_in_map; eauto."},{"statement":"(map : mapping) (i0 : ident) (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : find_var map i0 s1 = OK r s2 i) : reg_map_ok map r (Some i0).","proofString":"constructor.\nunfold find_var in H0.\ndestruct (map_vars map)!i0; monadInv H0.\nauto."},{"statement":"(map : mapping) (i0 : ident) (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : find_var map i0 s1 = OK r s2 i) : (map_vars map) ! i0 = Some r.","proofString":"unfold find_var in H0.\ndestruct (map_vars map)!i0; monadInv H0.\nauto."},{"statement":"(map : mapping) (i0 : ident) (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : match (map_vars map) ! i0 with\n| Some r0 => ret r0\n| None =>\n    error (Errors.MSG \"RTLgen: unbound variable \" :: Errors.CTX i0 :: nil)\nend s1 = OK r s2 i) : (map_vars map) ! i0 = Some r.","proofString":"destruct (map_vars map)!i0; monadInv H0.\nauto."},{"statement":"(map : mapping) (i0 : ident) (r : reg) (s2 : state) (H : map_valid map s2) (i : state_incr s2 s2) : Some r = Some r.","proofString":"auto."},{"statement":"(map : mapping) (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : new_reg s1 = OK r s2 i) : reg_map_ok map r None.","proofString":"constructor.\neapply new_reg_not_in_map; eauto."},{"statement":"(map : mapping) (s1 : state) (r : reg) (s2 : state) (i : state_incr s1 s2) (H : map_valid map s1) (H0 : new_reg s1 = OK r s2 i) : ~ reg_in_map map r.","proofString":"eapply new_reg_not_in_map; eauto."},{"statement":"(s1 s2 : state) (EXT : state_incr s1 s2) : forall (map : mapping) (a : exitexpr) (ns : node) (nexits : list node),\ntr_exitexpr (st_code s1) map a ns nexits ->\ntr_exitexpr (st_code s2) map a ns nexits.","proofString":"generalize tr_expr_incr tr_condition_incr; intros I1 I2.\ninduction 1; econstructor; eauto with rtlg."},{"statement":"(s1 s2 : state) (EXT : state_incr s1 s2) (I1 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (a : expr) \n  (ns nd : node) (rd : reg) (dst : option ident),\ntr_expr (st_code s0) map pr a ns nd rd dst ->\ntr_expr (st_code s3) map pr a ns nd rd dst) (I2 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (a : condexpr)\n  (ns ntrue nfalse : node),\ntr_condition (st_code s0) map pr a ns ntrue nfalse ->\ntr_condition (st_code s3) map pr a ns ntrue nfalse) : forall (map : mapping) (a : exitexpr) (ns : node) (nexits : list node),\ntr_exitexpr (st_code s1) map a ns nexits ->\ntr_exitexpr (st_code s2) map a ns nexits.","proofString":"induction 1; econstructor; eauto with rtlg."},{"statement":"(s1 s2 : state) (EXT : state_incr s1 s2) : forall (map : mapping) (s : stmt) (ns nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg),\ntr_stmt (st_code s1) map s ns nd nexits ngoto nret rret ->\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret.","proofString":"generalize tr_expr_incr tr_condition_incr tr_exprlist_incr tr_exitexpr_incr; intros I1 I2 I3 I4.\npose (AT := fun pc i => instr_at_incr s1 s2 pc i EXT).\ninduction 1; econstructor; eauto."},{"statement":"(s1 s2 : state) (EXT : state_incr s1 s2) (I1 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (a : expr) \n  (ns nd : node) (rd : reg) (dst : option ident),\ntr_expr (st_code s0) map pr a ns nd rd dst ->\ntr_expr (st_code s3) map pr a ns nd rd dst) (I2 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (a : condexpr)\n  (ns ntrue nfalse : node),\ntr_condition (st_code s0) map pr a ns ntrue nfalse ->\ntr_condition (st_code s3) map pr a ns ntrue nfalse) (I3 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (al : exprlist) \n  (ns nd : node) (rl : list reg),\ntr_exprlist (st_code s0) map pr al ns nd rl ->\ntr_exprlist (st_code s3) map pr al ns nd rl) (I4 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (a : exitexpr) (ns : node) (nexits : list node),\ntr_exitexpr (st_code s0) map a ns nexits ->\ntr_exitexpr (st_code s3) map a ns nexits) : forall (map : mapping) (s : stmt) (ns nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg),\ntr_stmt (st_code s1) map s ns nd nexits ngoto nret rret ->\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret.","proofString":"pose (AT := fun pc i => instr_at_incr s1 s2 pc i EXT).\ninduction 1; econstructor; eauto."},{"statement":"(s1 s2 : state) (EXT : state_incr s1 s2) (I1 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (a : expr) \n  (ns nd : node) (rd : reg) (dst : option ident),\ntr_expr (st_code s0) map pr a ns nd rd dst ->\ntr_expr (st_code s3) map pr a ns nd rd dst) (I2 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (a : condexpr)\n  (ns ntrue nfalse : node),\ntr_condition (st_code s0) map pr a ns ntrue nfalse ->\ntr_condition (st_code s3) map pr a ns ntrue nfalse) (I3 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (pr : list reg) (al : exprlist) \n  (ns nd : node) (rl : list reg),\ntr_exprlist (st_code s0) map pr al ns nd rl ->\ntr_exprlist (st_code s3) map pr al ns nd rl) (I4 : forall s0 s3 : state,\nstate_incr s0 s3 ->\nforall (map : mapping) (a : exitexpr) (ns : node) (nexits : list node),\ntr_exitexpr (st_code s0) map a ns nexits ->\ntr_exitexpr (st_code s3) map a ns nexits) (AT : forall (pc : positive) (i : instruction),\n(st_code s1) ! pc = Some i -> (st_code s2) ! pc = Some i) : forall (map : mapping) (s : stmt) (ns nd : node) (nexits : list node)\n  (ngoto : labelmap) (nret : node) (rret : option reg),\ntr_stmt (st_code s1) map s ns nd nexits ngoto nret rret ->\ntr_stmt (st_code s2) map s ns nd nexits ngoto nret rret.","proofString":"induction 1; econstructor; eauto."},{"statement":"(nexits : list node) (n : nat) (s : state) (ne : node) (s' : state) (incr : state_incr s s') : transl_exit nexits n s = OK ne s' incr ->\nnth_error nexits n = Some ne /\\ s' = s.","proofString":"unfold transl_exit.\ndestruct (nth_error nexits n); intro; monadInv H.\nauto."},{"statement":"(nexits : list node) (n : nat) (s : state) (ne : node) (s' : state) (incr : state_incr s s') : match nth_error nexits n with\n| Some ne0 => ret ne0\n| None => error (Errors.msg \"RTLgen: wrong exit\")\nend s = OK ne s' incr -> nth_error nexits n = Some ne /\\ s' = s.","proofString":"destruct (nth_error nexits n); intro; monadInv H.\nauto."},{"statement":"(nexits : list node) (n : nat) (ne : node) (s' : state) (incr : state_incr s' s') : Some ne = Some ne /\\ s' = s'.","proofString":"auto."},{"statement":"(nexits : list node) (s : state) (nl : list node) (s' : state) (incr : state_incr s s') (H : transl_jumptable nexits nil s = OK nl s' incr) : tr_jumptable nexits nil nl /\\ s' = s.","proofString":"monadInv H.\nsplit.\nred.\nsimpl.\nintros.\ndiscriminate.\nauto."},{"statement":"(nexits : list node) (s' : state) (incr : state_incr s' s') : tr_jumptable nexits nil nil /\\ s' = s'.","proofString":"split.\nred.\nsimpl.\nintros.\ndiscriminate.\nauto."},{"statement":"(nexits : list node) (s' : state) (incr : state_incr s' s') : tr_jumptable nexits nil nil.","proofString":"red.\nsimpl.\nintros.\ndiscriminate."},{"statement":"(nexits : list node) (s' : state) (incr : state_incr s' s') : forall (v : Z) (act : nat),\nlist_nth_z nil v = Some act ->\nexists n : node, list_nth_z nil v = Some n /\\ nth_error nexits act = Some n.","proofString":"simpl.\nintros.\ndiscriminate."},{"statement":"(nexits : list node) (s' : state) (incr : state_incr s' s') : Z ->\nforall act : nat,\nNone = Some act ->\nexists n : node, None = Some n /\\ nth_error nexits act = Some n.","proofString":"intros.\ndiscriminate."},{"statement":"(nexits : list node) (s' : state) (incr : state_incr s' s') (v : Z) (act : nat) (H : None = Some act) : exists n : node, None = Some n /\\ nth_error nexits act = Some n.","proofString":"discriminate."},{"statement":"(nexits : list node) (s' : state) (incr : state_incr s' s') : s' = s'.","proofString":"auto."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s0 : state) (nl0 : list node) (s'0 : state)\n  (incr0 : state_incr s0 s'0),\ntransl_jumptable nexits tbl s0 = OK nl0 s'0 incr0 ->\ntr_jumptable nexits tbl nl0 /\\ s'0 = s0) (s : state) (nl : list node) (s' : state) (incr : state_incr s s') (H : transl_jumptable nexits (a :: tbl) s = OK nl s' incr) : tr_jumptable nexits (a :: tbl) nl /\\ s' = s.","proofString":"monadInv H.\nexploit transl_exit_charact; eauto.\nintros [A B].\nexploit IHtbl; eauto.\nintros [C D].\nsplit.\nred.\nsimpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto.\ncongruence."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') : tr_jumptable nexits (a :: tbl) (x :: x0) /\\ s' = s.","proofString":"exploit transl_exit_charact; eauto.\nintros [A B].\nexploit IHtbl; eauto.\nintros [C D].\nsplit.\nred.\nsimpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto.\ncongruence."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') : nth_error nexits a = Some x /\\ s0 = s ->\ntr_jumptable nexits (a :: tbl) (x :: x0) /\\ s' = s.","proofString":"intros [A B].\nexploit IHtbl; eauto.\nintros [C D].\nsplit.\nred.\nsimpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto.\ncongruence."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) : tr_jumptable nexits (a :: tbl) (x :: x0) /\\ s' = s.","proofString":"exploit IHtbl; eauto.\nintros [C D].\nsplit.\nred.\nsimpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto.\ncongruence."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) : tr_jumptable nexits tbl x0 /\\ s' = s0 ->\ntr_jumptable nexits (a :: tbl) (x :: x0) /\\ s' = s.","proofString":"intros [C D].\nsplit.\nred.\nsimpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto.\ncongruence."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) : tr_jumptable nexits (a :: tbl) (x :: x0) /\\ s' = s.","proofString":"split.\nred.\nsimpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto.\ncongruence."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) : tr_jumptable nexits (a :: tbl) (x :: x0).","proofString":"red.\nsimpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) : forall (v : Z) (act : nat),\nlist_nth_z (a :: tbl) v = Some act ->\nexists n : node,\n  list_nth_z (x :: x0) v = Some n /\\ nth_error nexits act = Some n.","proofString":"simpl.\nintros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) : forall (v : Z) (act : nat),\n(if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) = Some act ->\nexists n : node,\n  (if zeq v 0 then Some x else list_nth_z x0 (Z.pred v)) = Some n /\\\n  nth_error nexits act = Some n.","proofString":"intros.\ndestruct (zeq v 0).\ninv H.\nexists x; auto.\nauto."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) (v : Z) (act : nat) (H : (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) = Some act) : exists n : node,\n  (if zeq v 0 then Some x else list_nth_z x0 (Z.pred v)) = Some n /\\\n  nth_error nexits act = Some n.","proofString":"destruct (zeq v 0).\ninv H.\nexists x; auto.\nauto."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) (v : Z) (act : nat) (e : v = 0) (H : Some a = Some act) : exists n : node, Some x = Some n /\\ nth_error nexits act = Some n.","proofString":"inv H.\nexists x; auto."},{"statement":"(nexits : list node) (tbl : list nat) (IHtbl : forall (s0 : state) (nl : list node) (s' : state) (incr0 : state_incr s0 s'),\ntransl_jumptable nexits tbl s0 = OK nl s' incr0 ->\ntr_jumptable nexits tbl nl /\\ s' = s0) (s : state) (incr : state_incr s s) (x : node) (INCR : state_incr s s) (act : nat) (EQ : transl_exit nexits act s = OK x s INCR) (INCR0 : state_incr s s) (x0 : list node) (INCR2 INCR1 : state_incr s s) (EQ1 : transl_jumptable nexits tbl s = OK x0 s INCR1) (A : nth_error nexits act = Some x) (C : tr_jumptable nexits tbl x0) : exists n : node, Some x = Some n /\\ nth_error nexits act = Some n.","proofString":"exists x; auto."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) (v : Z) (act : nat) (n : v <> 0) (H : list_nth_z tbl (Z.pred v) = Some act) : exists n0 : node,\n  list_nth_z x0 (Z.pred v) = Some n0 /\\ nth_error nexits act = Some n0.","proofString":"auto."},{"statement":"(nexits : list node) (a : nat) (tbl : list nat) (IHtbl : forall (s1 : state) (nl : list node) (s'0 : state)\n  (incr0 : state_incr s1 s'0),\ntransl_jumptable nexits tbl s1 = OK nl s'0 incr0 ->\ntr_jumptable nexits tbl nl /\\ s'0 = s1) (s s' : state) (incr : state_incr s s') (x : node) (s0 : state) (INCR : state_incr s s0) (INCR0 : state_incr s0 s') (EQ : transl_exit nexits a s = OK x s0 INCR) (x0 : list node) (INCR1 : state_incr s0 s') (EQ1 : transl_jumptable nexits tbl s0 = OK x0 s' INCR1) (INCR2 : state_incr s' s') (A : nth_error nexits a = Some x) (B : s0 = s) (C : tr_jumptable nexits tbl x0) (D : s' = s0) : s' = s.","proofString":"congruence."},{"statement":"(nexits : list node) (n : nat) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exit nexits n s = OK ns s' INCR) (WF : map_valid map s) : tr_exitexpr (st_code s') map (XEexit n) ns nexits.","proofString":"exploit transl_exit_charact; eauto.\nintros [A B].\neconstructor; eauto."},{"statement":"(nexits : list node) (n : nat) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exit nexits n s = OK ns s' INCR) (WF : map_valid map s) : nth_error nexits n = Some ns /\\ s' = s ->\ntr_exitexpr (st_code s') map (XEexit n) ns nexits.","proofString":"intros [A B].\neconstructor; eauto."},{"statement":"(nexits : list node) (n : nat) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exit nexits n s = OK ns s' INCR) (WF : map_valid map s) (A : nth_error nexits n = Some ns) (B : s' = s) : tr_exitexpr (st_code s') map (XEexit n) ns nexits.","proofString":"econstructor; eauto."},{"statement":"(nexits : list node) (e : expr) (l : list nat) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map e s = OK x s0 INCR0) (x0 : list node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_jumptable nexits l s0 = OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Ijumptable x x0) s1 = OK x1 s2 INCR4) (EQ3 : transl_expr map e x x1 s2 = OK ns s' INCR5) (INCR6 : state_incr s0 s2) (INCR7 : state_incr s s2) (INCR8 : state_incr s s1) : tr_exitexpr (st_code s') map (XEjumptable e l) ns nexits.","proofString":"exploit transl_jumptable_charact; eauto.\nintros [A B].\neconstructor; eauto.\neapply transl_expr_charact; eauto with rtlg.\neauto with rtlg."},{"statement":"(nexits : list node) (e : expr) (l : list nat) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map e s = OK x s0 INCR0) (x0 : list node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_jumptable nexits l s0 = OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Ijumptable x x0) s1 = OK x1 s2 INCR4) (EQ3 : transl_expr map e x x1 s2 = OK ns s' INCR5) (INCR6 : state_incr s0 s2) (INCR7 : state_incr s s2) (INCR8 : state_incr s s1) : tr_jumptable nexits l x0 /\\ s1 = s0 ->\ntr_exitexpr (st_code s') map (XEjumptable e l) ns nexits.","proofString":"intros [A B].\neconstructor; eauto.\neapply transl_expr_charact; eauto with rtlg.\neauto with rtlg."},{"statement":"(nexits : list node) (e : expr) (l : list nat) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map e s = OK x s0 INCR0) (x0 : list node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_jumptable nexits l s0 = OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Ijumptable x x0) s1 = OK x1 s2 INCR4) (EQ3 : transl_expr map e x x1 s2 = OK ns s' INCR5) (INCR6 : state_incr s0 s2) (INCR7 : state_incr s s2) (INCR8 : state_incr s s1) (A : tr_jumptable nexits l x0) (B : s1 = s0) : tr_exitexpr (st_code s') map (XEjumptable e l) ns nexits.","proofString":"econstructor; eauto.\neapply transl_expr_charact; eauto with rtlg.\neauto with rtlg."},{"statement":"(nexits : list node) (c : condexpr) (a1 a2 : exitexpr) (IHa1 : forall (map0 : mapping) (s2 : state) (ns0 : node) \n  (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_exitexpr map0 a1 nexits s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 -> tr_exitexpr (st_code s'0) map0 a1 ns0 nexits) (IHa2 : forall (map0 : mapping) (s2 : state) (ns0 : node) \n  (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_exitexpr map0 a2 nexits s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 -> tr_exitexpr (st_code s'0) map0 a2 ns0 nexits) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_exitexpr map a2 nexits s = OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_exitexpr map a1 nexits s0 = OK x0 s1 INCR2) (EQ2 : transl_condexpr map c x0 x s1 = OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_exitexpr (st_code s') map (XEcondition c a1 a2) ns nexits.","proofString":"econstructor.\neapply transl_condexpr_charact; eauto with rtlg.\napply tr_exitexpr_incr with s1; eauto with rtlg.\napply tr_exitexpr_incr with s0; eauto with rtlg."},{"statement":"(nexits : list node) (e : expr) (a : exitexpr) (IHa : forall (map0 : mapping) (s2 : state) (ns0 : node) \n  (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_exitexpr map0 a nexits s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 -> tr_exitexpr (st_code s'0) map0 a ns0 nexits) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_exitexpr (add_letvar map x) a nexits s0 = OK x0 s1 INCR2) (EQ2 : transl_expr map e x x0 s1 = OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_exitexpr (st_code s') map (XElet e a) ns nexits.","proofString":"econstructor; eauto with rtlg.\neapply transl_expr_charact; eauto with rtlg.\napply tr_exitexpr_incr with s1; auto.\neapply IHa; eauto with rtlg.\napply add_letvar_valid; eauto with rtlg."},{"statement":"(nexits : list node) (e : expr) (a : exitexpr) (IHa : forall (map0 : mapping) (s2 : state) (ns0 : node) \n  (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_exitexpr map0 a nexits s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 -> tr_exitexpr (st_code s'0) map0 a ns0 nexits) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_exitexpr (add_letvar map x) a nexits s0 = OK x0 s1 INCR2) (EQ2 : transl_expr map e x x0 s1 = OK ns s' INCR3) (INCR4 : state_incr s s1) : tr_exitexpr (st_code s1) (add_letvar map x) a x0 nexits.","proofString":"eapply IHa; eauto with rtlg.\napply add_letvar_valid; eauto with rtlg."},{"statement":"(nexits : list node) (e : expr) (a : exitexpr) (IHa : forall (map0 : mapping) (s2 : state) (ns0 : node) \n  (s'0 : state) (INCR5 : state_incr s2 s'0),\ntransl_exitexpr map0 a nexits s2 = OK ns0 s'0 INCR5 ->\nmap_valid map0 s2 -> tr_exitexpr (st_code s'0) map0 a ns0 nexits) (map : mapping) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : new_reg s = OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_exitexpr (add_letvar map x) a nexits s0 = OK x0 s1 INCR2) (EQ2 : transl_expr map e x x0 s1 = OK ns s' INCR3) (INCR4 : state_incr s s1) : map_valid (add_letvar map x) s0.","proofString":"apply add_letvar_valid; eauto with rtlg."},{"statement":"(map : mapping) (oty : xtype) (x : ident) (s : state) (res' : builtin_res reg) (s' : state) (INCR : state_incr s s') (TR : (do r <- find_var map x; ret (BR r)) s = OK res' s' INCR) (WF : map_valid map s) : tr_builtin_res map (BR x) res'.","proofString":"monadInv TR.\nconstructor.\nunfold find_var in EQ.\ndestruct (map_vars map)!x; inv EQ; auto."},{"statement":"(map : mapping) (oty : xtype) (x : ident) (s s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x0 : reg) (INCR0 : state_incr s s') (EQ : find_var map x s = OK x0 s' INCR0) (INCR1 : state_incr s' s') : tr_builtin_res map (BR x) (BR x0).","proofString":"constructor.\nunfold find_var in EQ.\ndestruct (map_vars map)!x; inv EQ; auto."},{"statement":"(map : mapping) (oty : xtype) (x : ident) (s s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x0 : reg) (INCR0 : state_incr s s') (EQ : find_var map x s = OK x0 s' INCR0) (INCR1 : state_incr s' s') : (map_vars map) ! x = Some x0.","proofString":"unfold find_var in EQ.\ndestruct (map_vars map)!x; inv EQ; auto."},{"statement":"(map : mapping) (oty : xtype) (x : ident) (s s' : state) (INCR : state_incr s s') (WF : map_valid map s) (x0 : reg) (INCR0 : state_incr s s') (EQ : match (map_vars map) ! x with\n| Some r => ret r\n| None =>\n    error (Errors.MSG \"RTLgen: unbound variable \" :: Errors.CTX x :: nil)\nend s = OK x0 s' INCR0) (INCR1 : state_incr s' s') : (map_vars map) ! x = Some x0.","proofString":"destruct (map_vars map)!x; inv EQ; auto."},{"statement":"(map : mapping) (oty : xtype) (s : state) (res' : builtin_res reg) (s' : state) (INCR : state_incr s s') (TR : (if xtype_eq oty Xvoid then ret BR_none else do r <- new_reg; ret (BR r)) s =\nOK res' s' INCR) (WF : map_valid map s) : tr_builtin_res map BR_none res'.","proofString":"destruct (xtype_eq oty Xvoid); monadInv TR.\nconstructor.\nconstructor.\neauto with rtlg."},{"statement":"(map : mapping) (s' : state) (WF : map_valid map s') (INCR : state_incr s' s') : tr_builtin_res map BR_none BR_none.","proofString":"constructor."},{"statement":"(map : mapping) (oty : xtype) (s s' : state) (INCR : state_incr s s') (n : oty <> Xvoid) (WF : map_valid map s) (x : reg) (INCR0 : state_incr s s') (EQ : new_reg s = OK x s' INCR0) (INCR1 : state_incr s' s') : tr_builtin_res map BR_none (BR x).","proofString":"constructor.\neauto with rtlg."},{"statement":"(map : mapping) (oty : xtype) (s s' : state) (INCR : state_incr s s') (n : oty <> Xvoid) (WF : map_valid map s) (x : reg) (INCR0 : state_incr s s') (EQ : new_reg s = OK x s' INCR0) (INCR1 : state_incr s' s') : ~ reg_in_map map x.","proofString":"eauto with rtlg."},{"statement":"(map : mapping) (oty : xtype) (res1 res2 : builtin_res ident) (s : state) (res' : builtin_res reg) (s' : state) (INCR : state_incr s s') (TR : error (Errors.msg \"RTLgen: bad builtin_res\") s = OK res' s' INCR) (WF : map_valid map s) : tr_builtin_res map (BR_splitlong res1 res2) res'.","proofString":"monadInv TR."},{"statement":"(map : mapping) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (ns : node) (s' : state) (OK : return_reg_ok s' map rret) (WF : map_valid map s') (INCR : state_incr s' s') : tr_stmt (st_code s') map Sskip ns ns nexits ngoto nret rret.","proofString":"constructor."},{"statement":"(map : mapping) (i : ident) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : find_var map i s = RTLgen.OK x s0 INCR0) (EQ0 : transl_expr map e x nd s0 = RTLgen.OK ns s' INCR1) : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret.","proofString":"revert EQ.\nunfold find_var.\ncase_eq (map_vars map)!i; intros; monadInv EQ.\neapply tr_Sassign; eauto.\neapply transl_expr_assign_charact; eauto with rtlg.\nconstructor.\nauto."},{"statement":"(map : mapping) (i : ident) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (OK : return_reg_ok s0 map rret) (WF : map_valid map s0) (INCR : state_incr s0 s') (x : reg) (INCR1 : state_incr s0 s') (EQ0 : transl_expr map e x nd s0 = RTLgen.OK ns s' INCR1) (H : (map_vars map) ! i = Some x) : tr_stmt (st_code s') map (Sassign i e) ns nd nexits ngoto nret rret.","proofString":"eapply tr_Sassign; eauto.\neapply transl_expr_assign_charact; eauto with rtlg.\nconstructor.\nauto."},{"statement":"(map : mapping) (i : ident) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (OK : return_reg_ok s0 map rret) (WF : map_valid map s0) (INCR : state_incr s0 s') (x : reg) (INCR1 : state_incr s0 s') (EQ0 : transl_expr map e x nd s0 = RTLgen.OK ns s' INCR1) (H : (map_vars map) ! i = Some x) : tr_expr (st_code s') map nil e ns nd x (Some i).","proofString":"eapply transl_expr_assign_charact; eauto with rtlg.\nconstructor.\nauto."},{"statement":"(map : mapping) (i : ident) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (OK : return_reg_ok s0 map rret) (WF : map_valid map s0) (INCR : state_incr s0 s') (x : reg) (INCR1 : state_incr s0 s') (EQ0 : transl_expr map e x nd s0 = RTLgen.OK ns s' INCR1) (H : (map_vars map) ! i = Some x) : reg_map_ok map x (Some i).","proofString":"constructor.\nauto."},{"statement":"(map : mapping) (i : ident) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (ns : node) (s' s0 : state) (INCR0 : state_incr s0 s0) (OK : return_reg_ok s0 map rret) (WF : map_valid map s0) (INCR : state_incr s0 s') (x : reg) (INCR1 : state_incr s0 s') (EQ0 : transl_expr map e x nd s0 = RTLgen.OK ns s' INCR1) (H : (map_vars map) ! i = Some x) : (map_vars map) ! i = Some x.","proofString":"auto."},{"statement":"(map : mapping) (m : memory_chunk) (a : addressing) (e : exprlist) (e0 : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s = RTLgen.OK x s0 INCR0) (x0 : reg) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : alloc_reg map e0 s0 = RTLgen.OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Istore m a x x0 nd) s1 = RTLgen.OK x1 s2 INCR4) (x2 : node) (s3 : state) (INCR6 : state_incr s2 s3) (INCR7 : state_incr s3 s') (EQ2 : transl_expr map e0 x0 x1 s2 = RTLgen.OK x2 s3 INCR6) (EQ4 : transl_exprlist map e x x2 s3 = RTLgen.OK ns s' INCR7) (INCR8 : state_incr s1 s3) (INCR9 : state_incr s0 s3) (INCR10 : state_incr s s3) (INCR11 : state_incr s0 s2) (INCR12 : state_incr s s2) (INCR13 : state_incr s s1) : tr_stmt (st_code s') map (Sstore m a e e0) ns nd nexits ngoto nret rret.","proofString":"econstructor; eauto with rtlg.\neapply transl_exprlist_charact; eauto 3 with rtlg.\napply tr_expr_incr with s3; auto.\neapply transl_expr_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (m : memory_chunk) (a : addressing) (e : exprlist) (e0 : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s = RTLgen.OK x s0 INCR0) (x0 : reg) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : alloc_reg map e0 s0 = RTLgen.OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Istore m a x x0 nd) s1 = RTLgen.OK x1 s2 INCR4) (x2 : node) (s3 : state) (INCR6 : state_incr s2 s3) (INCR7 : state_incr s3 s') (EQ2 : transl_expr map e0 x0 x1 s2 = RTLgen.OK x2 s3 INCR6) (EQ4 : transl_exprlist map e x x2 s3 = RTLgen.OK ns s' INCR7) (INCR8 : state_incr s1 s3) (INCR9 : state_incr s0 s3) (INCR10 : state_incr s s3) (INCR11 : state_incr s0 s2) (INCR12 : state_incr s s2) (INCR13 : state_incr s s1) : tr_expr (st_code s3) map x e0 x2 x1 x0 None.","proofString":"eapply transl_expr_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (s0 : expr + ident) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (TR : match s0 with\n| inl b =>\n    do rf <- alloc_reg map b;\n    do rargs <- alloc_regs map e;\n    do r <- alloc_optreg map o;\n    do n1 <- add_instr (Icall s (inl rf) rargs r nd);\n    do n2 <- transl_exprlist map e rargs n1; transl_expr map b rf n2\n| inr id =>\n    do rargs <- alloc_regs map e;\n    do r <- alloc_optreg map o;\n    do n1 <- add_instr (Icall s (inr id) rargs r nd);\n    transl_exprlist map e rargs n1\nend s1 = RTLgen.OK ns s' INCR) (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) : tr_stmt (st_code s') map (Scall o s s0 e) ns nd nexits ngoto nret rret.","proofString":"destruct s0 as [b | id]; monadInv TR; saturateTrans.\neconstructor; eauto 4 with rtlg.\neapply transl_expr_charact; eauto 3 with rtlg.\napply tr_exprlist_incr with s5.\nauto.\neapply transl_exprlist_charact; eauto 3 with rtlg.\neapply alloc_regs_target_ok with (s1 := s0); eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg.\napply regs_valid_incr with s0; eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg.\napply regs_valid_incr with s2; eauto 3 with rtlg.\neapply alloc_optreg_map_ok with (s1 := s2); eauto 3 with rtlg.\neconstructor; eauto 4 with rtlg.\neapply transl_exprlist_charact; eauto 3 with rtlg.\neapply alloc_optreg_map_ok with (s1 := s0); eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : tr_stmt (st_code s') map (Scall o s (inl b) e) ns nd nexits ngoto nret rret.","proofString":"econstructor; eauto 4 with rtlg.\neapply transl_expr_charact; eauto 3 with rtlg.\napply tr_exprlist_incr with s5.\nauto.\neapply transl_exprlist_charact; eauto 3 with rtlg.\neapply alloc_regs_target_ok with (s1 := s0); eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg.\napply regs_valid_incr with s0; eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg.\napply regs_valid_incr with s2; eauto 3 with rtlg.\neapply alloc_optreg_map_ok with (s1 := s2); eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : state_incr s5 s'.","proofString":"auto."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : tr_exprlist (st_code s5) map (x :: nil) e x3 x2 x0.","proofString":"eapply transl_exprlist_charact; eauto 3 with rtlg.\neapply alloc_regs_target_ok with (s1 := s0); eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg.\napply regs_valid_incr with s0; eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg.\napply regs_valid_incr with s2; eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : target_regs_ok map (x :: nil) e x0.","proofString":"eapply alloc_regs_target_ok with (s1 := s0); eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : regs_valid (x :: nil) s0.","proofString":"apply regs_valid_cons; eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : regs_valid (x :: nil) s4.","proofString":"apply regs_valid_incr with s0; eauto 3 with rtlg.\napply regs_valid_cons; eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : regs_valid (x :: nil) s0.","proofString":"apply regs_valid_cons; eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : regs_valid x0 s4.","proofString":"apply regs_valid_incr with s2; eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : reg) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : alloc_optreg map o s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : add_instr (Icall s (inl x) x0 x1 nd) s3 = RTLgen.OK x2 s4 INCR6) (x3 : node) (s5 : state) (INCR8 : state_incr s4 s5) (INCR9 : state_incr s5 s') (EQ3 : transl_exprlist map e x0 x2 s4 = RTLgen.OK x3 s5 INCR8) (EQ5 : transl_expr map b x x3 s5 = RTLgen.OK ns s' INCR9) (INCR10 : state_incr s3 s5) (INCR11 : state_incr s2 s5) (INCR12 : state_incr s0 s5) (INCR13 : state_incr s1 s5) (INCR14 : state_incr s2 s4) (INCR15 : state_incr s0 s4) (INCR16 : state_incr s1 s4) (INCR17 : state_incr s0 s3) (INCR18 : state_incr s1 s3) (INCR19 : state_incr s1 s2) : reg_map_ok map x1 o.","proofString":"eapply alloc_optreg_map_ok with (s1 := s2); eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (id : ident) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s1 = RTLgen.OK x s0 INCR0) (x0 : reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_optreg map o s0 = RTLgen.OK x0 s2 INCR2) (x1 : node) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : add_instr (Icall s (inr id) x x0 nd) s2 = RTLgen.OK x1 s3 INCR4) (EQ3 : transl_exprlist map e x x1 s3 = RTLgen.OK ns s' INCR5) (INCR6 : state_incr s0 s3) (INCR7 : state_incr s1 s3) (INCR8 : state_incr s1 s2) : tr_stmt (st_code s') map (Scall o s (inr id) e) ns nd nexits ngoto nret rret.","proofString":"econstructor; eauto 4 with rtlg.\neapply transl_exprlist_charact; eauto 3 with rtlg.\neapply alloc_optreg_map_ok with (s1 := s0); eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (id : ident) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s1 = RTLgen.OK x s0 INCR0) (x0 : reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_optreg map o s0 = RTLgen.OK x0 s2 INCR2) (x1 : node) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : add_instr (Icall s (inr id) x x0 nd) s2 = RTLgen.OK x1 s3 INCR4) (EQ3 : transl_exprlist map e x x1 s3 = RTLgen.OK ns s' INCR5) (INCR6 : state_incr s0 s3) (INCR7 : state_incr s1 s3) (INCR8 : state_incr s1 s2) : tr_exprlist (st_code s') map nil e ns x1 x.","proofString":"eapply transl_exprlist_charact; eauto 3 with rtlg."},{"statement":"(map : mapping) (o : option ident) (s : signature) (id : ident) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s1 = RTLgen.OK x s0 INCR0) (x0 : reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_optreg map o s0 = RTLgen.OK x0 s2 INCR2) (x1 : node) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : add_instr (Icall s (inr id) x x0 nd) s2 = RTLgen.OK x1 s3 INCR4) (EQ3 : transl_exprlist map e x x1 s3 = RTLgen.OK ns s' INCR5) (INCR6 : state_incr s0 s3) (INCR7 : state_incr s1 s3) (INCR8 : state_incr s1 s2) : reg_map_ok map x0 o.","proofString":"eapply alloc_optreg_map_ok with (s1 := s0); eauto 3 with rtlg."},{"statement":"(map : mapping) (s : signature) (s0 : expr + ident) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (TR : match s0 with\n| inl b =>\n    do rf <- alloc_reg map b;\n    do rargs <- alloc_regs map e;\n    do n1 <- add_instr (Itailcall s (inl rf) rargs);\n    do n2 <- transl_exprlist map e rargs n1; transl_expr map b rf n2\n| inr id =>\n    do rargs <- alloc_regs map e;\n    do n1 <- add_instr (Itailcall s (inr id) rargs);\n    transl_exprlist map e rargs n1\nend s1 = RTLgen.OK ns s' INCR) (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) : tr_stmt (st_code s') map (Stailcall s s0 e) ns nd nexits ngoto nret rret.","proofString":"destruct s0 as [b | id]; monadInv TR; saturateTrans.\nassert (RV: regs_valid (x :: nil) s0).\napply regs_valid_cons; eauto 3 with rtlg.\neconstructor; eauto 3 with rtlg.\neapply transl_expr_charact; eauto 3 with rtlg.\napply tr_exprlist_incr with s4; auto.\neapply transl_exprlist_charact; eauto 4 with rtlg.\neconstructor; eauto 3 with rtlg.\neapply transl_exprlist_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : node) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : add_instr (Itailcall s (inl x) x0) s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : transl_exprlist map e x0 x1 s3 = RTLgen.OK x2 s4 INCR6) (EQ4 : transl_expr map b x x2 s4 = RTLgen.OK ns s' INCR7) (INCR8 : state_incr s2 s4) (INCR9 : state_incr s0 s4) (INCR10 : state_incr s1 s4) (INCR11 : state_incr s0 s3) (INCR12 : state_incr s1 s3) (INCR13 : state_incr s1 s2) : tr_stmt (st_code s') map (Stailcall s (inl b) e) ns nd nexits ngoto nret rret.","proofString":"assert (RV: regs_valid (x :: nil) s0).\napply regs_valid_cons; eauto 3 with rtlg.\neconstructor; eauto 3 with rtlg.\neapply transl_expr_charact; eauto 3 with rtlg.\napply tr_exprlist_incr with s4; auto.\neapply transl_exprlist_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : node) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : add_instr (Itailcall s (inl x) x0) s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : transl_exprlist map e x0 x1 s3 = RTLgen.OK x2 s4 INCR6) (EQ4 : transl_expr map b x x2 s4 = RTLgen.OK ns s' INCR7) (INCR8 : state_incr s2 s4) (INCR9 : state_incr s0 s4) (INCR10 : state_incr s1 s4) (INCR11 : state_incr s0 s3) (INCR12 : state_incr s1 s3) (INCR13 : state_incr s1 s2) : regs_valid (x :: nil) s0.","proofString":"apply regs_valid_cons; eauto 3 with rtlg."},{"statement":"(map : mapping) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : node) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : add_instr (Itailcall s (inl x) x0) s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : transl_exprlist map e x0 x1 s3 = RTLgen.OK x2 s4 INCR6) (EQ4 : transl_expr map b x x2 s4 = RTLgen.OK ns s' INCR7) (INCR8 : state_incr s2 s4) (INCR9 : state_incr s0 s4) (INCR10 : state_incr s1 s4) (INCR11 : state_incr s0 s3) (INCR12 : state_incr s1 s3) (INCR13 : state_incr s1 s2) (RV : regs_valid (x :: nil) s0) : tr_stmt (st_code s') map (Stailcall s (inl b) e) ns nd nexits ngoto nret rret.","proofString":"econstructor; eauto 3 with rtlg.\neapply transl_expr_charact; eauto 3 with rtlg.\napply tr_exprlist_incr with s4; auto.\neapply transl_exprlist_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (s : signature) (b : expr) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_reg map b s1 = RTLgen.OK x s0 INCR0) (x0 : list reg) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : alloc_regs map e s0 = RTLgen.OK x0 s2 INCR2) (x1 : node) (s3 : state) (INCR4 : state_incr s2 s3) (INCR5 : state_incr s3 s') (EQ0 : add_instr (Itailcall s (inl x) x0) s2 = RTLgen.OK x1 s3 INCR4) (x2 : node) (s4 : state) (INCR6 : state_incr s3 s4) (INCR7 : state_incr s4 s') (EQ2 : transl_exprlist map e x0 x1 s3 = RTLgen.OK x2 s4 INCR6) (EQ4 : transl_expr map b x x2 s4 = RTLgen.OK ns s' INCR7) (INCR8 : state_incr s2 s4) (INCR9 : state_incr s0 s4) (INCR10 : state_incr s1 s4) (INCR11 : state_incr s0 s3) (INCR12 : state_incr s1 s3) (INCR13 : state_incr s1 s2) (RV : regs_valid (x :: nil) s0) : tr_exprlist (st_code s4) map (x :: nil) e x2 x1 x0.","proofString":"eapply transl_exprlist_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (s : signature) (id : ident) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s1 = RTLgen.OK x s0 INCR0) (x0 : node) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : add_instr (Itailcall s (inr id) x) s0 = RTLgen.OK x0 s2 INCR2) (EQ2 : transl_exprlist map e x x0 s2 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s1 s2) : tr_stmt (st_code s') map (Stailcall s (inr id) e) ns nd nexits ngoto nret\n  rret.","proofString":"econstructor; eauto 3 with rtlg.\neapply transl_exprlist_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (s : signature) (id : ident) (e : exprlist) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s1 : state) (ns : node) (s' : state) (INCR : state_incr s1 s') (WF : map_valid map s1) (OK : return_reg_ok s1 map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s1 s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map e s1 = RTLgen.OK x s0 INCR0) (x0 : node) (s2 : state) (INCR2 : state_incr s0 s2) (INCR3 : state_incr s2 s') (EQ1 : add_instr (Itailcall s (inr id) x) s0 = RTLgen.OK x0 s2 INCR2) (EQ2 : transl_exprlist map e x x0 s2 = RTLgen.OK ns s' INCR3) (INCR4 : state_incr s1 s2) : tr_exprlist (st_code s') map nil e ns x0 x.","proofString":"eapply transl_exprlist_charact; eauto 4 with rtlg."},{"statement":"(map : mapping) (b : builtin_res ident) (e : external_function) (l : list (builtin_arg expr)) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)) s =\nRTLgen.OK x s0 INCR0) (x0 : builtin_res reg) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : convert_builtin_res map (sig_res (ef_sig e)) b s0 = RTLgen.OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Ibuiltin e (convert_builtin_args l x) x0 nd) s1 =\nRTLgen.OK x1 s2 INCR4) (EQ3 : transl_exprlist map (exprlist_of_expr_list (params_of_builtin_args l)) x x1\n  s2 = RTLgen.OK ns s' INCR5) (INCR6 : state_incr s0 s2) (INCR7 : state_incr s s2) (INCR8 : state_incr s s1) : tr_stmt (st_code s') map (Sbuiltin b e l) ns nd nexits ngoto nret rret.","proofString":"econstructor; eauto 4 with rtlg.\neapply transl_exprlist_charact; eauto 3 with rtlg.\neapply convert_builtin_res_charact; eauto with rtlg."},{"statement":"(map : mapping) (b : builtin_res ident) (e : external_function) (l : list (builtin_arg expr)) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)) s =\nRTLgen.OK x s0 INCR0) (x0 : builtin_res reg) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : convert_builtin_res map (sig_res (ef_sig e)) b s0 = RTLgen.OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Ibuiltin e (convert_builtin_args l x) x0 nd) s1 =\nRTLgen.OK x1 s2 INCR4) (EQ3 : transl_exprlist map (exprlist_of_expr_list (params_of_builtin_args l)) x x1\n  s2 = RTLgen.OK ns s' INCR5) (INCR6 : state_incr s0 s2) (INCR7 : state_incr s s2) (INCR8 : state_incr s s1) : tr_exprlist (st_code s') map nil\n  (exprlist_of_expr_list (params_of_builtin_args l)) ns x1 x.","proofString":"eapply transl_exprlist_charact; eauto 3 with rtlg."},{"statement":"(map : mapping) (b : builtin_res ident) (e : external_function) (l : list (builtin_arg expr)) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : list reg) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : alloc_regs map (exprlist_of_expr_list (params_of_builtin_args l)) s =\nRTLgen.OK x s0 INCR0) (x0 : builtin_res reg) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : convert_builtin_res map (sig_res (ef_sig e)) b s0 = RTLgen.OK x0 s1 INCR2) (x1 : node) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : add_instr (Ibuiltin e (convert_builtin_args l x) x0 nd) s1 =\nRTLgen.OK x1 s2 INCR4) (EQ3 : transl_exprlist map (exprlist_of_expr_list (params_of_builtin_args l)) x x1\n  s2 = RTLgen.OK ns s' INCR5) (INCR6 : state_incr s0 s2) (INCR7 : state_incr s s2) (INCR8 : state_incr s s1) : tr_builtin_res map b x0.","proofString":"eapply convert_builtin_res_charact; eauto with rtlg."},{"statement":"(map : mapping) (stmt1 stmt2 : stmt) (IHstmt1 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s1 : state) \n  (ns0 : node) (s'0 : state) (INCR2 : state_incr s1 s'0),\ntransl_stmt map stmt1 nd0 nexits0 ngoto0 nret0 rret0 s1 =\nRTLgen.OK ns0 s'0 INCR2 ->\nmap_valid map s1 ->\nreturn_reg_ok s1 map rret0 ->\ntr_stmt (st_code s'0) map stmt1 ns0 nd0 nexits0 ngoto0 nret0 rret0) (IHstmt2 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s1 : state) \n  (ns0 : node) (s'0 : state) (INCR2 : state_incr s1 s'0),\ntransl_stmt map stmt2 nd0 nexits0 ngoto0 nret0 rret0 s1 =\nRTLgen.OK ns0 s'0 INCR2 ->\nmap_valid map s1 ->\nreturn_reg_ok s1 map rret0 ->\ntr_stmt (st_code s'0) map stmt2 ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_stmt map stmt2 nd nexits ngoto nret rret s = RTLgen.OK x s0 INCR0) (EQ0 : transl_stmt map stmt1 x nexits ngoto nret rret s0 = RTLgen.OK ns s' INCR1) : tr_stmt (st_code s') map (Sseq stmt1 stmt2) ns nd nexits ngoto nret rret.","proofString":"econstructor.\napply tr_stmt_incr with s0; auto.\neapply IHstmt2; eauto with rtlg.\neapply IHstmt1; eauto with rtlg."},{"statement":"(map : mapping) (c : condexpr) (stmt1 stmt2 : stmt) (IHstmt1 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s0 : state) \n  (ns0 : node) (s'0 : state) (INCR0 : state_incr s0 s'0),\ntransl_stmt map stmt1 nd0 nexits0 ngoto0 nret0 rret0 s0 =\nRTLgen.OK ns0 s'0 INCR0 ->\nmap_valid map s0 ->\nreturn_reg_ok s0 map rret0 ->\ntr_stmt (st_code s'0) map stmt1 ns0 nd0 nexits0 ngoto0 nret0 rret0) (IHstmt2 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s0 : state) \n  (ns0 : node) (s'0 : state) (INCR0 : state_incr s0 s'0),\ntransl_stmt map stmt2 nd0 nexits0 ngoto0 nret0 rret0 s0 =\nRTLgen.OK ns0 s'0 INCR0 ->\nmap_valid map s0 ->\nreturn_reg_ok s0 map rret0 ->\ntr_stmt (st_code s'0) map stmt2 ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : (if more_likely c stmt1 stmt2\n then\n  do nfalse <- transl_stmt map stmt2 nd nexits ngoto nret rret;\n  do ntrue <- transl_stmt map stmt1 nd nexits ngoto nret rret;\n  transl_condexpr map c ntrue nfalse\n else\n  do ntrue <- transl_stmt map stmt1 nd nexits ngoto nret rret;\n  do nfalse <- transl_stmt map stmt2 nd nexits ngoto nret rret;\n  transl_condexpr map c ntrue nfalse) s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto nret\n  rret.","proofString":"destruct (more_likely c stmt1 stmt2); monadInv TR.\neconstructor.\napply tr_stmt_incr with s1; auto.\neapply IHstmt1; eauto with rtlg.\napply tr_stmt_incr with s0; auto.\neapply IHstmt2; eauto with rtlg.\neapply transl_condexpr_charact; eauto with rtlg.\neconstructor.\napply tr_stmt_incr with s0; auto.\neapply IHstmt1; eauto with rtlg.\napply tr_stmt_incr with s1; auto.\neapply IHstmt2; eauto with rtlg.\neapply transl_condexpr_charact; eauto with rtlg."},{"statement":"(map : mapping) (c : condexpr) (stmt1 stmt2 : stmt) (IHstmt1 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR4 : state_incr s2 s'0),\ntransl_stmt map stmt1 nd0 nexits0 ngoto0 nret0 rret0 s2 =\nRTLgen.OK ns0 s'0 INCR4 ->\nmap_valid map s2 ->\nreturn_reg_ok s2 map rret0 ->\ntr_stmt (st_code s'0) map stmt1 ns0 nd0 nexits0 ngoto0 nret0 rret0) (IHstmt2 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR4 : state_incr s2 s'0),\ntransl_stmt map stmt2 nd0 nexits0 ngoto0 nret0 rret0 s2 =\nRTLgen.OK ns0 s'0 INCR4 ->\nmap_valid map s2 ->\nreturn_reg_ok s2 map rret0 ->\ntr_stmt (st_code s'0) map stmt2 ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_stmt map stmt2 nd nexits ngoto nret rret s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_stmt map stmt1 nd nexits ngoto nret rret s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_condexpr map c x0 x s1 = RTLgen.OK ns s' INCR3) : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto nret\n  rret.","proofString":"econstructor.\napply tr_stmt_incr with s1; auto.\neapply IHstmt1; eauto with rtlg.\napply tr_stmt_incr with s0; auto.\neapply IHstmt2; eauto with rtlg.\neapply transl_condexpr_charact; eauto with rtlg."},{"statement":"(map : mapping) (c : condexpr) (stmt1 stmt2 : stmt) (IHstmt1 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR4 : state_incr s2 s'0),\ntransl_stmt map stmt1 nd0 nexits0 ngoto0 nret0 rret0 s2 =\nRTLgen.OK ns0 s'0 INCR4 ->\nmap_valid map s2 ->\nreturn_reg_ok s2 map rret0 ->\ntr_stmt (st_code s'0) map stmt1 ns0 nd0 nexits0 ngoto0 nret0 rret0) (IHstmt2 : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR4 : state_incr s2 s'0),\ntransl_stmt map stmt2 nd0 nexits0 ngoto0 nret0 rret0 s2 =\nRTLgen.OK ns0 s'0 INCR4 ->\nmap_valid map s2 ->\nreturn_reg_ok s2 map rret0 ->\ntr_stmt (st_code s'0) map stmt2 ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_stmt map stmt1 nd nexits ngoto nret rret s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_stmt map stmt2 nd nexits ngoto nret rret s0 = RTLgen.OK x0 s1 INCR2) (EQ2 : transl_condexpr map c x x0 s1 = RTLgen.OK ns s' INCR3) : tr_stmt (st_code s') map (Sifthenelse c stmt1 stmt2) ns nd nexits ngoto nret\n  rret.","proofString":"econstructor.\napply tr_stmt_incr with s0; auto.\neapply IHstmt1; eauto with rtlg.\napply tr_stmt_incr with s1; auto.\neapply IHstmt2; eauto with rtlg.\neapply transl_condexpr_charact; eauto with rtlg."},{"statement":"(map : mapping) (stmt : CminorSel.stmt) (IHstmt : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s3 : state) \n  (ns0 : node) (s'0 : state) (INCR9 : state_incr s3 s'0),\ntransl_stmt map stmt nd0 nexits0 ngoto0 nret0 rret0 s3 =\nRTLgen.OK ns0 s'0 INCR9 ->\nmap_valid map s3 ->\nreturn_reg_ok s3 map rret0 ->\ntr_stmt (st_code s'0) map stmt ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : reserve_instr s = RTLgen.OK x s0 INCR0) (x0 : node) (s1 : state) (INCR2 : state_incr s0 s1) (INCR3 : state_incr s1 s') (EQ1 : transl_stmt map stmt x nexits ngoto nret rret s0 = RTLgen.OK x0 s1 INCR2) (x1 : unit) (s2 : state) (INCR4 : state_incr s1 s2) (INCR5 : state_incr s2 s') (EQ0 : update_instr x (Inop x0) s1 = RTLgen.OK x1 s2 INCR4) (EQ3 : add_instr (Inop x0) s2 = RTLgen.OK ns s' INCR5) (INCR6 : state_incr s0 s2) (INCR7 : state_incr s s2) (INCR8 : state_incr s s1) : tr_stmt (st_code s') map (Sloop stmt) ns nd nexits ngoto nret rret.","proofString":"econstructor.\napply tr_stmt_incr with s1; auto.\neapply IHstmt; eauto with rtlg.\neauto with rtlg.\neauto with rtlg."},{"statement":"(map : mapping) (stmt : CminorSel.stmt) (IHstmt : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s0 : state) \n  (ns0 : node) (s'0 : state) (INCR0 : state_incr s0 s'0),\ntransl_stmt map stmt nd0 nexits0 ngoto0 nret0 rret0 s0 =\nRTLgen.OK ns0 s'0 INCR0 ->\nmap_valid map s0 ->\nreturn_reg_ok s0 map rret0 ->\ntr_stmt (st_code s'0) map stmt ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_stmt map stmt nd (nd :: nexits) ngoto nret rret s =\nRTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sblock stmt) ns nd nexits ngoto nret rret.","proofString":"econstructor.\neapply IHstmt; eauto with rtlg."},{"statement":"(map : mapping) (stmt : CminorSel.stmt) (IHstmt : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s0 : state) \n  (ns0 : node) (s'0 : state) (INCR0 : state_incr s0 s'0),\ntransl_stmt map stmt nd0 nexits0 ngoto0 nret0 rret0 s0 =\nRTLgen.OK ns0 s'0 INCR0 ->\nmap_valid map s0 ->\nreturn_reg_ok s0 map rret0 ->\ntr_stmt (st_code s'0) map stmt ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_stmt map stmt nd (nd :: nexits) ngoto nret rret s =\nRTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map stmt ns nd (nd :: nexits) ngoto nret rret.","proofString":"eapply IHstmt; eauto with rtlg."},{"statement":"(map : mapping) (n : nat) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exit nexits n s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret.","proofString":"exploit transl_exit_charact; eauto.\nintros [A B].\neconstructor.\neauto."},{"statement":"(map : mapping) (n : nat) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exit nexits n s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : nth_error nexits n = Some ns /\\ s' = s ->\ntr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret.","proofString":"intros [A B].\neconstructor.\neauto."},{"statement":"(map : mapping) (n : nat) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exit nexits n s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) (A : nth_error nexits n = Some ns) (B : s' = s) : tr_stmt (st_code s') map (Sexit n) ns nd nexits ngoto nret rret.","proofString":"econstructor.\neauto."},{"statement":"(map : mapping) (n : nat) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exit nexits n s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) (A : nth_error nexits n = Some ns) (B : s' = s) : nth_error nexits n = Some ns.","proofString":"eauto."},{"statement":"(map : mapping) (e : exitexpr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exitexpr map e nexits s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sswitch e) ns nd nexits ngoto nret rret.","proofString":"econstructor.\neapply transl_exitexpr_charact; eauto."},{"statement":"(map : mapping) (e : exitexpr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : transl_exitexpr map e nexits s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_exitexpr (st_code s') map e ns nexits.","proofString":"eapply transl_exitexpr_charact; eauto."},{"statement":"(map : mapping) (o : option expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : match o with\n| Some a =>\n    match rret with\n    | Some r => transl_expr map a r nret\n    | None => error (Errors.msg \"RTLgen: type mismatch on return\")\n    end\n| None => ret nret\nend s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sreturn o) ns nd nexits ngoto nret rret.","proofString":"destruct o.\ndestruct rret; inv TR.\ninv OK.\neconstructor; eauto with rtlg.\neapply transl_expr_charact; eauto with rtlg.\nconstructor.\nauto.\nsimpl; tauto.\nmonadInv TR.\nconstructor."},{"statement":"(map : mapping) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : match rret with\n| Some r => transl_expr map e r nret\n| None => error (Errors.msg \"RTLgen: type mismatch on return\")\nend s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret rret.","proofString":"destruct rret; inv TR.\ninv OK.\neconstructor; eauto with rtlg.\neapply transl_expr_charact; eauto with rtlg.\nconstructor.\nauto.\nsimpl; tauto."},{"statement":"(map : mapping) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (r : reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map (Some r)) (H0 : transl_expr map e r nret s = RTLgen.OK ns s' INCR) : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret (Some r).","proofString":"inv OK.\neconstructor; eauto with rtlg.\neapply transl_expr_charact; eauto with rtlg.\nconstructor.\nauto.\nsimpl; tauto."},{"statement":"(map : mapping) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (r : reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (H0 : transl_expr map e r nret s = OK ns s' INCR) (H1 : ~ reg_in_map map r) (H4 : reg_valid r s) : tr_stmt (st_code s') map (Sreturn (Some e)) ns nd nexits ngoto nret (Some r).","proofString":"econstructor; eauto with rtlg.\neapply transl_expr_charact; eauto with rtlg.\nconstructor.\nauto.\nsimpl; tauto."},{"statement":"(map : mapping) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (r : reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (H0 : transl_expr map e r nret s = OK ns s' INCR) (H1 : ~ reg_in_map map r) (H4 : reg_valid r s) : tr_expr (st_code s') map nil e ns nret r None.","proofString":"eapply transl_expr_charact; eauto with rtlg.\nconstructor.\nauto.\nsimpl; tauto."},{"statement":"(map : mapping) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (r : reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (H0 : transl_expr map e r nret s = OK ns s' INCR) (H1 : ~ reg_in_map map r) (H4 : reg_valid r s) : target_reg_ok map nil e r.","proofString":"constructor.\nauto.\nsimpl; tauto."},{"statement":"(map : mapping) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (r : reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (H0 : transl_expr map e r nret s = OK ns s' INCR) (H1 : ~ reg_in_map map r) (H4 : reg_valid r s) : ~ reg_in_map map r.","proofString":"auto."},{"statement":"(map : mapping) (e : expr) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (r : reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (H0 : transl_expr map e r nret s = OK ns s' INCR) (H1 : ~ reg_in_map map r) (H4 : reg_valid r s) : ~ In r nil.","proofString":"simpl; tauto."},{"statement":"(map : mapping) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : ret nret s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sreturn None) ns nd nexits ngoto nret rret.","proofString":"monadInv TR.\nconstructor."},{"statement":"(map : mapping) (nd : node) (nexits : list node) (ngoto : labelmap) (rret : option reg) (ns : node) (s' : state) (OK : return_reg_ok s' map rret) (WF : map_valid map s') (INCR : state_incr s' s') : tr_stmt (st_code s') map (Sreturn None) ns nd nexits ngoto ns rret.","proofString":"constructor."},{"statement":"(map : mapping) (l : Cminor.label) (stmt : CminorSel.stmt) (IHstmt : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s1 : state) \n  (ns0 : node) (s'0 : state) (INCR2 : state_incr s1 s'0),\ntransl_stmt map stmt nd0 nexits0 ngoto0 nret0 rret0 s1 =\nRTLgen.OK ns0 s'0 INCR2 ->\nmap_valid map s1 ->\nreturn_reg_ok s1 map rret0 ->\ntr_stmt (st_code s'0) map stmt ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (x : node) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_stmt map stmt nd nexits ngoto nret rret s = RTLgen.OK x s0 INCR0) (EQ0 : match ngoto ! l with\n| Some n =>\n    do _ <-\n    handle_error (update_instr n (Inop x))\n      (error (Errors.MSG \"Multiply-defined label \" :: Errors.CTX l :: nil));\n    ret x\n| None => error (Errors.msg \"RTLgen: unbound label\")\nend s0 = RTLgen.OK ns s' INCR1) : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret.","proofString":"generalize EQ0; clear EQ0.\ncase_eq (ngoto!l); intros; monadInv EQ0.\ngeneralize EQ1; clear EQ1.\nunfold handle_error.\ncase_eq (update_instr n (Inop ns) s0); intros; inv EQ1.\neconstructor.\neauto.\neauto with rtlg.\neapply tr_stmt_incr with s0; eauto with rtlg."},{"statement":"(map : mapping) (l : Cminor.label) (stmt : CminorSel.stmt) (IHstmt : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s1 : state) \n  (ns0 : node) (s'0 : state) (INCR4 : state_incr s1 s'0),\ntransl_stmt map stmt nd0 nexits0 ngoto0 nret0 rret0 s1 =\nRTLgen.OK ns0 s'0 INCR4 ->\nmap_valid map s1 ->\nreturn_reg_ok s1 map rret0 ->\ntr_stmt (st_code s'0) map stmt ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_stmt map stmt nd nexits ngoto nret rret s = RTLgen.OK ns s0 INCR0) (n : node) (H : ngoto ! l = Some n) (x0 : unit) (INCR2 : state_incr s0 s') (EQ1 : handle_error (update_instr n (Inop ns))\n  (error (Errors.MSG \"Multiply-defined label \" :: Errors.CTX l :: nil)) s0 =\nRTLgen.OK x0 s' INCR2) (INCR3 : state_incr s' s') : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret.","proofString":"generalize EQ1; clear EQ1.\nunfold handle_error.\ncase_eq (update_instr n (Inop ns) s0); intros; inv EQ1.\neconstructor.\neauto.\neauto with rtlg.\neapply tr_stmt_incr with s0; eauto with rtlg."},{"statement":"(map : mapping) (l : Cminor.label) (stmt : CminorSel.stmt) (IHstmt : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR4 : state_incr s2 s'0),\ntransl_stmt map stmt nd0 nexits0 ngoto0 nret0 rret0 s2 =\nRTLgen.OK ns0 s'0 INCR4 ->\nmap_valid map s2 ->\nreturn_reg_ok s2 map rret0 ->\ntr_stmt (st_code s'0) map stmt ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_stmt map stmt nd nexits ngoto nret rret s = RTLgen.OK ns s0 INCR0) (n : node) (H : ngoto ! l = Some n) (x0 : unit) (INCR2 : state_incr s0 s') (INCR3 : state_incr s' s') (s1 : state_incr s0 s') (H0 : update_instr n (Inop ns) s0 = RTLgen.OK x0 s' s1) : tr_stmt (st_code s') map (Slabel l stmt) ns nd nexits ngoto nret rret.","proofString":"econstructor.\neauto.\neauto with rtlg.\neapply tr_stmt_incr with s0; eauto with rtlg."},{"statement":"(map : mapping) (l : Cminor.label) (stmt : CminorSel.stmt) (IHstmt : forall (nd0 : node) (nexits0 : list node) (ngoto0 : labelmap) \n  (nret0 : node) (rret0 : option reg) (s2 : state) \n  (ns0 : node) (s'0 : state) (INCR4 : state_incr s2 s'0),\ntransl_stmt map stmt nd0 nexits0 ngoto0 nret0 rret0 s2 =\nRTLgen.OK ns0 s'0 INCR4 ->\nmap_valid map s2 ->\nreturn_reg_ok s2 map rret0 ->\ntr_stmt (st_code s'0) map stmt ns0 nd0 nexits0 ngoto0 nret0 rret0) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (WF : map_valid map s) (OK : return_reg_ok s map rret) (s0 : state) (INCR0 : state_incr s s0) (INCR1 : state_incr s0 s') (EQ : transl_stmt map stmt nd nexits ngoto nret rret s = RTLgen.OK ns s0 INCR0) (n : node) (H : ngoto ! l = Some n) (x0 : unit) (INCR2 : state_incr s0 s') (INCR3 : state_incr s' s') (s1 : state_incr s0 s') (H0 : update_instr n (Inop ns) s0 = RTLgen.OK x0 s' s1) : tr_stmt (st_code s') map stmt ns nd nexits ngoto nret rret.","proofString":"eapply tr_stmt_incr with s0; eauto with rtlg."},{"statement":"(map : mapping) (l : Cminor.label) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (s : state) (ns : node) (s' : state) (INCR : state_incr s s') (TR : match ngoto ! l with\n| Some n => ret n\n| None =>\n    error (Errors.MSG \"Undefined defined label \" :: Errors.CTX l :: nil)\nend s = RTLgen.OK ns s' INCR) (WF : map_valid map s) (OK : return_reg_ok s map rret) : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret.","proofString":"generalize TR; clear TR.\ncase_eq (ngoto!l); intros; monadInv TR.\neconstructor.\nauto."},{"statement":"(map : mapping) (l : Cminor.label) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (ns : node) (s' : state) (OK : return_reg_ok s' map rret) (WF : map_valid map s') (INCR : state_incr s' s') (H : ngoto ! l = Some ns) : tr_stmt (st_code s') map (Sgoto l) ns nd nexits ngoto nret rret.","proofString":"econstructor.\nauto."},{"statement":"(map : mapping) (l : Cminor.label) (nd : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (ns : node) (s' : state) (OK : return_reg_ok s' map rret) (WF : map_valid map s') (INCR : state_incr s' s') (H : ngoto ! l = Some ns) : ngoto ! l = Some ns.","proofString":"auto."},{"statement":"(f : CminorSel.function) (tf : function) : transl_function f = Errors.OK tf -> tr_function f tf.","proofString":"unfold transl_function.\ncaseEq (transl_fun f init_state).\ncongruence.\nintros [nentry rparams] sfinal INCR TR E.\ninv E.\nmonadInv TR.\nexploit add_vars_valid.\neexact EQ1.\napply init_mapping_valid.\nintros [A B].\nexploit add_vars_valid.\neexact EQ0.\nauto.\nintros [C D].\neapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (tf : function) : match transl_fun f init_state with\n| Error msg => Errors.Error msg\n| OK (nentry, rparams) s _ =>\n    Errors.OK\n      {|\n        fn_sig := CminorSel.fn_sig f;\n        fn_params := rparams;\n        fn_stacksize := fn_stackspace f;\n        fn_code := st_code s;\n        fn_entrypoint := nentry\n      |}\nend = Errors.OK tf -> tr_function f tf.","proofString":"caseEq (transl_fun f init_state).\ncongruence.\nintros [nentry rparams] sfinal INCR TR E.\ninv E.\nmonadInv TR.\nexploit add_vars_valid.\neexact EQ1.\napply init_mapping_valid.\nintros [A B].\nexploit add_vars_valid.\neexact EQ0.\nauto.\nintros [C D].\neapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (tf : function) : forall e : Errors.errmsg,\ntransl_fun f init_state = Error e ->\nErrors.Error e = Errors.OK tf -> tr_function f tf.","proofString":"congruence."},{"statement":"(f : CminorSel.function) (tf : function) : forall (p : node * list reg) (s' : state) (s : state_incr init_state s'),\ntransl_fun f init_state = OK p s' s ->\n(let (nentry, rparams) := p in\n Errors.OK\n   {|\n     fn_sig := CminorSel.fn_sig f;\n     fn_params := rparams;\n     fn_stacksize := fn_stackspace f;\n     fn_code := st_code s';\n     fn_entrypoint := nentry\n   |}) = Errors.OK tf -> tr_function f tf.","proofString":"intros [nentry rparams] sfinal INCR TR E.\ninv E.\nmonadInv TR.\nexploit add_vars_valid.\neexact EQ1.\napply init_mapping_valid.\nintros [A B].\nexploit add_vars_valid.\neexact EQ0.\nauto.\nintros [C D].\neapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (tf : function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (TR : transl_fun f init_state = OK (nentry, rparams) sfinal INCR) (E : Errors.OK\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |} = Errors.OK tf) : tr_function f tf.","proofString":"inv E.\nmonadInv TR.\nexploit add_vars_valid.\neexact EQ1.\napply init_mapping_valid.\nintros [A B].\nexploit add_vars_valid.\neexact EQ0.\nauto.\nintros [C D].\neapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (TR : transl_fun f init_state = OK (nentry, rparams) sfinal INCR) : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}.","proofString":"monadInv TR.\nexploit add_vars_valid.\neexact EQ1.\napply init_mapping_valid.\nintros [A B].\nexploit add_vars_valid.\neexact EQ0.\nauto.\nintros [C D].\neapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (x : labelmap) (s : state) (INCR0 : state_incr init_state s) (INCR1 : state_incr s sfinal) (EQ : reserve_labels (fn_body f) (PTree.empty node) init_state = OK x s INCR0) (x1 : mapping) (s0 : state) (INCR2 : state_incr s s0) (INCR3 : state_incr s0 sfinal) (EQ1 : add_vars init_mapping (CminorSel.fn_params f) s = OK (rparams, x1) s0 INCR2) (x2 : list reg) (x3 : mapping) (s1 : state) (INCR4 : state_incr s0 s1) (INCR5 : state_incr s1 sfinal) (EQ0 : add_vars x1 (fn_vars f) s0 = OK (x2, x3) s1 INCR4) (x4 : reg) (s2 : state) (INCR6 : state_incr s1 s2) (INCR7 : state_incr s2 sfinal) (EQ2 : new_reg s1 = OK x4 s2 INCR6) (x5 : node) (s3 : state) (INCR8 : state_incr s2 s3) (INCR9 : state_incr s3 sfinal) (EQ3 : add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2 = OK x5 s3 INCR8) (INCR10 : state_incr s3 sfinal) (EQ4 : transl_stmt x3 (fn_body f) x5 nil x x5 (ret_reg (CminorSel.fn_sig f) x4) s3 =\nOK nentry sfinal INCR10) (INCR11 : state_incr sfinal sfinal) : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}.","proofString":"exploit add_vars_valid.\neexact EQ1.\napply init_mapping_valid.\nintros [A B].\nexploit add_vars_valid.\neexact EQ0.\nauto.\nintros [C D].\neapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (x : labelmap) (s : state) (INCR0 : state_incr init_state s) (INCR1 : state_incr s sfinal) (EQ : reserve_labels (fn_body f) (PTree.empty node) init_state = OK x s INCR0) (x1 : mapping) (s0 : state) (INCR2 : state_incr s s0) (INCR3 : state_incr s0 sfinal) (EQ1 : add_vars init_mapping (CminorSel.fn_params f) s = OK (rparams, x1) s0 INCR2) (x2 : list reg) (x3 : mapping) (s1 : state) (INCR4 : state_incr s0 s1) (INCR5 : state_incr s1 sfinal) (EQ0 : add_vars x1 (fn_vars f) s0 = OK (x2, x3) s1 INCR4) (x4 : reg) (s2 : state) (INCR6 : state_incr s1 s2) (INCR7 : state_incr s2 sfinal) (EQ2 : new_reg s1 = OK x4 s2 INCR6) (x5 : node) (s3 : state) (INCR8 : state_incr s2 s3) (INCR9 : state_incr s3 sfinal) (EQ3 : add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2 = OK x5 s3 INCR8) (INCR10 : state_incr s3 sfinal) (EQ4 : transl_stmt x3 (fn_body f) x5 nil x x5 (ret_reg (CminorSel.fn_sig f) x4) s3 =\nOK nentry sfinal INCR10) (INCR11 : state_incr sfinal sfinal) (A : regs_valid rparams s0) (B : map_valid x1 s0) : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}.","proofString":"exploit add_vars_valid.\neexact EQ0.\nauto.\nintros [C D].\neapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (x : labelmap) (s : state) (INCR0 : state_incr init_state s) (INCR1 : state_incr s sfinal) (EQ : reserve_labels (fn_body f) (PTree.empty node) init_state = OK x s INCR0) (x1 : mapping) (s0 : state) (INCR2 : state_incr s s0) (INCR3 : state_incr s0 sfinal) (EQ1 : add_vars init_mapping (CminorSel.fn_params f) s = OK (rparams, x1) s0 INCR2) (x2 : list reg) (x3 : mapping) (s1 : state) (INCR4 : state_incr s0 s1) (INCR5 : state_incr s1 sfinal) (EQ0 : add_vars x1 (fn_vars f) s0 = OK (x2, x3) s1 INCR4) (x4 : reg) (s2 : state) (INCR6 : state_incr s1 s2) (INCR7 : state_incr s2 sfinal) (EQ2 : new_reg s1 = OK x4 s2 INCR6) (x5 : node) (s3 : state) (INCR8 : state_incr s2 s3) (INCR9 : state_incr s3 sfinal) (EQ3 : add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2 = OK x5 s3 INCR8) (INCR10 : state_incr s3 sfinal) (EQ4 : transl_stmt x3 (fn_body f) x5 nil x x5 (ret_reg (CminorSel.fn_sig f) x4) s3 =\nOK nentry sfinal INCR10) (INCR11 : state_incr sfinal sfinal) (A : regs_valid rparams s0) (B : map_valid x1 s0) (C : regs_valid x2 s1) (D : map_valid x3 s1) : tr_function f\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := st_code sfinal;\n    fn_entrypoint := nentry\n  |}.","proofString":"eapply tr_function_intro; eauto with rtlg.\neapply transl_stmt_charact; eauto with rtlg.\nunfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (x : labelmap) (s : state) (INCR0 : state_incr init_state s) (INCR1 : state_incr s sfinal) (EQ : reserve_labels (fn_body f) (PTree.empty node) init_state = OK x s INCR0) (x1 : mapping) (s0 : state) (INCR2 : state_incr s s0) (INCR3 : state_incr s0 sfinal) (EQ1 : add_vars init_mapping (CminorSel.fn_params f) s = OK (rparams, x1) s0 INCR2) (x2 : list reg) (x3 : mapping) (s1 : state) (INCR4 : state_incr s0 s1) (INCR5 : state_incr s1 sfinal) (EQ0 : add_vars x1 (fn_vars f) s0 = OK (x2, x3) s1 INCR4) (x4 : reg) (s2 : state) (INCR6 : state_incr s1 s2) (INCR7 : state_incr s2 sfinal) (EQ2 : new_reg s1 = OK x4 s2 INCR6) (x5 : node) (s3 : state) (INCR8 : state_incr s2 s3) (INCR9 : state_incr s3 sfinal) (EQ3 : add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2 = OK x5 s3 INCR8) (INCR10 : state_incr s3 sfinal) (EQ4 : transl_stmt x3 (fn_body f) x5 nil x x5 (ret_reg (CminorSel.fn_sig f) x4) s3 =\nOK nentry sfinal INCR10) (INCR11 : state_incr sfinal sfinal) (A : regs_valid rparams s0) (B : map_valid x1 s0) (C : regs_valid x2 s1) (D : map_valid x3 s1) : return_reg_ok s3 x3 (ret_reg (CminorSel.fn_sig f) x4).","proofString":"unfold ret_reg.\ndestruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (x : labelmap) (s : state) (INCR0 : state_incr init_state s) (INCR1 : state_incr s sfinal) (EQ : reserve_labels (fn_body f) (PTree.empty node) init_state = OK x s INCR0) (x1 : mapping) (s0 : state) (INCR2 : state_incr s s0) (INCR3 : state_incr s0 sfinal) (EQ1 : add_vars init_mapping (CminorSel.fn_params f) s = OK (rparams, x1) s0 INCR2) (x2 : list reg) (x3 : mapping) (s1 : state) (INCR4 : state_incr s0 s1) (INCR5 : state_incr s1 sfinal) (EQ0 : add_vars x1 (fn_vars f) s0 = OK (x2, x3) s1 INCR4) (x4 : reg) (s2 : state) (INCR6 : state_incr s1 s2) (INCR7 : state_incr s2 sfinal) (EQ2 : new_reg s1 = OK x4 s2 INCR6) (x5 : node) (s3 : state) (INCR8 : state_incr s2 s3) (INCR9 : state_incr s3 sfinal) (EQ3 : add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2 = OK x5 s3 INCR8) (INCR10 : state_incr s3 sfinal) (EQ4 : transl_stmt x3 (fn_body f) x5 nil x x5 (ret_reg (CminorSel.fn_sig f) x4) s3 =\nOK nentry sfinal INCR10) (INCR11 : state_incr sfinal sfinal) (A : regs_valid rparams s0) (B : map_valid x1 s0) (C : regs_valid x2 s1) (D : map_valid x3 s1) : return_reg_ok s3 x3\n  (if xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid then None else Some x4).","proofString":"destruct (xtype_eq (sig_res (CminorSel.fn_sig f)) Xvoid).\nconstructor.\nconstructor; eauto with rtlg."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (x : labelmap) (s : state) (INCR0 : state_incr init_state s) (INCR1 : state_incr s sfinal) (EQ : reserve_labels (fn_body f) (PTree.empty node) init_state = OK x s INCR0) (x1 : mapping) (s0 : state) (INCR2 : state_incr s s0) (INCR3 : state_incr s0 sfinal) (EQ1 : add_vars init_mapping (CminorSel.fn_params f) s = OK (rparams, x1) s0 INCR2) (x2 : list reg) (x3 : mapping) (s1 : state) (INCR4 : state_incr s0 s1) (INCR5 : state_incr s1 sfinal) (EQ0 : add_vars x1 (fn_vars f) s0 = OK (x2, x3) s1 INCR4) (x4 : reg) (s2 : state) (INCR6 : state_incr s1 s2) (INCR7 : state_incr s2 sfinal) (EQ2 : new_reg s1 = OK x4 s2 INCR6) (x5 : node) (s3 : state) (INCR8 : state_incr s2 s3) (INCR9 : state_incr s3 sfinal) (EQ3 : add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2 = OK x5 s3 INCR8) (INCR10 : state_incr s3 sfinal) (EQ4 : transl_stmt x3 (fn_body f) x5 nil x x5 (ret_reg (CminorSel.fn_sig f) x4) s3 =\nOK nentry sfinal INCR10) (INCR11 : state_incr sfinal sfinal) (A : regs_valid rparams s0) (B : map_valid x1 s0) (C : regs_valid x2 s1) (D : map_valid x3 s1) (e : sig_res (CminorSel.fn_sig f) = Xvoid) : return_reg_ok s3 x3 None.","proofString":"constructor."},{"statement":"(f : CminorSel.function) (nentry : node) (rparams : list reg) (sfinal : state) (INCR : state_incr init_state sfinal) (x : labelmap) (s : state) (INCR0 : state_incr init_state s) (INCR1 : state_incr s sfinal) (EQ : reserve_labels (fn_body f) (PTree.empty node) init_state = OK x s INCR0) (x1 : mapping) (s0 : state) (INCR2 : state_incr s s0) (INCR3 : state_incr s0 sfinal) (EQ1 : add_vars init_mapping (CminorSel.fn_params f) s = OK (rparams, x1) s0 INCR2) (x2 : list reg) (x3 : mapping) (s1 : state) (INCR4 : state_incr s0 s1) (INCR5 : state_incr s1 sfinal) (EQ0 : add_vars x1 (fn_vars f) s0 = OK (x2, x3) s1 INCR4) (x4 : reg) (s2 : state) (INCR6 : state_incr s1 s2) (INCR7 : state_incr s2 sfinal) (EQ2 : new_reg s1 = OK x4 s2 INCR6) (x5 : node) (s3 : state) (INCR8 : state_incr s2 s3) (INCR9 : state_incr s3 sfinal) (EQ3 : add_instr (Ireturn (ret_reg (CminorSel.fn_sig f) x4)) s2 = OK x5 s3 INCR8) (INCR10 : state_incr s3 sfinal) (EQ4 : transl_stmt x3 (fn_body f) x5 nil x x5 (ret_reg (CminorSel.fn_sig f) x4) s3 =\nOK nentry sfinal INCR10) (INCR11 : state_incr sfinal sfinal) (A : regs_valid rparams s0) (B : map_valid x1 s0) (C : regs_valid x2 s1) (D : map_valid x3 s1) (n : sig_res (CminorSel.fn_sig f) <> Xvoid) : return_reg_ok s3 x3 (Some x4).","proofString":"constructor; eauto with rtlg."}]}