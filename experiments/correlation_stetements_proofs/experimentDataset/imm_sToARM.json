[{"statement":"Lemma WF : Wf G.","proof":"apply CON.\n"},{"statement":"Lemma COMP : complete G.","proof":"apply CON.\n"},{"statement":"Lemma SC_PER_LOC : sc_per_loc G.","proof":"apply CON.\n"},{"statement":"Lemma RMW_COI : rmw ⨾ coi ⊆ obs' ∪ dob ∪ aob ∪ boba.","proof":"cdes CON.\nrewrite rmw_in_fri; auto.\nrewrite fri_coi; auto.\nrewrite fri_in_fr.\nunfold Arm.obs'.\neauto with hahn.\n"},{"statement":"Lemma R_ex_fail_sb_in_ctrl : ⦗R_ex \\₁ dom_rel rmw⦘ ⨾ sb ⊆ ctrl.","proof":"rewrite <- REX_IN_RMW_CTRL.\nbasic_solver.\n"},{"statement":"Lemma s_ppo_in_dob : s_ppo ⊆ dob⁺.","proof":"unfold imm_s_ppo.ppo.\nrewrite REX_IN_RMW_CTRL.\narewrite (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ctrl ⊆            data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw_dep ⨾ sb^?).\n{\nrewrite RMW_DEPS.\nunionL; eauto with hahn.\n}\nrewrite path_union, !seq_union_l, !seq_union_r.\nunionL.\n{\napply ppo_in_dob_helper; auto.\n}\nassert ((data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi)＊ ⊆ sb^?) as AA.\n{\nrewrite (data_in_sb WF), (ctrl_in_sb WF), (addr_in_sb WF).\narewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nins.\nrelsf.\n}\nrewrite AA at 2.\nrewrite ct_begin, !seqA.\nrewrite AA at 2.\narewrite (sb^? ⨾ (sb^? ⨾ rmw_dep ⨾ sb^?)＊ ⨾ sb^? ⊆ sb^?).\n{\nrewrite (rmw_dep_in_sb WF).\ngeneralize (@sb_trans G).\nins.\nrelsf.\n}\narewrite (rmw_dep ⨾ sb^? ⨾ ⦗W⦘ ⊆ rmw_dep ⨾ sb ⨾ ⦗W⦘).\n{\nrewrite (dom_r (wf_rmw_depD WF)) at 1.\nrewrite R_ex_in_R.\ntype_solver.\n}\nsin_rewrite DEPS_RMW_SB.\narewrite (ctrl ⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi) at 2.\nseq_rewrite <- ct_end.\napply ppo_in_dob_helper; auto.\n"},{"statement":"Lemma s_ppo_in_ord : s_ppo ⊆ (obs⁺ ∩ sb ∪ dob ∪ aob ∪ boba' ∪ sb ⨾ ⦗F^ld⦘)⁺.","proof":"rewrite s_ppo_in_dob.\napply clos_trans_mori.\neauto with hahn.\n"},{"statement":"Lemma s_ar_int_in_ord : ⦗R⦘ ⨾ s_ar_int⁺ ⨾ ⦗W⦘ ⊆ (obs ∪ dob ∪ aob ∪ boba')⁺.","proof":"unfold imm_s_ppo.ar_int.\ntransitivity (⦗R⦘ ⨾  ((obs⁺∩ sb) ∪ dob ∪ aob ∪ boba' ∪ sb ⨾ ⦗F^ld⦘)⁺ ⨾ ⦗W⦘).\n2: {\nrewrite path_union.\nrelsf; unionL.\n{\narewrite_id ⦗R⦘; arewrite_id ⦗W⦘.\nrels.\narewrite (obs⁺ ∩ sb ⊆ obs⁺).\napply inclusion_t_t2.\napply_unionL_once.\napply_unionL_once.\napply_unionL_once.\n{\napply inclusion_t_t.\nbasic_solver.\n}\nall: rewrite <- ct_step; basic_solver.\n}\nrewrite (dob_in_sb WF) at 1 2.\nrewrite (aob_in_sb WF) at 1 2.\nrewrite (bob'_in_sb WF) at 1 2.\narewrite (obs⁺ ∩ sb ⊆ sb).\nrewrite ct_begin.\narewrite_id ⦗F^ld⦘ at 2.\ngeneralize (@sb_trans G); ins; relsf.\narewrite (⦗F^ld⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ⦗F^ld⦘ ⨾ sb) by type_solver.\nunfold Arm.bob', Arm.bob.\nrewrite <- ct_step.\nbasic_solver 21.\n}\narewrite (detour ⊆ detour ∩ sb).\nrewrite W_ex_acq_sb_in_boba1; auto.\nrewrite bob_in_boba; auto.\nrewrite detour_in_obs; auto.\nhahn_frame.\napply inclusion_t_t2.\napply_unionL_once.\n2: {\nrewrite <- ct_step.\nunfold Arm.aob.\nbasic_solver 12.\n}\napply_unionL_once.\n2: {\napply inclusion_t_t; basic_solver 12.\n}\napply_unionL_once.\n2: by unfolder; ins; econs; eauto.\napply_unionL_once.\n{\nrewrite <- ct_step; rewrite <- ct_step; unfold Arm.obs; ie_unfolder; basic_solver 12.\n}\napply s_ppo_in_ord.\n"},{"statement":"Lemma C_EXT_helper: imm_s.acyc_ext G (⦗F∩₁Sc⦘ ⨾ s_hb ⨾ eco ⨾ s_hb ⨾ ⦗F∩₁Sc⦘).","proof":"apply (s_acyc_ext_psc_helper WF).\nrewrite s_ar_int_in_ord.\narewrite (rfe ⊆ (obs ∪ dob ∪ aob ∪ boba')⁺ ).\n{\nunfold Arm.obs; rewrite <- ct_step; basic_solver 12.\n}\narewrite (imm_s.psc G ⊆ imm.psc G).\n{\nunfold imm_s.psc, imm.psc.\nby rewrite s_hb_in_hb.\n}\nrewrite psc_in_ord; auto.\nrelsf; red; relsf.\napply (external_alt_bob' WF CON).\n"},{"statement":"Lemma C_SC : acyclic (imm_s.psc_f G ∪ imm_s.psc_base G).","proof":"unfold imm_s.psc_f, imm_s.psc_base, imm_s.scb.\nrewrite s_hb_in_hb.\napply immToARMhelper.C_SC; auto.\n"},{"statement":"Lemma IMM_s_coherence :\n  imm_s_hb.coherence G.","proof":"red.\nrewrite crE, seq_union_r, seq_id_r.\nrewrite s_hb_in_hb.\napply irreflexive_union.\nsplit.\n2: {\napply COH; auto.\n}\nrewrite hb_in_ord; auto.\napply irreflexive_union.\nsplit.\n{\nby apply (@sb_irr G).\n}\napply (external_alt_bob' WF CON).\n"},{"statement":"Lemma IMM_s_psc_consistent (FINDOM : set_finite E) :\n  exists sc, imm_psc_consistent G sc.","proof":"edestruct (imm_s.s_acyc_ext_helper WF FINDOM C_EXT_helper) as [sc HH].\ndesc.\nexists sc.\nred.\nsplits; eauto.\n2: by apply C_SC.\nred.\nsplits; eauto; try apply CON.\nnow apply IMM_s_coherence.\n"},{"statement":"Lemma no_ar_int_to_init:\n  s_ar_int ≡ s_ar_int ⨾ ⦗set_compl is_init⦘.","proof":"split; [| basic_solver].\napply domb_helper.\nrewrite imm_s_ppo.ar_int_in_sb; [| by apply WF].\nerewrite no_sb_to_init.\nbasic_solver.\n"},{"statement":"Lemma IMM_s_fsupp\n      (FSUPP : fsupp (⦗set_compl is_init⦘ ⨾ (obs ∪ dob ∪ aob ∪ boba')⁺))\n      (NOSC : E ∩₁ F ∩₁ Sc ⊆₁ ∅) :  \n  imm_s_fair G ∅₂.","proof":"assert (WF' : Wf G) by apply WF.\nassert (transitive sb) as TSB by apply sb_trans.\nred.\nunfold imm_s.ar.\nrewrite union_false_l.\nrewrite ct_unionE, seq_union_r.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ s_ar_int⁺)) as AA.\n{\nrewrite imm_s_ppo.ar_int_in_sb; auto.\nrewrite ct_of_trans; auto.\nby apply fsupp_sb.\n}\napply fsupp_union; auto.\nrewrite <- seqA, clos_refl_trans_domb_l.\n2: {\nrewrite no_ar_int_to_init.\nbasic_solver.\n}\nrewrite <- seqA.\nrewrite seqA with (r2 := ⦗set_compl is_init⦘).\napply fsupp_seq.\n{\nrewrite rtE, seq_union_r.\napply fsupp_union; auto.\nrewrite <- id_inter.\napply fsupp_eqv.\n}\narewrite (rfe ⊆ rfe ⨾ ⦗set_compl is_init⦘).\n{\napply domb_helper.\nrewrite rfe_in_rf, no_rf_to_init; basic_solver.\n}\nrewrite (wf_rfeD WF), !seqA.\nrewrite ct_rotl.\nrewrite <- seqA.\nrewrite <- id_inter.\nrewrite <- seqA.\napply fsupp_seq.\n2: {\nrewrite <- seqA.\napply fsupp_seq.\n{\nrewrite inclusion_seq_eqv_r, rfe_in_rf.\nby apply fsupp_rf.\n}\nrewrite rtE, seq_union_r.\napply fsupp_union; auto.\nrewrite <- id_inter.\napply fsupp_eqv.\n}\nseq_rewrite <- id_inter.\nerewrite eqv_rel_mori with (x := R ∩₁ _).\n2: {\nunfolder.\nintros ?.\napply proj1.\n}\nrewrite !seqA.\narewrite (⦗R⦘ ⨾ s_ar_int＊ ⨾ ⦗W⦘ ⊆ ⦗R⦘ ⨾ s_ar_int⁺ ⨾ ⦗W⦘).\n{\nrewrite rtE.\nclear.\ntype_solver.\n}\nrewrite s_ar_int_in_ord.\narewrite (rfe ⊆ (obs ∪ dob ∪ aob ∪ boba')⁺).\n{\nrewrite <- ct_step.\nunfold Arm.obs.\neauto with hahn.\n}\nrewrite ct_ct, rt_of_ct.\nrewrite rtE, seq_union_r.\nrewrite <- id_inter.\napply fsupp_union; [by apply fsupp_eqv| ].\neapply fsupp_mori; [| by apply FSUPP].\nred.\nbasic_solver.\n"},{"statement":"Lemma IMM_s_consistent\n      (NOSC : E ∩₁ F ∩₁ Sc ⊆₁ ∅):\n  imm_psc_consistent G ∅₂.","proof":"assert (WF' : Wf G) by apply WF.\nassert (transitive sb) as TSB by apply sb_trans.\nred; splits.\n2: now apply C_SC.\nred.\nsplits; try apply CON.\n{\nconstructor; rewrite ?NOSC.\nall: basic_solver.\n}\n{\nred.\nbasic_solver.\n}\n{\nnow apply IMM_s_coherence.\n}\nred.\nunfold imm_s.ar.\narewrite (∅₂ ⊆ ⦗F∩₁Sc⦘ ⨾ s_hb ⨾ eco ⨾ s_hb ⨾ ⦗F∩₁Sc⦘).\napply C_EXT_helper.\n"},{"statement":"Lemma IMM_s_fsupp_consistent\n      (* NEXT TODO: note that here we use boba' instead of original Arm.bob *)\n      (FSUPP : fsupp (⦗set_compl is_init⦘ ⨾ (obs ∪ dob ∪ aob ∪ boba')⁺))\n      (NOSC : E ∩₁ F ∩₁ Sc ⊆₁ ∅) :  \n  ⟪ CONS  : imm_psc_consistent G ∅₂ ⟫ /\\\n  ⟪ FSUPP : imm_s_fair G ∅₂⟫.","proof":"auto using IMM_s_consistent, IMM_s_fsupp.\n"}]