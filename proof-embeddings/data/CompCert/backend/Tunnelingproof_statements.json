{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Tunnelingproof.v","fileSamples":[{"statement":"(p : program) : match_prog p (tunnel_program p).","proofString":"eapply match_transform_program; eauto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) : {f' : node -> nat | branch_map_correct_1 c (record_branch u pc b) f'}.","proofString":"assert (PC: U.repr u pc = pc).\nspecialize (BMC pc).\nrewrite PTree.grs in BMC.\nauto.\nassert (DFL: { f | branch_map_correct_1 c u f }).\nexists f.\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\ndestruct b as [ | [] b ]; auto.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nexact BMC.\nunfold record_branch.\ndestruct b as [ | [] b ]; auto.\nexists (measure_branch u pc s f).\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) : U.repr u pc = pc.","proofString":"specialize (BMC pc).\nrewrite PTree.grs in BMC.\nauto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : match (PTree.remove pc c) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr u pc = pc \\/ U.repr u pc = U.repr u s /\\ (f s < f pc)%nat\n| _ => U.repr u pc = pc\nend) (GET1 : c ! pc = Some b) : U.repr u pc = pc.","proofString":"rewrite PTree.grs in BMC.\nauto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : U.repr u pc = pc) (GET1 : c ! pc = Some b) : U.repr u pc = pc.","proofString":"auto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) : {f' : node -> nat | branch_map_correct_1 c (record_branch u pc b) f'}.","proofString":"assert (DFL: { f | branch_map_correct_1 c u f }).\nexists f.\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\ndestruct b as [ | [] b ]; auto.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nexact BMC.\nunfold record_branch.\ndestruct b as [ | [] b ]; auto.\nexists (measure_branch u pc s f).\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) : {f0 : node -> nat | branch_map_correct_1 c u f0}.","proofString":"exists f.\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\ndestruct b as [ | [] b ]; auto.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nexact BMC."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) : branch_map_correct_1 c u f.","proofString":"intros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\ndestruct b as [ | [] b ]; auto.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nexact BMC."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) (p : positive) : match c ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| _ => U.repr u p = p\nend.","proofString":"destruct (peq p pc).\nsubst p.\nrewrite GET1.\ndestruct b as [ | [] b ]; auto.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nexact BMC."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) (p : positive) (e : p = pc) : match c ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| _ => U.repr u p = p\nend.","proofString":"subst p.\nrewrite GET1.\ndestruct b as [ | [] b ]; auto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) : match c ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr u pc = pc \\/ U.repr u pc = U.repr u s /\\ (f s < f pc)%nat\n| _ => U.repr u pc = pc\nend.","proofString":"rewrite GET1.\ndestruct b as [ | [] b ]; auto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) : match b with\n| Lbranch s :: _ =>\n    U.repr u pc = pc \\/ U.repr u pc = U.repr u s /\\ (f s < f pc)%nat\n| _ => U.repr u pc = pc\nend.","proofString":"destruct b as [ | [] b ]; auto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) (p : positive) (n : p <> pc) : match c ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| _ => U.repr u p = p\nend.","proofString":"specialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nexact BMC."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (p : positive) (BMC : match (PTree.remove pc c) ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) (n : p <> pc) : match c ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| _ => U.repr u p = p\nend.","proofString":"rewrite PTree.gro in BMC by auto.\nexact BMC."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (p : positive) (BMC : match c ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) (n : p <> pc) : match c ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| _ => U.repr u p = p\nend.","proofString":"exact BMC."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : {f' : node -> nat | branch_map_correct_1 c (record_branch u pc b) f'}.","proofString":"unfold record_branch.\ndestruct b as [ | [] b ]; auto.\nexists (measure_branch u pc s f).\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some b) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : {f' : node -> nat\n| branch_map_correct_1 c\n    match b with\n    | Lbranch s :: _ => U.union u pc s\n    | _ => u\n    end f'}.","proofString":"destruct b as [ | [] b ]; auto.\nexists (measure_branch u pc s f).\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : {f' : node -> nat | branch_map_correct_1 c (U.union u pc s) f'}.","proofString":"exists (measure_branch u pc s f).\nintros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : branch_map_correct_1 c (U.union u pc s) (measure_branch u pc s f).","proofString":"intros p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (p : positive) : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr (U.union u pc s) p = p \\/\n    U.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n    (measure_branch u pc s f s0 < measure_branch u pc s f p)%nat\n| _ => U.repr (U.union u pc s) p = p\nend.","proofString":"destruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia.\nspecialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (p : positive) (e : p = pc) : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr (U.union u pc s) p = p \\/\n    U.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n    (measure_branch u pc s f s0 < measure_branch u pc s f p)%nat\n| _ => U.repr (U.union u pc s) p = p\nend.","proofString":"subst p.\nrewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : match c ! pc with\n| Some (Lbranch s0 :: _) =>\n    U.repr (U.union u pc s) pc = pc \\/\n    U.repr (U.union u pc s) pc = U.repr (U.union u pc s) s0 /\\\n    (measure_branch u pc s f s0 < measure_branch u pc s f pc)%nat\n| _ => U.repr (U.union u pc s) pc = pc\nend.","proofString":"rewrite GET1.\nunfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : U.repr (U.union u pc s) pc = pc \\/\nU.repr (U.union u pc s) pc = U.repr (U.union u pc s) s /\\\n(measure_branch u pc s f s < measure_branch u pc s f pc)%nat.","proofString":"unfold measure_branch.\nrewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : U.repr (U.union u pc s) pc = pc \\/\nU.repr (U.union u pc s) pc = U.repr (U.union u pc s) s /\\\n((if peq (U.repr u s) pc\n  then f s\n  else if peq (U.repr u s) pc then f s + f s + 1 else f s) <\n (if peq (U.repr u s) pc\n  then f pc\n  else if peq (U.repr u pc) pc then f pc + f s + 1 else f pc))%nat.","proofString":"rewrite (U.repr_union_2 u pc s); auto.\nrewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : U.repr u s = pc \\/\nU.repr u s = U.repr (U.union u pc s) s /\\\n((if peq (U.repr u s) pc\n  then f s\n  else if peq (U.repr u s) pc then f s + f s + 1 else f s) <\n (if peq (U.repr u s) pc\n  then f pc\n  else if peq (U.repr u pc) pc then f pc + f s + 1 else f pc))%nat.","proofString":"rewrite U.repr_union_3.\ndestruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) : U.repr u s = pc \\/\nU.repr u s = U.repr u s /\\\n((if peq (U.repr u s) pc\n  then f s\n  else if peq (U.repr u s) pc then f s + f s + 1 else f s) <\n (if peq (U.repr u s) pc\n  then f pc\n  else if peq (U.repr u pc) pc then f pc + f s + 1 else f pc))%nat.","proofString":"destruct (peq (U.repr u s) pc); auto.\nrewrite PC, peq_true.\nright; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : U.repr u s <> pc) : U.repr u s = pc \\/\nU.repr u s = U.repr u s /\\\n(f s < (if peq (U.repr u pc) pc then f pc + f s + 1 else f pc))%nat.","proofString":"rewrite PC, peq_true.\nright; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : U.repr u s <> pc) : U.repr u s = pc \\/ U.repr u s = U.repr u s /\\ (f s < f pc + f s + 1)%nat.","proofString":"right; split; auto.\nlia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : U.repr u s <> pc) : (f s < f pc + f s + 1)%nat.","proofString":"lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (BMC : branch_map_correct_1 (PTree.remove pc c) u f) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (p : positive) (n : p <> pc) : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr (U.union u pc s) p = p \\/\n    U.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n    (measure_branch u pc s f s0 < measure_branch u pc s f p)%nat\n| _ => U.repr (U.union u pc s) p = p\nend.","proofString":"specialize (BMC p).\nrewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (BMC : match (PTree.remove pc c) ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr (U.union u pc s) p = p \\/\n    U.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n    (measure_branch u pc s f s0 < measure_branch u pc s f p)%nat\n| _ => U.repr (U.union u pc s) p = p\nend.","proofString":"rewrite PTree.gro in BMC by auto.\nassert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (BMC : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr (U.union u pc s) p = p \\/\n    U.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n    (measure_branch u pc s f s0 < measure_branch u pc s f p)%nat\n| _ => U.repr (U.union u pc s) p = p\nend.","proofString":"assert (U.repr u p = p -> U.repr (U.union u pc s) p = p).\nintro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence.\ndestruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (BMC : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) : U.repr u p = p -> U.repr (U.union u pc s) p = p.","proofString":"intro.\nrewrite <- H at 2.\napply U.repr_union_1.\ncongruence."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (BMC : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p) : U.repr (U.union u pc s) p = p.","proofString":"rewrite <- H at 2.\napply U.repr_union_1.\ncongruence."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (BMC : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p) : U.repr (U.union u pc s) p = U.repr u p.","proofString":"apply U.repr_union_1.\ncongruence."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (BMC : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p) : U.repr u p <> U.repr u pc.","proofString":"congruence."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (BMC : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) : match c ! p with\n| Some (Lbranch s0 :: _) =>\n    U.repr (U.union u pc s) p = p \\/\n    U.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n    (measure_branch u pc s f s0 < measure_branch u pc s f p)%nat\n| _ => U.repr (U.union u pc s) p = p\nend.","proofString":"destruct (c!p) as [ [ | [] _ ] | ]; auto.\ndestruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (BMC : U.repr u p = p \\/ U.repr u p = U.repr u s0 /\\ (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) : U.repr (U.union u pc s) p = p \\/\nU.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n(measure_branch u pc s f s0 < measure_branch u pc s f p)%nat.","proofString":"destruct BMC as [A | [A B]].\nauto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = p) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) : U.repr (U.union u pc s) p = p \\/\nU.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n(measure_branch u pc s f s0 < measure_branch u pc s f p)%nat.","proofString":"auto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = U.repr u s0) (B : (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) : U.repr (U.union u pc s) p = p \\/\nU.repr (U.union u pc s) p = U.repr (U.union u pc s) s0 /\\\n(measure_branch u pc s f s0 < measure_branch u pc s f p)%nat.","proofString":"right; split.\napply U.sameclass_union_2; auto.\nunfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = U.repr u s0) (B : (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) : U.repr (U.union u pc s) p = U.repr (U.union u pc s) s0.","proofString":"apply U.sameclass_union_2; auto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = U.repr u s0) (B : (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) : (measure_branch u pc s f s0 < measure_branch u pc s f p)%nat.","proofString":"unfold measure_branch.\ndestruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = U.repr u s0) (B : (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) : ((if peq (U.repr u s) pc\n  then f s0\n  else if peq (U.repr u s0) pc then f s0 + f s + 1 else f s0) <\n (if peq (U.repr u s) pc\n  then f p\n  else if peq (U.repr u p) pc then f p + f s + 1 else f p))%nat.","proofString":"destruct (peq (U.repr u s) pc).\nauto.\nrewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = U.repr u s0) (B : (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) (e : U.repr u s = pc) : (f s0 < f p)%nat.","proofString":"auto."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = U.repr u s0) (B : (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) (n0 : U.repr u s <> pc) : ((if peq (U.repr u s0) pc then f s0 + f s + 1 else f s0) <\n (if peq (U.repr u p) pc then f p + f s + 1 else f p))%nat.","proofString":"rewrite A.\ndestruct (peq (U.repr u s0) pc); lia."},{"statement":"(c : PTree.tree bblock) (u : U.t) (f : node -> nat) (pc : positive) (s : node) (b : list instruction) (p : positive) (s0 : node) (A : U.repr u p = U.repr u s0) (B : (f s0 < f p)%nat) (GET1 : c ! pc = Some (Lbranch s :: b)) (PC : U.repr u pc = pc) (DFL : {f0 : node -> nat | branch_map_correct_1 c u f0}) (n : p <> pc) (H : U.repr u p = p -> U.repr (U.union u pc s) p = p) (n0 : U.repr u s <> pc) : ((if peq (U.repr u s0) pc then f s0 + f s + 1 else f s0) <\n (if peq (U.repr u s0) pc then f p + f s + 1 else f p))%nat.","proofString":"destruct (peq (U.repr u s0) pc); lia."},{"statement":"{f : node -> nat\n| branch_map_correct_1 (fn_code fn)\n    (PTree.fold record_branch (fn_code fn) U.empty) f}.","proofString":"apply PTree_Properties.fold_ind.\nintros m EMPTY.\nexists (fun _ => O).\nred; intros.\nrewrite EMPTY.\napply U.repr_empty.\nintros m u pc bb GET1 GET2 [f BMC].\neapply record_branch_correct; eauto."},{"statement":"forall m : PTree.t bblock,\n(forall k : PTree.elt, m ! k = None) ->\n{f : node -> nat | branch_map_correct_1 m U.empty f}.","proofString":"intros m EMPTY.\nexists (fun _ => O).\nred; intros.\nrewrite EMPTY.\napply U.repr_empty."},{"statement":"(m : PTree.t bblock) (EMPTY : forall k : PTree.elt, m ! k = None) : {f : node -> nat | branch_map_correct_1 m U.empty f}.","proofString":"exists (fun _ => O).\nred; intros.\nrewrite EMPTY.\napply U.repr_empty."},{"statement":"(m : PTree.t bblock) (EMPTY : forall k : PTree.elt, m ! k = None) : branch_map_correct_1 m U.empty (fun _ : node => 0%nat).","proofString":"red; intros.\nrewrite EMPTY.\napply U.repr_empty."},{"statement":"(m : PTree.t bblock) (EMPTY : forall k : PTree.elt, m ! k = None) (pc : positive) : match m ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr U.empty pc = pc \\/\n    U.repr U.empty pc = U.repr U.empty s /\\ (0 < 0)%nat\n| _ => U.repr U.empty pc = pc\nend.","proofString":"rewrite EMPTY.\napply U.repr_empty."},{"statement":"(m : PTree.t bblock) (EMPTY : forall k : PTree.elt, m ! k = None) (pc : positive) : U.repr U.empty pc = pc.","proofString":"apply U.repr_empty."},{"statement":"forall (m : PTree.t bblock) (a : U.t) (k : PTree.elt) (v : bblock),\nm ! k = Some v ->\n(fn_code fn) ! k = Some v ->\n{f : node -> nat | branch_map_correct_1 (PTree.remove k m) a f} ->\n{f : node -> nat | branch_map_correct_1 m (record_branch a k v) f}.","proofString":"intros m u pc bb GET1 GET2 [f BMC].\neapply record_branch_correct; eauto."},{"statement":"(m : PTree.t bblock) (u : U.t) (pc : PTree.elt) (bb : bblock) (GET1 : m ! pc = Some bb) (GET2 : (fn_code fn) ! pc = Some bb) (f : node -> nat) (BMC : branch_map_correct_1 (PTree.remove pc m) u f) : {f0 : node -> nat | branch_map_correct_1 m (record_branch u pc bb) f0}.","proofString":"eapply record_branch_correct; eauto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some b) (GET2 : c ! pc <> None) : let\n'(c1, u1, _) := record_cond (c, u, changed) pc b in\n {f' : node -> nat | branch_map_correct_2 c1 u1 f'}.","proofString":"assert (DFL: { f' | branch_map_correct_2 c u f' }).\nexists f; auto.\nunfold record_cond.\ndestruct b as [ | [] b ]; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); auto.\nexists (measure_cond u pc s1 s2 f).\nassert (PC: U.repr u pc = pc).\nspecialize (BMC pc).\nrewrite GET1 in BMC.\nintuition congruence.\nintro p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some b) (GET2 : c ! pc <> None) : {f' : node -> nat | branch_map_correct_2 c u f'}.","proofString":"exists f; auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some b) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) : let\n'(c1, u1, _) := record_cond (c, u, changed) pc b in\n {f' : node -> nat | branch_map_correct_2 c1 u1 f'}.","proofString":"unfold record_cond.\ndestruct b as [ | [] b ]; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); auto.\nexists (measure_cond u pc s1 s2 f).\nassert (PC: U.repr u pc = pc).\nspecialize (BMC pc).\nrewrite GET1 in BMC.\nintuition congruence.\nintro p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (b : bblock) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some b) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) : let\n'(c1, u1, _) :=\n match b with\n | Lcond _ _ s1 s2 :: _ =>\n     if peq (U.repr u s1) (U.repr u s2)\n     then (PTree.remove pc c, U.union u pc s1, true)\n     else (c, u, changed)\n | _ => (c, u, changed)\n end in {f' : node -> nat | branch_map_correct_2 c1 u1 f'}.","proofString":"destruct b as [ | [] b ]; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); auto.\nexists (measure_cond u pc s1 s2 f).\nassert (PC: U.repr u pc = pc).\nspecialize (BMC pc).\nrewrite GET1 in BMC.\nintuition congruence.\nintro p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) : let\n'(c1, u1, _) :=\n if peq (U.repr u s1) (U.repr u s2)\n then (PTree.remove pc c, U.union u pc s1, true)\n else (c, u, changed) in {f' : node -> nat | branch_map_correct_2 c1 u1 f'}.","proofString":"destruct (peq (U.repr u s1) (U.repr u s2)); auto.\nexists (measure_cond u pc s1 s2 f).\nassert (PC: U.repr u pc = pc).\nspecialize (BMC pc).\nrewrite GET1 in BMC.\nintuition congruence.\nintro p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) : {f' : node -> nat\n| branch_map_correct_2 (PTree.remove pc c) (U.union u pc s1) f'}.","proofString":"exists (measure_cond u pc s1 s2 f).\nassert (PC: U.repr u pc = pc).\nspecialize (BMC pc).\nrewrite GET1 in BMC.\nintuition congruence.\nintro p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) : branch_map_correct_2 (PTree.remove pc c) (U.union u pc s1)\n  (measure_cond u pc s1 s2 f).","proofString":"assert (PC: U.repr u pc = pc).\nspecialize (BMC pc).\nrewrite GET1 in BMC.\nintuition congruence.\nintro p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) : U.repr u pc = pc.","proofString":"specialize (BMC pc).\nrewrite GET1 in BMC.\nintuition congruence."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr u pc = pc \\/ U.repr u pc = U.repr u s /\\ (f s < f pc)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr u pc = pc \\/\n    c ! pc = None /\\\n    U.repr u pc = U.repr u s0 /\\\n    U.repr u pc = U.repr u s3 /\\ (f s0 < f pc)%nat /\\ (f s3 < f pc)%nat\n| _ => U.repr u pc = pc\nend) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) : U.repr u pc = pc.","proofString":"rewrite GET1 in BMC.\nintuition congruence."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : U.repr u pc = pc \\/\nc ! pc = None /\\\nU.repr u pc = U.repr u s1 /\\\nU.repr u pc = U.repr u s2 /\\ (f s1 < f pc)%nat /\\ (f s2 < f pc)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) : U.repr u pc = pc.","proofString":"intuition congruence."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) : branch_map_correct_2 (PTree.remove pc c) (U.union u pc s1)\n  (measure_cond u pc s1 s2 f).","proofString":"intro p.\ndestruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (p : positive) : match (fn_code fn) ! p with\n| Some (Lbranch s :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s /\\\n    (measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    (PTree.remove pc c) ! p = None /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0 /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3 /\\\n    (measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n    (measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat\n| _ => U.repr (U.union u pc s1) p = p\nend.","proofString":"destruct (peq p pc).\nsubst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia.\nassert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (p : positive) (e0 : p = pc) : match (fn_code fn) ! p with\n| Some (Lbranch s :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s /\\\n    (measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    (PTree.remove pc c) ! p = None /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0 /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3 /\\\n    (measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n    (measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat\n| _ => U.repr (U.union u pc s1) p = p\nend.","proofString":"subst p.\nrewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr (U.union u pc s1) pc = pc \\/\n    U.repr (U.union u pc s1) pc = U.repr (U.union u pc s1) s /\\\n    (measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f pc)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr (U.union u pc s1) pc = pc \\/\n    (PTree.remove pc c) ! pc = None /\\\n    U.repr (U.union u pc s1) pc = U.repr (U.union u pc s1) s0 /\\\n    U.repr (U.union u pc s1) pc = U.repr (U.union u pc s1) s3 /\\\n    (measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f pc)%nat /\\\n    (measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f pc)%nat\n| _ => U.repr (U.union u pc s1) pc = pc\nend.","proofString":"rewrite GET1.\nunfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) : U.repr (U.union u pc s1) pc = pc \\/\n(PTree.remove pc c) ! pc = None /\\\nU.repr (U.union u pc s1) pc = U.repr (U.union u pc s1) s1 /\\\nU.repr (U.union u pc s1) pc = U.repr (U.union u pc s1) s2 /\\\n(measure_cond u pc s1 s2 f s1 < measure_cond u pc s1 s2 f pc)%nat /\\\n(measure_cond u pc s1 s2 f s2 < measure_cond u pc s1 s2 f pc)%nat.","proofString":"unfold measure_cond.\nrewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) : U.repr (U.union u pc s1) pc = pc \\/\n(PTree.remove pc c) ! pc = None /\\\nU.repr (U.union u pc s1) pc = U.repr (U.union u pc s1) s1 /\\\nU.repr (U.union u pc s1) pc = U.repr (U.union u pc s1) s2 /\\\n((if peq (U.repr u s1) pc\n  then f s1\n  else\n   if peq (U.repr u s1) pc then f s1 + Nat.max (f s1) (f s2) + 1 else f s1) <\n (if peq (U.repr u s1) pc\n  then f pc\n  else\n   if peq (U.repr u pc) pc then f pc + Nat.max (f s1) (f s2) + 1 else f pc))%nat /\\\n((if peq (U.repr u s1) pc\n  then f s2\n  else\n   if peq (U.repr u s2) pc then f s2 + Nat.max (f s1) (f s2) + 1 else f s2) <\n (if peq (U.repr u s1) pc\n  then f pc\n  else\n   if peq (U.repr u pc) pc then f pc + Nat.max (f s1) (f s2) + 1 else f pc))%nat.","proofString":"rewrite U.repr_union_2 by auto.\nrewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) : U.repr u s1 = pc \\/\n(PTree.remove pc c) ! pc = None /\\\nU.repr u s1 = U.repr (U.union u pc s1) s1 /\\\nU.repr u s1 = U.repr (U.union u pc s1) s2 /\\\n((if peq (U.repr u s1) pc\n  then f s1\n  else\n   if peq (U.repr u s1) pc then f s1 + Nat.max (f s1) (f s2) + 1 else f s1) <\n (if peq (U.repr u s1) pc\n  then f pc\n  else\n   if peq (U.repr u pc) pc then f pc + Nat.max (f s1) (f s2) + 1 else f pc))%nat /\\\n((if peq (U.repr u s1) pc\n  then f s2\n  else\n   if peq (U.repr u s2) pc then f s2 + Nat.max (f s1) (f s2) + 1 else f s2) <\n (if peq (U.repr u s1) pc\n  then f pc\n  else\n   if peq (U.repr u pc) pc then f pc + Nat.max (f s1) (f s2) + 1 else f pc))%nat.","proofString":"rewrite <- e, PC, peq_true.\ndestruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) : U.repr u s1 = pc \\/\n(PTree.remove pc c) ! pc = None /\\\nU.repr u s1 = U.repr (U.union u pc s1) s1 /\\\nU.repr u s1 = U.repr (U.union u pc s1) s2 /\\\n((if peq (U.repr u s1) pc\n  then f s1\n  else\n   if peq (U.repr u s1) pc then f s1 + Nat.max (f s1) (f s2) + 1 else f s1) <\n (if peq (U.repr u s1) pc then f pc else f pc + Nat.max (f s1) (f s2) + 1))%nat /\\\n((if peq (U.repr u s1) pc\n  then f s2\n  else\n   if peq (U.repr u s1) pc then f s2 + Nat.max (f s1) (f s2) + 1 else f s2) <\n (if peq (U.repr u s1) pc then f pc else f pc + Nat.max (f s1) (f s2) + 1))%nat.","proofString":"destruct (peq (U.repr u s1) pc); auto.\nright; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : U.repr u s1 = pc \\/\n(PTree.remove pc c) ! pc = None /\\\nU.repr u s1 = U.repr (U.union u pc s1) s1 /\\\nU.repr u s1 = U.repr (U.union u pc s1) s2 /\\\n(f s1 < f pc + Nat.max (f s1) (f s2) + 1)%nat /\\\n(f s2 < f pc + Nat.max (f s1) (f s2) + 1)%nat.","proofString":"right; repeat split.\napply PTree.grs.\nrewrite U.repr_union_3.\nauto.\nrewrite U.repr_union_1 by congruence.\nauto.\nlia.\nlia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : (PTree.remove pc c) ! pc = None.","proofString":"apply PTree.grs."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : U.repr u s1 = U.repr (U.union u pc s1) s1.","proofString":"rewrite U.repr_union_3.\nauto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : U.repr u s1 = U.repr u s1.","proofString":"auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : U.repr u s1 = U.repr (U.union u pc s1) s2.","proofString":"rewrite U.repr_union_1 by congruence.\nauto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : U.repr u s1 = U.repr u s2.","proofString":"auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : (f s1 < f pc + Nat.max (f s1) (f s2) + 1)%nat.","proofString":"lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : U.repr u s1 <> pc) : (f s2 < f pc + Nat.max (f s1) (f s2) + 1)%nat.","proofString":"lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (p : positive) (n : p <> pc) : match (fn_code fn) ! p with\n| Some (Lbranch s :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s /\\\n    (measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    (PTree.remove pc c) ! p = None /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0 /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3 /\\\n    (measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n    (measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat\n| _ => U.repr (U.union u pc s1) p = p\nend.","proofString":"assert (P: U.repr u p = p -> U.repr (U.union u pc s1) p = p).\nintros.\nrewrite U.repr_union_1 by congruence.\nauto.\nspecialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (p : positive) (n : p <> pc) : U.repr u p = p -> U.repr (U.union u pc s1) p = p.","proofString":"intros.\nrewrite U.repr_union_1 by congruence.\nauto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (p : positive) (n : p <> pc) (H : U.repr u p = p) : U.repr (U.union u pc s1) p = p.","proofString":"rewrite U.repr_union_1 by congruence.\nauto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (p : positive) (n : p <> pc) (H : U.repr u p = p) : U.repr u p = p.","proofString":"auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (BMC : branch_map_correct_2 c u f) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (p : positive) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : match (fn_code fn) ! p with\n| Some (Lbranch s :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s /\\\n    (measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    (PTree.remove pc c) ! p = None /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0 /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3 /\\\n    (measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n    (measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat\n| _ => U.repr (U.union u pc s1) p = p\nend.","proofString":"specialize (BMC p).\ndestruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (BMC : match (fn_code fn) ! p with\n| Some (Lbranch s :: _) =>\n    U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr u p = p \\/\n    c ! p = None /\\\n    U.repr u p = U.repr u s0 /\\\n    U.repr u p = U.repr u s3 /\\ (f s0 < f p)%nat /\\ (f s3 < f p)%nat\n| _ => U.repr u p = p\nend) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : match (fn_code fn) ! p with\n| Some (Lbranch s :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s /\\\n    (measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat\n| Some (Lcond _ _ s0 s3 :: _) =>\n    U.repr (U.union u pc s1) p = p \\/\n    (PTree.remove pc c) ! p = None /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0 /\\\n    U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3 /\\\n    (measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n    (measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat\n| _ => U.repr (U.union u pc s1) p = p\nend.","proofString":"destruct (fn_code fn)!p as [ [ | [] bb ] | ]; auto.\ndestruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia.\ndestruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (BMC : U.repr u p = p \\/ U.repr u p = U.repr u s /\\ (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : U.repr (U.union u pc s1) p = p \\/\nU.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s /\\\n(measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat.","proofString":"destruct BMC as [A | (A & B)]; auto.\nright; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (A : U.repr u p = U.repr u s) (B : (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : U.repr (U.union u pc s1) p = p \\/\nU.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s /\\\n(measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat.","proofString":"right; split.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (A : U.repr u p = U.repr u s) (B : (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s.","proofString":"apply U.sameclass_union_2; auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (A : U.repr u p = U.repr u s) (B : (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : (measure_cond u pc s1 s2 f s < measure_cond u pc s1 s2 f p)%nat.","proofString":"unfold measure_cond.\nrewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (A : U.repr u p = U.repr u s) (B : (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : ((if peq (U.repr u s1) pc\n  then f s\n  else if peq (U.repr u s) pc then f s + Nat.max (f s1) (f s2) + 1 else f s) <\n (if peq (U.repr u s1) pc\n  then f p\n  else if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat.","proofString":"rewrite <- A.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (A : U.repr u p = U.repr u s) (B : (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : ((if peq (U.repr u s1) pc\n  then f s\n  else if peq (U.repr u p) pc then f s + Nat.max (f s1) (f s2) + 1 else f s) <\n (if peq (U.repr u s1) pc\n  then f p\n  else if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat.","proofString":"destruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (A : U.repr u p = U.repr u s) (B : (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) (e0 : U.repr u s1 = pc) : (f s < f p)%nat.","proofString":"auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (s : node) (bb : list instruction) (A : U.repr u p = U.repr u s) (B : (f s < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) (n0 : U.repr u s1 <> pc) : ((if peq (U.repr u p) pc then f s + Nat.max (f s1) (f s2) + 1 else f s) <\n (if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat.","proofString":"destruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (BMC : U.repr u p = p \\/\nc ! p = None /\\\nU.repr u p = U.repr u s0 /\\\nU.repr u p = U.repr u s3 /\\ (f s0 < f p)%nat /\\ (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : U.repr (U.union u pc s1) p = p \\/\n(PTree.remove pc c) ! p = None /\\\nU.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0 /\\\nU.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3 /\\\n(measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n(measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat.","proofString":"destruct BMC as [A | (A & B & C & D & E)]; auto.\nright; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : U.repr (U.union u pc s1) p = p \\/\n(PTree.remove pc c) ! p = None /\\\nU.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0 /\\\nU.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3 /\\\n(measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n(measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat.","proofString":"right; split; [ | split; [ | split]].\nrewrite PTree.gro by auto.\nauto.\napply U.sameclass_union_2; auto.\napply U.sameclass_union_2; auto.\nunfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : (PTree.remove pc c) ! p = None.","proofString":"rewrite PTree.gro by auto.\nauto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : c ! p = None.","proofString":"auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s0.","proofString":"apply U.sameclass_union_2; auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : U.repr (U.union u pc s1) p = U.repr (U.union u pc s1) s3.","proofString":"apply U.sameclass_union_2; auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : (measure_cond u pc s1 s2 f s0 < measure_cond u pc s1 s2 f p)%nat /\\\n(measure_cond u pc s1 s2 f s3 < measure_cond u pc s1 s2 f p)%nat.","proofString":"unfold measure_cond.\nrewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : ((if peq (U.repr u s1) pc\n  then f s0\n  else\n   if peq (U.repr u s0) pc then f s0 + Nat.max (f s1) (f s2) + 1 else f s0) <\n (if peq (U.repr u s1) pc\n  then f p\n  else if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat /\\\n((if peq (U.repr u s1) pc\n  then f s3\n  else\n   if peq (U.repr u s3) pc then f s3 + Nat.max (f s1) (f s2) + 1 else f s3) <\n (if peq (U.repr u s1) pc\n  then f p\n  else if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat.","proofString":"rewrite <- B, <- C.\ndestruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) : ((if peq (U.repr u s1) pc\n  then f s0\n  else if peq (U.repr u p) pc then f s0 + Nat.max (f s1) (f s2) + 1 else f s0) <\n (if peq (U.repr u s1) pc\n  then f p\n  else if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat /\\\n((if peq (U.repr u s1) pc\n  then f s3\n  else if peq (U.repr u p) pc then f s3 + Nat.max (f s1) (f s2) + 1 else f s3) <\n (if peq (U.repr u s1) pc\n  then f p\n  else if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat.","proofString":"destruct (peq (U.repr u s1) pc).\nauto.\ndestruct (peq (U.repr u p) pc); lia."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) (e0 : U.repr u s1 = pc) : (f s0 < f p)%nat /\\ (f s3 < f p)%nat.","proofString":"auto."},{"statement":"(c : code) (u : U.t) (changed : bool) (f : node -> nat) (pc : positive) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (p : positive) (cond0 : condition) (args0 : list mreg) (s0 s3 : node) (bb : list instruction) (A : c ! p = None) (B : U.repr u p = U.repr u s0) (C : U.repr u p = U.repr u s3) (D : (f s0 < f p)%nat) (E : (f s3 < f p)%nat) (GET1 : (fn_code fn) ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c ! pc <> None) (DFL : {f' : node -> nat | branch_map_correct_2 c u f'}) (e : U.repr u s1 = U.repr u s2) (PC : U.repr u pc = pc) (n : p <> pc) (P : U.repr u p = p -> U.repr (U.union u pc s1) p = p) (n0 : U.repr u s1 <> pc) : ((if peq (U.repr u p) pc then f s0 + Nat.max (f s1) (f s2) + 1 else f s0) <\n (if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat /\\\n((if peq (U.repr u p) pc then f s3 + Nat.max (f s1) (f s2) + 1 else f s3) <\n (if peq (U.repr u p) pc then f p + Nat.max (f s1) (f s2) + 1 else f p))%nat.","proofString":"destruct (peq (U.repr u p) pc); lia."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) : let\n'(c', u', _) := record_conds_1 (c0, u0) in\n code_compat c' * {f' : node -> nat | branch_map_correct_2 c' u' f'}.","proofString":"unfold record_conds_1.\nset (x := PTree.fold record_cond c0 (c0, u0, false)).\nset (P := fun (cd: code) (cuc: code * U.t * bool) =>            (code_compat (fst (fst cuc)) *             code_invariant cd (fst (fst cuc)) c0 *             { f | branch_map_correct_2 (fst (fst cuc)) (snd (fst cuc)) f })%type).\nassert (REC: P c0 x).\nunfold x; apply PTree_Properties.fold_ind.\nintros cd EMPTY.\nsplit; [split|]; simpl.\nauto.\nred; auto.\nexists f0; auto.\nintros cd [[c u] changed] pc b GET1 GET2 [[COMPAT INV] [f BMC]].\nsimpl in *.\nsplit; [split|].\nunfold record_cond; destruct b as [ | [] b]; simpl; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq pc0 pc).\ndiscriminate.\nauto.\nassert (DFL: code_invariant cd c c0).\nintros p GET.\napply INV.\nrewrite PTree.gro by congruence.\nauto.\nunfold record_cond; destruct b as [ | [] b]; simpl; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nintros p GET.\nrewrite PTree.gro by congruence.\napply INV.\nrewrite PTree.gro by congruence.\nauto.\nassert (GET3: c!pc = Some b).\nrewrite <- GET2.\napply INV.\napply PTree.grs.\nassert (X: fn.(fn_code)!pc = Some b) by auto.\nassert (Y: c!pc <> None) by congruence.\ngeneralize (record_cond_correct c u changed f pc b BMC X Y).\ndestruct (record_cond (c, u, changed) pc b) as [[c1 u1] changed1]; simpl.\nauto.\ndestruct x as [[c1 u1] changed1]; destruct REC as [[COMPAT1 INV1] BMC1]; auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) : let\n'(c', u', _) := PTree.fold record_cond c0 (c0, u0, false) in\n code_compat c' * {f' : node -> nat | branch_map_correct_2 c' u' f'}.","proofString":"set (x := PTree.fold record_cond c0 (c0, u0, false)).\nset (P := fun (cd: code) (cuc: code * U.t * bool) =>            (code_compat (fst (fst cuc)) *             code_invariant cd (fst (fst cuc)) c0 *             { f | branch_map_correct_2 (fst (fst cuc)) (snd (fst cuc)) f })%type).\nassert (REC: P c0 x).\nunfold x; apply PTree_Properties.fold_ind.\nintros cd EMPTY.\nsplit; [split|]; simpl.\nauto.\nred; auto.\nexists f0; auto.\nintros cd [[c u] changed] pc b GET1 GET2 [[COMPAT INV] [f BMC]].\nsimpl in *.\nsplit; [split|].\nunfold record_cond; destruct b as [ | [] b]; simpl; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq pc0 pc).\ndiscriminate.\nauto.\nassert (DFL: code_invariant cd c c0).\nintros p GET.\napply INV.\nrewrite PTree.gro by congruence.\nauto.\nunfold record_cond; destruct b as [ | [] b]; simpl; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nintros p GET.\nrewrite PTree.gro by congruence.\napply INV.\nrewrite PTree.gro by congruence.\nauto.\nassert (GET3: c!pc = Some b).\nrewrite <- GET2.\napply INV.\napply PTree.grs.\nassert (X: fn.(fn_code)!pc = Some b) by auto.\nassert (Y: c!pc <> None) by congruence.\ngeneralize (record_cond_correct c u changed f pc b BMC X Y).\ndestruct (record_cond (c, u, changed) pc b) as [[c1 u1] changed1]; simpl.\nauto.\ndestruct x as [[c1 u1] changed1]; destruct REC as [[COMPAT1 INV1] BMC1]; auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (EMPTY : forall k : PTree.elt, cd ! k = None) : code_compat c0.","proofString":"auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (EMPTY : forall k : PTree.elt, cd ! k = None) : code_invariant cd c0 c0.","proofString":"red; auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (EMPTY : forall k : PTree.elt, cd ! k = None) : {f : node -> nat | branch_map_correct_2 c0 u0 f}.","proofString":"exists f0; auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : code_compat (fst (fst (record_cond (c, u, changed) pc b))).","proofString":"unfold record_cond; destruct b as [ | [] b]; simpl; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq pc0 pc).\ndiscriminate.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : code_compat\n  (fst\n     (fst\n        (if peq (U.repr u s1) (U.repr u s2)\n         then (PTree.remove pc c, U.union u pc s1, true)\n         else (c, u, changed)))).","proofString":"destruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq pc0 pc).\ndiscriminate.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (e : U.repr u s1 = U.repr u s2) : code_compat (PTree.remove pc c).","proofString":"red; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq pc0 pc).\ndiscriminate.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (e : U.repr u s1 = U.repr u s2) (pc0 : positive) (b0 : bblock) (H : (PTree.remove pc c) ! pc0 = Some b0) : (fn_code fn) ! pc0 = Some b0.","proofString":"rewrite PTree.grspec in H.\ndestruct (PTree.elt_eq pc0 pc).\ndiscriminate.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (e : U.repr u s1 = U.repr u s2) (pc0 : positive) (b0 : bblock) (H : (if PTree.elt_eq pc0 pc then None else c ! pc0) = Some b0) : (fn_code fn) ! pc0 = Some b0.","proofString":"destruct (PTree.elt_eq pc0 pc).\ndiscriminate.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (e : U.repr u s1 = U.repr u s2) (pc0 : positive) (b0 : bblock) (e0 : pc0 = pc) (H : None = Some b0) : (fn_code fn) ! pc0 = Some b0.","proofString":"discriminate."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (e : U.repr u s1 = U.repr u s2) (pc0 : positive) (b0 : bblock) (n : pc0 <> pc) (H : c ! pc0 = Some b0) : (fn_code fn) ! pc0 = Some b0.","proofString":"auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : code_invariant cd (fst (fst (record_cond (c, u, changed) pc b))) c0.","proofString":"assert (DFL: code_invariant cd c c0).\nintros p GET.\napply INV.\nrewrite PTree.gro by congruence.\nauto.\nunfold record_cond; destruct b as [ | [] b]; simpl; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nintros p GET.\nrewrite PTree.gro by congruence.\napply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : code_invariant cd c c0.","proofString":"intros p GET.\napply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (p : positive) (GET : cd ! p = None) : c ! p = c0 ! p.","proofString":"apply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (p : positive) (GET : cd ! p = None) : (PTree.remove pc cd) ! p = None.","proofString":"rewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (p : positive) (GET : cd ! p = None) : cd ! p = None.","proofString":"auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (DFL : code_invariant cd c c0) : code_invariant cd (fst (fst (record_cond (c, u, changed) pc b))) c0.","proofString":"unfold record_cond; destruct b as [ | [] b]; simpl; auto.\ndestruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nintros p GET.\nrewrite PTree.gro by congruence.\napply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (DFL : code_invariant cd c c0) : code_invariant cd\n  (fst\n     (fst\n        (if peq (U.repr u s1) (U.repr u s2)\n         then (PTree.remove pc c, U.union u pc s1, true)\n         else (c, u, changed)))) c0.","proofString":"destruct (peq (U.repr u s1) (U.repr u s2)); simpl; auto.\nintros p GET.\nrewrite PTree.gro by congruence.\napply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (DFL : code_invariant cd c c0) (e : U.repr u s1 = U.repr u s2) : code_invariant cd (PTree.remove pc c) c0.","proofString":"intros p GET.\nrewrite PTree.gro by congruence.\napply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (DFL : code_invariant cd c c0) (e : U.repr u s1 = U.repr u s2) (p : positive) (GET : cd ! p = None) : (PTree.remove pc c) ! p = c0 ! p.","proofString":"rewrite PTree.gro by congruence.\napply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (DFL : code_invariant cd c c0) (e : U.repr u s1 = U.repr u s2) (p : positive) (GET : cd ! p = None) : c ! p = c0 ! p.","proofString":"apply INV.\nrewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (DFL : code_invariant cd c c0) (e : U.repr u s1 = U.repr u s2) (p : positive) (GET : cd ! p = None) : (PTree.remove pc cd) ! p = None.","proofString":"rewrite PTree.gro by congruence.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list instruction) (GET1 : cd ! pc = Some (Lcond cond args s1 s2 :: b)) (GET2 : c0 ! pc = Some (Lcond cond args s1 s2 :: b)) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (DFL : code_invariant cd c c0) (e : U.repr u s1 = U.repr u s2) (p : positive) (GET : cd ! p = None) : cd ! p = None.","proofString":"auto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : {f1 : node -> nat\n| branch_map_correct_2 (fst (fst (record_cond (c, u, changed) pc b)))\n    (snd (fst (record_cond (c, u, changed) pc b))) f1}.","proofString":"assert (GET3: c!pc = Some b).\nrewrite <- GET2.\napply INV.\napply PTree.grs.\nassert (X: fn.(fn_code)!pc = Some b) by auto.\nassert (Y: c!pc <> None) by congruence.\ngeneralize (record_cond_correct c u changed f pc b BMC X Y).\ndestruct (record_cond (c, u, changed) pc b) as [[c1 u1] changed1]; simpl.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : c ! pc = Some b.","proofString":"rewrite <- GET2.\napply INV.\napply PTree.grs."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : c ! pc = c0 ! pc.","proofString":"apply INV.\napply PTree.grs."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) : (PTree.remove pc cd) ! pc = None.","proofString":"apply PTree.grs."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (GET3 : c ! pc = Some b) : {f1 : node -> nat\n| branch_map_correct_2 (fst (fst (record_cond (c, u, changed) pc b)))\n    (snd (fst (record_cond (c, u, changed) pc b))) f1}.","proofString":"assert (X: fn.(fn_code)!pc = Some b) by auto.\nassert (Y: c!pc <> None) by congruence.\ngeneralize (record_cond_correct c u changed f pc b BMC X Y).\ndestruct (record_cond (c, u, changed) pc b) as [[c1 u1] changed1]; simpl.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (GET3 : c ! pc = Some b) (X : (fn_code fn) ! pc = Some b) : {f1 : node -> nat\n| branch_map_correct_2 (fst (fst (record_cond (c, u, changed) pc b)))\n    (snd (fst (record_cond (c, u, changed) pc b))) f1}.","proofString":"assert (Y: c!pc <> None) by congruence.\ngeneralize (record_cond_correct c u changed f pc b BMC X Y).\ndestruct (record_cond (c, u, changed) pc b) as [[c1 u1] changed1]; simpl.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (GET3 : c ! pc = Some b) (X : (fn_code fn) ! pc = Some b) (Y : c ! pc <> None) : {f1 : node -> nat\n| branch_map_correct_2 (fst (fst (record_cond (c, u, changed) pc b)))\n    (snd (fst (record_cond (c, u, changed) pc b))) f1}.","proofString":"generalize (record_cond_correct c u changed f pc b BMC X Y).\ndestruct (record_cond (c, u, changed) pc b) as [[c1 u1] changed1]; simpl.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (GET3 : c ! pc = Some b) (X : (fn_code fn) ! pc = Some b) (Y : c ! pc <> None) : (let\n '(c1, u1, _) := record_cond (c, u, changed) pc b in\n  {f' : node -> nat | branch_map_correct_2 c1 u1 f'}) ->\n{f1 : node -> nat\n| branch_map_correct_2 (fst (fst (record_cond (c, u, changed) pc b)))\n    (snd (fst (record_cond (c, u, changed) pc b))) f1}.","proofString":"destruct (record_cond (c, u, changed) pc b) as [[c1 u1] changed1]; simpl.\nauto."},{"statement":"(c0 : code) (u0 : U.t) (f0 : node -> nat) (BMC0 : branch_map_correct_2 c0 u0 f0) (COMPAT0 : code_compat c0) (x : code * U.t * bool) (P : code -> code * U.t * bool -> Set) (cd : PTree.t bblock) (c : code) (u : U.t) (changed : bool) (pc : PTree.elt) (b : bblock) (GET1 : cd ! pc = Some b) (GET2 : c0 ! pc = Some b) (COMPAT : code_compat c) (INV : code_invariant (PTree.remove pc cd) c c0) (f : node -> nat) (BMC : branch_map_correct_2 c u f) (GET3 : c ! pc = Some b) (X : (fn_code fn) ! pc = Some b) (Y : c ! pc <> None) (c1 : code) (u1 : U.t) (changed1 : bool) : {f' : node -> nat | branch_map_correct_2 c1 u1 f'} ->\n{f1 : node -> nat | branch_map_correct_2 c1 u1 f1}.","proofString":"auto."},{"statement":"(cu0 : code * U.t) : {f : node -> nat | branch_map_correct_2 (fst cu0) (snd cu0) f} ->\ncode_compat (fst cu0) ->\n{f : node -> nat | branch_map_correct (record_conds cu0) f}.","proofString":"functional induction (record_conds cu0); intros.\ndestruct cu as [c u], cu' as [c' u'], H as [f BMC].\ngeneralize (record_conds_1_correct c u f BMC H0).\nrewrite e.\nintros [U V].\napply IHt; auto.\ndestruct cu as [c u], H as [f BMC].\nexists f.\nintros pc.\nspecialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; tauto."},{"statement":"(cu cu' : code * U.t) (e : record_conds_1 cu = (cu', true)) (IHt : {f : node -> nat | branch_map_correct_2 (fst cu') (snd cu') f} ->\ncode_compat (fst cu') ->\n{f : node -> nat | branch_map_correct (record_conds cu') f}) (H : {f : node -> nat | branch_map_correct_2 (fst cu) (snd cu) f}) (H0 : code_compat (fst cu)) : {f : node -> nat | branch_map_correct (record_conds cu') f}.","proofString":"destruct cu as [c u], cu' as [c' u'], H as [f BMC].\ngeneralize (record_conds_1_correct c u f BMC H0).\nrewrite e.\nintros [U V].\napply IHt; auto."},{"statement":"(c : code) (u : U.t) (c' : code) (u' : U.t) (e : record_conds_1 (c, u) = (c', u', true)) (IHt : {f0 : node -> nat | branch_map_correct_2 (fst (c', u')) (snd (c', u')) f0} ->\ncode_compat (fst (c', u')) ->\n{f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}) (f : node -> nat) (BMC : branch_map_correct_2 (fst (c, u)) (snd (c, u)) f) (H0 : code_compat (fst (c, u))) : {f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}.","proofString":"generalize (record_conds_1_correct c u f BMC H0).\nrewrite e.\nintros [U V].\napply IHt; auto."},{"statement":"(c : code) (u : U.t) (c' : code) (u' : U.t) (e : record_conds_1 (c, u) = (c', u', true)) (IHt : {f0 : node -> nat | branch_map_correct_2 (fst (c', u')) (snd (c', u')) f0} ->\ncode_compat (fst (c', u')) ->\n{f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}) (f : node -> nat) (BMC : branch_map_correct_2 (fst (c, u)) (snd (c, u)) f) (H0 : code_compat (fst (c, u))) : (let\n '(c'0, u'0, _) := record_conds_1 (c, u) in\n  code_compat c'0 * {f' : node -> nat | branch_map_correct_2 c'0 u'0 f'}) ->\n{f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}.","proofString":"rewrite e.\nintros [U V].\napply IHt; auto."},{"statement":"(c : code) (u : U.t) (c' : code) (u' : U.t) (e : record_conds_1 (c, u) = (c', u', true)) (IHt : {f0 : node -> nat | branch_map_correct_2 (fst (c', u')) (snd (c', u')) f0} ->\ncode_compat (fst (c', u')) ->\n{f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}) (f : node -> nat) (BMC : branch_map_correct_2 (fst (c, u)) (snd (c, u)) f) (H0 : code_compat (fst (c, u))) : code_compat c' * {f' : node -> nat | branch_map_correct_2 c' u' f'} ->\n{f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}.","proofString":"intros [U V].\napply IHt; auto."},{"statement":"(c : code) (u : U.t) (c' : code) (u' : U.t) (e : record_conds_1 (c, u) = (c', u', true)) (IHt : {f0 : node -> nat | branch_map_correct_2 (fst (c', u')) (snd (c', u')) f0} ->\ncode_compat (fst (c', u')) ->\n{f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}) (f : node -> nat) (BMC : branch_map_correct_2 (fst (c, u)) (snd (c, u)) f) (H0 : code_compat (fst (c, u))) (U : code_compat c') (V : {f' : node -> nat | branch_map_correct_2 c' u' f'}) : {f0 : node -> nat | branch_map_correct (record_conds (c', u')) f0}.","proofString":"apply IHt; auto."},{"statement":"(cu cu' : code * U.t) (e : record_conds_1 cu = (cu', false)) (H : {f : node -> nat | branch_map_correct_2 (fst cu) (snd cu) f}) (H0 : code_compat (fst cu)) : {f : node -> nat | branch_map_correct (snd cu) f}.","proofString":"destruct cu as [c u], H as [f BMC].\nexists f.\nintros pc.\nspecialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; tauto."},{"statement":"(c : code) (u : U.t) (cu' : code * U.t) (e : record_conds_1 (c, u) = (cu', false)) (f : node -> nat) (BMC : branch_map_correct_2 (fst (c, u)) (snd (c, u)) f) (H0 : code_compat (fst (c, u))) : {f0 : node -> nat | branch_map_correct (snd (c, u)) f0}.","proofString":"exists f.\nintros pc.\nspecialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; tauto."},{"statement":"(c : code) (u : U.t) (cu' : code * U.t) (e : record_conds_1 (c, u) = (cu', false)) (f : node -> nat) (BMC : branch_map_correct_2 (fst (c, u)) (snd (c, u)) f) (H0 : code_compat (fst (c, u))) : branch_map_correct (snd (c, u)) f.","proofString":"intros pc.\nspecialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; tauto."},{"statement":"(c : code) (u : U.t) (cu' : code * U.t) (e : record_conds_1 (c, u) = (cu', false)) (f : node -> nat) (BMC : branch_map_correct_2 (fst (c, u)) (snd (c, u)) f) (H0 : code_compat (fst (c, u))) (pc : positive) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr (snd (c, u)) pc = pc \\/\n    U.repr (snd (c, u)) pc = U.repr (snd (c, u)) s /\\ (f s < f pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    U.repr (snd (c, u)) pc = pc \\/\n    U.repr (snd (c, u)) pc = U.repr (snd (c, u)) s1 /\\\n    U.repr (snd (c, u)) pc = U.repr (snd (c, u)) s2 /\\\n    (f s1 < f pc)%nat /\\ (f s2 < f pc)%nat\n| _ => U.repr (snd (c, u)) pc = pc\nend.","proofString":"specialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; tauto."},{"statement":"(c : code) (u : U.t) (cu' : code * U.t) (e : PTree.fold record_cond c (c, u, false) = (cu', false)) (f : node -> nat) (pc : positive) (BMC : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr u pc = pc \\/ U.repr u pc = U.repr u s /\\ (f s < f pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    U.repr u pc = pc \\/\n    c ! pc = None /\\\n    U.repr u pc = U.repr u s1 /\\\n    U.repr u pc = U.repr u s2 /\\ (f s1 < f pc)%nat /\\ (f s2 < f pc)%nat\n| _ => U.repr u pc = pc\nend) (H0 : code_compat c) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr u pc = pc \\/ U.repr u pc = U.repr u s /\\ (f s < f pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    U.repr u pc = pc \\/\n    U.repr u pc = U.repr u s1 /\\\n    U.repr u pc = U.repr u s2 /\\ (f s1 < f pc)%nat /\\ (f s2 < f pc)%nat\n| _ => U.repr u pc = pc\nend.","proofString":"destruct (fn_code fn)!pc as [ [ | [] b ] | ]; tauto."},{"statement":"{f : node -> nat | branch_map_correct_2 (fn_code fn) (record_branches fn) f}.","proofString":"destruct record_branches_correct as [f BMC].\nexists f.\nintros pc.\nspecialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; auto."},{"statement":"(f : node -> nat) (BMC : branch_map_correct_1 (fn_code fn) (record_branches fn) f) : {f0 : node -> nat\n| branch_map_correct_2 (fn_code fn) (record_branches fn) f0}.","proofString":"exists f.\nintros pc.\nspecialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; auto."},{"statement":"(f : node -> nat) (BMC : branch_map_correct_1 (fn_code fn) (record_branches fn) f) : branch_map_correct_2 (fn_code fn) (record_branches fn) f.","proofString":"intros pc.\nspecialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; auto."},{"statement":"(f : node -> nat) (BMC : branch_map_correct_1 (fn_code fn) (record_branches fn) f) (pc : positive) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr (record_branches fn) pc = pc \\/\n    U.repr (record_branches fn) pc = U.repr (record_branches fn) s /\\\n    (f s < f pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    U.repr (record_branches fn) pc = pc \\/\n    (fn_code fn) ! pc = None /\\\n    U.repr (record_branches fn) pc = U.repr (record_branches fn) s1 /\\\n    U.repr (record_branches fn) pc = U.repr (record_branches fn) s2 /\\\n    (f s1 < f pc)%nat /\\ (f s2 < f pc)%nat\n| _ => U.repr (record_branches fn) pc = pc\nend.","proofString":"specialize (BMC pc); simpl in *.\ndestruct (fn_code fn)!pc as [ [ | [] b ] | ]; auto."},{"statement":"(f : node -> nat) (pc : positive) (BMC : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr (record_branches fn) pc = pc \\/\n    U.repr (record_branches fn) pc = U.repr (record_branches fn) s /\\\n    (f s < f pc)%nat\n| _ => U.repr (record_branches fn) pc = pc\nend) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    U.repr (record_branches fn) pc = pc \\/\n    U.repr (record_branches fn) pc = U.repr (record_branches fn) s /\\\n    (f s < f pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    U.repr (record_branches fn) pc = pc \\/\n    (fn_code fn) ! pc = None /\\\n    U.repr (record_branches fn) pc = U.repr (record_branches fn) s1 /\\\n    U.repr (record_branches fn) pc = U.repr (record_branches fn) s2 /\\\n    (f s1 < f pc)%nat /\\ (f s2 < f pc)%nat\n| _ => U.repr (record_branches fn) pc = pc\nend.","proofString":"destruct (fn_code fn)!pc as [ [ | [] b ] | ]; auto."},{"statement":"code_compat (fn_code fn).","proofString":"red; auto."},{"statement":"(pc : positive) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    branch_target pc = pc \\/\n    branch_target pc = branch_target s /\\\n    (count_gotos s < count_gotos pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    branch_target pc = pc \\/\n    branch_target pc = branch_target s1 /\\\n    branch_target pc = branch_target s2 /\\\n    (count_gotos s1 < count_gotos pc)%nat /\\\n    (count_gotos s2 < count_gotos pc)%nat\n| _ => branch_target pc = pc\nend.","proofString":"unfold count_gotos.\ndestruct record_gotos_correct_1 as [f P]; simpl.\napply P."},{"statement":"(pc : positive) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    branch_target pc = pc \\/\n    branch_target pc = branch_target s /\\\n    (proj1_sig record_gotos_correct_1 s < proj1_sig record_gotos_correct_1 pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    branch_target pc = pc \\/\n    branch_target pc = branch_target s1 /\\\n    branch_target pc = branch_target s2 /\\\n    (proj1_sig record_gotos_correct_1 s1 <\n     proj1_sig record_gotos_correct_1 pc)%nat /\\\n    (proj1_sig record_gotos_correct_1 s2 <\n     proj1_sig record_gotos_correct_1 pc)%nat\n| _ => branch_target pc = pc\nend.","proofString":"destruct record_gotos_correct_1 as [f P]; simpl.\napply P."},{"statement":"(pc : positive) (f : node -> nat) (P : branch_map_correct (record_gotos fn) f) : match (fn_code fn) ! pc with\n| Some (Lbranch s :: _) =>\n    branch_target pc = pc \\/\n    branch_target pc = branch_target s /\\ (f s < f pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    branch_target pc = pc \\/\n    branch_target pc = branch_target s1 /\\\n    branch_target pc = branch_target s2 /\\\n    (f s1 < f pc)%nat /\\ (f s2 < f pc)%nat\n| _ => branch_target pc = pc\nend.","proofString":"apply P."},{"statement":"(ls1 ls2 : locset) (v1 v2 : val) (l : loc) (H : locmap_lessdef ls1 ls2) (H0 : Val.lessdef v1 v2) (l' : loc) : Val.lessdef (Locmap.set l v1 ls1 l') (Locmap.set l v2 ls2 l').","proofString":"unfold Locmap.set.\ndestruct (Loc.eq l l').\ndestruct l; auto using Val.load_result_lessdef.\ndestruct (Loc.diff_dec l l'); auto."},{"statement":"(ls1 ls2 : locset) (v1 v2 : val) (l : loc) (H : locmap_lessdef ls1 ls2) (H0 : Val.lessdef v1 v2) (l' : loc) : Val.lessdef\n  (if Loc.eq l l'\n   then\n    match l with\n    | R _ => v1\n    | S _ _ ty => Val.load_result (chunk_of_type ty) v1\n    end\n   else if Loc.diff_dec l l' then ls1 l' else Vundef)\n  (if Loc.eq l l'\n   then\n    match l with\n    | R _ => v2\n    | S _ _ ty => Val.load_result (chunk_of_type ty) v2\n    end\n   else if Loc.diff_dec l l' then ls2 l' else Vundef).","proofString":"destruct (Loc.eq l l').\ndestruct l; auto using Val.load_result_lessdef.\ndestruct (Loc.diff_dec l l'); auto."},{"statement":"(ls1 ls2 : locset) (v1 v2 : val) (l : loc) (H : locmap_lessdef ls1 ls2) (H0 : Val.lessdef v1 v2) (l' : loc) (e : l = l') : Val.lessdef\n  match l with\n  | R _ => v1\n  | S _ _ ty => Val.load_result (chunk_of_type ty) v1\n  end\n  match l with\n  | R _ => v2\n  | S _ _ ty => Val.load_result (chunk_of_type ty) v2\n  end.","proofString":"destruct l; auto using Val.load_result_lessdef."},{"statement":"(ls1 ls2 : locset) (v1 v2 : val) (l : loc) (H : locmap_lessdef ls1 ls2) (H0 : Val.lessdef v1 v2) (l' : loc) (n : l <> l') : Val.lessdef (if Loc.diff_dec l l' then ls1 l' else Vundef)\n  (if Loc.diff_dec l l' then ls2 l' else Vundef).","proofString":"destruct (Loc.diff_dec l l'); auto."},{"statement":"(ls1 ls2 : locset) (l : loc) (H : locmap_lessdef ls1 ls2) (l' : loc) : Val.lessdef (Locmap.set l Vundef ls1 l') (ls2 l').","proofString":"unfold Locmap.set.\ndestruct (Loc.eq l l').\ndestruct l; auto.\ndestruct ty; auto.\ndestruct (Loc.diff_dec l l'); auto."},{"statement":"(ls1 ls2 : locset) (l : loc) (H : locmap_lessdef ls1 ls2) (l' : loc) : Val.lessdef\n  (if Loc.eq l l'\n   then\n    match l with\n    | R _ => Vundef\n    | S _ _ ty => Val.load_result (chunk_of_type ty) Vundef\n    end\n   else if Loc.diff_dec l l' then ls1 l' else Vundef) \n  (ls2 l').","proofString":"destruct (Loc.eq l l').\ndestruct l; auto.\ndestruct ty; auto.\ndestruct (Loc.diff_dec l l'); auto."},{"statement":"(ls1 ls2 : locset) (l : loc) (H : locmap_lessdef ls1 ls2) (l' : loc) (e : l = l') : Val.lessdef\n  match l with\n  | R _ => Vundef\n  | S _ _ ty => Val.load_result (chunk_of_type ty) Vundef\n  end (ls2 l').","proofString":"destruct l; auto.\ndestruct ty; auto."},{"statement":"(ls1 ls2 : locset) (sl : slot) (pos : Z) (ty : typ) (H : locmap_lessdef ls1 ls2) (l' : loc) (e : S sl pos ty = l') : Val.lessdef (Val.load_result (chunk_of_type ty) Vundef) (ls2 l').","proofString":"destruct ty; auto."},{"statement":"(ls1 ls2 : locset) (l : loc) (H : locmap_lessdef ls1 ls2) (l' : loc) (n : l <> l') : Val.lessdef (if Loc.diff_dec l l' then ls1 l' else Vundef) (ls2 l').","proofString":"destruct (Loc.diff_dec l l'); auto."},{"statement":"(ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) : locmap_lessdef ls1 ls2.","proofString":"auto."},{"statement":"(r : mreg) (rl : list mreg) (IHrl : forall ls0 ls3 : locset,\nlocmap_lessdef ls0 ls3 ->\nlocmap_lessdef (undef_regs rl ls0) (undef_regs rl ls3)) (ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) : locmap_lessdef (Locmap.set (R r) Vundef (undef_regs rl ls1))\n  (Locmap.set (R r) Vundef (undef_regs rl ls2)).","proofString":"apply locmap_set_lessdef; auto."},{"statement":"(ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) : locmap_lessdef ls1 ls2.","proofString":"auto."},{"statement":"(r : mreg) (rl : list mreg) (IHrl : forall ls0 ls3 : locset,\nlocmap_lessdef ls0 ls3 -> locmap_lessdef (undef_regs rl ls0) ls3) (ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) : locmap_lessdef (Locmap.set (R r) Vundef (undef_regs rl ls1)) ls2.","proofString":"apply locmap_set_undef_lessdef; auto."},{"statement":"(pl : list (rpair loc)) (ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) : Val.lessdef_list (map (fun p : rpair loc => Locmap.getpair p ls1) pl)\n  (map (fun p : rpair loc => Locmap.getpair p ls2) pl).","proofString":"induction pl; simpl; auto using locmap_getpair_lessdef."},{"statement":"(ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) (l : loc) : Val.lessdef (undef_caller_save_regs ls1 l) (undef_caller_save_regs ls2 l).","proofString":"unfold undef_caller_save_regs.\ndestruct l.\ndestruct (Conventions1.is_callee_save r); auto.\ndestruct sl; auto."},{"statement":"(ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) (l : loc) : Val.lessdef\n  match l with\n  | R r => if Conventions1.is_callee_save r then ls1 (R r) else Vundef\n  | S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => ls1 (S sl ofs ty)\n  | S Outgoing _ _ => Vundef\n  end\n  match l with\n  | R r => if Conventions1.is_callee_save r then ls2 (R r) else Vundef\n  | S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => ls2 (S sl ofs ty)\n  | S Outgoing _ _ => Vundef\n  end.","proofString":"destruct l.\ndestruct (Conventions1.is_callee_save r); auto.\ndestruct sl; auto."},{"statement":"(ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) (r : mreg) : Val.lessdef (if Conventions1.is_callee_save r then ls1 (R r) else Vundef)\n  (if Conventions1.is_callee_save r then ls2 (R r) else Vundef).","proofString":"destruct (Conventions1.is_callee_save r); auto."},{"statement":"(ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) (sl : slot) (pos : Z) (ty : typ) : Val.lessdef match sl with\n            | Outgoing => Vundef\n            | _ => ls1 (S sl pos ty)\n            end\n  match sl with\n  | Outgoing => Vundef\n  | _ => ls2 (S sl pos ty)\n  end.","proofString":"destruct sl; auto."},{"statement":"(ros : mreg + ident) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : find_function ge ros ls = Some fd) : find_function tge ros tls = Some (tunnel_fundef fd).","proofString":"destruct ros; simpl in *.\nassert (E: tls (R m) = ls (R m)).\nexploit Genv.find_funct_inv; eauto.\nintros (b & EQ).\ngeneralize (H (R m)).\nrewrite EQ.\nintros LD; inv LD.\nauto.\nrewrite E.\napply functions_translated; auto.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i); inv H0.\napply function_ptr_translated; auto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) : Genv.find_funct tge (tls (R m)) = Some (tunnel_fundef fd).","proofString":"assert (E: tls (R m) = ls (R m)).\nexploit Genv.find_funct_inv; eauto.\nintros (b & EQ).\ngeneralize (H (R m)).\nrewrite EQ.\nintros LD; inv LD.\nauto.\nrewrite E.\napply functions_translated; auto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) : tls (R m) = ls (R m).","proofString":"exploit Genv.find_funct_inv; eauto.\nintros (b & EQ).\ngeneralize (H (R m)).\nrewrite EQ.\nintros LD; inv LD.\nauto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) : (exists b : block, ls (R m) = Vptr b Integers.Ptrofs.zero) ->\ntls (R m) = ls (R m).","proofString":"intros (b & EQ).\ngeneralize (H (R m)).\nrewrite EQ.\nintros LD; inv LD.\nauto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) (b : block) (EQ : ls (R m) = Vptr b Integers.Ptrofs.zero) : tls (R m) = ls (R m).","proofString":"generalize (H (R m)).\nrewrite EQ.\nintros LD; inv LD.\nauto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) (b : block) (EQ : ls (R m) = Vptr b Integers.Ptrofs.zero) : Val.lessdef (ls (R m)) (tls (R m)) -> tls (R m) = ls (R m).","proofString":"rewrite EQ.\nintros LD; inv LD.\nauto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) (b : block) (EQ : ls (R m) = Vptr b Integers.Ptrofs.zero) : Val.lessdef (Vptr b Integers.Ptrofs.zero) (tls (R m)) ->\ntls (R m) = Vptr b Integers.Ptrofs.zero.","proofString":"intros LD; inv LD.\nauto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) (b : block) (EQ : ls (R m) = Vptr b Integers.Ptrofs.zero) (H3 : Vptr b Integers.Ptrofs.zero = tls (R m)) : Vptr b Integers.Ptrofs.zero = Vptr b Integers.Ptrofs.zero.","proofString":"auto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) (E : tls (R m) = ls (R m)) : Genv.find_funct tge (tls (R m)) = Some (tunnel_fundef fd).","proofString":"rewrite E.\napply functions_translated; auto."},{"statement":"(m : mreg) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : Genv.find_funct ge (ls (R m)) = Some fd) (E : tls (R m) = ls (R m)) : Genv.find_funct tge (ls (R m)) = Some (tunnel_fundef fd).","proofString":"apply functions_translated; auto."},{"statement":"(i : ident) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) : match Genv.find_symbol tge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (tunnel_fundef fd).","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i); inv H0.\napply function_ptr_translated; auto."},{"statement":"(i : ident) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (H0 : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (tunnel_fundef fd).","proofString":"destruct (Genv.find_symbol ge i); inv H0.\napply function_ptr_translated; auto."},{"statement":"(i : ident) (ls tls : locset) (fd : fundef) (H : locmap_lessdef ls tls) (b : block) (H2 : Genv.find_funct_ptr ge b = Some fd) : Genv.find_funct_ptr tge b = Some (tunnel_fundef fd).","proofString":"apply function_ptr_translated; auto."},{"statement":"(ls1 ls2 : locset) (H : locmap_lessdef ls1 ls2) (l : loc) : Val.lessdef (call_regs ls1 l) (call_regs ls2 l).","proofString":"destruct l as [r | [] ofs ty]; simpl; auto."},{"statement":"(caller1 callee1 caller2 callee2 : locset) (H : locmap_lessdef caller1 caller2) (H0 : locmap_lessdef callee1 callee2) (l : loc) : Val.lessdef (return_regs caller1 callee1 l) (return_regs caller2 callee2 l).","proofString":"destruct l; simpl.\ndestruct (Conventions1.is_callee_save r); auto.\ndestruct sl; auto."},{"statement":"(caller1 callee1 caller2 callee2 : locset) (H : locmap_lessdef caller1 caller2) (H0 : locmap_lessdef callee1 callee2) (r : mreg) : Val.lessdef\n  (if Conventions1.is_callee_save r then caller1 (R r) else callee1 (R r))\n  (if Conventions1.is_callee_save r then caller2 (R r) else callee2 (R r)).","proofString":"destruct (Conventions1.is_callee_save r); auto."},{"statement":"(caller1 callee1 caller2 callee2 : locset) (H : locmap_lessdef caller1 caller2) (H0 : locmap_lessdef callee1 callee2) (sl : slot) (pos : Z) (ty : typ) : Val.lessdef\n  match sl with\n  | Outgoing => Vundef\n  | _ => caller1 (S sl pos ty)\n  end match sl with\n      | Outgoing => Vundef\n      | _ => caller2 (S sl pos ty)\n      end.","proofString":"destruct sl; auto."},{"statement":"locmap_lessdef (Locmap.init Vundef) (Locmap.init Vundef).","proofString":"red; auto."},{"statement":"(a1 : stackframe) (al : list stackframe) (b1 : stackframe) (bl : list stackframe) (H : match_stackframes a1 b1) (H0 : list_forall2 match_stackframes al bl) (IHlist_forall2 : locmap_lessdef (parent_locset al) (parent_locset bl)) : locmap_lessdef match a1 with\n               | Stackframe _ _ ls _ => ls\n               end match b1 with\n                   | Stackframe _ _ ls _ => ls\n                   end.","proofString":"inv H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (bb : bblock) (H : (fn_code f) ! pc = Some bb) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp bb rs m) st2') \\/\n(measure (Block s f sp bb rs m) < measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"assert (DEFAULT: branch_target f pc = pc ->    (exists st2' : state,     step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0 st2'     /\\ match_states (Block s f sp bb rs m) st2')).\nintros.\nrewrite H0.\neconstructor; split.\neconstructor.\nsimpl.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\neauto.\neconstructor; eauto.\ngeneralize (record_gotos_correct f pc).\nrewrite H.\ndestruct bb; auto.\ndestruct i; auto.\nintros [A | [B C]].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\nintros [A | (B & C & D & E)].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (bb : bblock) (H : (fn_code f) ! pc = Some bb) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp bb rs m) st2'.","proofString":"intros.\nrewrite H0.\neconstructor; split.\neconstructor.\nsimpl.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\neauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (bb : bblock) (H : (fn_code f) ! pc = Some bb) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (H0 : branch_target f pc = pc) : exists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp bb rs m) st2'.","proofString":"rewrite H0.\neconstructor; split.\neconstructor.\nsimpl.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\neauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (bb : bblock) (H : (fn_code f) ! pc = Some bb) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (H0 : branch_target f pc = pc) : exists st2' : state,\n  step tge (State ts (tunnel_function f) sp pc tls tm) E0 st2' /\\\n  match_states (Block s f sp bb rs m) st2'.","proofString":"econstructor; split.\neconstructor.\nsimpl.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\neauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (bb : bblock) (H : (fn_code f) ! pc = Some bb) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp bb rs m) st2') : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp bb rs m) st2') \\/\n(measure (Block s f sp bb rs m) < measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"generalize (record_gotos_correct f pc).\nrewrite H.\ndestruct bb; auto.\ndestruct i; auto.\nintros [A | [B C]].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\nintros [A | (B & C & D & E)].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (bb : bblock) (H : (fn_code f) ! pc = Some bb) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp bb rs m) st2') : match (fn_code f) ! pc with\n| Some (Lbranch s0 :: _) =>\n    branch_target f pc = pc \\/\n    branch_target f pc = branch_target f s0 /\\\n    (count_gotos f s0 < count_gotos f pc)%nat\n| Some (Lcond _ _ s1 s2 :: _) =>\n    branch_target f pc = pc \\/\n    branch_target f pc = branch_target f s1 /\\\n    branch_target f pc = branch_target f s2 /\\\n    (count_gotos f s1 < count_gotos f pc)%nat /\\\n    (count_gotos f s2 < count_gotos f pc)%nat\n| _ => branch_target f pc = pc\nend ->\n(exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp bb rs m) st2') \\/\n(measure (Block s f sp bb rs m) < measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"rewrite H.\ndestruct bb; auto.\ndestruct i; auto.\nintros [A | [B C]].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\nintros [A | (B & C & D & E)].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (bb : bblock) (H : (fn_code f) ! pc = Some bb) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp bb rs m) st2') : match bb with\n| Lbranch s0 :: _ =>\n    branch_target f pc = pc \\/\n    branch_target f pc = branch_target f s0 /\\\n    (count_gotos f s0 < count_gotos f pc)%nat\n| Lcond _ _ s1 s2 :: _ =>\n    branch_target f pc = pc \\/\n    branch_target f pc = branch_target f s1 /\\\n    branch_target f pc = branch_target f s2 /\\\n    (count_gotos f s1 < count_gotos f pc)%nat /\\\n    (count_gotos f s2 < count_gotos f pc)%nat\n| _ => branch_target f pc = pc\nend ->\n(exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp bb rs m) st2') \\/\n(measure (Block s f sp bb rs m) < measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"destruct bb; auto.\ndestruct i; auto.\nintros [A | [B C]].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\nintros [A | (B & C & D & E)].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (i : instruction) (bb : list instruction) (H : (fn_code f) ! pc = Some (i :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (i :: bb) rs m) st2') : match i with\n| Lbranch s0 =>\n    branch_target f pc = pc \\/\n    branch_target f pc = branch_target f s0 /\\\n    (count_gotos f s0 < count_gotos f pc)%nat\n| Lcond _ _ s1 s2 =>\n    branch_target f pc = pc \\/\n    branch_target f pc = branch_target f s1 /\\\n    branch_target f pc = branch_target f s2 /\\\n    (count_gotos f s1 < count_gotos f pc)%nat /\\\n    (count_gotos f s2 < count_gotos f pc)%nat\n| _ => branch_target f pc = pc\nend ->\n(exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp (i :: bb) rs m) st2') \\/\n(measure (Block s f sp (i :: bb) rs m) < measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (i :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"destruct i; auto.\nintros [A | [B C]].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\nintros [A | (B & C & D & E)].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') : branch_target f pc = pc \\/\nbranch_target f pc = branch_target f s0 /\\\n(count_gotos f s0 < count_gotos f pc)%nat ->\n(exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') \\/\n(measure (Block s f sp (Lbranch s0 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lbranch s0 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"intros [A | [B C]].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (A : branch_target f pc = pc) : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') \\/\n(measure (Block s f sp (Lbranch s0 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lbranch s0 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') \\/\n(measure (Block s f sp (Lbranch s0 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lbranch s0 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"right.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : (measure (Block s f sp (Lbranch s0 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lbranch s0 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"split.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : (measure (Block s f sp (Lbranch s0 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat.","proofString":"simpl.\nlia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : (count_gotos f s0 * 2 + 1 < count_gotos f pc * 2)%nat.","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : E0 = E0 /\\\nmatch_states (Block s f sp (Lbranch s0 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"split.\nauto.\nrewrite B.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : E0 = E0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : match_states (Block s f sp (Lbranch s0 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"rewrite B.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (s0 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lbranch s0 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\ match_states (Block s f sp (Lbranch s0 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s0) (C : (count_gotos f s0 < count_gotos f pc)%nat) : match_states (Block s f sp (Lbranch s0 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f s0) tls tm).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') : branch_target f pc = pc \\/\nbranch_target f pc = branch_target f s1 /\\\nbranch_target f pc = branch_target f s2 /\\\n(count_gotos f s1 < count_gotos f pc)%nat /\\\n(count_gotos f s2 < count_gotos f pc)%nat ->\n(exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\\n   match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') \\/\n(measure (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"intros [A | (B & C & D & E)].\nauto.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (A : branch_target f pc = pc) : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\\n   match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') \\/\n(measure (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\\n   match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') \\/\n(measure (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"right.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : (measure (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"split.\nsimpl.\nlia.\nsplit.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : (measure (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) <\n measure (State s f sp pc rs m))%nat.","proofString":"simpl.\nlia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : (Nat.max (count_gotos f s1) (count_gotos f s2) * 2 + 1 < count_gotos f pc * 2)%nat.","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : E0 = E0 /\\\nmatch_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"split.\nauto.\nrewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : E0 = E0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"rewrite B.\neconstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m)\n  (State ts (tunnel_function f) sp (branch_target f s1) tls tm).","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : locset) (m : mem) (cond : condition) (args : list mreg) (s1 s2 : node) (bb : list instruction) (H : (fn_code f) ! pc = Some (Lcond cond args s1 s2 :: bb)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (DEFAULT : branch_target f pc = pc ->\nexists st2' : state,\n  step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n    st2' /\\\n  match_states (Block s f sp (Lcond cond args s1 s2 :: bb) rs m) st2') (B : branch_target f pc = branch_target f s1) (C : branch_target f pc = branch_target f s2) (D : (count_gotos f s1 < count_gotos f pc)%nat) (E : (count_gotos f s2 < count_gotos f pc)%nat) : branch_target f s1 = branch_target f s2.","proofString":"congruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list instruction) (rs : locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lop op args res :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) <\n measure (Block s f sp (Lop op args res :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m)\n  (Block ts (tunnel_function f) sp (tunneled_block f (Lop op args res :: bb))\n     tls tm).","proofString":"exploit eval_operation_lessdef.\napply reglist_lessdef; eauto.\neauto.\neauto.\nintros (tv & EV & LD).\nleft; simpl; econstructor; split.\neapply exec_Lop with (v := tv); eauto.\nrewrite <- EV.\napply eval_operation_preserved.\nexact symbols_preserved.\neconstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list instruction) (rs : locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tv : val) (EV : eval_operation ge sp op (reglist tls args) tm = Some tv) (LD : Val.lessdef v tv) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lop op args res :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) <\n measure (Block s f sp (Lop op args res :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m)\n  (Block ts (tunnel_function f) sp (tunneled_block f (Lop op args res :: bb))\n     tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Lop with (v := tv); eauto.\nrewrite <- EV.\napply eval_operation_preserved.\nexact symbols_preserved.\neconstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list instruction) (rs : locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tv : val) (EV : eval_operation ge sp op (reglist tls args) tm = Some tv) (LD : Val.lessdef v tv) : eval_operation tge sp op (reglist tls args) tm = Some tv.","proofString":"rewrite <- EV.\napply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list instruction) (rs : locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tv : val) (EV : eval_operation ge sp op (reglist tls args) tm = Some tv) (LD : Val.lessdef v tv) : eval_operation tge sp op (reglist tls args) tm =\neval_operation ge sp op (reglist tls args) tm.","proofString":"apply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list instruction) (rs : locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tv : val) (EV : eval_operation ge sp op (reglist tls args) tm = Some tv) (LD : Val.lessdef v tv) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list instruction) (rs : locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lload chunk addr args dst :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs))\n        m) st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m) <\n measure (Block s f sp (Lload chunk addr args dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lload chunk addr args dst :: bb)) tls tm).","proofString":"exploit eval_addressing_lessdef.\napply reglist_lessdef; eauto.\neauto.\nintros (ta & EV & LD).\nexploit Mem.loadv_extends.\neauto.\neauto.\neexact LD.\nintros (tv & LOAD & LD').\nleft; simpl; econstructor; split.\neapply exec_Lload with (a := ta).\nrewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list instruction) (rs : locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lload chunk addr args dst :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs))\n        m) st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m) <\n measure (Block s f sp (Lload chunk addr args dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lload chunk addr args dst :: bb)) tls tm).","proofString":"exploit Mem.loadv_extends.\neauto.\neauto.\neexact LD.\nintros (tv & LOAD & LD').\nleft; simpl; econstructor; split.\neapply exec_Lload with (a := ta).\nrewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list instruction) (rs : locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tv : val) (LOAD : Mem.loadv chunk tm ta = Some tv) (LD' : Val.lessdef v tv) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lload chunk addr args dst :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs))\n        m) st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m) <\n measure (Block s f sp (Lload chunk addr args dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lload chunk addr args dst :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Lload with (a := ta).\nrewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list instruction) (rs : locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tv : val) (LOAD : Mem.loadv chunk tm ta = Some tv) (LD' : Val.lessdef v tv) : eval_addressing tge sp addr (reglist tls args) = Some ta.","proofString":"rewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list instruction) (rs : locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tv : val) (LOAD : Mem.loadv chunk tm ta = Some tv) (LD' : Val.lessdef v tv) : eval_addressing tge sp addr (reglist tls args) =\neval_addressing ge sp addr (reglist tls args).","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list instruction) (rs : locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tv : val) (LOAD : Mem.loadv chunk tm ta = Some tv) (LD' : Val.lessdef v tv) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (bb : list instruction) (rs : loc -> val) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lgetstack sl ofs ty dst :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) (rs (S sl ofs ty))\n           (undef_regs (destroyed_by_getstack sl) rs)) m) st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) (rs (S sl ofs ty))\n         (undef_regs (destroyed_by_getstack sl) rs)) m) <\n measure (Block s f sp (Lgetstack sl ofs ty dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (undef_regs (destroyed_by_getstack sl) rs)) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lgetstack sl ofs ty dst :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neconstructor; eauto.\neconstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (bb : list instruction) (rs : loc -> val) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lsetstack src sl ofs ty :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (S sl ofs ty) (rs (R src))\n           (undef_regs (destroyed_by_setstack ty) rs)) m) st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (S sl ofs ty) (rs (R src))\n         (undef_regs (destroyed_by_setstack ty) rs)) m) <\n measure (Block s f sp (Lsetstack src sl ofs ty :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (undef_regs (destroyed_by_setstack ty) rs)) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lsetstack src sl ofs ty :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neconstructor; eauto.\neconstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list instruction) (rs : locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lstore chunk addr args src :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n     st2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m') <\n measure (Block s f sp (Lstore chunk addr args src :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lstore chunk addr args src :: bb)) tls tm).","proofString":"exploit eval_addressing_lessdef.\napply reglist_lessdef; eauto.\neauto.\nintros (ta & EV & LD).\nexploit Mem.storev_extends.\neauto.\neauto.\neexact LD.\napply LS.\nintros (tm' & STORE & MEM').\nleft; simpl; econstructor; split.\neapply exec_Lstore with (a := ta).\nrewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto using locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list instruction) (rs : locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lstore chunk addr args src :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n     st2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m') <\n measure (Block s f sp (Lstore chunk addr args src :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lstore chunk addr args src :: bb)) tls tm).","proofString":"exploit Mem.storev_extends.\neauto.\neauto.\neexact LD.\napply LS.\nintros (tm' & STORE & MEM').\nleft; simpl; econstructor; split.\neapply exec_Lstore with (a := ta).\nrewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto using locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list instruction) (rs : locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tm' : mem) (STORE : Mem.storev chunk tm ta (tls (R src)) = Some tm') (MEM' : Mem.extends m' tm') : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lstore chunk addr args src :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n     st2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m') <\n measure (Block s f sp (Lstore chunk addr args src :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lstore chunk addr args src :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Lstore with (a := ta).\nrewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto using locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list instruction) (rs : locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tm' : mem) (STORE : Mem.storev chunk tm ta (tls (R src)) = Some tm') (MEM' : Mem.extends m' tm') : eval_addressing tge sp addr (reglist tls args) = Some ta.","proofString":"rewrite <- EV.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list instruction) (rs : locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tm' : mem) (STORE : Mem.storev chunk tm ta (tls (R src)) = Some tm') (MEM' : Mem.extends m' tm') : eval_addressing tge sp addr (reglist tls args) =\neval_addressing ge sp addr (reglist tls args).","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list instruction) (rs : locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (ta : val) (EV : eval_addressing ge sp addr (reglist tls args) = Some ta) (LD : Val.lessdef a ta) (tm' : mem) (STORE : Mem.storev chunk tm ta (tls (R src)) = Some tm') (MEM' : Mem.extends m' tm') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (H : find_function ge ros rs = Some fd) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lcall (funsig fd) ros :: bb)) tls tm) E0 st2' /\\\n   match_states (Callstate (Stackframe f sp rs bb :: s) fd rs m) st2') \\/\n(measure (Callstate (Stackframe f sp rs bb :: s) fd rs m) <\n measure (Block s f sp (Lcall (funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate (Stackframe f sp rs bb :: s) fd rs m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lcall (funsig fd) ros :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Lcall with (fd := tunnel_fundef fd); eauto.\neapply find_function_translated; eauto.\nrewrite sig_preserved.\nauto.\neconstructor; eauto.\nconstructor; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (H : find_function ge ros rs = Some fd) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : find_function tge ros tls = Some (tunnel_fundef fd).","proofString":"eapply find_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (H : find_function ge ros rs = Some fd) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : funsig (tunnel_fundef fd) = funsig fd.","proofString":"rewrite sig_preserved.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (H : find_function ge ros rs = Some fd) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : funsig fd = funsig fd.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (H : find_function ge ros rs = Some fd) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : list_forall2 match_stackframes (Stackframe f sp rs bb :: s)\n  (Stackframe (tunnel_function f) sp tls (tunneled_block f bb) :: ts).","proofString":"constructor; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (H : find_function ge ros rs = Some fd) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : match_stackframes (Stackframe f sp rs bb)\n  (Stackframe (tunnel_function f) sp tls (tunneled_block f bb)).","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : block) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n        (tunneled_block f (Ltailcall (funsig fd) ros :: bb)) tls tm) E0 st2' /\\\n   match_states (Callstate s fd (return_regs (parent_locset s) rs) m') st2') \\/\n(measure (Callstate s fd (return_regs (parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Integers.Ptrofs.zero)\n      (Ltailcall (funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd (return_regs (parent_locset s) rs) m')\n  (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n     (tunneled_block f (Ltailcall (funsig fd) ros :: bb)) tls tm).","proofString":"exploit Mem.free_parallel_extends.\neauto.\neauto.\nintros (tm' & FREE & MEM').\nleft; simpl; econstructor; split.\neapply exec_Ltailcall with (fd := tunnel_fundef fd); eauto.\neapply find_function_translated; eauto using return_regs_lessdef, match_parent_locset.\napply sig_preserved.\neconstructor; eauto using return_regs_lessdef, match_parent_locset."},{"statement":"(s : list stackframe) (f : function) (sp : block) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stacksize f) = Some tm') (MEM' : Mem.extends m' tm') : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n        (tunneled_block f (Ltailcall (funsig fd) ros :: bb)) tls tm) E0 st2' /\\\n   match_states (Callstate s fd (return_regs (parent_locset s) rs) m') st2') \\/\n(measure (Callstate s fd (return_regs (parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Integers.Ptrofs.zero)\n      (Ltailcall (funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd (return_regs (parent_locset s) rs) m')\n  (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n     (tunneled_block f (Ltailcall (funsig fd) ros :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Ltailcall with (fd := tunnel_fundef fd); eauto.\neapply find_function_translated; eauto using return_regs_lessdef, match_parent_locset.\napply sig_preserved.\neconstructor; eauto using return_regs_lessdef, match_parent_locset."},{"statement":"(s : list stackframe) (f : function) (sp : block) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stacksize f) = Some tm') (MEM' : Mem.extends m' tm') : find_function tge ros (return_regs (parent_locset ts) tls) =\nSome (tunnel_fundef fd).","proofString":"eapply find_function_translated; eauto using return_regs_lessdef, match_parent_locset."},{"statement":"(s : list stackframe) (f : function) (sp : block) (ros : mreg + ident) (bb : list instruction) (rs : locset) (m : mem) (fd : fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stacksize f) = Some tm') (MEM' : Mem.extends m' tm') : funsig (tunnel_fundef fd) = funsig fd.","proofString":"apply sig_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm) t st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n     st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m') <\n measure (Block s f sp (Lbuiltin ef args res :: bb) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm).","proofString":"exploit eval_builtin_args_lessdef.\neexact LS.\neauto.\neauto.\nintros (tvargs & EVA & LDA).\nexploit external_call_mem_extends; eauto.\nintros (tvres & tm' & A & B & C & D).\nleft; simpl; econstructor; split.\neapply exec_Lbuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\neconstructor; eauto using locmap_setres_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tvargs : list val) (EVA : eval_builtin_args ge tls sp tm args tvargs) (LDA : Val.lessdef_list vargs tvargs) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm) t st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n     st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m') <\n measure (Block s f sp (Lbuiltin ef args res :: bb) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm).","proofString":"exploit external_call_mem_extends; eauto.\nintros (tvres & tm' & A & B & C & D).\nleft; simpl; econstructor; split.\neapply exec_Lbuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\neconstructor; eauto using locmap_setres_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tvargs : list val) (EVA : eval_builtin_args ge tls sp tm args tvargs) (LDA : Val.lessdef_list vargs tvargs) : (exists (vres' : val) (m2' : mem),\n   external_call ef ge tvargs tm t vres' m2' /\\\n   Val.lessdef vres vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) tm m2') ->\n(exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm) t st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n     st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m') <\n measure (Block s f sp (Lbuiltin ef args res :: bb) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm).","proofString":"intros (tvres & tm' & A & B & C & D).\nleft; simpl; econstructor; split.\neapply exec_Lbuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\neconstructor; eauto using locmap_setres_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tvargs : list val) (EVA : eval_builtin_args ge tls sp tm args tvargs) (LDA : Val.lessdef_list vargs tvargs) (tvres : val) (tm' : mem) (A : external_call ef ge tvargs tm t tvres tm') (B : Val.lessdef vres tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm) t st2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n     st2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m') <\n measure (Block s f sp (Lbuiltin ef args res :: bb) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lbuiltin ef args res :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Lbuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\neconstructor; eauto using locmap_setres_lessdef, locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tvargs : list val) (EVA : eval_builtin_args ge tls sp tm args tvargs) (LDA : Val.lessdef_list vargs tvargs) (tvres : val) (tm' : mem) (A : external_call ef ge tvargs tm t tvres tm') (B : Val.lessdef vres tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp (tunneled_block f (Lbranch pc :: bb))\n        tls tm) E0 st2' /\\ match_states (State s f sp pc rs m) st2') \\/\n(measure (State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs m)\n  (Block ts (tunnel_function f) sp (tunneled_block f (Lbranch pc :: bb)) tls\n     tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Lbranch; eauto.\nfold (branch_target f pc).\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : match_states (State s f sp pc rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0\n     st2' /\\ match_states (State s f sp pc rs m) st2') \\/\n(measure (State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"right; split.\nsimpl.\nlia.\nsplit.\nauto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (measure (State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat.","proofString":"simpl.\nlia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (count_gotos f pc * 2 < count_gotos f pc * 2 + 1)%nat.","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : E0 = E0 /\\\nmatch_states (State s f sp pc rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"split.\nauto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : E0 = E0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (bb : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : match_states (State s f sp pc rs m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Lcond cond args pc1 pc2 :: bb)) tls tm) E0 st2' /\\\n   match_states\n     (State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) st2') \\/\n(measure\n   (State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Lcond cond args pc1 pc2 :: bb)) tls tm).","proofString":"simpl tunneled_block.\nset (s1 := U.repr (record_gotos f) pc1).\nset (s2 := U.repr (record_gotos f) pc2).\ndestruct (peq s1 s2).\nleft; econstructor; split.\neapply exec_Lbranch.\nset (pc := if b then pc1 else pc2).\nreplace s1 with (branch_target f pc) by (unfold pc; destruct b; auto).\nconstructor; eauto using locmap_undef_regs_lessdef_1.\nleft; econstructor; split.\neapply exec_Lcond; eauto.\neapply eval_condition_lessdef; eauto using reglist_lessdef.\ndestruct b; econstructor; eauto using locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        ((if peq (U.repr (record_gotos f) pc1) (U.repr (record_gotos f) pc2)\n          then Lbranch (U.repr (record_gotos f) pc1)\n          else\n           Lcond cond args (U.repr (record_gotos f) pc1)\n             (U.repr (record_gotos f) pc2)) :: tunneled_block f bb) tls tm)\n     E0 st2' /\\\n   match_states\n     (State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) st2') \\/\n(measure\n   (State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (Block ts (tunnel_function f) sp\n     ((if peq (U.repr (record_gotos f) pc1) (U.repr (record_gotos f) pc2)\n       then Lbranch (U.repr (record_gotos f) pc1)\n       else\n        Lcond cond args (U.repr (record_gotos f) pc1)\n          (U.repr (record_gotos f) pc2)) :: tunneled_block f bb) tls tm).","proofString":"set (s1 := U.repr (record_gotos f) pc1).\nset (s2 := U.repr (record_gotos f) pc2).\ndestruct (peq s1 s2).\nleft; econstructor; split.\neapply exec_Lbranch.\nset (pc := if b then pc1 else pc2).\nreplace s1 with (branch_target f pc) by (unfold pc; destruct b; auto).\nconstructor; eauto using locmap_undef_regs_lessdef_1.\nleft; econstructor; split.\neapply exec_Lcond; eauto.\neapply eval_condition_lessdef; eauto using reglist_lessdef.\ndestruct b; econstructor; eauto using locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (s1 : U.elt) (s2 : U.elt) (e : s1 = s2) (pc : node) : match_states (State s f sp pc (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"constructor; eauto using locmap_undef_regs_lessdef_1."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (SAME : branch_target f pc1 = branch_target f pc2) : (exists st2' : state,\n   step tge (State ts (tunnel_function f) sp (branch_target f pc1) tls tm) E0\n     st2' /\\\n   match_states\n     (State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) st2') \\/\n(measure\n   (State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts (tunnel_function f) sp (branch_target f pc1) tls tm).","proofString":"right; split.\nsimpl.\ndestruct b; lia.\nsplit.\nauto.\nset (pc := if b then pc1 else pc2).\nreplace (branch_target f pc1) with (branch_target f pc) by (unfold pc; destruct b; auto).\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (SAME : branch_target f pc1 = branch_target f pc2) : (measure\n   (State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (Lcond cond args pc1 pc2 :: bb) rs m))%nat.","proofString":"simpl.\ndestruct b; lia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (SAME : branch_target f pc1 = branch_target f pc2) : (count_gotos f (if b then pc1 else pc2) * 2 <\n Nat.max (count_gotos f pc1) (count_gotos f pc2) * 2 + 1)%nat.","proofString":"destruct b; lia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (SAME : branch_target f pc1 = branch_target f pc2) : E0 = E0 /\\\nmatch_states\n  (State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts (tunnel_function f) sp (branch_target f pc1) tls tm).","proofString":"split.\nauto.\nset (pc := if b then pc1 else pc2).\nreplace (branch_target f pc1) with (branch_target f pc) by (unfold pc; destruct b; auto).\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (SAME : branch_target f pc1 = branch_target f pc2) : E0 = E0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (SAME : branch_target f pc1 = branch_target f pc2) : match_states\n  (State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts (tunnel_function f) sp (branch_target f pc1) tls tm).","proofString":"set (pc := if b then pc1 else pc2).\nreplace (branch_target f pc1) with (branch_target f pc) by (unfold pc; destruct b; auto).\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list instruction) (rs : locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (SAME : branch_target f pc1 = branch_target f pc2) (pc : node) : match_states (State s f sp pc (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts (tunnel_function f) sp (branch_target f pc) tls tm).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list node) (bb : list instruction) (rs : loc -> val) (m : mem) (n : Integers.Int.int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Ljumptable arg tbl :: bb)) tls tm) E0 st2' /\\\n   match_states (State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n     st2') \\/\n(measure (State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (Ljumptable arg tbl :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Ljumptable arg tbl :: bb)) tls tm).","proofString":"assert (tls (R arg) = Vint n).\ngeneralize (LS (R arg)); rewrite H; intros LD; inv LD; auto.\nleft; simpl; econstructor; split.\neapply exec_Ljumptable.\neauto.\nrewrite list_nth_z_map.\nchange U.elt with node.\nrewrite H0.\nreflexivity.\neauto.\neconstructor; eauto using locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list node) (bb : list instruction) (rs : loc -> val) (m : mem) (n : Integers.Int.int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : tls (R arg) = Vint n.","proofString":"generalize (LS (R arg)); rewrite H; intros LD; inv LD; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list node) (bb : list instruction) (rs : loc -> val) (m : mem) (n : Integers.Int.int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (H1 : tls (R arg) = Vint n) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) sp\n        (tunneled_block f (Ljumptable arg tbl :: bb)) tls tm) E0 st2' /\\\n   match_states (State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n     st2') \\/\n(measure (State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (Ljumptable arg tbl :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (Block ts (tunnel_function f) sp\n     (tunneled_block f (Ljumptable arg tbl :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Ljumptable.\neauto.\nrewrite list_nth_z_map.\nchange U.elt with node.\nrewrite H0.\nreflexivity.\neauto.\neconstructor; eauto using locmap_undef_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (sp : block) (bb : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m sp 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n        (tunneled_block f (Lreturn :: bb)) tls tm) E0 st2' /\\\n   match_states (Returnstate s (return_regs (parent_locset s) rs) m') st2') \\/\n(measure (Returnstate s (return_regs (parent_locset s) rs) m') <\n measure (Block s f (Vptr sp Integers.Ptrofs.zero) (Lreturn :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (return_regs (parent_locset s) rs) m')\n  (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n     (tunneled_block f (Lreturn :: bb)) tls tm).","proofString":"exploit Mem.free_parallel_extends.\neauto.\neauto.\nintros (tm' & FREE & MEM').\nleft; simpl; econstructor; split.\neapply exec_Lreturn; eauto.\nconstructor; eauto using return_regs_lessdef, match_parent_locset."},{"statement":"(s : list stackframe) (f : function) (sp : block) (bb : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m sp 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stacksize f) = Some tm') (MEM' : Mem.extends m' tm') : (exists st2' : state,\n   step tge\n     (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n        (tunneled_block f (Lreturn :: bb)) tls tm) E0 st2' /\\\n   match_states (Returnstate s (return_regs (parent_locset s) rs) m') st2') \\/\n(measure (Returnstate s (return_regs (parent_locset s) rs) m') <\n measure (Block s f (Vptr sp Integers.Ptrofs.zero) (Lreturn :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (return_regs (parent_locset s) rs) m')\n  (Block ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n     (tunneled_block f (Lreturn :: bb)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_Lreturn; eauto.\nconstructor; eauto using return_regs_lessdef, match_parent_locset."},{"statement":"(s : list stackframe) (f : function) (rs : locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', sp)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge (Callstate ts (tunnel_fundef (Internal f)) tls tm) E0 st2' /\\\n   match_states\n     (State s f (Vptr sp Integers.Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') st2') \\/\n(measure\n   (State s f (Vptr sp Integers.Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp Integers.Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts (tunnel_fundef (Internal f)) tls tm).","proofString":"exploit Mem.alloc_extends.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & ALLOC & MEM').\nleft; simpl; econstructor; split.\neapply exec_function_internal; eauto.\nsimpl.\neconstructor; eauto using locmap_undef_regs_lessdef, call_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (rs : locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', sp)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tm' : Mem.mem') (ALLOC : Mem.alloc tm 0 (fn_stacksize f) = (tm', sp)) (MEM' : Mem.extends m' tm') : (exists st2' : state,\n   step tge (Callstate ts (tunnel_fundef (Internal f)) tls tm) E0 st2' /\\\n   match_states\n     (State s f (Vptr sp Integers.Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') st2') \\/\n(measure\n   (State s f (Vptr sp Integers.Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp Integers.Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts (tunnel_fundef (Internal f)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_function_internal; eauto.\nsimpl.\neconstructor; eauto using locmap_undef_regs_lessdef, call_regs_lessdef."},{"statement":"(s : list stackframe) (f : function) (rs : locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', sp)) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tm' : Mem.mem') (ALLOC : Mem.alloc tm 0 (fn_stacksize f) = (tm', sp)) (MEM' : Mem.extends m' tm') : match_states\n  (State s f (Vptr sp Integers.Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (State ts (tunnel_function f) (Vptr sp Integers.Ptrofs.zero)\n     (U.repr (record_gotos f) (fn_entrypoint f))\n     (undef_regs destroyed_at_function_entry (call_regs tls)) tm').","proofString":"econstructor; eauto using locmap_undef_regs_lessdef, call_regs_lessdef."},{"statement":"(s : list stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge (Callstate ts (tunnel_fundef (External ef)) tls tm) t st2' /\\\n   match_states\n     (Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (undef_caller_save_regs rs)) m') st2') \\/\n(measure\n   (Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (undef_caller_save_regs rs)) m') <\n measure (Callstate s (External ef) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m')\n  (Callstate ts (tunnel_fundef (External ef)) tls tm).","proofString":"exploit external_call_mem_extends; eauto using locmap_getpairs_lessdef.\nintros (tvres & tm' & A & B & C & D).\nleft; simpl; econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nsimpl.\neconstructor; eauto using locmap_setpair_lessdef, locmap_undef_caller_save_regs_lessdef."},{"statement":"(s : list stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists (vres' : val) (m2' : mem),\n   external_call ef ge\n     (map (fun p : rpair loc => Locmap.getpair p tls)\n        (Conventions1.loc_arguments (ef_sig ef))) tm t vres' m2' /\\\n   Val.lessdef res vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) tm m2') ->\n(exists st2' : state,\n   step tge (Callstate ts (tunnel_fundef (External ef)) tls tm) t st2' /\\\n   match_states\n     (Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (undef_caller_save_regs rs)) m') st2') \\/\n(measure\n   (Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (undef_caller_save_regs rs)) m') <\n measure (Callstate s (External ef) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m')\n  (Callstate ts (tunnel_fundef (External ef)) tls tm).","proofString":"intros (tvres & tm' & A & B & C & D).\nleft; simpl; econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nsimpl.\neconstructor; eauto using locmap_setpair_lessdef, locmap_undef_caller_save_regs_lessdef."},{"statement":"(s : list stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tvres : val) (tm' : mem) (A : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p tls)\n     (Conventions1.loc_arguments (ef_sig ef))) tm t tvres tm') (B : Val.lessdef res tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : (exists st2' : state,\n   step tge (Callstate ts (tunnel_fundef (External ef)) tls tm) t st2' /\\\n   match_states\n     (Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (undef_caller_save_regs rs)) m') st2') \\/\n(measure\n   (Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (undef_caller_save_regs rs)) m') <\n measure (Callstate s (External ef) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m')\n  (Callstate ts (tunnel_fundef (External ef)) tls tm).","proofString":"left; simpl; econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nsimpl.\neconstructor; eauto using locmap_setpair_lessdef, locmap_undef_caller_save_regs_lessdef."},{"statement":"(s : list stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tvres : val) (tm' : mem) (A : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p tls)\n     (Conventions1.loc_arguments (ef_sig ef))) tm t tvres tm') (B : Val.lessdef res tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : Senv.equiv ge tge.","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes s ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (tvres : val) (tm' : mem) (A : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p tls)\n     (Conventions1.loc_arguments (ef_sig ef))) tm t tvres tm') (B : Val.lessdef res tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : match_states\n  (Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m')\n  (Returnstate ts\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) tvres\n        (undef_caller_save_regs tls)) tm').","proofString":"econstructor; eauto using locmap_setpair_lessdef, locmap_undef_caller_save_regs_lessdef."},{"statement":"(f : function) (sp : val) (rs1 : locset) (bb : bblock) (s : list stackframe) (rs : locset) (m : mem) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes (Stackframe f sp rs1 bb :: s) ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : (exists st2' : state,\n   step tge (Returnstate ts tls tm) E0 st2' /\\\n   match_states (Block s f sp bb rs m) st2') \\/\n(measure (Block s f sp bb rs m) <\n measure (Returnstate (Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\ match_states (Block s f sp bb rs m) (Returnstate ts tls tm).","proofString":"inv STK.\ninv H1.\nleft; econstructor; split.\neapply exec_return; eauto.\nconstructor; auto."},{"statement":"(f : function) (sp : val) (rs1 : locset) (bb : bblock) (s : list stackframe) (rs : locset) (m : mem) (tls : locset) (tm : mem) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (b1 : stackframe) (bl : list stackframe) (H1 : match_stackframes (Stackframe f sp rs1 bb) b1) (H3 : list_forall2 match_stackframes s bl) : (exists st2' : state,\n   step tge (Returnstate (b1 :: bl) tls tm) E0 st2' /\\\n   match_states (Block s f sp bb rs m) st2') \\/\n(measure (Block s f sp bb rs m) <\n measure (Returnstate (Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m) (Returnstate (b1 :: bl) tls tm).","proofString":"inv H1.\nleft; econstructor; split.\neapply exec_return; eauto.\nconstructor; auto."},{"statement":"(f : function) (sp : val) (rs1 : locset) (bb : bblock) (s : list stackframe) (rs : locset) (m : mem) (tls : locset) (tm : mem) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (bl : list stackframe) (H3 : list_forall2 match_stackframes s bl) (tls0 : locset) (H6 : locmap_lessdef rs1 tls0) : (exists st2' : state,\n   step tge\n     (Returnstate\n        (Stackframe (tunnel_function f) sp tls0 (tunneled_block f bb) :: bl)\n        tls tm) E0 st2' /\\ match_states (Block s f sp bb rs m) st2') \\/\n(measure (Block s f sp bb rs m) <\n measure (Returnstate (Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m)\n  (Returnstate\n     (Stackframe (tunnel_function f) sp tls0 (tunneled_block f bb) :: bl) tls\n     tm).","proofString":"left; econstructor; split.\neapply exec_return; eauto.\nconstructor; auto."},{"statement":"(st1 : state) (H : initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","proofString":"inversion H.\nexists (Callstate nil (tunnel_fundef f) (Locmap.init Vundef) m0); split.\neconstructor; eauto.\napply (Genv.init_mem_transf TRANSL); auto.\nrewrite (match_program_main TRANSL).\nrewrite symbols_preserved.\neauto.\napply function_ptr_translated; auto.\nrewrite <- H3.\napply sig_preserved.\nconstructor.\nconstructor.\nred; simpl; auto.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) : Genv.init_mem tprog = Some m0.","proofString":"apply (Genv.init_mem_transf TRANSL); auto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) : funsig (tunnel_fundef f) = signature_main.","proofString":"rewrite <- H3.\napply sig_preserved."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) : funsig (tunnel_fundef f) = funsig f.","proofString":"apply sig_preserved."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) : match_states (Callstate nil f (Locmap.init Vundef) m0)\n  (Callstate nil (tunnel_fundef f) (Locmap.init Vundef) m0).","proofString":"constructor.\nconstructor.\nred; simpl; auto.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) : list_forall2 match_stackframes nil nil.","proofString":"constructor."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) : locmap_lessdef (Locmap.init Vundef) (Locmap.init Vundef).","proofString":"red; simpl; auto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) : Mem.extends m0 m0.","proofString":"apply Mem.extends_refl."},{"statement":"(st1 st2 : state) (r : Integers.Int.int) (H : match_states st1 st2) (H0 : final_state st1 r) : final_state st2 r.","proofString":"inv H0.\ninv H.\ninv STK.\nset (p := map_rpair R (Conventions1.loc_result signature_main)) in *.\ngeneralize (locmap_getpair_lessdef p _ _ LS).\nrewrite H1; intros LD; inv LD.\neconstructor; eauto."},{"statement":"(st2 : state) (r : Integers.Int.int) (rs : Locmap.t) (m : mem) (H : match_states (Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) : final_state st2 r.","proofString":"inv H.\ninv STK.\nset (p := map_rpair R (Conventions1.loc_result signature_main)) in *.\ngeneralize (locmap_getpair_lessdef p _ _ LS).\nrewrite H1; intros LD; inv LD.\neconstructor; eauto."},{"statement":"(r : Integers.Int.int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) (ts : list stackframe) (tls : locset) (tm : mem) (STK : list_forall2 match_stackframes nil ts) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : final_state (Returnstate ts tls tm) r.","proofString":"inv STK.\nset (p := map_rpair R (Conventions1.loc_result signature_main)) in *.\ngeneralize (locmap_getpair_lessdef p _ _ LS).\nrewrite H1; intros LD; inv LD.\neconstructor; eauto."},{"statement":"(r : Integers.Int.int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) (tls : locset) (tm : mem) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) : final_state (Returnstate nil tls tm) r.","proofString":"set (p := map_rpair R (Conventions1.loc_result signature_main)) in *.\ngeneralize (locmap_getpair_lessdef p _ _ LS).\nrewrite H1; intros LD; inv LD.\neconstructor; eauto."},{"statement":"(r : Integers.Int.int) (rs : Locmap.t) (m : mem) (p : rpair loc) (H1 : Locmap.getpair p rs = Vint r) (tls : locset) (tm : mem) (LS : locmap_lessdef rs tls) (MEM : Mem.extends m tm) (H2 : Vint r = tls (R R0)) : final_state (Returnstate nil tls tm) r.","proofString":"econstructor; eauto."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","proofString":"apply senv_preserved."}]}