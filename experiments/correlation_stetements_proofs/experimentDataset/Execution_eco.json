[{"statement":"Lemma co_in_eco: co ⊆ eco.","proof":"unfold eco; basic_solver 6.\n"},{"statement":"Lemma rf_in_eco: rf ⊆ eco.","proof":"unfold eco; basic_solver 6.\n"},{"statement":"Lemma fr_in_eco: fr ⊆ eco.","proof":"unfold eco; basic_solver 6.\n"},{"statement":"Lemma co_rf_in_eco: co ⨾ rf ⊆ eco.","proof":"unfold eco; basic_solver 6.\n"},{"statement":"Lemma fr_rf_in_eco: fr ⨾ rf ⊆ eco.","proof":"unfold eco; basic_solver 6.\n"},{"statement":"Lemma rfe_in_eco : rfe ⊆ eco.","proof":"rewrite rfe_in_rf.\napply rf_in_eco.\n"},{"statement":"Lemma coe_in_eco : coe ⊆ eco.","proof":"rewrite coe_in_co.\napply co_in_eco.\n"},{"statement":"Lemma fre_in_eco : fre ⊆ eco.","proof":"rewrite fre_in_fr.\napply fr_in_eco.\n"},{"statement":"Lemma loceq_eco WF : funeq loc eco.","proof":"destruct WF; desf.\neauto 10 with hahn.\n"},{"statement":"Lemma wf_ecoE WF : eco ≡ ⦗E⦘ ⨾ eco ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold eco.\nrewrite (wf_rfE WF) at 1 2 3.\nrewrite (wf_coE WF) at 1.\nrewrite (wf_frE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_ecoD WF : eco ≡ ⦗RW⦘ ⨾ eco ⨾ ⦗RW⦘.","proof":"split; [|basic_solver].\nunfold eco.\nrewrite wf_rfD at 1 2 3; try done.\nrewrite wf_coD at 1; try done.\nrewrite wf_frD at 1; try done.\ntype_solver 42.\n"},{"statement":"Lemma eco_alt WF: eco ≡ (co ∪ fr) ∪ (co ∪ fr)^? ⨾ rf.","proof":"unfold eco, Execution.fr; basic_solver 42.\n"},{"statement":"Lemma eco_alt2 WF: eco ≡ rf ∪ (rf⁻¹)^? ⨾ co ⨾ rf^?.","proof":"unfold eco, Execution.fr; basic_solver 42.\n"},{"statement":"Lemma eco_trans WF: transitive eco.","proof":"unfold eco.\napply transitiveI.\ngeneralize (rf_rf WF) (rf_fr WF) (co_co WF) (rf_co WF) (co_fr WF) (fr_fr WF) (fr_co WF).\nunfolder; ins; desf; try basic_solver 1.\nall: try (exfalso; basic_solver).\nall: basic_solver 42.\n"},{"statement":"Lemma eco_irr WF: irreflexive eco.","proof":"unfold eco.\ngeneralize (co_irr WF) (rf_irr WF) (fr_irr WF).\ngeneralize (rf_fr WF) (rf_co WF).\nbasic_solver 5.\n"},{"statement":"Lemma eco_alt3 WF: eco ≡ (rf ∪ co ∪ fr)⁺.","proof":"split; eauto 8 using rf_in_eco, co_in_eco, fr_in_eco, eco_trans with hahn.\nunfold eco; rewrite !crE; relsf.\nunionL; eauto 6 using inclusion_step2_ct with hahn.\n"},{"statement":"Lemma eco_f WF : eco ⨾ ⦗F⦘ ⊆ ∅₂.","proof":"rewrite (wf_ecoD WF); type_solver.\n"},{"statement":"Lemma eco_almost_total WF COMP x y \n  (ACTx: E x) (ACTy: E y)\n  (RWx: RW x) (RWy: RW y) (LOC: loc x = loc y)\n  (NEQ: x <> y): \n  eco x y \\/ eco y x \\/ exists z, rf z x /\\ rf z y.","proof":"generalize (dom_to_doma (wf_rfE WF)); intro rfE1; unfolder in rfE1.\ngeneralize (dom_to_domb (wf_rfE WF)); intro rfE2; unfolder in rfE2.\ngeneralize (dom_to_doma (wf_rfD WF)); intro rfD1; unfolder in rfD1.\ngeneralize (dom_to_domb (wf_rfD WF)); intro rfD2; unfolder in rfD2.\ngeneralize (loceq_rf WF); intro rfL; unfolder in rfL.\nassert (exists l, loc x = l).\nby destruct x; eauto.\nunfolder in RWx.\nunfolder in RWy.\nins; desf.\n- assert (exists wx, rf wx x) by (apply COMP; basic_solver).\nassert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wx=wy)); try subst; eauto.\nassert (co wx wy \\/ co wy wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; apply (loceq_rf WF) in H0; congruence.\n- assert (exists wy, rf wy y) by (apply COMP; basic_solver).\ndesf.\ndestruct (classic (wy=x)); [subst; unfold eco; basic_solver 5|].\nassert (co wy x \\/ co x wy); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\n- assert (exists wx, rf wx x).\nby apply COMP; basic_solver.\ndesf.\ndestruct (classic (wx=y)); [subst; unfold eco; basic_solver 5|].\nassert (co wx y \\/ co y wx); cycle 1.\nby unfold eco, Execution.fr; basic_solver 42.\neapply WF; unfolder; splits; eauto.\nby apply (loceq_rf WF) in H; congruence.\n- assert (co x y \\/ co y x); [eapply WF|unfold eco]; basic_solver 10.\n"},{"statement":"Lemma transp_rf_rf_eco_in_eco WF : rf⁻¹ ⨾ rf ⨾ eco ⊆ eco.","proof":"unfold eco, Execution.fr; relsf.\nrewrite rf_rf; auto.\nseq_rewrite rf_co; auto.\nrewrite !seqA.\nsin_rewrite rf_transp_rf; basic_solver 10.\n"},{"statement":"Lemma eco_transp_rf_rf_in_eco WF : eco ⨾ rf⁻¹ ⨾ rf ⊆ eco.","proof":"unfold eco, Execution.fr; relsf.\nrewrite !seqA, !crE; relsf.\narewrite_false (co ⨾ rf⁻¹).\nby rewrite (wf_coD WF), (wf_rfD WF); type_solver.\nsin_rewrite !rf_transp_rf; auto.\nbasic_solver 8.\n"},{"statement":"Lemma no_co_to_init WF SC_PER_LOC : co ≡ co ⨾ ⦗set_compl is_init⦘.","proof":"split; [| basic_solver].\nrewrite wf_coE at 1; try done.\nunfolder; ins; splits; auto; desf; intro.\neapply SC_PER_LOC; exists x; splits; [|eby apply co_in_eco].\nunfold Execution.sb; unfolder; splits; try done.\ncut (~ is_init x).\n{\ndestruct x, y; ins.\n}\nintro.\nassert (x=y).\neby apply (loceq_co WF) in H0; eapply init_same_loc.\neby subst; eapply (co_irr WF).\n"},{"statement":"Lemma no_co_cr_to_init WF SC_PER_LOC :\n  ⦗set_compl is_init⦘ ⨾ co^? ⊆ ⦗set_compl is_init⦘ ⨾ co^? ⨾ ⦗set_compl is_init⦘.","proof":"rewrite no_co_to_init at 1; auto.\nclear.\nbasic_solver.\n"},{"statement":"Lemma no_fr_to_init WF SC_PER_LOC : fr ⊆ fr ⨾  ⦗fun x => ~ is_init x⦘.","proof":"unfold Execution.fr.\nrewrite no_co_to_init at 1; try done.\nbasic_solver.\n"},{"statement":"Lemma co_from_init WF SC_PER_LOC : \n  ⦗fun x => is_init x⦘ ⨾ (same_loc \\ (fun x y => x = y)) ⨾ ⦗E ∩₁ W⦘ ⊆ co.","proof":"unfolder; ins; desf.\ngeneralize (init_w WF H); intro Wx.\ngeneralize (is_w_loc lab x Wx).\nunfold Events.same_loc in *; ins; desf.\neapply tot_ex.\n- eapply WF.\n- basic_solver.\n- unfolder; splits; try edone.\ndestruct x; [|unfold is_init in *; desf].\neapply (wf_init WF); exists y; splits; eauto.\nunfold Events.loc in *.\nrewrite (wf_init_lab WF) in *.\ncongruence.\n- intro A.\nhahn_rewrite (no_co_to_init WF SC_PER_LOC) in A.\nunfolder in *; desf.\n- intro; eauto.\n"},{"statement":"Lemma atomicity_alt WF SC_PER_LOC ATOM : rmw ∩ (fr ⨾ co) ⊆ ∅₂.","proof":"rewrite rmw_from_non_init, no_fr_to_init; eauto.\nunfolder; red in ATOM; red in SC_PER_LOC; ins; desf.\ndestruct (classic (sb x z));destruct (classic (sb z y)); eauto 8.\n- by eapply wf_rmwi; eauto.\n- eapply sb_semi_total_l with (y:=y) in H4; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply co_in_eco].\neby intro; subst; eapply (co_irr WF).\neby apply rmw_in_sb.\n- eapply sb_semi_total_r with (x:=y) (y:=x) in H5; eauto.\ndesf.\neapply SC_PER_LOC.\nby eexists; splits; [eauto| apply fr_in_eco].\neby intro; subst; eapply fr_irr.\neby apply rmw_in_sb.\n- by eapply ATOM; unfolder; splits; eauto.\n"},{"statement":"Lemma BasicRMW WF SC_PER_LOC: irreflexive (co^? ⨾ rf ⨾ rmw).","proof":"rewrite rmw_in_sb; try done.\nunfold sc_per_loc, eco in *; unfolder in *; basic_solver 10.\n"},{"statement":"Lemma w_r_loc_w_in_co WF r \n  (rE: r ≡ ⦗E⦘ ⨾ r ⨾  ⦗E⦘) (IRR: irreflexive r)\n  (A: irreflexive (r ⨾ eco)): \n  ⦗W⦘ ⨾ r ∩ same_loc ⨾ ⦗W⦘ ⊆ co.","proof":"rewrite rE.\nunfolder; ins; desf.\neapply tot_ex.\n- eapply WF.\n- unfolder; splits; try edone.\n- unfolder; splits; try edone.\n- intro; eapply A; unfold eco; basic_solver 12.\n- intro; subst; eapply IRR; eauto.\n"},{"statement":"Lemma w_r_loc_r_in_co_rf WF r\n  (rE: r ≡ ⦗E⦘ ⨾ r ⨾  ⦗E⦘) \n  (A: irreflexive (r ⨾ eco)) COMP : \n  ⦗W⦘ ⨾ r ∩ same_loc ⨾ ⦗R⦘ ⊆ co^? ⨾ rf.","proof":"rewrite rE.\ncut (⦗W⦘ ⨾  ⦗E⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ co^? ⨾ rf).\nby basic_solver 12.\nred in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [|edone].\ndestruct (classic (x=z)); [eauto|].\nright; eapply tot_ex.\n- eapply WF.\n- splits; try edone.\n- splits; try edone.\n- intro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\n- congruence.\n"},{"statement":"Lemma r_r_loc_w_in_fr WF r\n  (rE: r ≡ ⦗E⦘ ⨾ r ⨾  ⦗E⦘) \n  (A: irreflexive (r ⨾ eco)) COMP : \n  ⦗R⦘ ⨾ r ∩ same_loc ⨾ ⦗W⦘ ⊆ fr.","proof":"rewrite rE.\ncut (⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ W⦘ ⊆ fr).\nby basic_solver 12.\nred in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1.\nunfolder; ins; desf; eexists; splits; [edone|].\neapply tot_ex.\n- eapply WF.\n- splits; try edone.\n- unfolder; splits; [done | done | unfolder in *; congruence].\n- intro; eapply A.\nunfold eco; basic_solver 22.\n- intro; subst.\neapply A.\nunfold eco; basic_solver 22.\n"},{"statement":"Lemma r_r_loc_r_in_fr_rf WF r\n  (rE: r ≡ ⦗E⦘ ⨾ r ⨾  ⦗E⦘) \n  (A: irreflexive (r ⨾ eco)) COMP : \n  ⦗R⦘ ⨾ r ∩ same_loc ⨾ ⦗R⦘ ⊆ fr ⨾ rf ∪ rf^{-1} ⨾ rf.","proof":"rewrite rE.\ncut (⦗E ∩₁ R⦘ ⨾ r ∩ same_loc ⨾ ⦗E ∩₁ R⦘ ⊆ fr ⨾ rf ∪ rf^{-1} ⨾ rf).\nby basic_solver 12.\nred in COMP; rewrite COMP.\nrewrite (dom_l (wf_rfD WF)) at 1 2.\nrewrite (dom_l (wf_rfE WF)) at 1 2.\nrewrite (loceq_same_loc (loceq_rf WF)) at 1 2.\nunfolder; ins; desf.\ndestruct (classic (z0=z)).\nby right; eexists; subst; eauto.\nleft.\nunfold Execution.fr; unfolder.\neexists; splits; [|edone].\neexists; splits; [edone|].\neapply tot_ex.\n- eapply WF.\n- splits; try edone.\n- unfolder; splits; [done | done | unfolder in *; congruence].\n- intro; eapply A.\nunfold eco, Execution.fr; basic_solver 22.\n- intro; subst; eauto.\n"},{"statement":"Lemma w_sb_loc_w_in_coi WF SC_PER_LOC:\n  ⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ coi.","proof":"arewrite (⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ (⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘) ∩ sb).\nbasic_solver.\nrewrite (w_r_loc_w_in_co WF (@wf_sbE G) (@sb_irr G) SC_PER_LOC).\nby ie_unfolder.\n"},{"statement":"Lemma w_sb_loc_r_in_co_rf WF SC_PER_LOC COMP:\n  ⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗R⦘ ⊆ co^? ⨾ rf.","proof":"apply (w_r_loc_r_in_co_rf WF (@wf_sbE G) SC_PER_LOC COMP).\n"},{"statement":"Lemma r_sb_loc_w_in_fri WF SC_PER_LOC COMP:\n  ⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ fri.","proof":"arewrite (⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ (⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘) ∩ sb).\nbasic_solver.\nrewrite (r_r_loc_w_in_fr WF (@wf_sbE G) SC_PER_LOC COMP).\nby ie_unfolder.\n"},{"statement":"Lemma r_sb_loc_r_in_fr_rf WF SC_PER_LOC COMP:\n  ⦗R⦘ ⨾ sb ∩ same_loc ⨾ ⦗R⦘ ⊆ fr ⨾ rf ∪ rf^{-1} ⨾ rf.","proof":"apply (r_r_loc_r_in_fr_rf WF (@wf_sbE G) SC_PER_LOC COMP).\n"},{"statement":"Lemma rmw_sb_loc_in_rmw_coi WF SC_PER_LOC :\n  rmw ⨾ (sb ∩ same_loc ⨾ ⦗W⦘)^? ⊆ rmw ⨾ coi^?.","proof":"rewrite !crE, !seq_union_r, !seq_id_r.\napply union_mori; [done|].\nrewrite (dom_r (wf_rmwD WF)) at 1.\nrewrite !seqA.\nby rewrite (w_sb_loc_w_in_coi WF).\n"},{"statement":"Lemma rmw_in_fri WF SC_PER_LOC COMP : rmw ⊆ fri.","proof":"rewrite (wf_rmwD WF), (rmw_in_sb_loc WF).\nrewrite (r_sb_loc_w_in_fri WF SC_PER_LOC COMP).\nie_unfolder; basic_solver.\n"},{"statement":"Lemma rmw_in_fr WF SC_PER_LOC COMP : rmw ⊆ fr.","proof":"rewrite rmw_in_fri; auto.\napply fri_in_fr.\n"},{"statement":"Lemma rf_rmw_in_co_helper WF SC_PER_LOC: rf ⨾ rmw ⊆ co ∪ co^{-1}.","proof":"rewrite (dom_l (wf_rfE WF)).\nrewrite (dom_r (wf_rmwE WF)).\nrewrite (dom_l (wf_rfD WF)).\nrewrite (dom_r (wf_rmwD WF)).\nunfolder; ins; desf.\neapply (wf_co_total WF); [basic_solver| |].\n{\nunfolder; ins; desf; splits; eauto.\napply (wf_rfl WF) in H0.\napply (wf_rmwl WF) in H1.\nunfold Events.same_loc in *; congruence.\n}\nintro; subst.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply rf_in_eco; edone.\n"},{"statement":"Lemma rf_rmw_in_co WF SC_PER_LOC : rf ⨾ rmw ⊆ co.","proof":"arewrite (rf ⨾ rmw ⊆ (rf ⨾ rmw) ∩ (rf ⨾ rmw)).\nrewrite rf_rmw_in_co_helper at 1; eauto.\nrewrite inter_union_l; unionL; [basic_solver|].\ntransitivity (fun _ _ : actid => False); [|basic_solver].\nunfolder; ins; desf.\neapply SC_PER_LOC.\nexists y; splits; eauto.\neapply (rmw_in_sb WF); edone.\neapply co_rf_in_eco; basic_solver.\n"},{"statement":"Lemma rf_rmw_ct_in_co WF SC_PER_LOC : (rf ⨾ rmw)⁺ ⊆ co.","proof":"by rewrite rf_rmw_in_co, (ct_of_trans (co_trans WF)).\n"},{"statement":"Lemma rf_rmw_rt_in_co WF SC_PER_LOC : (rf ⨾ rmw)＊ ⊆ co^?.","proof":"by rewrite rf_rmw_in_co, (rt_of_trans (co_trans WF)).\n"},{"statement":"Lemma rf_rmw_in_coimm WF SC_PER_LOC ATOM: rf ⨾ rmw ⊆ immediate co.","proof":"ins; split; [by apply rf_rmw_in_co|].\nins; unfolder in *; desf.\neapply atomicity_alt; try done.\nunfold Execution.fr; basic_solver 10.\n"},{"statement":"Lemma coe_coi WF SC_PER_LOC: coe ⨾ coi ⊆ coe.","proof":"cut ((co \\ sb) ⨾ co ∩ sb ⊆ co ⨾ co \\ sb).\nby rewrite (co_co WF).\napply re_ri; try done; try by apply no_co_to_init.\nby apply co_irr.\nrotate 1.\nby rewrite co_in_eco.\n"},{"statement":"Lemma fre_coi WF SC_PER_LOC : fre ⨾ coi ⊆ fre.","proof":"cut ((fr \\ sb) ⨾ co ∩ sb ⊆ fr ⨾ co \\ sb).\nby rewrite (fr_co WF).\napply re_ri; try done; try by apply no_fr_to_init.\nby apply fr_irr.\nrotate 1.\nby rewrite fr_in_eco.\n"},{"statement":"Lemma coi_coe WF SC_PER_LOC: \n ⦗fun x => ~ is_init x⦘ ⨾ coi ⨾ coe ⊆ coe.","proof":"cut (⦗fun x => ~ is_init x⦘ ⨾ (co ∩ sb) ⨾ (co \\ sb) ⊆ co ⨾ co \\ sb).\nby rewrite (co_co WF).\napply ri_re; try done; try by apply no_co_to_init.\nby apply co_irr.\nrotate 1.\nby rewrite co_in_eco.\n"},{"statement":"Lemma rfe_fri WF SC_PER_LOC : rfe ⨾ fri ⊆ coe.","proof":"cut ((rf \\ sb) ⨾ fr ∩ sb ⊆ rf ⨾ fr \\ sb).\n{\nby rewrite (rf_fr WF).\n}\napply re_ri; try done; try by apply no_rf_to_init.\n{\nby apply rf_irr.\n}\nrotate 1.\nby rewrite rf_in_eco.\n"},{"statement":"Lemma eco_refl : \n  eco^? ⊆ ((co ∪ fre)^? ⨾ rf^?) ∪ fri ⨾ rfi^? ∪ fri ⨾ rfe.","proof":"unfold eco.\nrewrite !(@fri_union_fre G).\nrewrite !(@rfi_union_rfe G).\nbasic_solver 12.\n"},{"statement":"Lemma eco_alt4 WF : eco ⊆ ⦗RW⦘ ⨾ sb ∪ rfe ∪ co ⨾ rf^? ∪ fre ⨾ rf^? ∪ fri ⨾ rfe.","proof":"unfold eco.\nrewrite (dom_l (wf_rfD WF)) at 1.\nrewrite (dom_l (wf_frD WF)) at 1.\nrewrite !(@fri_union_fre G); relsf.\nunionL.\n- rewrite !(@rfi_union_rfe G).\narewrite (rfi ⊆ sb) at 1.\nbasic_solver 12.\n- basic_solver 12.\n- rewrite !(@rfi_union_rfe G).\ncase_refl (rfi ∪ rfe).\narewrite (fri ⊆ sb); basic_solver 12.\nrelsf; unionL; [|basic_solver 12].\narewrite (fri ⊆ sb); arewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver 12.\n- basic_solver 12.\n"},{"statement":"Lemma thread_rfe_sb WF SC_PER_LOC : (rfe^{-1} ⨾ sb) ∩ same_tid ⊆ ∅₂.","proof":"ie_unfolder; unfolder; unfold same_tid; ins; desf.\nhahn_rewrite (@wf_sbE G) in H1; unfolder in H1; desf.\nhahn_rewrite (wf_rfE WF) in H; unfolder in H; desf.\nhahn_rewrite (no_rf_to_init WF) in H5; unfolder in H5; desf.\napply (@same_thread G) in H0; try done.\ndesf.\n- destruct H0; [subst; auto|].\neapply sb_semi_total_r in H0; try edone.\n2:  by intro; subst; eapply (rf_irr WF); edone.\ndesf; eapply SC_PER_LOC; unfold eco; basic_solver 12.\n- eapply H2; eapply (@sb_trans G); edone.\n"},{"statement":"Lemma co_sb_loc WF SC_PER_LOC : ⦗W⦘ ⨾ co^? ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ co^?.","proof":"case_refl (sb ∩ same_loc); [basic_solver|].\nrewrite (dom_r (wf_coD WF)).\narewrite (⦗W⦘ ⨾ (co ⨾ ⦗W⦘)^? ⊆ co^? ⨾ ⦗W⦘) by basic_solver.\nrewrite (w_sb_loc_w_in_coi WF SC_PER_LOC), (dom_r (wf_coiD WF)).\ngeneralize (co_trans WF); ie_unfolder; basic_solver 12.\n"},{"statement":"Lemma rf_sb_loc_w_in_co WF SC_PER_LOC:\n  rf ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ co.","proof":"red.\nintros w1 w2 [w' [RF HH]].\napply seq_eqv_r in HH as [[SB LOC] W2].\nforward eapply is_w_loc as [l Ll]; eauto.\nred in LOC.\npose proof (wf_rfl WF _ _ RF) as Ll'.\nred in Ll'.\neapply same_relation_exp in RF.\n2: {\nrewrite wf_rfE, wf_rfD; auto.\n}\napply wf_sbE in SB.\nforward eapply (@wf_co_total _ WF (Some l)) with (a := w1) (b := w2).\n1, 2: unfolder in *; desc; splits; congruence.\n{\nintros <-.\nred in SC_PER_LOC.\ndestruct (SC_PER_LOC w').\nexists w1.\nsplit.\n{\ngeneralize SB.\nbasic_solver.\n}\nunfold eco.\ndo 2 left.\ngeneralize RF.\nbasic_solver.\n}\nins.\ndes; auto.\ndestruct (SC_PER_LOC w').\nexists w2.\nsplit.\n{\ngeneralize SB.\nbasic_solver.\n}\nleft.\nright.\neexists.\nsplits; eauto.\ngeneralize RF.\nbasic_solver.\n"}]