{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/powerpc/SelectOpproof.v","fileSamples":[{"statement":"(le : letenv) (id : ident) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (addrsymbol id ofs) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addrsymbol id ofs) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v","hypotheses":"(le : letenv) (id : ident) (ofs : ptrofs)","proofString":"unfold addrsymbol.\neconstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"(le : letenv) (id : ident) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrsymbol id ofs) Enil) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrsymbol id ofs) Enil) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v","hypotheses":"(le : letenv) (id : ident) (ofs : ptrofs)","proofString":"econstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"(le : letenv) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (addrstack ofs) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addrstack ofs) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v","hypotheses":"(le : letenv) (ofs : ptrofs)","proofString":"unfold addrstack.\neconstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"(le : letenv) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrstack ofs) Enil) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrstack ofs) Enil) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v","hypotheses":"(le : letenv) (ofs : ptrofs)","proofString":"econstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"forall v : val, Val.lessdef (Val.notint (Val.notint v)) v.","conclusion":"forall v : val, Val.lessdef (Val.notint (Val.notint v)) v","hypotheses":"","proofString":"destruct v; simpl; auto.\nrewrite Int.not_involutive; auto."},{"statement":"(i : int) : Val.lessdef (Vint (Int.not (Int.not i))) (Vint i).","conclusion":"Val.lessdef (Vint (Int.not (Int.not i))) (Vint i)","hypotheses":"(i : int)","proofString":"rewrite Int.not_involutive; auto."},{"statement":"(H : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a : expr) (n : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.not n)) Enil) v /\\\n  Val.lessdef (Val.notint (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.not n)) Enil) v /\\\n  Val.lessdef (Val.notint (Vint n)) v","hypotheses":"(H : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a : expr) (n : int)","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero)","proofString":"subst n.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.add_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint Int.zero)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val)","proofString":"intros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.add_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.add_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.add x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.add x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int.add_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.add i Int.zero)) (Vint i).","conclusion":"Val.lessdef (Vint (Int.add i Int.zero)) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.add_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","conclusion":"Val.lessdef (Vint i) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int) : Some (Vint (Int.add n m0)) = Some (Vint (Int.add m0 n)).","conclusion":"Some (Vint (Int.add n m0)) = Some (Vint (Int.add m0 n))","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int)","proofString":"rewrite Int.add_commut.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int) : Some (Vint (Int.add m0 n)) = Some (Vint (Int.add m0 n)).","conclusion":"Some (Vint (Int.add m0 n)) = Some (Vint (Int.add m0 n))","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.sub x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.sub x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"rewrite Val.sub_add_opp.\napply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.add x (Vint (Int.neg n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.add x (Vint (Int.neg n2))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Val.add v1 (Vint n1) = x) (H0 : Val.add v0 (Vint n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Val.add v1 (Vint n1) = x) (H0 : Val.add v0 (Vint n2) = y)","proofString":"subst.\nrewrite Val.sub_add_l.\nrewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Val.sub_add_l.\nrewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 (Val.add v0 (Vint n2))) (Vint n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 (Val.add v0 (Vint n2))) (Vint n1)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.add (Val.sub v1 v0) (Vint (Int.neg n2))) (Vint n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.add (Val.sub v1 v0) (Vint (Int.neg n2))) (Vint n1)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.sub v1 v0) (Val.add (Vint (Int.neg n2)) (Vint n1))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.sub v1 v0) (Val.add (Vint (Int.neg n2)) (Vint n1))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"simpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add (Int.neg n2) n1))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add (Int.neg n2) n1))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add n1 (Int.neg n2)))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add n1 (Int.neg n2)))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.sub n1 n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.sub n1 n2))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H : Val.add v1 (Vint n1) = x) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H : Val.add v1 (Vint n1) = x)","proofString":"subst.\nrewrite Val.sub_add_l.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.sub_add_l.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 y) (Vint n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 y) (Vint n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) (H0 : Val.add v1 (Vint n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) (H0 : Val.add v1 (Vint n2) = y)","proofString":"subst.\nrewrite Val.sub_add_r.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x (Val.add v1 (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x (Val.add v1 (Vint n2))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.sub_add_r.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub x v1) (Vint (Int.neg n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub x v1) (Vint (Int.neg n2))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"apply eval_addimm; EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero)","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.shl x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shl x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shl i Int.zero)\n   else Vundef) (Vint i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shl i Int.zero)\n   else Vundef) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.shl_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shru x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shru x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero)","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shru_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shru x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shru x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shru_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.shru x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shru x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int.shru_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shru i Int.zero)\n   else Vundef) (Vint i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shru i Int.zero)\n   else Vundef) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.shru_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero)","proofString":"intros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shr x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shr x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shr i Int.zero)\n   else Vundef) (Vint i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shr i Int.zero)\n   else Vundef) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.shr_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int) (H0 : eval_expr ge sp e m le (Eop (Ointconst n1) Enil) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if negb true\n     then\n      Eop Oshr (Eop (Ointconst n1) Enil ::: Eop (Ointconst n) Enil ::: Enil)\n     else Eop (Ointconst (Int.shr n1 n)) Enil) v /\\\n  Val.lessdef (Val.shr x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if negb true\n     then\n      Eop Oshr (Eop (Ointconst n1) Enil ::: Eop (Ointconst n) Enil ::: Enil)\n     else Eop (Ointconst (Int.shr n1 n)) Enil) v /\\\n  Val.lessdef (Val.shr x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int) (H0 : eval_expr ge sp e m le (Eop (Ointconst n1) Enil) x)","proofString":"InvEval.\nexists (Vint (Int.shr n1 n)); split.\nEvalOp.\nsimpl; rewrite WS; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le\n    (if negb true\n     then\n      Eop Oshr (Eop (Ointconst n1) Enil ::: Eop (Ointconst n) Enil ::: Enil)\n     else Eop (Ointconst (Int.shr n1 n)) Enil) v /\\\n  Val.lessdef (Val.shr (Vint n1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if negb true\n     then\n      Eop Oshr (Eop (Ointconst n1) Enil ::: Eop (Ointconst n) Enil ::: Enil)\n     else Eop (Ointconst (Int.shr n1 n)) Enil) v /\\\n  Val.lessdef (Val.shr (Vint n1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int)","proofString":"exists (Vint (Int.shr n1 n)); split.\nEvalOp.\nsimpl; rewrite WS; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int) : eval_expr ge sp e m le\n  (if negb true\n   then\n    Eop Oshr (Eop (Ointconst n1) Enil ::: Eop (Ointconst n) Enil ::: Enil)\n   else Eop (Ointconst (Int.shr n1 n)) Enil) (Vint (Int.shr n1 n)).","conclusion":"eval_expr ge sp e m le\n  (if negb true\n   then\n    Eop Oshr (Eop (Ointconst n1) Enil ::: Eop (Ointconst n) Enil ::: Enil)\n   else Eop (Ointconst (Int.shr n1 n)) Enil) (Vint (Int.shr n1 n))","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int)","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef (Val.shr (Vint n1) (Vint n)) (Vint (Int.shr n1 n)).","conclusion":"Val.lessdef (Val.shr (Vint n1) (Vint n)) (Vint (Int.shr n1 n))","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (WS : Int.ltu n Int.iwordsize = true) (n1 : int)","proofString":"simpl; rewrite WS; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then Eop (Ointconst Int.zero) Enil\n     else\n      if Int.eq n Int.one\n      then a\n      else\n       match mulimm_match a with\n       | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n       | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n       | mulimm_default e2 => mulimm_base n e2\n       end) v /\\ Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then Eop (Ointconst Int.zero) Enil\n     else\n      if Int.eq n Int.one\n      then a\n      else\n       match mulimm_match a with\n       | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n       | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n       | mulimm_default e2 => mulimm_base n e2\n       end) v /\\ Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val)","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto.\npredSpec Int.eq Int.eq_spec n Int.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto.\ncase (mulimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nsubst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero)","proofString":"intros.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"exists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mul x (Vint n)) (Vint Int.zero).","conclusion":"Val.lessdef (Val.mul x (Vint n)) (Vint Int.zero)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i n)) (Vint Int.zero).","conclusion":"Val.lessdef (Vint (Int.mul i n)) (Vint Int.zero)","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a (Vint i))","proofString":"subst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i Int.zero)) (Vint Int.zero).","conclusion":"Val.lessdef (Vint (Int.mul i Int.zero)) (Vint Int.zero)","hypotheses":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint Int.zero) (Vint Int.zero).","conclusion":"Val.lessdef (Vint Int.zero) (Vint Int.zero)","hypotheses":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.one\n     then a\n     else\n      match mulimm_match a with\n      | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n      | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n      | mulimm_default e2 => mulimm_base n e2\n      end) v /\\ Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.one\n     then a\n     else\n      match mulimm_match a with\n      | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n      | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n      | mulimm_default e2 => mulimm_base n e2\n      end) v /\\ Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero)","proofString":"predSpec Int.eq Int.eq_spec n Int.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto.\ncase (mulimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nsubst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one)","proofString":"intros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mul x (Vint n)) x.","conclusion":"Val.lessdef (Val.mul x (Vint n)) x","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i n)) (Vint i).","conclusion":"Val.lessdef (Vint (Int.mul i n)) (Vint i)","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a (Vint i))","proofString":"subst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i Int.one)) (Vint i).","conclusion":"Val.lessdef (Vint (Int.mul i Int.one)) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","conclusion":"Val.lessdef (Vint i) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match mulimm_match a with\n    | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n    | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n    | mulimm_default e2 => mulimm_base n e2\n    end v /\\ Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match mulimm_match a with\n    | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n    | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n    | mulimm_default e2 => mulimm_base n e2\n    end v /\\ Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one)","proofString":"case (mulimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nsubst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mul (Vint n2) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mul (Vint n2) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int)","proofString":"TrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : eval_operation ge sp (Ointconst (Int.mul n n2)) nil m =\nSome (Val.mul (Vint n2) (Vint n)).","conclusion":"eval_operation ge sp (Ointconst (Int.mul n n2)) nil m =\nSome (Val.mul (Vint n2) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int)","proofString":"simpl.\nrewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : Some (Vint (Int.mul n n2)) = Some (Vint (Int.mul n2 n)).","conclusion":"Some (Vint (Int.mul n n2)) = Some (Vint (Int.mul n2 n))","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int)","proofString":"rewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H1 : Val.add v1 (Vint n2) = x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H1 : Val.add v1 (Vint n2) = x)","proofString":"subst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.mul (Val.add v1 (Vint n2)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.mul (Val.add v1 (Vint n2)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"exploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : (exists v : val,\n   eval_expr ge sp e m le (mulimm_base n t2) v /\\\n   Val.lessdef (Val.mul v1 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (mulimm_base n t2) v /\\\n   Val.lessdef (Val.mul v1 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"intros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v')","proofString":"exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : eval_expr ge sp e m le (mulimm_base n t2) v'.","conclusion":"eval_expr ge sp e m le (mulimm_base n t2) v'","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v')","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : (exists v : val,\n   eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n   Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n   Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v')","proofString":"intros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'') : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'')","proofString":"exists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'') : Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v''.","conclusion":"Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v''","hypotheses":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'')","proofString":"eapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (mulimm_base n e2) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mulimm_base n e2) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x)","proofString":"apply eval_mulimm_base; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (mul a b) v /\\ Val.lessdef (Val.mul x y) v.","conclusion":"eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (mul a b) v /\\ Val.lessdef (Val.mul x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val)","proofString":"unfold mul; case (mul_match a b); intros; InvEval.\nrewrite Val.mul_commut.\napply eval_mulimm.\nauto.\napply eval_mulimm.\nauto.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul (Vint n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul (Vint n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.mul_commut.\napply eval_mulimm.\nauto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul y (Vint n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul y (Vint n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"apply eval_mulimm.\nauto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : eval_expr ge sp e m le t2 y.","conclusion":"eval_expr ge sp e m le t2 y","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (mulimm n2 t1) v /\\\n  Val.lessdef (Val.mul x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mulimm n2 t1) v /\\\n  Val.lessdef (Val.mul x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_mulimm.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : eval_expr ge sp e m le t1 x.","conclusion":"eval_expr ge sp e m le t1 x","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mul x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omul (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mul x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andimm n1 t2) v /\\\n  Val.lessdef (Val.and (Vint n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andimm n1 t2) v /\\\n  Val.lessdef (Val.and (Vint n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.and_commut.\napply eval_andimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andimm n1 t2) v /\\\n  Val.lessdef (Val.and y (Vint n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andimm n1 t2) v /\\\n  Val.lessdef (Val.and y (Vint n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"apply eval_andimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (andimm n2 t1) v /\\\n  Val.lessdef (Val.and x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andimm n2 t1) v /\\\n  Val.lessdef (Val.and x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_andimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H : Val.notint v1 = x) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H : Val.notint v1 = x)","proofString":"subst.\nrewrite Val.and_commut.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and (Val.notint v1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and (Val.notint v1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.and_commut.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and y (Val.notint v1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and y (Val.notint v1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) (H0 : Val.notint v1 = y) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) (H0 : Val.notint v1 = y)","proofString":"subst.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x (Val.notint v1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x (Val.notint v1)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (orimm n a) v /\\ Val.lessdef (Val.or x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (orimm n a) v /\\ Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val)","proofString":"unfold orimm.\npredSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nsubst.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nrewrite Int.or_mone; auto.\nclear H H0.\ndestruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.eq n Int.mone\n      then Eop (Ointconst Int.mone) Enil\n      else\n       match orimm_match a with\n       | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n       | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n       | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.or x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.eq n Int.mone\n      then Eop (Ointconst Int.mone) Enil\n      else\n       match orimm_match a with\n       | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n       | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n       | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val)","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nsubst.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nrewrite Int.or_mone; auto.\nclear H H0.\ndestruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero)","proofString":"intros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.or x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.or x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i Int.zero)) (Vint i).","conclusion":"Val.lessdef (Vint (Int.or i Int.zero)) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.or_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.mone\n     then Eop (Ointconst Int.mone) Enil\n     else\n      match orimm_match a with\n      | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n      | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n      | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.or x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.mone\n     then Eop (Ointconst Int.mone) Enil\n     else\n      match orimm_match a with\n      | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n      | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n      | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero)","proofString":"predSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nsubst.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nrewrite Int.or_mone; auto.\nclear H H0.\ndestruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone)","proofString":"intros.\nsubst.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x)","proofString":"subst.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint Int.mone)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint Int.mone)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a x)","proofString":"exists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) (Vint Int.mone).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) (Vint Int.mone)","hypotheses":"(le : letenv) (a : expr) (x : val) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a x)","proofString":"EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.or x (Vint Int.mone)) (Vint Int.mone).","conclusion":"Val.lessdef (Val.or x (Vint Int.mone)) (Vint Int.mone)","hypotheses":"(le : letenv) (a : expr) (x : val) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i Int.mone)) (Vint Int.mone).","conclusion":"Val.lessdef (Vint (Int.or i Int.mone)) (Vint Int.mone)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.or_mone; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orimm_match a with\n    | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n    | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n    | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.or x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orimm_match a with\n    | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n    | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n    | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.mone)","proofString":"clear H H0.\ndestruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orimm_match a with\n    | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n    | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n    | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.or x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orimm_match a with\n    | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n    | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n    | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val)","proofString":"destruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.or n n2)) Enil) v /\\\n  Val.lessdef (Val.or (Vint n2) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.or n n2)) Enil) v /\\\n  Val.lessdef (Val.or (Vint n2) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (n2 : int)","proofString":"TrivialExists.\nsimpl.\nrewrite Int.or_commut; auto."},{"statement":"(n : int) (le : letenv) (n2 : int) : eval_operation ge sp (Ointconst (Int.or n n2)) nil m =\nSome (Val.or (Vint n2) (Vint n)).","conclusion":"eval_operation ge sp (Ointconst (Int.or n n2)) nil m =\nSome (Val.or (Vint n2) (Vint n))","hypotheses":"(n : int) (le : letenv) (n2 : int)","proofString":"simpl.\nrewrite Int.or_commut; auto."},{"statement":"(n : int) (le : letenv) (n2 : int) : Some (Vint (Int.or n n2)) = Some (Vint (Int.or n2 n)).","conclusion":"Some (Vint (Int.or n n2)) = Some (Vint (Int.or n2 n))","hypotheses":"(n : int) (le : letenv) (n2 : int)","proofString":"rewrite Int.or_commut; auto."},{"statement":"(n : int) (le : letenv) (x : val) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (H : Val.or v1 (Vint n2) = x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (x : val) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (H : Val.or v1 (Vint n2) = x)","proofString":"subst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.or v1 (Vint n2)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.or v1 (Vint n2)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Val.or (Vint n2) (Vint n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Val.or (Vint n2) (Vint n))) v","hypotheses":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"simpl.\nrewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Vint (Int.or n2 n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Vint (Int.or n2 n))) v","hypotheses":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n2 n)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Vint (Int.or n2 n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n2 n)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Vint (Int.or n2 n))) v","hypotheses":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x)","proofString":"TrivialExists."},{"statement":"(a1 a2 : expr) (le : letenv) (v1 v2 : val) : same_expr_pure a1 a2 = true ->\neval_expr ge sp e m le a1 v1 ->\neval_expr ge sp e m le a2 v2 -> a1 = a2 /\\ v1 = v2.","conclusion":"same_expr_pure a1 a2 = true ->\neval_expr ge sp e m le a1 v1 ->\neval_expr ge sp e m le a2 v2 -> a1 = a2 /\\ v1 = v2","hypotheses":"(a1 a2 : expr) (le : letenv) (v1 v2 : val)","proofString":"destruct a1; simpl; try (intros; discriminate).\ndestruct a2; simpl; try (intros; discriminate).\ncase (ident_eq i i0); intros.\nsubst i0.\ninversion H0.\ninversion H1.\nsplit.\nauto.\ncongruence.\ndiscriminate."},{"statement":"(i : ident) (a2 : expr) (le : letenv) (v1 v2 : val) : match a2 with\n| Evar v3 => if ident_eq i v3 then true else false\n| _ => false\nend = true ->\neval_expr ge sp e m le (Evar i) v1 ->\neval_expr ge sp e m le a2 v2 -> Evar i = a2 /\\ v1 = v2.","conclusion":"match a2 with\n| Evar v3 => if ident_eq i v3 then true else false\n| _ => false\nend = true ->\neval_expr ge sp e m le (Evar i) v1 ->\neval_expr ge sp e m le a2 v2 -> Evar i = a2 /\\ v1 = v2","hypotheses":"(i : ident) (a2 : expr) (le : letenv) (v1 v2 : val)","proofString":"destruct a2; simpl; try (intros; discriminate).\ncase (ident_eq i i0); intros.\nsubst i0.\ninversion H0.\ninversion H1.\nsplit.\nauto.\ncongruence.\ndiscriminate."},{"statement":"(i i0 : ident) (le : letenv) (v1 v2 : val) : (if ident_eq i i0 then true else false) = true ->\neval_expr ge sp e m le (Evar i) v1 ->\neval_expr ge sp e m le (Evar i0) v2 -> Evar i = Evar i0 /\\ v1 = v2.","conclusion":"(if ident_eq i i0 then true else false) = true ->\neval_expr ge sp e m le (Evar i) v1 ->\neval_expr ge sp e m le (Evar i0) v2 -> Evar i = Evar i0 /\\ v1 = v2","hypotheses":"(i i0 : ident) (le : letenv) (v1 v2 : val)","proofString":"case (ident_eq i i0); intros.\nsubst i0.\ninversion H0.\ninversion H1.\nsplit.\nauto.\ncongruence.\ndiscriminate."},{"statement":"(i i0 : ident) (le : letenv) (v1 v2 : val) (e0 : i = i0) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2) : Evar i = Evar i0 /\\ v1 = v2.","conclusion":"Evar i = Evar i0 /\\ v1 = v2","hypotheses":"(i i0 : ident) (le : letenv) (v1 v2 : val) (e0 : i = i0) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2)","proofString":"subst i0.\ninversion H0.\ninversion H1.\nsplit.\nauto.\ncongruence."},{"statement":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) : Evar i = Evar i /\\ v1 = v2.","conclusion":"Evar i = Evar i /\\ v1 = v2","hypotheses":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2)","proofString":"inversion H0.\ninversion H1.\nsplit.\nauto.\ncongruence."},{"statement":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1) : Evar i = Evar i /\\ v1 = v2.","conclusion":"Evar i = Evar i /\\ v1 = v2","hypotheses":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1)","proofString":"inversion H1.\nsplit.\nauto.\ncongruence."},{"statement":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1) (le1 : letenv) (id0 : positive) (v0 : val) (H8 : Maps.PTree.get i e = Some v2) (H7 : le1 = le) (H6 : id0 = i) (H9 : v0 = v2) : Evar i = Evar i /\\ v1 = v2.","conclusion":"Evar i = Evar i /\\ v1 = v2","hypotheses":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1) (le1 : letenv) (id0 : positive) (v0 : val) (H8 : Maps.PTree.get i e = Some v2) (H7 : le1 = le) (H6 : id0 = i) (H9 : v0 = v2)","proofString":"split.\nauto.\ncongruence."},{"statement":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1) (le1 : letenv) (id0 : positive) (v0 : val) (H8 : Maps.PTree.get i e = Some v2) (H7 : le1 = le) (H6 : id0 = i) (H9 : v0 = v2) : Evar i = Evar i.","conclusion":"Evar i = Evar i","hypotheses":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1) (le1 : letenv) (id0 : positive) (v0 : val) (H8 : Maps.PTree.get i e = Some v2) (H7 : le1 = le) (H6 : id0 = i) (H9 : v0 = v2)","proofString":"auto."},{"statement":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1) (le1 : letenv) (id0 : positive) (v0 : val) (H8 : Maps.PTree.get i e = Some v2) (H7 : le1 = le) (H6 : id0 = i) (H9 : v0 = v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(i : ident) (le : letenv) (v1 v2 : val) (H : true = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i) v2) (le0 : letenv) (id : positive) (v : val) (H4 : Maps.PTree.get i e = Some v1) (H3 : le0 = le) (H2 : id = i) (H5 : v = v1) (le1 : letenv) (id0 : positive) (v0 : val) (H8 : Maps.PTree.get i e = Some v2) (H7 : le1 = le) (H6 : id0 = i) (H9 : v0 = v2)","proofString":"congruence."},{"statement":"(i i0 : ident) (le : letenv) (v1 v2 : val) (n : i <> i0) (H : false = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2) : Evar i = Evar i0 /\\ v1 = v2.","conclusion":"Evar i = Evar i0 /\\ v1 = v2","hypotheses":"(i i0 : ident) (le : letenv) (v1 v2 : val) (n : i <> i0) (H : false = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2)","proofString":"discriminate."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorimm n1 t2) v /\\\n  Val.lessdef (Val.xor (Vint n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorimm n1 t2) v /\\\n  Val.lessdef (Val.xor (Vint n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.xor_commut.\napply eval_xorimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorimm n1 t2) v /\\\n  Val.lessdef (Val.xor y (Vint n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorimm n1 t2) v /\\\n  Val.lessdef (Val.xor y (Vint n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"apply eval_xorimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (xorimm n2 t1) v /\\\n  Val.lessdef (Val.xor x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorimm n2 t1) v /\\\n  Val.lessdef (Val.xor x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_xorimm; auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : exists v : val, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z)","proofString":"unfold divs_base.\nexists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eop Odiv (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Odiv (a ::: b ::: Enil)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z)","proofString":"exists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : eval_expr ge sp e m le (Eop Odiv (a ::: b ::: Enil)) z.","conclusion":"eval_expr ge sp e m le (Eop Odiv (a ::: b ::: Enil)) z","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : Val.lessdef z z.","conclusion":"Val.lessdef z z","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z)","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z)","proofString":"exploit Val.mods_divs; eauto.\nintros [v [A B]].\nsubst.\neconstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divs); auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) : (exists v : val, Val.divs x y = Some v /\\ z = Val.sub x (Val.mul v y)) ->\nexists v : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v /\\ Val.lessdef z v.","conclusion":"(exists v : val, Val.divs x y = Some v /\\ z = Val.sub x (Val.mul v y)) ->\nexists v : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z)","proofString":"intros [v [A B]].\nsubst.\neconstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divs); auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (v : val) (A : Val.divs x y = Some v) (B : z = Val.sub x (Val.mul v y)) : exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v0 /\\ Val.lessdef z v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v0 /\\ Val.lessdef z v0","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (v : val) (A : Val.divs x y = Some v) (B : z = Val.sub x (Val.mul v y))","proofString":"subst.\neconstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divs); auto."},{"statement":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.mods x y = Some (Val.sub x (Val.mul v y))) (A : Val.divs x y = Some v) : exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v0 /\\\n  Val.lessdef (Val.sub x (Val.mul v y)) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odiv a b) v0 /\\\n  Val.lessdef (Val.sub x (Val.mul v y)) v0","hypotheses":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.mods x y = Some (Val.sub x (Val.mul v y))) (A : Val.divs x y = Some v)","proofString":"econstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divs); auto."},{"statement":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.mods x y = Some (Val.sub x (Val.mul v y))) (A : Val.divs x y = Some v) : eval_expr ge sp e m le (mod_aux Odiv a b) (Val.sub x (Val.mul v y)).","conclusion":"eval_expr ge sp e m le (mod_aux Odiv a b) (Val.sub x (Val.mul v y))","hypotheses":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.mods x y = Some (Val.sub x (Val.mul v y))) (A : Val.divs x y = Some v)","proofString":"apply eval_mod_aux with (semdivop := Val.divs); auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : exists v : val, eval_expr ge sp e m le (divu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z)","proofString":"unfold divu_base.\nexists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivu (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Odivu (a ::: b ::: Enil)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z)","proofString":"exists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : eval_expr ge sp e m le (Eop Odivu (a ::: b ::: Enil)) z.","conclusion":"eval_expr ge sp e m le (Eop Odivu (a ::: b ::: Enil)) z","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : Val.lessdef z z.","conclusion":"Val.lessdef z z","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z)","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z)","proofString":"exploit Val.modu_divu; eauto.\nintros [v [A B]].\nsubst.\neconstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divu); auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) : (exists v : val, Val.divu x y = Some v /\\ z = Val.sub x (Val.mul v y)) ->\nexists v : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v /\\ Val.lessdef z v.","conclusion":"(exists v : val, Val.divu x y = Some v /\\ z = Val.sub x (Val.mul v y)) ->\nexists v : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z)","proofString":"intros [v [A B]].\nsubst.\neconstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divu); auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (v : val) (A : Val.divu x y = Some v) (B : z = Val.sub x (Val.mul v y)) : exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v0 /\\ Val.lessdef z v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v0 /\\ Val.lessdef z v0","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (v : val) (A : Val.divu x y = Some v) (B : z = Val.sub x (Val.mul v y))","proofString":"subst.\neconstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divu); auto."},{"statement":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.modu x y = Some (Val.sub x (Val.mul v y))) (A : Val.divu x y = Some v) : exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v0 /\\\n  Val.lessdef (Val.sub x (Val.mul v y)) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (mod_aux Odivu a b) v0 /\\\n  Val.lessdef (Val.sub x (Val.mul v y)) v0","hypotheses":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.modu x y = Some (Val.sub x (Val.mul v y))) (A : Val.divu x y = Some v)","proofString":"econstructor; split; eauto.\napply eval_mod_aux with (semdivop := Val.divu); auto."},{"statement":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.modu x y = Some (Val.sub x (Val.mul v y))) (A : Val.divu x y = Some v) : eval_expr ge sp e m le (mod_aux Odivu a b) (Val.sub x (Val.mul v y)).","conclusion":"eval_expr ge sp e m le (mod_aux Odivu a b) (Val.sub x (Val.mul v y))","hypotheses":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (v : val) (H1 : Val.modu x y = Some (Val.sub x (Val.mul v y))) (A : Val.divu x y = Some v)","proofString":"apply eval_mod_aux with (semdivop := Val.divu); auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) : exists v : val, eval_expr ge sp e m le (shrximm a n) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (shrximm a n) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z)","proofString":"unfold shrximm.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\neconstructor; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z)","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\neconstructor; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n = Int.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n = Int.zero)","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z)","proofString":"exists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z) : Val.lessdef z x.","conclusion":"Val.lessdef z x","hypotheses":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z)","proofString":"destruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (z : val) (H : eval_expr ge sp e m le a (Vint i)) (H0 : (if Int.ltu Int.zero (Int.repr 31)\n then Some (Vint (Int.shrx i Int.zero))\n else None) = Some z) : Val.lessdef z (Vint i).","conclusion":"Val.lessdef z (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (z : val) (H : eval_expr ge sp e m le a (Vint i)) (H0 : (if Int.ltu Int.zero (Int.repr 31)\n then Some (Vint (Int.shrx i Int.zero))\n else None) = Some z)","proofString":"destruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.shrx i Int.zero)) (Vint i).","conclusion":"Val.lessdef (Vint (Int.shrx i Int.zero)) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"replace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","conclusion":"Val.lessdef (Vint i) (Vint i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.shrx i Int.zero.","conclusion":"i = Int.shrx i Int.zero","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"unfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i ÷ Int.signed (Int.shl Int.one Int.zero)).","conclusion":"i = Int.repr (Int.signed i ÷ Int.signed (Int.shl Int.one Int.zero))","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i ÷ Int.signed Int.one).","conclusion":"i = Int.repr (Int.signed i ÷ Int.signed Int.one)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"change (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i ÷ 1).","conclusion":"i = Int.repr (Int.signed i ÷ 1)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i).","conclusion":"i = Int.repr (Int.signed i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"rewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrximm n) (a ::: Enil)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrximm n) (a ::: Enil)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n <> Int.zero)","proofString":"econstructor; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\ Val.lessdef (Val.shl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\ Val.lessdef (Val.shl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y)","proofString":"InvEval.\napply eval_shlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\\n  Val.lessdef (Val.shl x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\\n  Val.lessdef (Val.shl x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshl (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oshl (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\ Val.lessdef (Val.shr x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\ Val.lessdef (Val.shr x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y)","proofString":"InvEval.\napply eval_shrimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\\n  Val.lessdef (Val.shr x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\\n  Val.lessdef (Val.shr x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shrimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshr (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shr x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oshr (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shr x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\ Val.lessdef (Val.shru x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\ Val.lessdef (Val.shru x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y)","proofString":"InvEval.\napply eval_shruimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\\n  Val.lessdef (Val.shru x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\\n  Val.lessdef (Val.shru x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shruimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshru (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shru x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oshru (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shru x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (negf a) v /\\ Val.lessdef (Val.negf x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (negf a) v /\\ Val.lessdef (Val.negf x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (absf a) v /\\ Val.lessdef (Val.absf x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (absf a) v /\\ Val.lessdef (Val.absf x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (negfs a) v /\\ Val.lessdef (Val.negfs x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (negfs a) v /\\ Val.lessdef (Val.negfs x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (absfs a) v /\\ Val.lessdef (Val.absfs x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (absfs a) v /\\ Val.lessdef (Val.absfs x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : comparison) (n1 : int) (H : eval_expr ge sp e m le (Eop (Ointconst n1) Enil) x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (sem c0 x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (sem c0 x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : comparison) (n1 : int) (H : eval_expr ge sp e m le (Eop (Ointconst n1) Enil) x)","proofString":"InvEval.\nrewrite sem_int.\nTrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (sem c0 (Vint n1) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (sem c0 (Vint n1) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int)","proofString":"rewrite sem_int.\nTrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (Val.of_bool (intsem c0 n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (Val.of_bool (intsem c0 n1 n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int)","proofString":"TrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : eval_operation ge sp\n  (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) nil m =\nSome (Val.of_bool (intsem c0 n1 n2)).","conclusion":"eval_operation ge sp\n  (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) nil m =\nSome (Val.of_bool (intsem c0 n1 n2))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int)","proofString":"simpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : Some (Vint (if intsem c0 n1 n2 then Int.one else Int.zero)) =\nSome (Val.of_bool (intsem c0 n1 n2)).","conclusion":"Some (Vint (if intsem c0 n1 n2 then Int.one else Int.zero)) =\nSome (Val.of_bool (intsem c0 n1 n2))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int)","proofString":"destruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x)","proofString":"InvEval.\ninv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x)","proofString":"inv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x)","proofString":"simpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x)","proofString":"inv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"destruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero)","proofString":"subst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"TrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","conclusion":"eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"simpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","conclusion":"Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"rewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","conclusion":"Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if negb b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.zero)).","conclusion":"Some (if negb b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool)","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero)).","conclusion":"Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool)","proofString":"destruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some Vundef = Some (sem Ceq Vundef (Vint Int.zero)).","conclusion":"Some Vundef = Some (sem Ceq Vundef (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp c0) el\n     else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp c0) el\n     else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero)","proofString":"destruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one)","proofString":"subst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"TrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","conclusion":"eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"simpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","conclusion":"Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.one)).","conclusion":"Some (if b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool)","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.one)).","conclusion":"Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool)","proofString":"destruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some Vundef = Some (sem Ceq Vundef (Vint Int.one)).","conclusion":"Some Vundef = Some (sem Ceq Vundef (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"exists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.zero).","conclusion":"Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.zero)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Ceq (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.zero).","conclusion":"Val.lessdef (sem Ceq (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.zero)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool)","proofString":"unfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.zero).","conclusion":"Val.lessdef (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.zero)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool)","proofString":"destruct b; rewrite sem_eq; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Ceq Vundef (Vint n2)) (Vint Int.zero).","conclusion":"Val.lessdef (sem Ceq Vundef (Vint n2)) (Vint Int.zero)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x)","proofString":"InvEval.\ninv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x)","proofString":"inv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x)","proofString":"simpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x)","proofString":"inv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"destruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero)","proofString":"subst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"TrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","conclusion":"eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"simpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","conclusion":"Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.zero)).","conclusion":"Some (if b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool)","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero)).","conclusion":"Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool)","proofString":"destruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some Vundef = Some (sem Cne Vundef (Vint Int.zero)).","conclusion":"Some Vundef = Some (sem Cne Vundef (Vint Int.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl)","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp (negate_condition c0)) el\n     else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp (negate_condition c0)) el\n     else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero)","proofString":"destruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one)","proofString":"subst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"TrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","conclusion":"eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"simpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","conclusion":"Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"rewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","conclusion":"Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if negb b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.one)).","conclusion":"Some (if negb b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool)","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.one)).","conclusion":"Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool)","proofString":"destruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some Vundef = Some (sem Cne Vundef (Vint Int.one)).","conclusion":"Some Vundef = Some (sem Cne Vundef (Vint Int.one))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero)","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"exists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) (Vint Int.one).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) (Vint Int.one)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.one).","conclusion":"Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.one)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Cne (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.one).","conclusion":"Val.lessdef (sem Cne (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.one)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool)","proofString":"unfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.one).","conclusion":"Val.lessdef (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.one)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool)","proofString":"destruct b; rewrite sem_ne; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Cne Vundef (Vint n2)) (Vint Int.one).","conclusion":"Val.lessdef (sem Cne Vundef (Vint n2)) (Vint Int.one)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one)","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (i : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) : Val.lessdef (Val.of_bool (Int.eq (Int.and i m0) Int.zero))\n  (if Int.eq (Int.and i m0) Int.zero then Vtrue else Vfalse).","conclusion":"Val.lessdef (Val.of_bool (Int.eq (Int.and i m0) Int.zero))\n  (if Int.eq (Int.and i m0) Int.zero then Vtrue else Vfalse)","hypotheses":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (i : int) (H2 : eval_expr ge sp e m le t1 (Vint i))","proofString":"auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem c (Vint n2) x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem c (Vint n2) x) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"rewrite <- sem_swap.\neapply eval_compimm; eauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem (swap_comparison c) x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem (swap_comparison c) x (Vint n2)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp (swap_comparison c) t2 n1)\n    v /\\ Val.lessdef (Val.cmp c (Vint n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp (swap_comparison c) t2 n1)\n    v /\\ Val.lessdef (Val.cmp c (Vint n1) y) v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"eapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : forall (c0 : comparison) (x y0 : val),\nVal.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x.","conclusion":"forall (c0 : comparison) (x y0 : val),\nVal.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"intros.\nunfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x.","conclusion":"Val.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val)","proofString":"unfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.of_optbool (Val.cmp_bool (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmp_bool c0 y0 x).","conclusion":"Val.of_optbool (Val.cmp_bool (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmp_bool c0 y0 x)","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val)","proofString":"rewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp c t1 n2) v /\\\n  Val.lessdef (Val.cmp c x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp c t1 n2) v /\\\n  Val.lessdef (Val.cmp c x (Vint n2)) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le\n    (compimm Ccompuimm Int.cmpu (swap_comparison c) t2 n1) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c (Vint n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (compimm Ccompuimm Int.cmpu (swap_comparison c) t2 n1) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c (Vint n1) y) v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"eapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : forall (c0 : comparison) (x y0 : val),\nVal.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x.","conclusion":"forall (c0 : comparison) (x y0 : val),\nVal.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"intros.\nunfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x.","conclusion":"Val.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val)","proofString":"unfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.of_optbool\n  (Val.cmpu_bool (Mem.valid_pointer m) (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmpu_bool (Mem.valid_pointer m) c0 y0 x).","conclusion":"Val.of_optbool\n  (Val.cmpu_bool (Mem.valid_pointer m) (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmpu_bool (Mem.valid_pointer m) c0 y0 x)","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val)","proofString":"rewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompuimm Int.cmpu c t1 n2) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (compimm Ccompuimm Int.cmpu c t1 n2) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c x (Vint n2)) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x)","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (compf c a b) v /\\ Val.lessdef (Val.cmpf c x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (compf c a b) v /\\ Val.lessdef (Val.cmpf c x y) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"unfold compf.\nTrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccompf c)) (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.cmpf c x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccompf c)) (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.cmpf c x y) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"TrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : eval_operation ge sp (Ocmp (Ccompfs c)) (x :: y :: nil) m =\nSome (Val.cmpf c (Val.floatofsingle x) (Val.floatofsingle y)).","conclusion":"eval_operation ge sp (Ocmp (Ccompfs c)) (x :: y :: nil) m =\nSome (Val.cmpf c (Val.floatofsingle x) (Val.floatofsingle y))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"auto.\ndestruct x; auto.\ndestruct y; auto.\nunfold Val.cmpf, Val.cmpfs; simpl.\nrewrite Float32.cmp_double.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : eval_operation ge sp (Ocmp (Ccompfs c)) (x :: y :: nil) m =\nSome (Val.cmpf c (Val.floatofsingle x) (Val.floatofsingle y)).","conclusion":"eval_operation ge sp (Ocmp (Ccompfs c)) (x :: y :: nil) m =\nSome (Val.cmpf c (Val.floatofsingle x) (Val.floatofsingle y))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct x; auto.\ndestruct y; auto.\nunfold Val.cmpf, Val.cmpfs; simpl.\nrewrite Float32.cmp_double.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b y) : eval_operation ge sp (Ocmp (Ccompfs c)) (Vsingle f :: y :: nil) m =\nSome (Val.cmpf c (Val.floatofsingle (Vsingle f)) (Val.floatofsingle y)).","conclusion":"eval_operation ge sp (Ocmp (Ccompfs c)) (Vsingle f :: y :: nil) m =\nSome (Val.cmpf c (Val.floatofsingle (Vsingle f)) (Val.floatofsingle y))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct y; auto.\nunfold Val.cmpf, Val.cmpfs; simpl.\nrewrite Float32.cmp_double.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (f0 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b (Vsingle f0)) : eval_operation ge sp (Ocmp (Ccompfs c)) (Vsingle f :: Vsingle f0 :: nil) m =\nSome\n  (Val.cmpf c (Val.floatofsingle (Vsingle f))\n     (Val.floatofsingle (Vsingle f0))).","conclusion":"eval_operation ge sp (Ocmp (Ccompfs c)) (Vsingle f :: Vsingle f0 :: nil) m =\nSome\n  (Val.cmpf c (Val.floatofsingle (Vsingle f))\n     (Val.floatofsingle (Vsingle f0)))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (f0 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b (Vsingle f0))","proofString":"unfold Val.cmpf, Val.cmpfs; simpl.\nrewrite Float32.cmp_double.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (f0 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b (Vsingle f0)) : Some (if Float32.cmp c f f0 then Vtrue else Vfalse) =\nSome\n  (if Float.cmp c (Float.of_single f) (Float.of_single f0)\n   then Vtrue\n   else Vfalse).","conclusion":"Some (if Float32.cmp c f f0 then Vtrue else Vfalse) =\nSome\n  (if Float.cmp c (Float.of_single f) (Float.of_single f0)\n   then Vtrue\n   else Vfalse)","hypotheses":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (f0 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b (Vsingle f0))","proofString":"rewrite Float32.cmp_double.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (f0 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b (Vsingle f0)) : Some\n  (if Float.cmp c (Float32.to_double f) (Float32.to_double f0)\n   then Vtrue\n   else Vfalse) =\nSome\n  (if Float.cmp c (Float.of_single f) (Float.of_single f0)\n   then Vtrue\n   else Vfalse).","conclusion":"Some\n  (if Float.cmp c (Float32.to_double f) (Float32.to_double f0)\n   then Vtrue\n   else Vfalse) =\nSome\n  (if Float.cmp c (Float.of_single f) (Float.of_single f0)\n   then Vtrue\n   else Vfalse)","hypotheses":"(c : comparison) (le : letenv) (a : expr) (f : float32) (b : expr) (f0 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : eval_expr ge sp e m le b (Vsingle f0))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (singleoffloat a) v /\\\n  Val.lessdef (Val.singleoffloat x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (singleoffloat a) v /\\\n  Val.lessdef (Val.singleoffloat x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"unfold singleoffloat.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Osingleoffloat (a ::: Enil)) v /\\\n  Val.lessdef (Val.singleoffloat x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Osingleoffloat (a ::: Enil)) v /\\\n  Val.lessdef (Val.singleoffloat x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (floatofsingle a) v /\\\n  Val.lessdef (Val.floatofsingle x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (floatofsingle a) v /\\\n  Val.lessdef (Val.floatofsingle x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"unfold floatofsingle.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatofsingle (a ::: Enil)) v /\\\n  Val.lessdef (Val.floatofsingle x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatofsingle (a ::: Enil)) v /\\\n  Val.lessdef (Val.floatofsingle x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intoffloat x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ointoffloat (a ::: Enil)) v /\\ Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Ointoffloat (a ::: Enil)) v /\\ Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intoffloat x = Some y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float) : eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 1) (Vfloat f).","conclusion":"eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 1) (Vfloat f)","hypotheses":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float)","proofString":"constructor.\nauto."},{"statement":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float) : nth_error (Vfloat fm :: Vfloat f :: le) 1 = Some (Vfloat f).","conclusion":"nth_error (Vfloat fm :: Vfloat f :: le) 1 = Some (Vfloat f)","hypotheses":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float) (H1 : eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 1) (Vfloat f)) : eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 0) (Vfloat fm).","conclusion":"eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 0) (Vfloat fm)","hypotheses":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float) (H1 : eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 1) (Vfloat f))","proofString":"constructor.\nauto."},{"statement":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float) (H1 : eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 1) (Vfloat f)) : nth_error (Vfloat fm :: Vfloat f :: le) 0 = Some (Vfloat fm).","conclusion":"nth_error (Vfloat fm :: Vfloat f :: le) 0 = Some (Vfloat fm)","hypotheses":"(le : letenv) (a : expr) (f : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n : int) (Heqo : Float.to_long f = Some (Int64.repr (Int.unsigned n))) (H0 : Int.modulus < Int64.max_unsigned) (im : int) (fm : float) (H1 : eval_expr ge sp e m (Vfloat fm :: Vfloat f :: le) (Eletvar 1) (Vfloat f))","proofString":"auto."},{"statement":"(le : letenv) (x y : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) (H0 : Val.floatofint x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (x y : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) (H0 : Val.floatofint x = Some y)","proofString":"InvEval.\nTrivialExists."},{"statement":"(le : letenv) (y : val) (n : int) (H0 : Val.floatofint (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (y : val) (n : int) (H0 : Val.floatofint (Vint n) = Some y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (x y : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) (H0 : Val.floatofintu x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (x y : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) (H0 : Val.floatofintu x = Some y)","proofString":"InvEval.\nTrivialExists."},{"statement":"(le : letenv) (y : val) (n : int) (H0 : Val.floatofintu (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (y : val) (n : int) (H0 : Val.floatofintu (Vint n) = Some y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intofsingle x = Some y) : Val.intoffloat (Val.floatofsingle x) = Some y.","conclusion":"Val.intoffloat (Val.floatofsingle x) = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intofsingle x = Some y)","proofString":"destruct x; simpl in H0; try discriminate.\ndestruct (Float32.to_int f) eqn:F; inv H0.\napply Float32.to_int_double in F.\nsimpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : option_map Vint (Float32.to_int f) = Some y) : Val.intoffloat (Val.floatofsingle (Vsingle f)) = Some y.","conclusion":"Val.intoffloat (Val.floatofsingle (Vsingle f)) = Some y","hypotheses":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : option_map Vint (Float32.to_int f) = Some y)","proofString":"destruct (Float32.to_int f) eqn:F; inv H0.\napply Float32.to_int_double in F.\nsimpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float32.to_int f = Some i) : Val.intoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i).","conclusion":"Val.intoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float32.to_int f = Some i)","proofString":"apply Float32.to_int_double in F.\nsimpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_int (Float32.to_double f) = Some i) : Val.intoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i).","conclusion":"Val.intoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_int (Float32.to_double f) = Some i)","proofString":"simpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_int (Float32.to_double f) = Some i) : option_map Vint (Float.to_int (Float.of_single f)) = Some (Vint i).","conclusion":"option_map Vint (Float.to_int (Float.of_single f)) = Some (Vint i)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_int (Float32.to_double f) = Some i)","proofString":"unfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleofint x = Some y) : exists z : val, Val.floatofint x = Some z /\\ y = Val.singleoffloat z.","conclusion":"exists z : val, Val.floatofint x = Some z /\\ y = Val.singleoffloat z","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleofint x = Some y)","proofString":"destruct x; inv H0.\nsimpl.\nexists (Vfloat (Float.of_int i)); simpl; split; auto.\nf_equal.\napply Float32.of_int_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : exists z : val,\n  Val.floatofint (Vint i) = Some z /\\\n  Vsingle (Float32.of_int i) = Val.singleoffloat z.","conclusion":"exists z : val,\n  Val.floatofint (Vint i) = Some z /\\\n  Vsingle (Float32.of_int i) = Val.singleoffloat z","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"simpl.\nexists (Vfloat (Float.of_int i)); simpl; split; auto.\nf_equal.\napply Float32.of_int_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : exists z : val,\n  Some (Vfloat (Float.of_int i)) = Some z /\\\n  Vsingle (Float32.of_int i) = Val.singleoffloat z.","conclusion":"exists z : val,\n  Some (Vfloat (Float.of_int i)) = Some z /\\\n  Vsingle (Float32.of_int i) = Val.singleoffloat z","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"exists (Vfloat (Float.of_int i)); simpl; split; auto.\nf_equal.\napply Float32.of_int_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Vsingle (Float32.of_int i) = Vsingle (Float.to_single (Float.of_int i)).","conclusion":"Vsingle (Float32.of_int i) = Vsingle (Float.to_single (Float.of_int i))","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"f_equal.\napply Float32.of_int_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Float32.of_int i = Float.to_single (Float.of_int i).","conclusion":"Float32.of_int i = Float.to_single (Float.of_int i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"apply Float32.of_int_double."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intuofsingle x = Some y) : Val.intuoffloat (Val.floatofsingle x) = Some y.","conclusion":"Val.intuoffloat (Val.floatofsingle x) = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intuofsingle x = Some y)","proofString":"destruct x; simpl in H0; try discriminate.\ndestruct (Float32.to_intu f) eqn:F; inv H0.\napply Float32.to_intu_double in F.\nsimpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : option_map Vint (Float32.to_intu f) = Some y) : Val.intuoffloat (Val.floatofsingle (Vsingle f)) = Some y.","conclusion":"Val.intuoffloat (Val.floatofsingle (Vsingle f)) = Some y","hypotheses":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H0 : option_map Vint (Float32.to_intu f) = Some y)","proofString":"destruct (Float32.to_intu f) eqn:F; inv H0.\napply Float32.to_intu_double in F.\nsimpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float32.to_intu f = Some i) : Val.intuoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i).","conclusion":"Val.intuoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float32.to_intu f = Some i)","proofString":"apply Float32.to_intu_double in F.\nsimpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_intu (Float32.to_double f) = Some i) : Val.intuoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i).","conclusion":"Val.intuoffloat (Val.floatofsingle (Vsingle f)) = Some (Vint i)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_intu (Float32.to_double f) = Some i)","proofString":"simpl.\nunfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_intu (Float32.to_double f) = Some i) : option_map Vint (Float.to_intu (Float.of_single f)) = Some (Vint i).","conclusion":"option_map Vint (Float.to_intu (Float.of_single f)) = Some (Vint i)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (i : int) (F : Float.to_intu (Float32.to_double f) = Some i)","proofString":"unfold Float32.to_double in F; rewrite F; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleofintu x = Some y) : exists z : val, Val.floatofintu x = Some z /\\ y = Val.singleoffloat z.","conclusion":"exists z : val, Val.floatofintu x = Some z /\\ y = Val.singleoffloat z","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleofintu x = Some y)","proofString":"destruct x; inv H0.\nsimpl.\nexists (Vfloat (Float.of_intu i)); simpl; split; auto.\nf_equal.\napply Float32.of_intu_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : exists z : val,\n  Val.floatofintu (Vint i) = Some z /\\\n  Vsingle (Float32.of_intu i) = Val.singleoffloat z.","conclusion":"exists z : val,\n  Val.floatofintu (Vint i) = Some z /\\\n  Vsingle (Float32.of_intu i) = Val.singleoffloat z","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"simpl.\nexists (Vfloat (Float.of_intu i)); simpl; split; auto.\nf_equal.\napply Float32.of_intu_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : exists z : val,\n  Some (Vfloat (Float.of_intu i)) = Some z /\\\n  Vsingle (Float32.of_intu i) = Val.singleoffloat z.","conclusion":"exists z : val,\n  Some (Vfloat (Float.of_intu i)) = Some z /\\\n  Vsingle (Float32.of_intu i) = Val.singleoffloat z","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"exists (Vfloat (Float.of_intu i)); simpl; split; auto.\nf_equal.\napply Float32.of_intu_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Vsingle (Float32.of_intu i) = Vsingle (Float.to_single (Float.of_intu i)).","conclusion":"Vsingle (Float32.of_intu i) = Vsingle (Float.to_single (Float.of_intu i))","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"f_equal.\napply Float32.of_intu_double."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Float32.of_intu i = Float.to_single (Float.of_intu i).","conclusion":"Float32.of_intu i = Float.to_single (Float.of_intu i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"apply Float32.of_intu_double."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le Enil vl /\\\n  eval_addressing ge sp (Ainstack n) vl = Some (Val.offset_ptr sp n).","conclusion":"exists vl : list val,\n  eval_exprlist ge sp e m le Enil vl /\\\n  eval_addressing ge sp (Ainstack n) vl = Some (Val.offset_ptr sp n)","hypotheses":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs)","proofString":"exists (@nil val).\nsplit.\neauto with evalexpr.\nsimpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : eval_exprlist ge sp e m le Enil nil /\\\neval_addressing ge sp (Ainstack n) nil = Some (Val.offset_ptr sp n).","conclusion":"eval_exprlist ge sp e m le Enil nil /\\\neval_addressing ge sp (Ainstack n) nil = Some (Val.offset_ptr sp n)","hypotheses":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs)","proofString":"split.\neauto with evalexpr.\nsimpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : eval_exprlist ge sp e m le Enil nil.","conclusion":"eval_exprlist ge sp e m le Enil nil","hypotheses":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs)","proofString":"eauto with evalexpr."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : eval_addressing ge sp (Ainstack n) nil = Some (Val.offset_ptr sp n).","conclusion":"eval_addressing ge sp (Ainstack n) nil = Some (Val.offset_ptr sp n)","hypotheses":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs)","proofString":"simpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : Some (Val.offset_ptr sp n) = Some (Val.offset_ptr sp n).","conclusion":"Some (Val.offset_ptr sp n) = Some (Val.offset_ptr sp n)","hypotheses":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs)","proofString":"auto."},{"statement":"(a : expr) (n : int) : eval_builtin_arg ge sp e m (BA_int n) (Vint n).","conclusion":"eval_builtin_arg ge sp e m (BA_int n) (Vint n)","hypotheses":"(a : expr) (n : int)","proofString":"constructor."},{"statement":"(a : expr) (n : int64) : eval_builtin_arg ge sp e m (BA_long n) (Vlong n).","conclusion":"eval_builtin_arg ge sp e m (BA_long n) (Vlong n)","hypotheses":"(a : expr) (n : int64)","proofString":"constructor."},{"statement":"(a : expr) (id : ident) (ofs : ptrofs) : eval_builtin_arg ge sp e m (BA_addrglobal id ofs)\n  (Genv.symbol_address ge id ofs).","conclusion":"eval_builtin_arg ge sp e m (BA_addrglobal id ofs)\n  (Genv.symbol_address ge id ofs)","hypotheses":"(a : expr) (id : ident) (ofs : ptrofs)","proofString":"constructor."},{"statement":"(a : expr) (ofs : ptrofs) : eval_builtin_arg ge sp e m (BA_addrstack ofs) (Val.offset_ptr sp ofs).","conclusion":"eval_builtin_arg ge sp e m (BA_addrstack ofs) (Val.offset_ptr sp ofs)","hypotheses":"(a : expr) (ofs : ptrofs)","proofString":"constructor."},{"statement":"(a : expr) (n : int64) (e1 : expr) (v1 : val) (H2 : eval_expr ge sp e m nil e1 v1) : eval_builtin_arg ge sp e m (BA e1) v1.","conclusion":"eval_builtin_arg ge sp e m (BA e1) v1","hypotheses":"(a : expr) (n : int64) (e1 : expr) (v1 : val) (H2 : eval_expr ge sp e m nil e1 v1)","proofString":"constructor; auto."},{"statement":"(a : expr) (v : val) (id : positive) (H0 : Maps.PTree.get id e = Some v) : eval_expr ge sp e m nil (Evar id) v.","conclusion":"eval_expr ge sp e m nil (Evar id) v","hypotheses":"(a : expr) (v : val) (id : positive) (H0 : Maps.PTree.get id e = Some v)","proofString":"repeat constructor; auto."},{"statement":"(bf : Builtins1.platform_builtin) (al : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (H : platform_builtin bf al = Some a) (H0 : eval_exprlist ge sp e m le al vl) (H1 : platform_builtin_sem bf vl = Some v) : exists v' : val, eval_expr ge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr ge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(bf : Builtins1.platform_builtin) (al : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (H : platform_builtin bf al = Some a) (H0 : eval_exprlist ge sp e m le al vl) (H1 : platform_builtin_sem bf vl = Some v)","proofString":"discriminate."}]}