{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/imm/SubExecution.v","fileSamples":[{"statement":"forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b.","conclusion":"forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b","hypotheses":"","proofString":"by ins; desf; apply (wf_index WF); splits; eauto; apply sub_E_in."},{"statement":"data' ⊆ sb'.","conclusion":"data' ⊆ sb'","hypotheses":"","proofString":"by rewrite (sub_data SUB), data_in_sb, sub_sb."},{"statement":"data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘.","conclusion":"data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_data SUB), wf_dataD, sub_R, sub_W; basic_solver."},{"statement":"addr' ⊆ sb'.","conclusion":"addr' ⊆ sb'","hypotheses":"","proofString":"by rewrite (sub_addr SUB), addr_in_sb, sub_sb."},{"statement":"addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘.","conclusion":"addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_addr SUB), wf_addrD, sub_R, sub_W; basic_solver 12."},{"statement":"ctrl' ⊆ sb'.","conclusion":"ctrl' ⊆ sb'","hypotheses":"","proofString":"by rewrite (sub_ctrl SUB), ctrl_in_sb, sub_sb."},{"statement":"ctrl' ≡ ⦗R'⦘ ⨾ ctrl'.","conclusion":"ctrl' ≡ ⦗R'⦘ ⨾ ctrl'","hypotheses":"","proofString":"rewrite (sub_ctrl SUB), wf_ctrlD, sub_R; basic_solver 12."},{"statement":"ctrl' ⨾ sb' ⊆ ctrl'.","conclusion":"ctrl' ⨾ sb' ⊆ ctrl'","hypotheses":"","proofString":"rewrite (sub_ctrl SUB), sub_sb.\ngeneralize (ctrl_sb WF); basic_solver 12."},{"statement":"(⦗E'⦘ ⨾ ctrl ⨾ ⦗E'⦘) ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ⊆ ⦗E'⦘ ⨾ ctrl ⨾ ⦗E'⦘.","conclusion":"(⦗E'⦘ ⨾ ctrl ⨾ ⦗E'⦘) ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ⊆ ⦗E'⦘ ⨾ ctrl ⨾ ⦗E'⦘","hypotheses":"","proofString":"generalize (ctrl_sb WF); basic_solver 12."},{"statement":"rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘.","conclusion":"rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_rmw SUB), wf_rmwD, sub_R, sub_W; basic_solver 12."},{"statement":"rmw' ⊆ same_loc'.","conclusion":"rmw' ⊆ same_loc'","hypotheses":"","proofString":"rewrite sub_rmw_in, sub_same_loc; apply WF."},{"statement":"rmw' ⊆ immediate sb'.","conclusion":"rmw' ⊆ immediate sb'","hypotheses":"","proofString":"rewrite (sub_rmw SUB).\nunfolder; ins; desf; splits.\napply sub_sb; generalize (rmw_in_sb WF); basic_solver 12.\nins; eapply  (wf_rmwi WF); eauto; apply (sub_sb_in); edone."},{"statement":"⦗E'⦘ ⨾ rmw ⨾ ⦗E'⦘ ⊆ immediate sb'.","conclusion":"⦗E'⦘ ⨾ rmw ⨾ ⦗E'⦘ ⊆ immediate sb'","hypotheses":"","proofString":"unfolder; ins; desf; splits.\napply sub_sb; generalize (rmw_in_sb WF); basic_solver 12.\nins; eapply  (wf_rmwi WF); eauto; apply (sub_sb_in); edone."},{"statement":"(x y : actid) (H : E' x) (H0 : rmw x y) (H1 : E' y) : sb' x y.","conclusion":"sb' x y","hypotheses":"(x y : actid) (H : E' x) (H0 : rmw x y) (H1 : E' y)","proofString":"apply sub_sb; generalize (rmw_in_sb WF); basic_solver 12."},{"statement":"(x y : actid) (H : E' x) (H0 : rmw x y) (H1 : E' y) : forall c : actid, sb' x c -> sb' c y -> False.","conclusion":"forall c : actid, sb' x c -> sb' c y -> False","hypotheses":"(x y : actid) (H : E' x) (H0 : rmw x y) (H1 : E' y)","proofString":"ins; eapply  (wf_rmwi WF); eauto; apply (sub_sb_in); edone."},{"statement":"rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘.","conclusion":"rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_rf SUB); basic_solver."},{"statement":"rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘.","conclusion":"rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_rf SUB), wf_rfD, sub_R, sub_W; basic_solver 12."},{"statement":"rf' ⊆ same_loc'.","conclusion":"rf' ⊆ same_loc'","hypotheses":"","proofString":"rewrite sub_rf_in, sub_same_loc; apply WF."},{"statement":"funeq val' rf'.","conclusion":"funeq val' rf'","hypotheses":"","proofString":"rewrite sub_val, sub_rf_in; apply WF."},{"statement":"functional rf'⁻¹.","conclusion":"functional rf'⁻¹","hypotheses":"","proofString":"rewrite sub_rf_in; apply WF."},{"statement":"co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘.","conclusion":"co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_co SUB); basic_solver 12."},{"statement":"co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘.","conclusion":"co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_co SUB), wf_coD, sub_W; basic_solver 12."},{"statement":"co' ⊆ same_loc'.","conclusion":"co' ⊆ same_loc'","hypotheses":"","proofString":"rewrite sub_co_in, sub_same_loc; apply WF."},{"statement":"transitive co'.","conclusion":"transitive co'","hypotheses":"","proofString":"rewrite (sub_co SUB), <- restr_relE; apply transitive_restr, WF."},{"statement":"forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co'.","conclusion":"forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co'","hypotheses":"","proofString":"intro ol.\nrewrite (sub_co SUB), sub_W.\nunfolder; ins; eapply (wf_co_total WF) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; [apply sub_E_in| rewrite <- sub_loc]."},{"statement":"(ol : option location) : is_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co'.","conclusion":"is_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co'","hypotheses":"(ol : option location)","proofString":"rewrite (sub_co SUB), sub_W.\nunfolder; ins; eapply (wf_co_total WF) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; [apply sub_E_in| rewrite <- sub_loc]."},{"statement":"(ol : option location) : is_total (E' ∩₁ W ∩₁ (fun x : actid => loc' x = ol)) (⦗E'⦘ ⨾ co ⨾ ⦗E'⦘).","conclusion":"is_total (E' ∩₁ W ∩₁ (fun x : actid => loc' x = ol)) (⦗E'⦘ ⨾ co ⨾ ⦗E'⦘)","hypotheses":"(ol : option location)","proofString":"unfolder; ins; eapply (wf_co_total WF) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; [apply sub_E_in| rewrite <- sub_loc]."},{"statement":"(ol : option location) (a : actid) (IWa : (E' a /\\ is_w lab a) /\\ loc' a = ol) (b : actid) (IWb : (E' b /\\ is_w lab b) /\\ loc' b = ol) (NEQ : co a b \\/ co b a) : E' a /\\ co a b /\\ E' b \\/ E' b /\\ co b a /\\ E' a.","conclusion":"E' a /\\ co a b /\\ E' b \\/ E' b /\\ co b a /\\ E' a","hypotheses":"(ol : option location) (a : actid) (IWa : (E' a /\\ is_w lab a) /\\ loc' a = ol) (b : actid) (IWb : (E' b /\\ is_w lab b) /\\ loc' b = ol) (NEQ : co a b \\/ co b a)","proofString":"by desf; eauto."},{"statement":"irreflexive co'.","conclusion":"irreflexive co'","hypotheses":"","proofString":"rewrite sub_co_in; apply WF."},{"statement":"forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l).","conclusion":"forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l)","hypotheses":"","proofString":"ins; desf.\napply INIT; unfolder; splits; eauto.\napply (wf_init WF); splits; exists b; splits; eauto.\nby apply sub_E_in.\ngeneralize sub_loc; congruence."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : E' (InitEvent l).","conclusion":"E' (InitEvent l)","hypotheses":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l)","proofString":"apply INIT; unfolder; splits; eauto.\napply (wf_init WF); splits; exists b; splits; eauto.\nby apply sub_E_in.\ngeneralize sub_loc; congruence."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : E (InitEvent l).","conclusion":"E (InitEvent l)","hypotheses":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l)","proofString":"apply (wf_init WF); splits; exists b; splits; eauto.\nby apply sub_E_in.\ngeneralize sub_loc; congruence."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : E b.","conclusion":"E b","hypotheses":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l)","proofString":"by apply sub_E_in."},{"statement":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l) : loc b = Some l.","conclusion":"loc b = Some l","hypotheses":"(l : location) (b : actid) (H : E' b) (H0 : loc' b = Some l)","proofString":"generalize sub_loc; congruence."},{"statement":"forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0.","conclusion":"forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0","hypotheses":"","proofString":"ins; rewrite (sub_lab SUB); apply WF."},{"statement":"rmw_dep' ⊆ sb'.","conclusion":"rmw_dep' ⊆ sb'","hypotheses":"","proofString":"by rewrite (sub_frmw SUB), rmw_dep_in_sb, sub_sb."},{"statement":"rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘.","conclusion":"rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_frmw SUB), wf_rmw_depD, sub_R, sub_R_ex; basic_solver 12."},{"statement":"forall e : actid, E' e -> threads_set' (tid e).","conclusion":"forall e : actid, E' e -> threads_set' (tid e)","hypotheses":"","proofString":"ins.\napply sub_threads; auto.\napply WF.\napply sub_E; auto."},{"statement":"(e : actid) (EE : E' e) : threads_set' (tid e).","conclusion":"threads_set' (tid e)","hypotheses":"(e : actid) (EE : E' e)","proofString":"apply sub_threads; auto.\napply WF.\napply sub_E; auto."},{"statement":"(e : actid) (EE : E' e) : threads_set (tid e).","conclusion":"threads_set (tid e)","hypotheses":"(e : actid) (EE : E' e)","proofString":"apply WF.\napply sub_E; auto."},{"statement":"(e : actid) (EE : E' e) : E e.","conclusion":"E e","hypotheses":"(e : actid) (EE : E' e)","proofString":"apply sub_E; auto."},{"statement":"(⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗W ∩₁ Rel⦘\n∪ ⦗W ∩₁ Rel⦘ ⨾ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ∩ same_loc ⨾ ⦗W⦘\n∪ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘\n≡ ⦗E'⦘\n  ⨾ (sb ⨾ ⦗W ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ sb ⨾ ⦗F ∩₁ Acq/Rel⦘\n     ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb) ⨾ ⦗E'⦘.","conclusion":"(⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗W ∩₁ Rel⦘\n∪ ⦗W ∩₁ Rel⦘ ⨾ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ∩ same_loc ⨾ ⦗W⦘\n∪ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘\n≡ ⦗E'⦘\n  ⨾ (sb ⨾ ⦗W ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ sb ⨾ ⦗F ∩₁ Acq/Rel⦘\n     ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb) ⨾ ⦗E'⦘","hypotheses":"","proofString":"basic_solver 21."},{"statement":"⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘ ∪ ⦗R ∩₁ Acq⦘ ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘\n≡ ⦗E'⦘ ⨾ (fwbob ∪ ⦗R ∩₁ Acq⦘ ⨾ sb) ⨾ ⦗E'⦘.","conclusion":"⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘ ∪ ⦗R ∩₁ Acq⦘ ⨾ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘\n≡ ⦗E'⦘ ⨾ (fwbob ∪ ⦗R ∩₁ Acq⦘ ⨾ sb) ⨾ ⦗E'⦘","hypotheses":"","proofString":"basic_solver 21."},{"statement":"⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (rf \\ sb) ⨾ ⦗E'⦘.","conclusion":"⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (rf \\ sb) ⨾ ⦗E'⦘","hypotheses":"","proofString":"split; [basic_solver 15 | unfolder; ins; desf; splits; eauto; intro; desf]."},{"statement":"⦗E'⦘ ⨾ co ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (co \\ sb) ⨾ ⦗E'⦘.","conclusion":"⦗E'⦘ ⨾ co ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (co \\ sb) ⨾ ⦗E'⦘","hypotheses":"","proofString":"split; [basic_solver 15 | unfolder; ins; desf; splits; eauto; intro; desf]."},{"statement":"(coe' ⨾ rfe') ∩ sb' ⊆ (coe ⨾ rfe) ∩ sb.","conclusion":"(coe' ⨾ rfe') ∩ sb' ⊆ (coe ⨾ rfe) ∩ sb","hypotheses":"","proofString":"rewrite sub_sb, sub_coe, sub_rfe_in.\nbasic_solver 21."},{"statement":"((⦗E'⦘ ⨾ coe ⨾ ⦗E'⦘) ⨾ rfe) ∩ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⊆ (coe ⨾ rfe) ∩ sb.","conclusion":"((⦗E'⦘ ⨾ coe ⨾ ⦗E'⦘) ⨾ rfe) ∩ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⊆ (coe ⨾ rfe) ∩ sb","hypotheses":"","proofString":"basic_solver 21."},{"statement":"⦗R'⦘\n⨾ (data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n   ∪ ⦗R_ex'⦘ ⨾ sb')⁺ ⨾ ⦗W'⦘\n⊆ ⦗R⦘\n  ⨾ (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb)⁺\n    ⨾ ⦗W⦘.","conclusion":"⦗R'⦘\n⨾ (data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n   ∪ ⦗R_ex'⦘ ⨾ sb')⁺ ⨾ ⦗W'⦘\n⊆ ⦗R⦘\n  ⨾ (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb)⁺\n    ⨾ ⦗W⦘","hypotheses":"","proofString":"rewrite sub_W, sub_R.\nhahn_frame; apply inclusion_t_t.\napply union_mori.\nrewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12.\nrewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"⦗R⦘\n⨾ (data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n   ∪ ⦗R_ex'⦘ ⨾ sb')⁺ ⨾ ⦗W⦘\n⊆ ⦗R⦘\n  ⨾ (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb)⁺\n    ⨾ ⦗W⦘.","conclusion":"⦗R⦘\n⨾ (data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n   ∪ ⦗R_ex'⦘ ⨾ sb')⁺ ⨾ ⦗W⦘\n⊆ ⦗R⦘\n  ⨾ (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb)⁺\n    ⨾ ⦗W⦘","hypotheses":"","proofString":"hahn_frame; apply inclusion_t_t.\napply union_mori.\nrewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12.\nrewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n∪ ⦗R_ex'⦘ ⨾ sb'\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb.","conclusion":"data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n∪ ⦗R_ex'⦘ ⨾ sb'\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb","hypotheses":"","proofString":"apply union_mori.\nrewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12.\nrewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","conclusion":"data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rfi' ∪ rmw' ∪ rmw_dep' ⨾ sb'^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?","hypotheses":"","proofString":"rewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12."},{"statement":"data' ∪ ctrl' ∪ addr' ⨾ sb^? ∪ rfi ∪ rmw' ∪ rmw_dep' ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","conclusion":"data' ∪ ctrl' ∪ addr' ⨾ sb^? ∪ rfi ∪ rmw' ∪ rmw_dep' ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?","hypotheses":"","proofString":"rewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12."},{"statement":"data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw' ∪ rmw_dep ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","conclusion":"data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw' ∪ rmw_dep ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?","hypotheses":"","proofString":"rewrite sub_rmw_in at 1.\nbasic_solver 12."},{"statement":"data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?.","conclusion":"data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?\n⊆ data ∪ ctrl ∪ addr ⨾ sb^? ∪ rfi ∪ rmw ∪ rmw_dep ⨾ sb^?","hypotheses":"","proofString":"basic_solver 12."},{"statement":"⦗R_ex'⦘ ⨾ sb' ⊆ ⦗R_ex⦘ ⨾ sb.","conclusion":"⦗R_ex'⦘ ⨾ sb' ⊆ ⦗R_ex⦘ ⨾ sb","hypotheses":"","proofString":"rewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"⦗R_ex'⦘ ⨾ ⦗E'⦘ ⨾ sb' ⊆ ⦗R_ex⦘ ⨾ sb.","conclusion":"⦗R_ex'⦘ ⨾ ⦗E'⦘ ⨾ sb' ⊆ ⦗R_ex⦘ ⨾ sb","hypotheses":"","proofString":"rewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf."},{"statement":"⦗R_ex⦘ ⨾ ⦗E'⦘ ⨾ sb ⊆ ⦗R_ex⦘ ⨾ sb.","conclusion":"⦗R_ex⦘ ⨾ ⦗E'⦘ ⨾ sb ⊆ ⦗R_ex⦘ ⨾ sb","hypotheses":"","proofString":"unfolder.\nins.\ndesf."},{"statement":"rf'⁻¹ ⨾ co' ⊆ rf⁻¹ ⨾ co.","conclusion":"rf'⁻¹ ⨾ co' ⊆ rf⁻¹ ⨾ co","hypotheses":"","proofString":"by rewrite sub_rf_in, sub_co_in."},{"statement":"⦗E'⦘ ⨾ fre' ⨾ ⦗E'⦘ ⊆ fre.","conclusion":"⦗E'⦘ ⨾ fre' ⨾ ⦗E'⦘ ⊆ fre","hypotheses":"","proofString":"ie_unfolder.\nrewrite sub_fr_in, sub_sb.\nbasic_solver 21."},{"statement":"⦗E'⦘ ⨾ (fr' \\ sb') ⨾ ⦗E'⦘ ⊆ fr \\ sb.","conclusion":"⦗E'⦘ ⨾ (fr' \\ sb') ⨾ ⦗E'⦘ ⊆ fr \\ sb","hypotheses":"","proofString":"rewrite sub_fr_in, sub_sb.\nbasic_solver 21."},{"statement":"⦗E'⦘ ⨾ (fr \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗E'⦘ ⊆ fr \\ sb.","conclusion":"⦗E'⦘ ⨾ (fr \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ⨾ ⦗E'⦘ ⊆ fr \\ sb","hypotheses":"","proofString":"basic_solver 21."},{"statement":"rf' ∪ co' ⨾ rf'^? ∪ fr' ⨾ rf'^? ⊆ rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?.","conclusion":"rf' ∪ co' ⨾ rf'^? ∪ fr' ⨾ rf'^? ⊆ rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?","hypotheses":"","proofString":"rewrite sub_rf_in, sub_co_in, sub_fr_in.\nbasic_solver 21."},{"statement":"rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^? ⊆ rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?.","conclusion":"rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^? ⊆ rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?","hypotheses":"","proofString":"basic_solver 21."},{"statement":"⦗W'⦘ ⨾ (sb' ∩ same_loc')^? ⨾ ⦗W'⦘ ⨾ (rf' ⨾ rmw')＊\n⊆ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw)＊.","conclusion":"⦗W'⦘ ⨾ (sb' ∩ same_loc')^? ⨾ ⦗W'⦘ ⨾ (rf' ⨾ rmw')＊\n⊆ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw)＊","hypotheses":"","proofString":"by rewrite sub_rf_in, sub_rmw_in, sub_sb_in, sub_same_loc, sub_W."},{"statement":"⦗Rel'⦘ ⨾ (⦗F'⦘ ⨾ sb')^? ⨾ rs' ⊆ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","conclusion":"⦗Rel'⦘ ⨾ (⦗F'⦘ ⨾ sb')^? ⨾ rs' ⊆ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs","hypotheses":"","proofString":"by rewrite sub_sb_in, sub_rs_in, sub_F, sub_Rel."},{"statement":"release' ⨾ rf' ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘\n⊆ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘.","conclusion":"release' ⨾ rf' ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘\n⊆ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘","hypotheses":"","proofString":"by rewrite sub_sb_in, sub_release_in, sub_rf_in, sub_F, sub_Acq."},{"statement":"(sb' ∪ sw')⁺ ⊆ (sb ∪ sw)⁺.","conclusion":"(sb' ∪ sw')⁺ ⊆ (sb ∪ sw)⁺","hypotheses":"","proofString":"by rewrite sub_sb_in, sub_sw_in."},{"statement":"bob' ∪ ppo' ∪ detour' ∪ ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘\n∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","conclusion":"bob' ∪ ppo' ∪ detour' ∪ ⦗W_ex_acq'⦘ ⨾ sb' ⨾ ⦗W'⦘\n∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘","hypotheses":"","proofString":"rewrite sub_bob_in, sub_ppo_in, sub_detour_in, sub_sb_in.\nrewrite sub_W_ex_acq_in, sub_W.\nrewrite sub_W_ex_in, sub_rfi_in.\nrewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq'⦘ ⨾ sb ⨾ ⦗W'⦘ ∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","conclusion":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq'⦘ ⨾ sb ⨾ ⦗W'⦘ ∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘","hypotheses":"","proofString":"rewrite sub_W_ex_acq_in, sub_W.\nrewrite sub_W_ex_in, sub_rfi_in.\nrewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","conclusion":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex'⦘ ⨾ rfi' ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘","hypotheses":"","proofString":"rewrite sub_W_ex_in, sub_rfi_in.\nrewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","conclusion":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R' ∩₁ Acq'⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘","hypotheses":"","proofString":"rewrite sub_R, sub_Acq.\ndone."},{"statement":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘.","conclusion":"bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘\n⊆ bob ∪ ppo ∪ detour ∪ ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ex⦘ ⨾ rfi ⨾ ⦗R ∩₁ Acq⦘","hypotheses":"","proofString":"done."},{"statement":"sc' ∪ rfe' ∪ ar_int' ⊆ sc ∪ rfe ∪ ar_int.","conclusion":"sc' ∪ rfe' ∪ ar_int' ⊆ sc ∪ rfe ∪ ar_int","hypotheses":"","proofString":"by rewrite sub_sc_in, sub_rfe_in, sub_ar_int_in."},{"statement":"(l : location) : ⦗W'_ l⦘ ⨾ rf'^? ⨾ (hb' ⨾ ⦗F' ∩₁ Sc'⦘)^? ⨾ sc'^? ⨾ hb'^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?.","conclusion":"⦗W'_ l⦘ ⨾ rf'^? ⨾ (hb' ⨾ ⦗F' ∩₁ Sc'⦘)^? ⨾ sc'^? ⨾ hb'^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?","hypotheses":"(l : location)","proofString":"by rewrite sub_rf_in, sub_hb_in, (sub_W_ l), sub_F, sub_Sc, sub_sc_in."},{"statement":"(fun x y : actid => exists l : location, urr' l x y)\n⊆ (fun x y : actid => exists l : location, urr l x y).","conclusion":"(fun x y : actid => exists l : location, urr' l x y)\n⊆ (fun x y : actid => exists l : location, urr l x y)","hypotheses":"","proofString":"unfolder; ins; desf; eexists; apply sub_urr_in; eauto."},{"statement":"(⋃₁t ∈ threads_set' \\₁ eq tid_init, eq (ta_propagate t))\n≡₁ (⋃₁t ∈ threads_set \\₁ eq tid_init, eq (ta_propagate t)).","conclusion":"(⋃₁t ∈ threads_set' \\₁ eq tid_init, eq (ta_propagate t))\n≡₁ (⋃₁t ∈ threads_set \\₁ eq tid_init, eq (ta_propagate t))","hypotheses":"","proofString":"now rewrite sub_threads."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc')⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc')⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘","hypotheses":"","proofString":"hahn_frame; apply map_rel_mori; auto.\ntry apply clos_trans_mori.\nrewrite sub_sc, sub_E; auto using SUB.\nclear; basic_solver."},{"statement":"(⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc')⁺ ⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc)⁺.","conclusion":"(⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc')⁺ ⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc)⁺","hypotheses":"","proofString":"try apply clos_trans_mori.\nrewrite sub_sc, sub_E; auto using SUB.\nclear; basic_solver."},{"statement":"⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc' ⊆ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc.","conclusion":"⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ∪ sc' ⊆ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc","hypotheses":"","proofString":"rewrite sub_sc, sub_E; auto using SUB.\nclear; basic_solver."},{"statement":"⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘ ⊆ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc.","conclusion":"⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ ⦗E⦘ ⨾ sc ⨾ ⦗E⦘ ⊆ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ sc","hypotheses":"","proofString":"clear; basic_solver."},{"statement":"⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W'⦘ ⨾ rf'^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W'⦘ ⨾ rf'^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘","hypotheses":"","proofString":"hahn_frame; apply map_rel_mori; auto.\ntry apply clos_trans_mori.\nrewrite sub_rf, sub_W; auto using SUB.\nclear; basic_solver."},{"statement":"⦗W'⦘ ⨾ rf'^? ⊆ ⦗W⦘ ⨾ rf^?.","conclusion":"⦗W'⦘ ⨾ rf'^? ⊆ ⦗W⦘ ⨾ rf^?","hypotheses":"","proofString":"try apply clos_trans_mori.\nrewrite sub_rf, sub_W; auto using SUB.\nclear; basic_solver."},{"statement":"⦗W'⦘ ⨾ rf'^? ⊆ ⦗W⦘ ⨾ rf^?.","conclusion":"⦗W'⦘ ⨾ rf'^? ⊆ ⦗W⦘ ⨾ rf^?","hypotheses":"","proofString":"rewrite sub_rf, sub_W; auto using SUB.\nclear; basic_solver."},{"statement":"⦗W⦘ ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^? ⊆ ⦗W⦘ ⨾ rf^?.","conclusion":"⦗W⦘ ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^? ⊆ ⦗W⦘ ⨾ rf^?","hypotheses":"","proofString":"clear; basic_solver."},{"statement":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob' ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob' ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"","proofString":"rewrite sub_fwbob; eauto using SUB; ins.\nrewrite sub_W; eauto using SUB; ins.\nclear; basic_solver 20."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ((⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘) ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ((⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘) ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"","proofString":"rewrite sub_W; eauto using SUB; ins.\nclear; basic_solver 20."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ((⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘) ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ((⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘) ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"","proofString":"clear; basic_solver 20."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W'⦘ ⨾ (ar' sc' ∪ rf' ⨾ ppo' ∩ same_loc')⁺ ⨾ ⦗W'⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W'⦘ ⨾ (ar' sc' ∪ rf' ⨾ ppo' ∩ same_loc')⁺ ⨾ ⦗W'⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"","proofString":"rewrite sub_ar_in, sub_ppo_in, sub_rf, sub_W; eauto using SUB.\nrewrite sub_same_loc; eauto using SUB.\nrepeat (apply seq_mori; try easy).\napply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc')⁺ ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc')⁺ ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"","proofString":"rewrite sub_same_loc; eauto using SUB.\nrepeat (apply seq_mori; try easy).\napply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"","proofString":"repeat (apply seq_mori; try easy).\napply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","conclusion":"event ↓ (⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)","hypotheses":"","proofString":"apply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘.","conclusion":"⦗W⦘ ⨾ (ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗W⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘","hypotheses":"","proofString":"repeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"(ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺\n⊆ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"(ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc)⁺\n⊆ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"","proofString":"apply clos_trans_mori.\nclear; basic_solver 10."},{"statement":"ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc ⊆ ar sc ∪ rf ⨾ ppo ∩ same_loc.","conclusion":"ar sc ∪ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘) ⨾ ppo ∩ same_loc ⊆ ar sc ∪ rf ⨾ ppo ∩ same_loc","hypotheses":"","proofString":"clear; basic_solver 10."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (eq ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G'⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (eq ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G'⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘","hypotheses":"","proofString":"rewrite sub_is_ta_propagate_to_G.\nnow rewrite sub_W; eauto using SUB."},{"statement":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (eq ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (eq ⨾ ⦗W'⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘","hypotheses":"","proofString":"now rewrite sub_W; eauto using SUB."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G'⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G'⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘","hypotheses":"","proofString":"rewrite sub_is_ta_propagate_to_G.\nrepeat (apply seq_mori; try easy).\napply inter_rel_mori; try easy.\napply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘","hypotheses":"","proofString":"repeat (apply seq_mori; try easy).\napply inter_rel_mori; try easy.\napply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n∩ (fun ta1 ta2 : trav_label =>\n   tid (event ta1) = ta_propagate_tid (action ta2))\n⊆ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2)).","conclusion":"event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘)\n∩ (fun ta1 ta2 : trav_label =>\n   tid (event ta1) = ta_propagate_tid (action ta2))\n⊆ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))","hypotheses":"","proofString":"apply inter_rel_mori; try easy.\napply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘) ⊆ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘).","conclusion":"event ↓ (fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘) ⊆ event ↓ (fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘)","hypotheses":"","proofString":"apply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘ ⊆ fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘.","conclusion":"fr'^? ⨾ furr' ⨾ co'^? ⨾ ⦗W'⦘ ⊆ fr^? ⨾ furr ⨾ co^? ⨾ ⦗W⦘","hypotheses":"","proofString":"by rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W."},{"statement":"restr_rel (event ↓₁ (E' \\₁ (fun a : actid => is_init a)))\n  (SB G' sc' ∪ RF G' ∪ FWBOB G' ∪ AR G' sc' ∪ IPROP G' ∪ PROP G' sc')\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc).","conclusion":"restr_rel (event ↓₁ (E' \\₁ (fun a : actid => is_init a)))\n  (SB G' sc' ∪ RF G' ∪ FWBOB G' ∪ AR G' sc' ∪ IPROP G' ∪ PROP G' sc')\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc)","hypotheses":"","proofString":"apply restr_rel_mori.\nrewrite sub_E; eauto using SUB.\nrewrite sub_SB, sub_RF, sub_FWBOB, sub_AR, sub_IPROP, sub_PROP.\neasy."},{"statement":"event ↓₁ (E' \\₁ (fun a : actid => is_init a))\n⊆₁ event ↓₁ (E \\₁ (fun a : actid => is_init a)).","conclusion":"event ↓₁ (E' \\₁ (fun a : actid => is_init a))\n⊆₁ event ↓₁ (E \\₁ (fun a : actid => is_init a))","hypotheses":"","proofString":"rewrite sub_E; eauto using SUB."},{"statement":"SB G' sc' ∪ RF G' ∪ FWBOB G' ∪ AR G' sc' ∪ IPROP G' ∪ PROP G' sc'\n⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc.","conclusion":"SB G' sc' ∪ RF G' ∪ FWBOB G' ∪ AR G' sc' ∪ IPROP G' ∪ PROP G' sc'\n⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc","hypotheses":"","proofString":"rewrite sub_SB, sub_RF, sub_FWBOB, sub_AR, sub_IPROP, sub_PROP.\neasy."},{"statement":"SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc\n⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc.","conclusion":"SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc\n⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc","hypotheses":"","proofString":"easy."},{"statement":"sc' ≡ ⦗E'⦘ ⨾ sc' ⨾ ⦗E'⦘.","conclusion":"sc' ≡ ⦗E'⦘ ⨾ sc' ⨾ ⦗E'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_sc SUB); basic_solver."},{"statement":"sc' ≡ ⦗F' ∩₁ Sc'⦘ ⨾ sc' ⨾ ⦗F' ∩₁ Sc'⦘.","conclusion":"sc' ≡ ⦗F' ∩₁ Sc'⦘ ⨾ sc' ⨾ ⦗F' ∩₁ Sc'⦘","hypotheses":"","proofString":"apply dom_helper_3; rewrite (sub_sc SUB), (wf_scD WF_SC).\nrewrite sub_F, sub_Sc; basic_solver 12."},{"statement":"⦗E'⦘ ⨾ (⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ ⦗E'⦘ ⊆ (F' ∩₁ Sc') × (F' ∩₁ Sc').","conclusion":"⦗E'⦘ ⨾ (⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ ⦗E'⦘ ⊆ (F' ∩₁ Sc') × (F' ∩₁ Sc')","hypotheses":"","proofString":"rewrite sub_F, sub_Sc; basic_solver 12."},{"statement":"transitive sc'.","conclusion":"transitive sc'","hypotheses":"","proofString":"rewrite (sub_sc SUB), <- restr_relE; apply transitive_restr, WF_SC."},{"statement":"is_total (E' ∩₁ F' ∩₁ Sc') sc'.","conclusion":"is_total (E' ∩₁ F' ∩₁ Sc') sc'","hypotheses":"","proofString":"rewrite (sub_sc SUB), sub_F, sub_Sc.\nunfolder; ins; eapply (wf_sc_total WF_SC) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"is_total (E' ∩₁ F ∩₁ Sc) (⦗E'⦘ ⨾ sc ⨾ ⦗E'⦘).","conclusion":"is_total (E' ∩₁ F ∩₁ Sc) (⦗E'⦘ ⨾ sc ⨾ ⦗E'⦘)","hypotheses":"","proofString":"unfolder; ins; eapply (wf_sc_total WF_SC) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : sc a b \\/ sc b a) : E' a /\\ sc a b /\\ E' b \\/ E' b /\\ sc b a /\\ E' a.","conclusion":"E' a /\\ sc a b /\\ E' b \\/ E' b /\\ sc b a /\\ E' a","hypotheses":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : sc a b \\/ sc b a)","proofString":"by desf; eauto."},{"statement":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : a <> b) : (E ∩₁ F ∩₁ Sc) a.","conclusion":"(E ∩₁ F ∩₁ Sc) a","hypotheses":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : a <> b)","proofString":"by unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : a <> b) : (E ∩₁ F ∩₁ Sc) b.","conclusion":"(E ∩₁ F ∩₁ Sc) b","hypotheses":"(a : actid) (IWa : (E' a /\\ is_f lab a) /\\ is_sc lab a) (b : actid) (IWb : (E' b /\\ is_f lab b) /\\ is_sc lab b) (NEQ : a <> b)","proofString":"by unfolder; desf; splits; auto; apply sub_E_in."},{"statement":"irreflexive sc'.","conclusion":"irreflexive sc'","hypotheses":"","proofString":"rewrite sub_sc_in; apply WF_SC."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : (coe' ⨾ (rf' \\ sb')) ∩ sb' ≡ ⦗E'⦘ ⨾ (coe ⨾ (rf \\ sb)) ∩ sb ⨾ ⦗E'⦘.","conclusion":"(coe' ⨾ (rf' \\ sb')) ∩ sb' ≡ ⦗E'⦘ ⨾ (coe ⨾ (rf \\ sb)) ∩ sb ⨾ ⦗E'⦘","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E')","proofString":"rewrite sub_sb, sub_coe, (sub_rf SUB).\nunfolder in RF_A; unfolder; splits; ins; desf; eauto 20.\nsplits; eauto 20.\nexists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : ((⦗E'⦘ ⨾ coe ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘))\n∩ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ≡ ⦗E'⦘ ⨾ (coe ⨾ (rf \\ sb)) ∩ sb ⨾ ⦗E'⦘.","conclusion":"((⦗E'⦘ ⨾ coe ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘))\n∩ (⦗E'⦘ ⨾ sb ⨾ ⦗E'⦘) ≡ ⦗E'⦘ ⨾ (coe ⨾ (rf \\ sb)) ∩ sb ⨾ ⦗E'⦘","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E')","proofString":"unfolder in RF_A; unfolder; splits; ins; desf; eauto 20.\nsplits; eauto 20.\nexists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : (E' x /\\\n (exists z0 : actid,\n    coe x z0 /\\\n    (exists z1 : actid,\n       (z0 = z1 /\\ E' z0) /\\\n       (E' z1 /\\ rf z1 y /\\ E' y) /\\ ~ (E' z1 /\\ sb z1 y /\\ E' y)))) /\\\nE' x /\\ sb x y /\\ E' y.","conclusion":"(E' x /\\\n (exists z0 : actid,\n    coe x z0 /\\\n    (exists z1 : actid,\n       (z0 = z1 /\\ E' z0) /\\\n       (E' z1 /\\ rf z1 y /\\ E' y) /\\ ~ (E' z1 /\\ sb z1 y /\\ E' y)))) /\\\nE' x /\\ sb x y /\\ E' y","hypotheses":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y)","proofString":"splits; eauto 20.\nexists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : exists z0 : actid,\n  coe x z0 /\\\n  (exists z1 : actid,\n     (z0 = z1 /\\ E' z0) /\\\n     (E' z1 /\\ rf z1 y /\\ E' y) /\\ ~ (E' z1 /\\ sb z1 y /\\ E' y)).","conclusion":"exists z0 : actid,\n  coe x z0 /\\\n  (exists z1 : actid,\n     (z0 = z1 /\\ E' z0) /\\\n     (E' z1 /\\ rf z1 y /\\ E' y) /\\ ~ (E' z1 /\\ sb z1 y /\\ E' y))","hypotheses":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y)","proofString":"exists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : exists z0 : actid,\n  (z = z0 /\\ E' z) /\\\n  (E' z0 /\\ rf z0 y /\\ E' y) /\\ ~ (E' z0 /\\ sb z0 y /\\ E' y).","conclusion":"exists z0 : actid,\n  (z = z0 /\\ E' z) /\\\n  (E' z0 /\\ rf z0 y /\\ E' y) /\\ ~ (E' z0 /\\ sb z0 y /\\ E' y)","hypotheses":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y)","proofString":"exists z; splits; eauto 20.\nintro; desf."},{"statement":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y) : ~ (E' z /\\ sb z y /\\ E' y).","conclusion":"~ (E' z /\\ sb z y /\\ E' y)","hypotheses":"(RF_A : forall x0 : actid, (exists y0 : actid, rf x0 y0 /\\ E' y0) -> E' x0) (x y : actid) (H : E' x) (z : actid) (H0 : coe x z) (H3 : rf z y) (H4 : ~ sb z y) (H2 : sb x y) (H1 : E' y)","proofString":"intro; desf."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : rf'⁻¹ ⨾ co' ≡ ⦗E'⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E'⦘.","conclusion":"rf'⁻¹ ⨾ co' ≡ ⦗E'⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E'⦘","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E')","proofString":"rewrite (sub_rf SUB), (sub_co SUB).\nunfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)⁻¹ ⨾ ⦗E'⦘ ⨾ co ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E'⦘.","conclusion":"(⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)⁻¹ ⨾ ⦗E'⦘ ⨾ co ⨾ ⦗E'⦘ ≡ ⦗E'⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E'⦘","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E')","proofString":"unfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : rf' ∪ co' ⨾ rf'^? ∪ fr' ⨾ rf'^? ≡ ⦗E'⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E'⦘.","conclusion":"rf' ∪ co' ⨾ rf'^? ∪ fr' ⨾ rf'^? ≡ ⦗E'⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E'⦘","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E')","proofString":"rewrite (sub_rf SUB), (sub_co SUB), (sub_fr RF_A).\nunfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') : ⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ ∪ (⦗E'⦘ ⨾ co ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^?\n∪ (⦗E'⦘ ⨾ fr ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^?\n≡ ⦗E'⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E'⦘.","conclusion":"⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘ ∪ (⦗E'⦘ ⨾ co ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^?\n∪ (⦗E'⦘ ⨾ fr ⨾ ⦗E'⦘) ⨾ (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)^?\n≡ ⦗E'⦘ ⨾ (rf ∪ co ⨾ rf^? ∪ fr ⨾ rf^?) ⨾ ⦗E'⦘","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E')","proofString":"unfolder in RF_A; basic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) : E' ∩₁ R ⊆₁ codom_rel (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘).","conclusion":"E' ∩₁ R ⊆₁ codom_rel (⦗E'⦘ ⨾ rf ⨾ ⦗E'⦘)","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G)","proofString":"unfolder; ins.\nedestruct (COMP x); eauto.\ngeneralize sub_E_in; basic_solver.\nunfolder; ins; desf.\ngeneralize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x) : exists x0 : actid, E' x0 /\\ rf x0 x /\\ E' x.","conclusion":"exists x0 : actid, E' x0 /\\ rf x0 x /\\ E' x","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x)","proofString":"edestruct (COMP x); eauto.\ngeneralize sub_E_in; basic_solver.\nunfolder; ins; desf.\ngeneralize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x) : (E ∩₁ R) x.","conclusion":"(E ∩₁ R) x","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x)","proofString":"generalize sub_E_in; basic_solver."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x) (x0 : actid) (H0 : rf x0 x) : exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","conclusion":"exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x /\\ is_r lab x) (x0 : actid) (H0 : rf x0 x)","proofString":"unfolder; ins; desf.\ngeneralize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x) : exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","conclusion":"exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x)","proofString":"generalize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21."},{"statement":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x) : E' ⊆₁ E -> exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","conclusion":"E' ⊆₁ E -> exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x","hypotheses":"(RF_A : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E') (COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x)","proofString":"revert RF_A.\nbasic_solver 21."},{"statement":"(COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x) : dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E' ->\nE' ⊆₁ E -> exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x.","conclusion":"dom_rel (rf ⨾ ⦗E'⦘) ⊆₁ E' ->\nE' ⊆₁ E -> exists x1 : actid, E' x1 /\\ rf x1 x /\\ E' x","hypotheses":"(COMP : complete G) (x : actid) (H : E' x) (H1 : is_r lab x) (x0 : actid) (H0 : rf x0 x)","proofString":"basic_solver 21."},{"statement":"(G : execution) (D : actid -> Prop) (IN : forall x0 : actid, D x0 -> acts_set G x0) (x : actid) (H : (D ∩₁ acts_set G) x) : D x.","conclusion":"D x","hypotheses":"(G : execution) (D : actid -> Prop) (IN : forall x0 : actid, D x0 -> acts_set G x0) (x : actid) (H : (D ∩₁ acts_set G) x)","proofString":"apply H."},{"statement":"(G : execution) (D : actid -> Prop) (IN : forall x0 : actid, D x0 -> acts_set G x0) (x : actid) (H : D x) : (D ∩₁ acts_set G) x.","conclusion":"(D ∩₁ acts_set G) x","hypotheses":"(G : execution) (D : actid -> Prop) (IN : forall x0 : actid, D x0 -> acts_set G x0) (x : actid) (H : D x)","proofString":"split; auto."},{"statement":"(G : execution) : acts_set G\n≡₁ (⋃₁t,\n     acts_set\n       {|\n         acts_set := Tid_ t ∩₁ acts_set G;\n         threads_set := threads_set G;\n         lab := lab G;\n         rmw := ⦗Tid_ t⦘ ⨾ rmw G ⨾ ⦗Tid_ t⦘;\n         data := ⦗Tid_ t⦘ ⨾ data G ⨾ ⦗Tid_ t⦘;\n         addr := ⦗Tid_ t⦘ ⨾ addr G ⨾ ⦗Tid_ t⦘;\n         ctrl := ⦗Tid_ t⦘ ⨾ ctrl G ⨾ ⦗Tid_ t⦘;\n         rmw_dep := ⦗Tid_ t⦘ ⨾ rmw_dep G ⨾ ⦗Tid_ t⦘;\n         rf := ⦗Tid_ t⦘ ⨾ rf G ⨾ ⦗Tid_ t⦘;\n         co := ⦗Tid_ t⦘ ⨾ co G ⨾ ⦗Tid_ t⦘\n       |}).","conclusion":"acts_set G\n≡₁ (⋃₁t,\n     acts_set\n       {|\n         acts_set := Tid_ t ∩₁ acts_set G;\n         threads_set := threads_set G;\n         lab := lab G;\n         rmw := ⦗Tid_ t⦘ ⨾ rmw G ⨾ ⦗Tid_ t⦘;\n         data := ⦗Tid_ t⦘ ⨾ data G ⨾ ⦗Tid_ t⦘;\n         addr := ⦗Tid_ t⦘ ⨾ addr G ⨾ ⦗Tid_ t⦘;\n         ctrl := ⦗Tid_ t⦘ ⨾ ctrl G ⨾ ⦗Tid_ t⦘;\n         rmw_dep := ⦗Tid_ t⦘ ⨾ rmw_dep G ⨾ ⦗Tid_ t⦘;\n         rf := ⦗Tid_ t⦘ ⨾ rf G ⨾ ⦗Tid_ t⦘;\n         co := ⦗Tid_ t⦘ ⨾ co G ⨾ ⦗Tid_ t⦘\n       |})","hypotheses":"(G : execution)","proofString":"simpl.\nrewrite set_bunion_inter_compat_r, set_interC, <- set_bunion_inter_compat_l.\napply set_bunion_separation."},{"statement":"(G : execution) : acts_set G ≡₁ (⋃₁t, Tid_ t ∩₁ acts_set G).","conclusion":"acts_set G ≡₁ (⋃₁t, Tid_ t ∩₁ acts_set G)","hypotheses":"(G : execution)","proofString":"rewrite set_bunion_inter_compat_r, set_interC, <- set_bunion_inter_compat_l.\napply set_bunion_separation."},{"statement":"(G : execution) : acts_set G ≡₁ (⋃₁x, acts_set G ∩₁ Tid_ x).","conclusion":"acts_set G ≡₁ (⋃₁x, acts_set G ∩₁ Tid_ x)","hypotheses":"(G : execution)","proofString":"apply set_bunion_separation."},{"statement":"(G : execution) (b : thread_id) (TB : threads_bound G b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (IN : exists y : BinNums.positive,\n  ~ BinPos.Pos.lt y b /\\ (tid x = y /\\ acts_set G x) /\\ ~ is_init x) : False.","conclusion":"False","hypotheses":"(G : execution) (b : thread_id) (TB : threads_bound G b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (IN : exists y : BinNums.positive,\n  ~ BinPos.Pos.lt y b /\\ (tid x = y /\\ acts_set G x) /\\ ~ is_init x)","proofString":"desc.\nred in TB.\napply TB in IN2.\ncongruence."},{"statement":"(G : execution) (b : thread_id) (TB : threads_bound G b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : acts_set G x) (IN1 : ~ is_init x) : False.","conclusion":"False","hypotheses":"(G : execution) (b : thread_id) (TB : threads_bound G b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : acts_set G x) (IN1 : ~ is_init x)","proofString":"red in TB.\napply TB in IN2.\ncongruence."},{"statement":"(G : execution) (b : thread_id) (TB : forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : acts_set G x) (IN1 : ~ is_init x) : False.","conclusion":"False","hypotheses":"(G : execution) (b : thread_id) (TB : forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : acts_set G x) (IN1 : ~ is_init x)","proofString":"apply TB in IN2.\ncongruence."},{"statement":"(G : execution) (b : thread_id) (TB : forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : BinPos.Pos.lt (tid x) b) (IN1 : ~ is_init x) : False.","conclusion":"False","hypotheses":"(G : execution) (b : thread_id) (TB : forall e : actid, acts_set G e -> BinPos.Pos.lt (tid e) b) (FIN_B : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)) (x : actid) (y : BinNums.positive) (IN : ~ BinPos.Pos.lt y b) (IN0 : tid x = y) (IN2 : BinPos.Pos.lt (tid x) b) (IN1 : ~ is_init x)","proofString":"congruence."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (FIN_THREADS : exists b : thread_id, threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) : fin_exec G.","conclusion":"fin_exec G","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (FIN_THREADS : exists b : thread_id, threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t))","proofString":"desf.\neapply fin_exec_bounded_threads; eauto.\nins.\ndestruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) : fin_exec G.","conclusion":"fin_exec G","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t))","proofString":"eapply fin_exec_bounded_threads; eauto.\nins.\ndestruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) : forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t).","conclusion":"forall t : BinNums.positive,\nBinPos.Pos.lt t b -> fin_exec (restrict G Tid_ t)","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t))","proofString":"ins.\ndestruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) : fin_exec (restrict G Tid_ t).","conclusion":"fin_exec (restrict G Tid_ t)","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b)","proofString":"destruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) : fin_exec (restrict G Tid_ t).","conclusion":"fin_exec (restrict G Tid_ t)","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False)","proofString":"red.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) : set_finite (acts_set (restrict G Tid_ t) \\₁ (fun a : actid => is_init a)).","conclusion":"set_finite (acts_set (restrict G Tid_ t) \\₁ (fun a : actid => is_init a))","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False)","proofString":"exists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x) : False.","conclusion":"False","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x)","proofString":"exfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x) : False.","conclusion":"False","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x)","proofString":"apply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x) : threads_set G t.","conclusion":"threads_set G t","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (Tid_ t ∩₁ acts_set G \\₁ (fun a : actid => is_init a)) x)","proofString":"unfolder in IN.\ndesf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (tid x = t /\\ acts_set G x) /\\ ~ is_init x) : threads_set G t.","conclusion":"threads_set G t","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t0 : thread_id, threads_set G t0 -> fin_exec (restrict G Tid_ t0)) (t : BinNums.positive) (LTB : BinPos.Pos.lt t b) (NTS : threads_set G t -> False) (x : actid) (IN : (tid x = t /\\ acts_set G x) /\\ ~ is_init x)","proofString":"desf.\nnow apply ACTS."},{"statement":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) (x : actid) (NTS : threads_set G (tid x) -> False) (LTB : BinPos.Pos.lt (tid x) b) (IN1 : acts_set G x) (IN0 : ~ is_init x) : threads_set G (tid x).","conclusion":"threads_set G (tid x)","hypotheses":"(G : execution) (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e)) (b : thread_id) (FIN_THREADS : threads_bound G b) (FIN_B : forall t : thread_id, threads_set G t -> fin_exec (restrict G Tid_ t)) (x : actid) (NTS : threads_set G (tid x) -> False) (LTB : BinPos.Pos.lt (tid x) b) (IN1 : acts_set G x) (IN0 : ~ is_init x)","proofString":"now apply ACTS."},{"statement":"(G : execution) (S : actid -> Prop) (FAIR : mem_fair G) : fsupp\n  (co\n     {|\n       acts_set := S ∩₁ acts_set G;\n       threads_set := threads_set G;\n       lab := lab G;\n       rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n       data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n       addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n       ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n       rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n       rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n       co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n     |}) /\\\nfsupp\n  ((rf\n      {|\n        acts_set := S ∩₁ acts_set G;\n        threads_set := threads_set G;\n        lab := lab G;\n        rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n        data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n        addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n        ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n        rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n        rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n        co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n      |})⁻¹\n   ⨾ co\n       {|\n         acts_set := S ∩₁ acts_set G;\n         threads_set := threads_set G;\n         lab := lab G;\n         rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n         data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n         addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n         ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n         rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n         rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n         co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n       |}).","conclusion":"fsupp\n  (co\n     {|\n       acts_set := S ∩₁ acts_set G;\n       threads_set := threads_set G;\n       lab := lab G;\n       rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n       data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n       addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n       ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n       rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n       rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n       co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n     |}) /\\\nfsupp\n  ((rf\n      {|\n        acts_set := S ∩₁ acts_set G;\n        threads_set := threads_set G;\n        lab := lab G;\n        rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n        data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n        addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n        ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n        rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n        rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n        co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n      |})⁻¹\n   ⨾ co\n       {|\n         acts_set := S ∩₁ acts_set G;\n         threads_set := threads_set G;\n         lab := lab G;\n         rmw := ⦗S⦘ ⨾ rmw G ⨾ ⦗S⦘;\n         data := ⦗S⦘ ⨾ data G ⨾ ⦗S⦘;\n         addr := ⦗S⦘ ⨾ addr G ⨾ ⦗S⦘;\n         ctrl := ⦗S⦘ ⨾ ctrl G ⨾ ⦗S⦘;\n         rmw_dep := ⦗S⦘ ⨾ rmw_dep G ⨾ ⦗S⦘;\n         rf := ⦗S⦘ ⨾ rf G ⨾ ⦗S⦘;\n         co := ⦗S⦘ ⨾ co G ⨾ ⦗S⦘\n       |})","hypotheses":"(G : execution) (S : actid -> Prop) (FAIR : mem_fair G)","proofString":"simpl.\ndestruct FAIR as [FSco FSfr].\nsplit.\neapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver.\neapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FAIR : mem_fair G) : fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘) /\\ fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","conclusion":"fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘) /\\ fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘)","hypotheses":"(G : execution) (S : actid -> Prop) (FAIR : mem_fair G)","proofString":"destruct FAIR as [FSco FSfr].\nsplit.\neapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver.\neapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘) /\\ fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","conclusion":"fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘) /\\ fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘)","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"split.\neapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver.\neapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","conclusion":"fsupp (⦗S⦘ ⨾ co G ⨾ ⦗S⦘)","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"eapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : Basics.flip inclusion (co G) (⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","conclusion":"Basics.flip inclusion (co G) (⦗S⦘ ⨾ co G ⨾ ⦗S⦘)","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"red.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ co G.","conclusion":"⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ co G","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"basic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","conclusion":"fsupp ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘)","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"eapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : Basics.flip inclusion (fr G) ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘).","conclusion":"Basics.flip inclusion (fr G) ((⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘)","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"red.\nunfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : (⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ fr G.","conclusion":"(⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ fr G","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"unfold fr.\nbasic_solver."},{"statement":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G)) : (⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ (rf G)⁻¹ ⨾ co G.","conclusion":"(⦗S⦘ ⨾ rf G ⨾ ⦗S⦘)⁻¹ ⨾ ⦗S⦘ ⨾ co G ⨾ ⦗S⦘ ⊆ (rf G)⁻¹ ⨾ co G","hypotheses":"(G : execution) (S : actid -> Prop) (FSco : fsupp (co G)) (FSfr : fsupp (fr G))","proofString":"basic_solver."},{"statement":"(G : execution) (b : thread_id) (S : actid -> Prop) (BOUND : threads_bound G b) (e : actid) (Ge : (S ∩₁ acts_set G) e) : BinPos.Pos.lt (tid e) b.","conclusion":"BinPos.Pos.lt (tid e) b","hypotheses":"(G : execution) (b : thread_id) (S : actid -> Prop) (BOUND : threads_bound G b) (e : actid) (Ge : (S ∩₁ acts_set G) e)","proofString":"apply BOUND, Ge."}]}