[{"statement":"Lemma exists_inf_thread (f: nat -> actid) (S: actid -> Prop) b \n      (IN_E: f ↑₁ set_full ⊆₁ E \\₁ is_init)\n      (INF: ~ set_finite (f ↓₁ S))\n      (FINTHREADS : threads_bound G b):\n    exists t, BinPos.Pos.lt t b /\\ ~ set_finite (f ↓₁ (S ∩₁ Tid_ t)).","proof":"apply set_infinite_bunion.\n{\nexists (mk_list (Datatypes.S (BinPos.Pos.to_nat b)) BinPos.Pos.of_nat).\nintros.\napply in_mk_list_iff.\neexists.\nsplit.\n2: {\nsymmetry.\napply Pnat.Pos2Nat.id.\n}\nred in IN.\napply Pnat.Pos2Nat.inj_lt in IN.\nlia.\n}\nintros FIN.\ndestruct INF.\nrewrite set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto.\n"},{"statement":"Lemma exists_inf_loc (f: nat -> actid) (S: actid -> Prop) locs\n      (IN_E: f ↑₁ set_full ⊆₁ E \\₁ is_init)\n      (INF: ~ set_finite (f ↓₁ S))\n      (FINLOCS: forall e (ENIe: (E \\₁ is_init) e), In (loc e) locs):\n    exists l, In l locs /\\ ~ set_finite (f ↓₁ (S ∩₁ Loc_ l)).","proof":"eapply set_infinite_bunion; [by vauto| ].\nintros FIN.\ndestruct INF.\nrewrite set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto.\n"}]