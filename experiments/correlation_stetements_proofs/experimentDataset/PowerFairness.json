[{"statement":"Lemma wf_hbpE:\n  hbp ≡ ⦗E⦘ ⨾ hbp ⨾ ⦗E⦘.","proof":"apply dom_helper_3.\nunfold \"hbp\".\nrewrite Power_ppo.wf_ppoE, wf_fenceE, wf_rfeE; auto; try apply CON.\nbasic_solver.\n"},{"statement":"Lemma hb_po_loc_hb:\n  hbp⁺ ⨾ sb ∩ same_loc ⊆ hbp⁺.","proof":""},{"statement":"Lemma exists_inf_thread (f: nat -> actid) (S: actid -> Prop) b \n      (IN_E: f ↑₁ set_full ⊆₁ E \\₁ is_init)\n      (INF: ~ set_finite (f ↓₁ S))\n      (FINTHREADS : threads_bound G b):\n    exists t, BinPos.Pos.lt t b /\\ ~ set_finite (f ↓₁ (S ∩₁ Tid_ t)).","proof":"apply set_infinite_bunion.\n{\nexists (mk_list (Datatypes.S (BinPos.Pos.to_nat b)) BinPos.Pos.of_nat).\nintros.\napply in_mk_list_iff.\neexists.\nsplit.\n2: {\nsymmetry.\napply Pnat.Pos2Nat.id.\n}\nred in IN.\napply Pnat.Pos2Nat.inj_lt in IN.\nlia.\n}\nintros FIN.\ndestruct INF.\nrewrite AuxRel2.set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto.\n"},{"statement":"Lemma exists_inf_loc (f: nat -> actid) (S: actid -> Prop) locs\n      (IN_E: f ↑₁ set_full ⊆₁ E \\₁ is_init)\n      (INF: ~ set_finite (f ↓₁ S))\n      (FINLOCS: forall e (ENIe: (E \\₁ is_init) e), In (loc e) locs):\n    exists l, In l locs /\\ ~ set_finite (f ↓₁ (S ∩₁ Loc_ l)).","proof":"eapply set_infinite_bunion; [by vauto| ].\nintros FIN.\ndestruct INF.\nrewrite AuxRel2.set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto.\n"},{"statement":"Lemma fin_threads_locs_power_hb_ct_fsupp \n      (FINLOCS: exists locs, forall e (ENIe: (E \\₁ is_init) e), In (loc e) locs)\n      (FINTHREADS: exists b, threads_bound G b):\n  fsupp (⦗set_compl is_init⦘ ⨾ hbp^+).","proof":"desc.\nassert (Wf G) as WF by apply CON.\nrewrite clos_trans_domb_begin.\n2: {\nrewrite no_hbp_to_init; basic_solver.\n}\napply fsupp_wf_implies_fsupp_ct.\n2: {\nunfold \"hbp\".\nrewrite Power_ppo.ppo_in_sb, fence_in_sb, unionK, rfe_in_rf; auto.\nrewrite seq_union_r.\napply fsupp_union.\n{\nby apply fsupp_sb.\n}\neapply fsupp_mori; [| by apply fsupp_rf; eauto].\nred.\nbasic_solver.\n}\ncontra NWF.\napply not_wf_inf_decr_enum in NWF as [f DECR].\nassert (forall i, (transp hbp) (f i) (f (i + 1))) as DECR'.\n{\nins.\nred.\neapply seq_eqv_l.\neauto.\n}\nassert (f ↑₁ set_full ⊆₁ E \\₁ is_init) as ENUM_E.\n{\nintros e [i [_ Fie]].\nspecialize (DECR i).\neapply same_relation_exp in DECR.\n2: {\nrewrite no_hbp_to_init, wf_hbpE; auto.\n}\ngeneralize DECR.\nsubst e.\nbasic_solver.\n}\nassert (~ set_finite (f ↓₁ W)) as INFW'.\n{\nintros [iws FINW].\nset (wb := list_max iws + 1).\nassert (forall j (GE: j >= wb), sb (f (j + 1)) (f j)) as SB_STEPS.\n{\nintros.\nspecialize (DECR j).\napply seq_eqv_l in DECR.\ndesc.\nunfold \"hbp\" in DECR0.\neapply hahn_inclusion_exp in DECR0.\n2: {\nrewrite Power_ppo.ppo_in_sb, fence_in_sb, unionK; auto.\nreflexivity.\n}\ndestruct DECR0; auto.\nspecialize (FINW (j + 1)).\nspecialize_full FINW.\n{\napply wf_rfeD, seq_eqv_lr in H; auto.\ndesc.\nvauto.\n}\napply In_gt_list_max in FINW; vauto.\nlia.\n}\nforward eapply fsupp_dom_enum with (f := fun k => f (wb + k))                                       (r := ⦗set_compl is_init⦘ ⨾ sb) as [].\n{\nins.\napply seq_eqv_l.\nsplit.\n{\napply ENUM_E.\nvauto.\n}\nrewrite PeanoNat.Nat.add_assoc.\napply SB_STEPS.\nlia.\n}\n{\neapply acyclic_mori; [| by apply sb_acyclic].\nred.\nbasic_solver.\n}\neapply fsupp_mori; [| by apply fsupp_sb; eauto].\nred.\nrewrite inclusion_ct_seq_eqv_l.\nrewrite ct_of_trans; vauto.\napply sb_trans.\n}\neapply exists_inf_thread in INFW' as [t [TBt INFt]]; eauto.\neapply exists_inf_loc in INFt as [ol [Ll INFtl]]; eauto.\ndestruct ol.\n2: {\ndestruct INFtl.\nexists [].\nunfolder.\nins.\ndesc.\nforward eapply is_w_loc; eauto.\nins.\ndesc.\nvauto.\n}\neapply enum_order_contradiction with (r' := sb ∩ same_loc)                                       (S := (E \\₁ is_init) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))); eauto.\n{\nintros FIN.\ndestruct INFtl.\neapply set_finite_mori; eauto.\nred.\nrewrite set_map_inter with (d := _ \\₁ _).\napply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto.\n}\n{\nred.\nins.\nforward eapply sb_total with (a := a) (b := b0) (t := t) as SB;      try by (generalize IWa; generalize IWb; vauto || basic_solver).\nunfolder in IWa.\nunfolder in IWb.\ndesc.\ndes; [left | right]; split; congruence.\n}\n{\nby apply CON.\n}\n{\nby apply fsupp_sb_loc.\n}\napply hb_po_loc_hb.\n"}]