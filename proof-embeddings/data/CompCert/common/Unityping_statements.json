{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Unityping.v","fileSamples":[{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end) = OK (changed, e')) : (te_equ e' = te_equ e \\/ te_equ e' = (r1, r2) :: te_equ e) /\\\n(changed = true -> te_equ e' = te_equ e).","proofString":"destruct (peq r1 r2).\ninv H.\nauto.\ndestruct e.(te_typ)!r1 as [ty1|]; destruct e.(te_typ)!r2 as [ty2|]; inv H; simpl.\ndestruct (T.eq ty1 ty2); inv H1.\nauto.\nauto.\nauto.\nsplit.\nauto.\nintros.\ndiscriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (e0 : r1 = r2) (H : OK (false, e) = OK (changed, e')) : (te_equ e' = te_equ e \\/ te_equ e' = (r1, r2) :: te_equ e) /\\\n(changed = true -> te_equ e' = te_equ e).","proofString":"inv H.\nauto."},{"statement":"(r2 : positive) (e' : typenv) : (te_equ e' = te_equ e' \\/ te_equ e' = (r2, r2) :: te_equ e') /\\\n(false = true -> te_equ e' = te_equ e').","proofString":"auto."},{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some ty1 =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        if T.eq ty1 ty2\n        then OK (false, e)\n        else\n         Error\n           (MSG \"ill-typed move from \"\n            :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    | None =>\n        OK\n          (true,\n           {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        OK\n          (true,\n           {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n    end\nend = OK (changed, e')) : (te_equ e' = te_equ e \\/ te_equ e' = (r1, r2) :: te_equ e) /\\\n(changed = true -> te_equ e' = te_equ e).","proofString":"destruct e.(te_typ)!r1 as [ty1|]; destruct e.(te_typ)!r2 as [ty2|]; inv H; simpl.\ndestruct (T.eq ty1 ty2); inv H1.\nauto.\nauto.\nauto.\nsplit.\nauto.\nintros.\ndiscriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (n : r1 <> r2) (ty1 ty2 : T.t) (H1 : (if T.eq ty1 ty2\n then OK (false, e)\n else\n  Error (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)) =\nOK (changed, e')) : (te_equ e' = te_equ e \\/ te_equ e' = (r1, r2) :: te_equ e) /\\\n(changed = true -> te_equ e' = te_equ e).","proofString":"destruct (T.eq ty1 ty2); inv H1.\nauto."},{"statement":"(r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty2 : T.t) : (te_equ e' = te_equ e' \\/ te_equ e' = (r1, r2) :: te_equ e') /\\\n(false = true -> te_equ e' = te_equ e').","proofString":"auto."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) : (te_equ e = te_equ e \\/ te_equ e = (r1, r2) :: te_equ e) /\\\n(true = true -> te_equ e = te_equ e).","proofString":"auto."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty2 : T.t) : (te_equ e = te_equ e \\/ te_equ e = (r1, r2) :: te_equ e) /\\\n(true = true -> te_equ e = te_equ e).","proofString":"auto."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) : ((r1, r2) :: te_equ e = te_equ e \\/\n (r1, r2) :: te_equ e = (r1, r2) :: te_equ e) /\\\n(false = true -> (r1, r2) :: te_equ e = te_equ e).","proofString":"split.\nauto.\nintros.\ndiscriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) : (r1, r2) :: te_equ e = te_equ e \\/\n(r1, r2) :: te_equ e = (r1, r2) :: te_equ e.","proofString":"auto."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) : false = true -> (r1, r2) :: te_equ e = te_equ e.","proofString":"intros.\ndiscriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (H : false = true) : (r1, r2) :: te_equ e = te_equ e.","proofString":"discriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end) = OK (changed, e')) : Datatypes.length (te_equ e') + (if changed then 1 else 0) <=\nS (Datatypes.length (te_equ e)).","proofString":"destruct (peq r1 r2).\ninv H.\nlia.\ndestruct e.(te_typ)!r1 as [ty1|]; destruct e.(te_typ)!r2 as [ty2|]; inv H; simpl.\ndestruct (T.eq ty1 ty2); inv H1.\nlia.\nlia.\nlia.\nlia."},{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (e0 : r1 = r2) (H : OK (false, e) = OK (changed, e')) : Datatypes.length (te_equ e') + (if changed then 1 else 0) <=\nS (Datatypes.length (te_equ e)).","proofString":"inv H.\nlia."},{"statement":"(r2 : positive) (e' : typenv) : Datatypes.length (te_equ e') + 0 <= S (Datatypes.length (te_equ e')).","proofString":"lia."},{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some ty1 =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        if T.eq ty1 ty2\n        then OK (false, e)\n        else\n         Error\n           (MSG \"ill-typed move from \"\n            :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    | None =>\n        OK\n          (true,\n           {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        OK\n          (true,\n           {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n    end\nend = OK (changed, e')) : Datatypes.length (te_equ e') + (if changed then 1 else 0) <=\nS (Datatypes.length (te_equ e)).","proofString":"destruct e.(te_typ)!r1 as [ty1|]; destruct e.(te_typ)!r2 as [ty2|]; inv H; simpl.\ndestruct (T.eq ty1 ty2); inv H1.\nlia.\nlia.\nlia.\nlia."},{"statement":"(e : typenv) (r1 r2 : positive) (changed : bool) (e' : typenv) (n : r1 <> r2) (ty1 ty2 : T.t) (H1 : (if T.eq ty1 ty2\n then OK (false, e)\n else\n  Error (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)) =\nOK (changed, e')) : Datatypes.length (te_equ e') + (if changed then 1 else 0) <=\nS (Datatypes.length (te_equ e)).","proofString":"destruct (T.eq ty1 ty2); inv H1.\nlia."},{"statement":"(r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty2 : T.t) : Datatypes.length (te_equ e') + 0 <= S (Datatypes.length (te_equ e')).","proofString":"lia."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) : Datatypes.length (te_equ e) + 1 <= S (Datatypes.length (te_equ e)).","proofString":"lia."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty2 : T.t) : Datatypes.length (te_equ e) + 1 <= S (Datatypes.length (te_equ e)).","proofString":"lia."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) : S (Datatypes.length (te_equ e) + 0) <= S (Datatypes.length (te_equ e)).","proofString":"lia."},{"statement":"(e : typenv) (ch : bool) (e' : typenv) (ch' : bool) (H : OK (e, ch) = OK (e', ch')) : Datatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + 0.","proofString":"inv H.\nreplace (ch' && negb ch') with false.\nlia.\ndestruct ch'; auto."},{"statement":"(e' : typenv) (ch' : bool) : Datatypes.length (te_equ e') + (if ch' && negb ch' then 1 else 0) <=\nDatatypes.length (te_equ e') + 0.","proofString":"replace (ch' && negb ch') with false.\nlia.\ndestruct ch'; auto."},{"statement":"(e' : typenv) (ch' : bool) : Datatypes.length (te_equ e') + 0 <= Datatypes.length (te_equ e') + 0.","proofString":"lia."},{"statement":"(e' : typenv) (ch' : bool) : false = ch' && negb ch'.","proofString":"destruct ch'; auto."},{"statement":"(a : constraint) (q : list constraint) (IHq : forall (e0 : typenv) (ch0 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e0 ch0 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch0 then 1 else 0) <=\nDatatypes.length (te_equ e0) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' : bool) (H : (let (r1, r2) := a in\n do (changed1, e1)<- move e r1 r2; solve_rec e1 (ch || changed1) q) =\nOK (e', ch')) : Datatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"destruct a as [r1 r2]; monadInv H.\nrename x0 into e0.\nrename x into ch0.\nexploit IHq; eauto.\nintros A.\nexploit length_move; eauto.\nintros B.\nset (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (ch0 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e0 ch0 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch0 then 1 else 0) <=\nDatatypes.length (te_equ e0) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' x : bool) (x0 : typenv) (EQ : move e r1 r2 = OK (x, x0)) (EQ0 : solve_rec x0 (ch || x) q = OK (e', ch')) : Datatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"rename x0 into e0.\nrename x into ch0.\nexploit IHq; eauto.\nintros A.\nexploit length_move; eauto.\nintros B.\nset (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch0 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch0 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch0 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' x : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (x, e0)) (EQ0 : solve_rec e0 (ch || x) q = OK (e', ch')) : Datatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"rename x into ch0.\nexploit IHq; eauto.\nintros A.\nexploit length_move; eauto.\nintros B.\nset (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) : Datatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"exploit IHq; eauto.\nintros A.\nexploit length_move; eauto.\nintros B.\nset (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) : Datatypes.length (te_equ e') + (if ch' && negb (ch || ch0) then 1 else 0) <=\nDatatypes.length (te_equ e0) + Datatypes.length q ->\nDatatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"intros A.\nexploit length_move; eauto.\nintros B.\nset (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) (A : Datatypes.length (te_equ e') + (if ch' && negb (ch || ch0) then 1 else 0) <=\nDatatypes.length (te_equ e0) + Datatypes.length q) : Datatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"exploit length_move; eauto.\nintros B.\nset (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) (A : Datatypes.length (te_equ e') + (if ch' && negb (ch || ch0) then 1 else 0) <=\nDatatypes.length (te_equ e0) + Datatypes.length q) : Datatypes.length (te_equ e0) + (if ch0 then 1 else 0) <=\nS (Datatypes.length (te_equ e)) ->\nDatatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"intros B.\nset (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) (A : Datatypes.length (te_equ e') + (if ch' && negb (ch || ch0) then 1 else 0) <=\nDatatypes.length (te_equ e0) + Datatypes.length q) (B : Datatypes.length (te_equ e0) + (if ch0 then 1 else 0) <=\nS (Datatypes.length (te_equ e))) : Datatypes.length (te_equ e') + (if ch' && negb ch then 1 else 0) <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"set (X := (if ch' && negb (ch || ch0) then 1 else 0)) in *.\nset (Y := (if ch0 then 1 else 0)) in *.\nset (Z := (if ch' && negb ch then 1 else 0)) in *.\ncut (Z <= X + Y).\nintros.\nlia.\nunfold X, Y, Z.\ndestruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) (X : nat) (A : Datatypes.length (te_equ e') + X <=\nDatatypes.length (te_equ e0) + Datatypes.length q) (Y : nat) (B : Datatypes.length (te_equ e0) + Y <= S (Datatypes.length (te_equ e))) (Z : nat) : Z <= X + Y ->\nDatatypes.length (te_equ e') + Z <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"intros.\nlia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) (X : nat) (A : Datatypes.length (te_equ e') + X <=\nDatatypes.length (te_equ e0) + Datatypes.length q) (Y : nat) (B : Datatypes.length (te_equ e0) + Y <= S (Datatypes.length (te_equ e))) (Z : nat) (H : Z <= X + Y) : Datatypes.length (te_equ e') + Z <=\nDatatypes.length (te_equ e) + S (Datatypes.length q).","proofString":"lia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e1 : typenv) (ch1 : bool) (e'0 : typenv) (ch'0 : bool),\nsolve_rec e1 ch1 q = OK (e'0, ch'0) ->\nDatatypes.length (te_equ e'0) + (if ch'0 && negb ch1 then 1 else 0) <=\nDatatypes.length (te_equ e1) + Datatypes.length q) (e : typenv) (ch : bool) (e' : typenv) (ch' ch0 : bool) (e0 : typenv) (EQ : move e r1 r2 = OK (ch0, e0)) (EQ0 : solve_rec e0 (ch || ch0) q = OK (e', ch')) (X : nat) (A : Datatypes.length (te_equ e') + X <=\nDatatypes.length (te_equ e0) + Datatypes.length q) (Y : nat) (B : Datatypes.length (te_equ e0) + Y <= S (Datatypes.length (te_equ e))) (Z : nat) : (if ch' && negb ch then 1 else 0) <=\n(if ch' && negb (ch || ch0) then 1 else 0) + (if ch0 then 1 else 0).","proofString":"destruct ch'; destruct ch; destruct ch0; simpl; auto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (H : (PTree.empty T.t) ! x = Some ty) : te x = ty.","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(te : typassign) (x y : positive) (H : False) : te x = te y.","proofString":"contradiction."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (H : match (te_typ e) ! x with\n| Some ty' =>\n    if T.eq ty ty'\n    then OK e\n    else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)\n| None => OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}\nend = OK e') (H0 : satisf te e') : satisf te e.","proofString":"destruct (te_typ e)!x as [ty'|] eqn:E.\ndestruct (T.eq ty ty'); inv H.\nauto.\ninv H.\ndestruct H0 as [A B]; simpl in *.\nred; split; intros; auto.\napply A.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (ty' : T.t) (E : (te_typ e) ! x = Some ty') (H : (if T.eq ty ty'\n then OK e\n else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)) = \nOK e') (H0 : satisf te e') : satisf te e.","proofString":"destruct (T.eq ty ty'); inv H.\nauto."},{"statement":"(te : typassign) (x : positive) (e' : typenv) (ty' : T.t) (E : (te_typ e') ! x = Some ty') (H0 : satisf te e') : satisf te e'.","proofString":"auto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (E : (te_typ e) ! x = None) (H : OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |} = OK e') (H0 : satisf te e') : satisf te e.","proofString":"inv H.\ndestruct H0 as [A B]; simpl in *.\nred; split; intros; auto.\napply A.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (H0 : satisf te {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}) : satisf te e.","proofString":"destruct H0 as [A B]; simpl in *.\nred; split; intros; auto.\napply A.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (A : forall (x0 : positive) (ty0 : T.t),\n(PTree.set x ty (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) (B : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) : satisf te e.","proofString":"red; split; intros; auto.\napply A.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (A : forall (x1 : positive) (ty1 : T.t),\n(PTree.set x ty (te_typ e)) ! x1 = Some ty1 -> te x1 = ty1) (B : forall x1 y : positive, In (x1, y) (te_equ e) -> te x1 = te y) (x0 : positive) (ty0 : T.t) (H : (te_typ e) ! x0 = Some ty0) : te x0 = ty0.","proofString":"apply A.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (A : forall (x1 : positive) (ty1 : T.t),\n(PTree.set x ty (te_typ e)) ! x1 = Some ty1 -> te x1 = ty1) (B : forall x1 y : positive, In (x1, y) (te_equ e) -> te x1 = te y) (x0 : positive) (ty0 : T.t) (H : (te_typ e) ! x0 = Some ty0) : (PTree.set x ty (te_typ e)) ! x0 = Some ty0.","proofString":"rewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (A : forall (x1 : positive) (ty1 : T.t),\n(PTree.set x ty (te_typ e)) ! x1 = Some ty1 -> te x1 = ty1) (B : forall x1 y : positive, In (x1, y) (te_equ e) -> te x1 = te y) (x0 : positive) (ty0 : T.t) (H : (te_typ e) ! x0 = Some ty0) : (te_typ e) ! x0 = Some ty0.","proofString":"auto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (H : match (te_typ e) ! x with\n| Some ty' =>\n    if T.eq ty ty'\n    then OK e\n    else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)\n| None => OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}\nend = OK e') (H0 : satisf te e') : te x = ty.","proofString":"destruct H0 as [P Q].\ndestruct (te_typ e)!x as [ty'|] eqn:E.\ndestruct (T.eq ty ty'); inv H.\neauto.\ninv H.\nsimpl in P.\napply P.\napply PTree.gss."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (H : match (te_typ e) ! x with\n| Some ty' =>\n    if T.eq ty ty'\n    then OK e\n    else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)\n| None => OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}\nend = OK e') (P : forall (x0 : positive) (ty0 : T.t),\n(te_typ e') ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e') -> te x0 = te y) : te x = ty.","proofString":"destruct (te_typ e)!x as [ty'|] eqn:E.\ndestruct (T.eq ty ty'); inv H.\neauto.\ninv H.\nsimpl in P.\napply P.\napply PTree.gss."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (ty' : T.t) (E : (te_typ e) ! x = Some ty') (H : (if T.eq ty ty'\n then OK e\n else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)) = \nOK e') (P : forall (x0 : positive) (ty0 : T.t),\n(te_typ e') ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e') -> te x0 = te y) : te x = ty.","proofString":"destruct (T.eq ty ty'); inv H.\neauto."},{"statement":"(te : typassign) (x : positive) (e' : typenv) (ty' : T.t) (E : (te_typ e') ! x = Some ty') (P : forall (x0 : positive) (ty : T.t), (te_typ e') ! x0 = Some ty -> te x0 = ty) (Q : forall x0 y : positive, In (x0, y) (te_equ e') -> te x0 = te y) : te x = ty'.","proofString":"eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (E : (te_typ e) ! x = None) (H : OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |} = OK e') (P : forall (x0 : positive) (ty0 : T.t),\n(te_typ e') ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e') -> te x0 = te y) : te x = ty.","proofString":"inv H.\nsimpl in P.\napply P.\napply PTree.gss."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_equ {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}) ->\nte x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(te_typ {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}) ! x0 =\nSome ty0 -> te x0 = ty0) : te x = ty.","proofString":"simpl in P.\napply P.\napply PTree.gss."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_equ {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}) ->\nte x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set x ty (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) : te x = ty.","proofString":"apply P.\napply PTree.gss."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_equ {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}) ->\nte x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set x ty (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) : (PTree.set x ty (te_typ e)) ! x = Some ty.","proofString":"apply PTree.gss."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl0 : list T.t) (e0 e'0 : typenv),\nset_list e0 xl tyl0 = OK e'0 -> satisf te e'0 -> map te xl = tyl0) (t : T.t) (tyl : list T.t) (e e' : typenv) (H0 : satisf te e') (x : typenv) (EQ : set e a t = OK x) (EQ0 : set_list x xl tyl = OK e') : te a :: map te xl = t :: tyl.","proofString":"f_equal.\neapply set_sound; eauto with ty.\neauto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl0 : list T.t) (e0 e'0 : typenv),\nset_list e0 xl tyl0 = OK e'0 -> satisf te e'0 -> map te xl = tyl0) (t : T.t) (tyl : list T.t) (e e' : typenv) (H0 : satisf te e') (x : typenv) (EQ : set e a t = OK x) (EQ0 : set_list x xl tyl = OK e') : te a = t.","proofString":"eapply set_sound; eauto with ty."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl0 : list T.t) (e0 e'0 : typenv),\nset_list e0 xl tyl0 = OK e'0 -> satisf te e'0 -> map te xl = tyl0) (t : T.t) (tyl : list T.t) (e e' : typenv) (H0 : satisf te e') (x : typenv) (EQ : set e a t = OK x) (EQ0 : set_list x xl tyl = OK e') : map te xl = tyl.","proofString":"eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end) = OK (changed, e')) (H0 : satisf te e') : satisf te e.","proofString":"destruct H0 as [P Q].\ndestruct (peq r1 r2).\ninv H; split; auto.\ndestruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nsplit; auto.\ninv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end) = OK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e.","proofString":"destruct (peq r1 r2).\ninv H; split; auto.\ndestruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nsplit; auto.\ninv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (e0 : r1 = r2) (H : OK (false, e) = OK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e.","proofString":"inv H; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some ty1 =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        if T.eq ty1 ty2\n        then OK (false, e)\n        else\n         Error\n           (MSG \"ill-typed move from \"\n            :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    | None =>\n        OK\n          (true,\n           {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        OK\n          (true,\n           {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n    end\nend = OK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e.","proofString":"destruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nsplit; auto.\ninv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (H : (if T.eq ty1 ty2\n then OK (false, e)\n else\n  Error (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e.","proofString":"destruct (T.eq ty1 ty2); inv H.\nsplit; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty2 : T.t) (E2 : (te_typ e') ! r2 = Some ty2) (E1 : (te_typ e') ! r1 = Some ty2) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e'.","proofString":"split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (H : OK (true, {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |}) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e.","proofString":"inv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x = Some ty -> te x = ty) : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty.","proofString":"intros.\napply P.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) (x : positive) (ty : T.t) (H : (te_typ e) ! x = Some ty) : te x = ty.","proofString":"apply P.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) (x : positive) (ty : T.t) (H : (te_typ e) ! x = Some ty) : (PTree.set r2 ty1 (te_typ e)) ! x = Some ty.","proofString":"rewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) (x : positive) (ty : T.t) (H : (te_typ e) ! x = Some ty) : (te_typ e) ! x = Some ty.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (H : OK (true, {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |}) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e.","proofString":"inv H; simpl in *; split; auto.\nintros.\napply P.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x = Some ty -> te x = ty) : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty.","proofString":"intros.\napply P.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) (x : positive) (ty : T.t) (H : (te_typ e) ! x = Some ty) : te x = ty.","proofString":"apply P.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) (x : positive) (ty : T.t) (H : (te_typ e) ! x = Some ty) : (PTree.set r1 ty2 (te_typ e)) ! x = Some ty.","proofString":"rewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (P : forall (x0 : positive) (ty0 : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x0 = Some ty0 -> te x0 = ty0) (x : positive) (ty : T.t) (H : (te_typ e) ! x = Some ty) : (te_typ e) ! x = Some ty.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (H : OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |}) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : satisf te e.","proofString":"inv H; simpl in *; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end) = OK (changed, e')) (H0 : satisf te e') : te r1 = te r2.","proofString":"destruct H0 as [P Q].\ndestruct (peq r1 r2).\ncongruence.\ndestruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nerewrite ! P by eauto.\nauto.\ninv H; simpl in *.\nrewrite (P r1 ty1).\nrewrite (P r2 ty1).\nauto.\napply PTree.gss.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *.\nrewrite (P r1 ty2).\nrewrite (P r2 ty2).\nauto.\nrewrite PTree.gso by congruence.\nauto.\napply PTree.gss.\ninv H; simpl in *.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end) = OK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"destruct (peq r1 r2).\ncongruence.\ndestruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nerewrite ! P by eauto.\nauto.\ninv H; simpl in *.\nrewrite (P r1 ty1).\nrewrite (P r2 ty1).\nauto.\napply PTree.gss.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *.\nrewrite (P r1 ty2).\nrewrite (P r2 ty2).\nauto.\nrewrite PTree.gso by congruence.\nauto.\napply PTree.gss.\ninv H; simpl in *.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (e0 : r1 = r2) (H : OK (false, e) = OK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some ty1 =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        if T.eq ty1 ty2\n        then OK (false, e)\n        else\n         Error\n           (MSG \"ill-typed move from \"\n            :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    | None =>\n        OK\n          (true,\n           {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        OK\n          (true,\n           {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n    end\nend = OK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"destruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nerewrite ! P by eauto.\nauto.\ninv H; simpl in *.\nrewrite (P r1 ty1).\nrewrite (P r2 ty1).\nauto.\napply PTree.gss.\nrewrite PTree.gso by congruence.\nauto.\ninv H; simpl in *.\nrewrite (P r1 ty2).\nrewrite (P r2 ty2).\nauto.\nrewrite PTree.gso by congruence.\nauto.\napply PTree.gss.\ninv H; simpl in *.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (H : (if T.eq ty1 ty2\n then OK (false, e)\n else\n  Error (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"destruct (T.eq ty1 ty2); inv H.\nerewrite ! P by eauto.\nauto."},{"statement":"(te : typassign) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty2 : T.t) (E2 : (te_typ e') ! r2 = Some ty2) (E1 : (te_typ e') ! r1 = Some ty2) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"erewrite ! P by eauto.\nauto."},{"statement":"(te : typassign) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty2 : T.t) (E2 : (te_typ e') ! r2 = Some ty2) (E1 : (te_typ e') ! r1 = Some ty2) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : ty2 = ty2.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (H : OK (true, {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |}) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"inv H; simpl in *.\nrewrite (P r1 ty1).\nrewrite (P r2 ty1).\nauto.\napply PTree.gss.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x = Some ty -> te x = ty) : te r1 = te r2.","proofString":"rewrite (P r1 ty1).\nrewrite (P r2 ty1).\nauto.\napply PTree.gss.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x = Some ty -> te x = ty) : ty1 = te r2.","proofString":"rewrite (P r2 ty1).\nauto.\napply PTree.gss."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x = Some ty -> te x = ty) : ty1 = ty1.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x = Some ty -> te x = ty) : (PTree.set r2 ty1 (te_typ e)) ! r2 = Some ty1.","proofString":"apply PTree.gss."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x = Some ty -> te x = ty) : (PTree.set r2 ty1 (te_typ e)) ! r1 = Some ty1.","proofString":"rewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r2 ty1 (te_typ e)) ! x = Some ty -> te x = ty) : (te_typ e) ! r1 = Some ty1.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (H : OK (true, {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |}) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"inv H; simpl in *.\nrewrite (P r1 ty2).\nrewrite (P r2 ty2).\nauto.\nrewrite PTree.gso by congruence.\nauto.\napply PTree.gss."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x = Some ty -> te x = ty) : te r1 = te r2.","proofString":"rewrite (P r1 ty2).\nrewrite (P r2 ty2).\nauto.\nrewrite PTree.gso by congruence.\nauto.\napply PTree.gss."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x = Some ty -> te x = ty) : ty2 = te r2.","proofString":"rewrite (P r2 ty2).\nauto.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x = Some ty -> te x = ty) : ty2 = ty2.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x = Some ty -> te x = ty) : (PTree.set r1 ty2 (te_typ e)) ! r2 = Some ty2.","proofString":"rewrite PTree.gso by congruence.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x = Some ty -> te x = ty) : (te_typ e) ! r2 = Some ty2.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t),\n(PTree.set r1 ty2 (te_typ e)) ! x = Some ty -> te x = ty) : (PTree.set r1 ty2 (te_typ e)) ! r1 = Some ty2.","proofString":"apply PTree.gss."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (H : OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |}) =\nOK (changed, e')) (P : forall (x : positive) (ty : T.t), (te_typ e') ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e') -> te x = te y) : te r1 = te r2.","proofString":"inv H; simpl in *.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive,\n(r1, r2) = (x, y) \\/ In (x, y) (te_equ e) -> te x = te y) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) : te r1 = te r2.","proofString":"apply Q; auto."},{"statement":"(te : typassign) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : OK (e, changed) = OK (e', changed')) (H0 : satisf te e') : satisf te e.","proofString":"inv H.\nauto."},{"statement":"(te : typassign) (e' : typenv) (changed' : bool) (H0 : satisf te e') : satisf te e'.","proofString":"auto."},{"statement":"(te : typassign) (a : constraint) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nsatisf te e'0 -> satisf te e0) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : (let (r1, r2) := a in\n do (changed1, e1)<- move e r1 r2; solve_rec e1 (changed || changed1) q) =\nOK (e', changed')) (H0 : satisf te e') : satisf te e.","proofString":"destruct a as [r1 r2]; monadInv H.\neauto with ty."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nsatisf te e'0 -> satisf te e0) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H0 : satisf te e') (x : bool) (x0 : typenv) (EQ : move e r1 r2 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : satisf te e.","proofString":"eauto with ty."},{"statement":"(te : typassign) (r1 r2 : positive) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : OK (e, changed) = OK (e', changed')) (H0 : False) (H1 : satisf te e') : te r1 = te r2.","proofString":"contradiction."},{"statement":"(te : typassign) (r1 r2 : positive) (a : constraint) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> te r1 = te r2) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : (let (r0, r3) := a in\n do (changed1, e1)<- move e r0 r3; solve_rec e1 (changed || changed1) q) =\nOK (e', changed')) (H0 : a = (r1, r2) \\/ In (r1, r2) q) (H1 : satisf te e') : te r1 = te r2.","proofString":"destruct a as [r3 r4]; monadInv H.\ndestruct H0.\ninv H.\neapply move_sound; eauto.\neapply solve_rec_incr; eauto.\neapply IHq; eauto with ty."},{"statement":"(te : typassign) (r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> te r1 = te r2) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H0 : (r3, r4) = (r1, r2) \\/ In (r1, r2) q) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : te r1 = te r2.","proofString":"destruct H0.\ninv H.\neapply move_sound; eauto.\neapply solve_rec_incr; eauto.\neapply IHq; eauto with ty."},{"statement":"(te : typassign) (r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> te r1 = te r2) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : (r3, r4) = (r1, r2)) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : te r1 = te r2.","proofString":"inv H.\neapply move_sound; eauto.\neapply solve_rec_incr; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> te r1 = te r2) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : move e r1 r2 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : te r1 = te r2.","proofString":"eapply move_sound; eauto.\neapply solve_rec_incr; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> te r1 = te r2) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : move e r1 r2 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : satisf te x0.","proofString":"eapply solve_rec_incr; eauto."},{"statement":"(te : typassign) (r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> te r1 = te r2) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : In (r1, r2) q) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : te r1 = te r2.","proofString":"eapply IHq; eauto with ty."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end) = OK (false, e')) : te_typ e' = te_typ e /\\ makeassign e r1 = makeassign e r2.","proofString":"destruct (peq r1 r2).\ninv H.\nsplit; auto.\nunfold makeassign;  destruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nauto.\ndiscriminate.\ndiscriminate.\ninv H.\nsplit; auto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (e0 : r1 = r2) (H : OK (false, e) = OK (false, e')) : te_typ e' = te_typ e /\\ makeassign e r1 = makeassign e r2.","proofString":"inv H.\nsplit; auto."},{"statement":"(r2 : positive) (e' : typenv) : te_typ e' = te_typ e' /\\ makeassign e' r2 = makeassign e' r2.","proofString":"split; auto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some ty1 =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        if T.eq ty1 ty2\n        then OK (false, e)\n        else\n         Error\n           (MSG \"ill-typed move from \"\n            :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    | None =>\n        OK\n          (true,\n           {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some ty2 =>\n        OK\n          (true,\n           {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n    end\nend = OK (false, e')) : te_typ e' = te_typ e /\\ makeassign e r1 = makeassign e r2.","proofString":"unfold makeassign;  destruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\ndestruct (T.eq ty1 ty2); inv H.\nauto.\ndiscriminate.\ndiscriminate.\ninv H.\nsplit; auto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (H : (if T.eq ty1 ty2\n then OK (false, e)\n else\n  Error (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)) =\nOK (false, e')) : te_typ e' = te_typ e /\\ ty1 = ty2.","proofString":"destruct (T.eq ty1 ty2); inv H.\nauto."},{"statement":"(r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty2 : T.t) (E2 : (te_typ e') ! r2 = Some ty2) (E1 : (te_typ e') ! r1 = Some ty2) : te_typ e' = te_typ e' /\\ ty2 = ty2.","proofString":"auto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (H : OK (true, {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |}) =\nOK (false, e')) : te_typ e' = te_typ e /\\ ty1 = T.default.","proofString":"discriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (H : OK (true, {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |}) =\nOK (false, e')) : te_typ e' = te_typ e /\\ T.default = ty2.","proofString":"discriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (H : OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |}) =\nOK (false, e')) : te_typ e' = te_typ e /\\ T.default = T.default.","proofString":"inv H.\nsplit; auto."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) : te_typ {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |} = te_typ e /\\\nT.default = T.default.","proofString":"split; auto."},{"statement":"(r1 r2 : positive) (e : typenv) (changed : bool) (e' : typenv) (H : OK (e, changed) = OK (e', false)) : changed = false /\\ (False -> makeassign e r1 = makeassign e r2).","proofString":"inv H.\ntauto."},{"statement":"(r1 r2 : positive) (e' : typenv) : false = false /\\ (False -> makeassign e' r1 = makeassign e' r2).","proofString":"tauto."},{"statement":"(r1 r2 : positive) (a : constraint) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e : typenv) (changed : bool) (e' : typenv) (H : (let (r0, r3) := a in\n do (changed1, e1)<- move e r0 r3; solve_rec e1 (changed || changed1) q) =\nOK (e', false)) : changed = false /\\\n(a = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"destruct a as [r3 r4]; monadInv H.\nexploit IHq; eauto.\nintros [P Q].\ndestruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e : typenv) (changed : bool) (e' : typenv) (x : bool) (x0 : typenv) (EQ : move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', false)) : changed = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"exploit IHq; eauto.\nintros [P Q].\ndestruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e : typenv) (changed : bool) (e' : typenv) (x : bool) (x0 : typenv) (EQ : move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', false)) : changed || x = false /\\\n(In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) ->\nchanged = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"intros [P Q].\ndestruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e : typenv) (changed : bool) (e' : typenv) (x : bool) (x0 : typenv) (EQ : move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', false)) (P : changed || x = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) : changed = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"destruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' : typenv) (x : bool) (x0 : typenv) (EQ : move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (false || x) q = OK (e', false)) (P : false || x = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) : false = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"destruct x; try discriminate.\nexploit move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) : false = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"exploit move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) : te_typ x0 = te_typ e /\\ makeassign e r3 = makeassign e r4 ->\nfalse = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"intros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) (U : te_typ x0 = te_typ e) (V : makeassign e r3 = makeassign e r4) : false = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2).","proofString":"split.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) (U : te_typ x0 = te_typ e) (V : makeassign e r3 = makeassign e r4) : false = false.","proofString":"auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) (U : te_typ x0 = te_typ e) (V : makeassign e r3 = makeassign e r4) : (r3, r4) = (r1, r2) \\/ In (r1, r2) q -> makeassign e r1 = makeassign e r2.","proofString":"intros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) (U : te_typ x0 = te_typ e) (V : makeassign e r3 = makeassign e r4) (A : (r3, r4) = (r1, r2)) : makeassign e r1 = makeassign e r2.","proofString":"inv A.\nauto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r1 r2 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) (U : te_typ x0 = te_typ e) (V : makeassign e r1 = makeassign e r2) : makeassign e r1 = makeassign e r2.","proofString":"auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) (U : te_typ x0 = te_typ e) (V : makeassign e r3 = makeassign e r4) (A : In (r1, r2) q) : makeassign e r1 = makeassign e r2.","proofString":"exploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\ (In (r1, r2) q -> makeassign e0 r1 = makeassign e0 r2)) (e e' x0 : typenv) (EQ : move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> makeassign x0 r1 = makeassign x0 r2) (U : te_typ x0 = te_typ e) (V : makeassign e r3 = makeassign e r4) (A : In (r1, r2) q) : makeassign x0 r1 = makeassign x0 r2 -> makeassign e r1 = makeassign e r2.","proofString":"unfold makeassign; rewrite U; auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', false)) (e'0 : typenv) (H : OK e = OK e'0) (H0 : satisf te e'0) : satisf te e.","proofString":"inv H.\nauto."},{"statement":"(te : typassign) (e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_equ := nil |} false (te_equ e'0) =\nOK (e', false)) (H0 : satisf te e'0) : satisf te e'0.","proofString":"auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) : satisf te e.","proofString":"exploit solve_rec_incr; eauto.\nintros [A B].\nsplit; auto.\nintros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) : satisf te {| te_typ := te_typ e; te_equ := nil |} -> satisf te e.","proofString":"intros [A B].\nsplit; auto.\nintros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) (A : forall (x : positive) (ty : T.t),\n(te_typ {| te_typ := te_typ e; te_equ := nil |}) ! x = Some ty -> te x = ty) (B : forall x y : positive,\nIn (x, y) (te_equ {| te_typ := te_typ e; te_equ := nil |}) -> te x = te y) : satisf te e.","proofString":"split; auto.\nintros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) (A : forall (x : positive) (ty : T.t),\n(te_typ {| te_typ := te_typ e; te_equ := nil |}) ! x = Some ty -> te x = ty) (B : forall x y : positive,\nIn (x, y) (te_equ {| te_typ := te_typ e; te_equ := nil |}) -> te x = te y) : forall x y : positive, In (x, y) (te_equ e) -> te x = te y.","proofString":"intros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (e' : typenv) (H : Error msg = OK e') (H0 : satisf te e') : satisf te e.","proofString":"discriminate."},{"statement":"(e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', false)) (e'0 : typenv) (H : OK e = OK e'0) : satisf (makeassign e'0) e'0.","proofString":"inv H.\nsplit; intros.\nunfold makeassign; rewrite H.\nsplit; auto with ty.\nexploit solve_rec_false.\neauto.\nintros [A B].\neapply B; eauto."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_equ := nil |} false (te_equ e'0) =\nOK (e', false)) : satisf (makeassign e'0) e'0.","proofString":"split; intros.\nunfold makeassign; rewrite H.\nsplit; auto with ty.\nexploit solve_rec_false.\neauto.\nintros [A B].\neapply B; eauto."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_equ := nil |} false (te_equ e'0) =\nOK (e', false)) (x : positive) (ty : T.t) (H : (te_typ e'0) ! x = Some ty) : makeassign e'0 x = ty.","proofString":"unfold makeassign; rewrite H.\nsplit; auto with ty."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_equ := nil |} false (te_equ e'0) =\nOK (e', false)) (x : positive) (ty : T.t) (H : (te_typ e'0) ! x = Some ty) : ty = ty.","proofString":"split; auto with ty."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_equ := nil |} false (te_equ e'0) =\nOK (e', false)) (x y : positive) (H : In (x, y) (te_equ e'0)) : makeassign e'0 x = makeassign e'0 y.","proofString":"exploit solve_rec_false.\neauto.\nintros [A B].\neapply B; eauto."},{"statement":"(e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf (makeassign e'1) e'1) (e'0 : typenv) (H : solve_constraints e' = OK e'0) : satisf (makeassign e'0) e'0.","proofString":"eauto."},{"statement":"(e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (e' : typenv) (H : Error msg = OK e') : satisf (makeassign e') e'.","proofString":"discriminate."},{"statement":"(e : typenv) (te : typassign) (H : (do e' <- solve_constraints e; OK (makeassign e')) = OK te) : satisf te e.","proofString":"monadInv H.\neapply solve_constraints_incr.\neauto.\neapply solve_constraints_sound; eauto."},{"statement":"(e x : typenv) (EQ : solve_constraints e = OK x) : satisf (makeassign x) e.","proofString":"eapply solve_constraints_incr.\neauto.\neapply solve_constraints_sound; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) : exists e' : typenv,\n  match (te_typ e) ! x with\n  | Some ty' =>\n      if T.eq ty ty'\n      then OK e\n      else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)\n  | None => OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}\n  end = OK e' /\\ satisf te e'.","proofString":"generalize H; intros [P Q].\ndestruct (te_typ e)!x as [ty1|] eqn:E.\nreplace ty1 with ty.\nrewrite dec_eq_true.\nexists e; auto.\nexploit P; eauto.\ncongruence.\neconstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x0 x).\ncongruence.\neauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) : exists e' : typenv,\n  match (te_typ e) ! x with\n  | Some ty' =>\n      if T.eq ty ty'\n      then OK e\n      else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)\n  | None => OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}\n  end = OK e' /\\ satisf te e'.","proofString":"destruct (te_typ e)!x as [ty1|] eqn:E.\nreplace ty1 with ty.\nrewrite dec_eq_true.\nexists e; auto.\nexploit P; eauto.\ncongruence.\neconstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x0 x).\ncongruence.\neauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (ty1 : T.t) (E : (te_typ e) ! x = Some ty1) : exists e' : typenv,\n  (if T.eq ty ty1\n   then OK e\n   else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)) =\n  OK e' /\\ satisf te e'.","proofString":"replace ty1 with ty.\nrewrite dec_eq_true.\nexists e; auto.\nexploit P; eauto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (ty1 : T.t) (E : (te_typ e) ! x = Some ty1) : exists e' : typenv,\n  (if T.eq ty ty\n   then OK e\n   else Error (MSG \"bad definition/use of variable \" :: POS x :: nil)) =\n  OK e' /\\ satisf te e'.","proofString":"rewrite dec_eq_true.\nexists e; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (ty1 : T.t) (E : (te_typ e) ! x = Some ty1) : exists e' : typenv, OK e = OK e' /\\ satisf te e'.","proofString":"exists e; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (ty1 : T.t) (E : (te_typ e) ! x = Some ty1) : ty = ty1.","proofString":"exploit P; eauto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (ty1 : T.t) (E : (te_typ e) ! x = Some ty1) : te x = ty1 -> ty = ty1.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (E : (te_typ e) ! x = None) : exists e' : typenv,\n  OK {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |} = OK e' /\\\n  satisf te e'.","proofString":"econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x0 x).\ncongruence.\neauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (E : (te_typ e) ! x = None) : satisf te {| te_typ := PTree.set x ty (te_typ e); te_equ := te_equ e |}.","proofString":"split; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x0 x).\ncongruence.\neauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x1 : positive) (ty1 : T.t), (te_typ e) ! x1 = Some ty1 -> te x1 = ty1) (Q : forall x1 y : positive, In (x1, y) (te_equ e) -> te x1 = te y) (E : (te_typ e) ! x = None) (x0 : positive) (ty0 : T.t) (H1 : (PTree.set x ty (te_typ e)) ! x0 = Some ty0) : te x0 = ty0.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x0 x).\ncongruence.\neauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x1 : positive) (ty1 : T.t), (te_typ e) ! x1 = Some ty1 -> te x1 = ty1) (Q : forall x1 y : positive, In (x1, y) (te_equ e) -> te x1 = te y) (E : (te_typ e) ! x = None) (x0 : positive) (ty0 : T.t) (H1 : (if peq x0 x then Some ty else (te_typ e) ! x0) = Some ty0) : te x0 = ty0.","proofString":"destruct (peq x0 x).\ncongruence.\neauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x1 : positive) (ty1 : T.t), (te_typ e) ! x1 = Some ty1 -> te x1 = ty1) (Q : forall x1 y : positive, In (x1, y) (te_equ e) -> te x1 = te y) (E : (te_typ e) ! x = None) (x0 : positive) (ty0 : T.t) (e0 : x0 = x) (H1 : Some ty = Some ty0) : te x0 = ty0.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : te x = ty) (P : forall (x1 : positive) (ty1 : T.t), (te_typ e) ! x1 = Some ty1 -> te x1 = ty1) (Q : forall x1 y : positive, In (x1, y) (te_equ e) -> te x1 = te y) (E : (te_typ e) ! x = None) (x0 : positive) (ty0 : T.t) (n : x0 <> x) (H1 : (te_typ e) ! x0 = Some ty0) : te x0 = ty0.","proofString":"eauto."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) : exists e' : typenv, OK e = OK e' /\\ satisf te e'.","proofString":"econstructor; eauto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nmap te xl = tyl ->\nexists e' : typenv, set_list e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) : exists e' : typenv,\n  (do e1 <- set e a (te a); set_list e1 xl (map te xl)) = OK e' /\\\n  satisf te e'.","proofString":"exploit (set_complete te e a (te a)); auto.\nintros (e1 & P & Q).\nexploit (IHxl (map te xl) e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nmap te xl = tyl ->\nexists e' : typenv, set_list e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) : (exists e' : typenv, set e a (te a) = OK e' /\\ satisf te e') ->\nexists e' : typenv,\n  (do e1 <- set e a (te a); set_list e1 xl (map te xl)) = OK e' /\\\n  satisf te e'.","proofString":"intros (e1 & P & Q).\nexploit (IHxl (map te xl) e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nmap te xl = tyl ->\nexists e' : typenv, set_list e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (e1 : typenv) (P : set e a (te a) = OK e1) (Q : satisf te e1) : exists e' : typenv,\n  (do e0 <- set e a (te a); set_list e0 xl (map te xl)) = OK e' /\\\n  satisf te e'.","proofString":"exploit (IHxl (map te xl) e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nmap te xl = tyl ->\nexists e' : typenv, set_list e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (e1 : typenv) (P : set e a (te a) = OK e1) (Q : satisf te e1) : (exists e' : typenv, set_list e1 xl (map te xl) = OK e' /\\ satisf te e') ->\nexists e' : typenv,\n  (do e0 <- set e a (te a); set_list e0 xl (map te xl)) = OK e' /\\\n  satisf te e'.","proofString":"intros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nmap te xl = tyl ->\nexists e' : typenv, set_list e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (e1 : typenv) (P : set e a (te a) = OK e1) (Q : satisf te e1) (e2 : typenv) (U : set_list e1 xl (map te xl) = OK e2) (V : satisf te e2) : exists e' : typenv,\n  (do e0 <- set e a (te a); set_list e0 xl (map te xl)) = OK e' /\\\n  satisf te e'.","proofString":"exists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nmap te xl = tyl ->\nexists e' : typenv, set_list e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (e1 : typenv) (P : set e a (te a) = OK e1) (Q : satisf te e1) (e2 : typenv) (U : set_list e1 xl (map te xl) = OK e2) (V : satisf te e2) : (do e0 <- set e a (te a); set_list e0 xl (map te xl)) = OK e2.","proofString":"rewrite P; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) : exists (changed : bool) (e' : typenv),\n  (if peq r1 r2\n   then OK (false, e)\n   else\n    match (te_typ e) ! r1 with\n    | Some ty1 =>\n        match (te_typ e) ! r2 with\n        | Some ty2 =>\n            if T.eq ty1 ty2\n            then OK (false, e)\n            else\n             Error\n               (MSG \"ill-typed move from \"\n                :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n        | None =>\n            OK\n              (true,\n               {|\n                 te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e\n               |})\n        end\n    | None =>\n        match (te_typ e) ! r2 with\n        | Some ty2 =>\n            OK\n              (true,\n               {|\n                 te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e\n               |})\n        | None =>\n            OK\n              (false,\n               {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n        end\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"elim H; intros P Q.\nassert (Q': forall x y, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y).\nintros.\ndestruct H1; auto.\ncongruence.\ndestruct (peq r1 r2).\neconstructor; econstructor; eauto.\ndestruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\nreplace ty2 with ty1.\nrewrite dec_eq_true.\neconstructor; econstructor; eauto.\nexploit (P r1); eauto.\nexploit (P r2); eauto.\ncongruence.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) : exists (changed : bool) (e' : typenv),\n  (if peq r1 r2\n   then OK (false, e)\n   else\n    match (te_typ e) ! r1 with\n    | Some ty1 =>\n        match (te_typ e) ! r2 with\n        | Some ty2 =>\n            if T.eq ty1 ty2\n            then OK (false, e)\n            else\n             Error\n               (MSG \"ill-typed move from \"\n                :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n        | None =>\n            OK\n              (true,\n               {|\n                 te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e\n               |})\n        end\n    | None =>\n        match (te_typ e) ! r2 with\n        | Some ty2 =>\n            OK\n              (true,\n               {|\n                 te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e\n               |})\n        | None =>\n            OK\n              (false,\n               {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n        end\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"assert (Q': forall x y, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y).\nintros.\ndestruct H1; auto.\ncongruence.\ndestruct (peq r1 r2).\neconstructor; econstructor; eauto.\ndestruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\nreplace ty2 with ty1.\nrewrite dec_eq_true.\neconstructor; econstructor; eauto.\nexploit (P r1); eauto.\nexploit (P r2); eauto.\ncongruence.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y.","proofString":"intros.\ndestruct H1; auto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty : T.t), (te_typ e) ! x0 = Some ty -> te x0 = ty) (Q : forall x0 y0 : positive, In (x0, y0) (te_equ e) -> te x0 = te y0) (x y : positive) (H1 : In (x, y) ((r1, r2) :: te_equ e)) : te x = te y.","proofString":"destruct H1; auto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty : T.t), (te_typ e) ! x0 = Some ty -> te x0 = ty) (Q : forall x0 y0 : positive, In (x0, y0) (te_equ e) -> te x0 = te y0) (x y : positive) (H1 : (r1, r2) = (x, y)) : te x = te y.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) : exists (changed : bool) (e' : typenv),\n  (if peq r1 r2\n   then OK (false, e)\n   else\n    match (te_typ e) ! r1 with\n    | Some ty1 =>\n        match (te_typ e) ! r2 with\n        | Some ty2 =>\n            if T.eq ty1 ty2\n            then OK (false, e)\n            else\n             Error\n               (MSG \"ill-typed move from \"\n                :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n        | None =>\n            OK\n              (true,\n               {|\n                 te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e\n               |})\n        end\n    | None =>\n        match (te_typ e) ! r2 with\n        | Some ty2 =>\n            OK\n              (true,\n               {|\n                 te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e\n               |})\n        | None =>\n            OK\n              (false,\n               {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n        end\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"destruct (peq r1 r2).\neconstructor; econstructor; eauto.\ndestruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\nreplace ty2 with ty1.\nrewrite dec_eq_true.\neconstructor; econstructor; eauto.\nexploit (P r1); eauto.\nexploit (P r2); eauto.\ncongruence.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (e0 : r1 = r2) : exists (changed : bool) (e' : typenv),\n  OK (false, e) = OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) : exists (changed : bool) (e' : typenv),\n  match (te_typ e) ! r1 with\n  | Some ty1 =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          if T.eq ty1 ty2\n          then OK (false, e)\n          else\n           Error\n             (MSG \"ill-typed move from \"\n              :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n      | None =>\n          OK\n            (true,\n             {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some ty2 =>\n          OK\n            (true,\n             {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |})\n      end\n  end = OK (changed, e') /\\ satisf te e'.","proofString":"destruct (te_typ e)!r1 as [ty1|] eqn:E1;  destruct (te_typ e)!r2 as [ty2|] eqn:E2.\nreplace ty2 with ty1.\nrewrite dec_eq_true.\neconstructor; econstructor; eauto.\nexploit (P r1); eauto.\nexploit (P r2); eauto.\ncongruence.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto.\neconstructor; econstructor; split; eauto.\nsplit; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : exists (changed : bool) (e' : typenv),\n  (if T.eq ty1 ty2\n   then OK (false, e)\n   else\n    Error\n      (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)) =\n  OK (changed, e') /\\ satisf te e'.","proofString":"replace ty2 with ty1.\nrewrite dec_eq_true.\neconstructor; econstructor; eauto.\nexploit (P r1); eauto.\nexploit (P r2); eauto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : exists (changed : bool) (e' : typenv),\n  (if T.eq ty1 ty1\n   then OK (false, e)\n   else\n    Error\n      (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)) =\n  OK (changed, e') /\\ satisf te e'.","proofString":"rewrite dec_eq_true.\neconstructor; econstructor; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : exists (changed : bool) (e' : typenv),\n  OK (false, e) = OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : ty1 = ty2.","proofString":"exploit (P r1); eauto.\nexploit (P r2); eauto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : te r1 = ty1 -> ty1 = ty2.","proofString":"exploit (P r2); eauto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : te r2 = ty2 -> te r1 = ty1 -> ty1 = ty2.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) : exists (changed : bool) (e' : typenv),\n  OK (true, {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |}) =\n  OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) : satisf te {| te_typ := PTree.set r2 ty1 (te_typ e); te_equ := te_equ e |}.","proofString":"split; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (x : positive) (ty : T.t) (H1 : (PTree.set r2 ty1 (te_typ e)) ! x = Some ty) : te x = ty.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (x : positive) (ty : T.t) (H1 : (if peq x r2 then Some ty1 else (te_typ e) ! x) = Some ty) : te x = ty.","proofString":"destruct (peq x r2).\ninv H1.\nrewrite <- H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (x : positive) (ty : T.t) (e0 : x = r2) (H1 : Some ty1 = Some ty) : te x = ty.","proofString":"inv H1.\nrewrite <- H0.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty0 : T.t), (te_typ e) ! x = Some ty0 -> te x = ty0) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty : T.t) (E1 : (te_typ e) ! r1 = Some ty) (E2 : (te_typ e) ! r2 = None) : te r2 = ty.","proofString":"rewrite <- H0.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty0 : T.t), (te_typ e) ! x = Some ty0 -> te x = ty0) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (ty : T.t) (E1 : (te_typ e) ! r1 = Some ty) (E2 : (te_typ e) ! r2 = None) : te r1 = ty.","proofString":"eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (ty1 : T.t) (E1 : (te_typ e) ! r1 = Some ty1) (E2 : (te_typ e) ! r2 = None) (x : positive) (ty : T.t) (n0 : x <> r2) (H1 : (te_typ e) ! x = Some ty) : te x = ty.","proofString":"eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : exists (changed : bool) (e' : typenv),\n  OK (true, {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |}) =\n  OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; split; eauto.\nsplit; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) : satisf te {| te_typ := PTree.set r1 ty2 (te_typ e); te_equ := te_equ e |}.","proofString":"split; simpl; intros; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (x : positive) (ty : T.t) (H1 : (PTree.set r1 ty2 (te_typ e)) ! x = Some ty) : te x = ty.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (x : positive) (ty : T.t) (H1 : (if peq x r1 then Some ty2 else (te_typ e) ! x) = Some ty) : te x = ty.","proofString":"destruct (peq x r1).\ninv H1.\nrewrite H0.\neauto.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (x : positive) (ty : T.t) (e0 : x = r1) (H1 : Some ty2 = Some ty) : te x = ty.","proofString":"inv H1.\nrewrite H0.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty0 : T.t), (te_typ e) ! x = Some ty0 -> te x = ty0) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty : T.t) (E2 : (te_typ e) ! r2 = Some ty) : te r1 = ty.","proofString":"rewrite H0.\neauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty0 : T.t), (te_typ e) ! x = Some ty0 -> te x = ty0) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty : T.t) (E2 : (te_typ e) ! r2 = Some ty) : te r2 = ty.","proofString":"eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x0 : positive) (ty0 : T.t), (te_typ e) ! x0 = Some ty0 -> te x0 = ty0) (Q : forall x0 y : positive, In (x0, y) (te_equ e) -> te x0 = te y) (Q' : forall x0 y : positive, In (x0, y) ((r1, r2) :: te_equ e) -> te x0 = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (ty2 : T.t) (E2 : (te_typ e) ! r2 = Some ty2) (x : positive) (ty : T.t) (n0 : x <> r1) (H1 : (te_typ e) ! x = Some ty) : te x = ty.","proofString":"eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) : exists (changed : bool) (e' : typenv),\n  OK (false, {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |}) =\n  OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; split; eauto.\nsplit; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : te r1 = te r2) (P : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (Q : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) (Q' : forall x y : positive, In (x, y) ((r1, r2) :: te_equ e) -> te x = te y) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) : satisf te {| te_typ := te_typ e; te_equ := (r1, r2) :: te_equ e |}.","proofString":"split; eauto."},{"statement":"(te : typassign) (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r1 r2 : positive, False -> te r1 = te r2) : exists (e' : typenv) (changed' : bool),\n  OK (e, changed) = OK (e', changed') /\\ satisf te e'.","proofString":"econstructor; econstructor; eauto."},{"statement":"(te : typassign) (a : positive * positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r1 r2 : positive, In (r1, r2) q -> te r1 = te r2) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r1 r2 : positive, a = (r1, r2) \\/ In (r1, r2) q -> te r1 = te r2) : exists (e' : typenv) (changed' : bool),\n  (let (r1, r2) := a in\n   do (changed1, e1)<- move e r1 r2; solve_rec e1 (changed || changed1) q) =\n  OK (e', changed') /\\ satisf te e'.","proofString":"destruct a as [r1 r2].\nexploit (move_complete te e r1 r2); auto.\nintros (changed1 & e1 & A & B).\nexploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> te r3 = te r4) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> te r0 = te r3) : exists (e' : typenv) (changed' : bool),\n  (do (changed1, e1)<- move e r1 r2; solve_rec e1 (changed || changed1) q) =\n  OK (e', changed') /\\ satisf te e'.","proofString":"exploit (move_complete te e r1 r2); auto.\nintros (changed1 & e1 & A & B).\nexploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> te r3 = te r4) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> te r0 = te r3) : (exists (changed0 : bool) (e' : typenv),\n   move e r1 r2 = OK (changed0, e') /\\ satisf te e') ->\nexists (e' : typenv) (changed' : bool),\n  (do (changed1, e1)<- move e r1 r2; solve_rec e1 (changed || changed1) q) =\n  OK (e', changed') /\\ satisf te e'.","proofString":"intros (changed1 & e1 & A & B).\nexploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> te r3 = te r4) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> te r0 = te r3) (changed1 : bool) (e1 : typenv) (A : move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) : exists (e' : typenv) (changed' : bool),\n  (do (changed0, e0)<- move e r1 r2; solve_rec e0 (changed || changed0) q) =\n  OK (e', changed') /\\ satisf te e'.","proofString":"exploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> te r3 = te r4) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> te r0 = te r3) (changed1 : bool) (e1 : typenv) (A : move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) : (exists (e' : typenv) (changed' : bool),\n   solve_rec e1 (changed || changed1) q = OK (e', changed') /\\ satisf te e') ->\nexists (e' : typenv) (changed' : bool),\n  (do (changed0, e0)<- move e r1 r2; solve_rec e0 (changed || changed0) q) =\n  OK (e', changed') /\\ satisf te e'.","proofString":"intros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> te r3 = te r4) ->\nexists (e'0 : typenv) (changed'0 : bool),\n  solve_rec e0 changed0 q = OK (e'0, changed'0) /\\ satisf te e'0) (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> te r0 = te r3) (changed1 : bool) (e1 : typenv) (A : move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) (e' : typenv) (changed' : bool) (C : solve_rec e1 (changed || changed1) q = OK (e', changed')) (D : satisf te e') : exists (e'0 : typenv) (changed'0 : bool),\n  (do (changed0, e0)<- move e r1 r2; solve_rec e0 (changed || changed0) q) =\n  OK (e'0, changed'0) /\\ satisf te e'0.","proofString":"exists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> te r3 = te r4) ->\nexists (e'0 : typenv) (changed'0 : bool),\n  solve_rec e0 changed0 q = OK (e'0, changed'0) /\\ satisf te e'0) (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> te r0 = te r3) (changed1 : bool) (e1 : typenv) (A : move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) (e' : typenv) (changed' : bool) (C : solve_rec e1 (changed || changed1) q = OK (e', changed')) (D : satisf te e') : (do (changed0, e0)<- move e r1 r2; solve_rec e0 (changed || changed0) q) =\nOK (e', changed') /\\ satisf te e'.","proofString":"rewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (e : typenv) : satisf te e ->\nexists e' : typenv, solve_constraints e = OK e' /\\ satisf te e'.","proofString":"functional induction (solve_constraints e); intros.\nexists e; auto.\nexploit (solve_rec_complete te (te_equ e) {| te_typ := te_typ e; te_equ := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\napply IHr.\ncongruence.\nexploit (solve_rec_complete te (te_equ e) {| te_typ := te_typ e; te_equ := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', false)) (H : satisf te e) : exists e'0 : typenv, OK e = OK e'0 /\\ satisf te e'0.","proofString":"exists e; auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : exists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0.","proofString":"exploit (solve_rec_complete te (te_equ e) {| te_typ := te_typ e; te_equ := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\napply IHr.\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : satisf te {| te_typ := te_typ e; te_equ := nil |}.","proofString":"destruct H; split; auto.\nsimpl; tauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (H0 : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) : forall x y : positive,\nIn (x, y) (te_equ {| te_typ := te_typ e; te_equ := nil |}) -> te x = te y.","proofString":"simpl; tauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : forall r1 r2 : positive, In (r1, r2) (te_equ e) -> te r1 = te r2.","proofString":"destruct H; auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : (exists (e'0 : typenv) (changed' : bool),\n   solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\n   OK (e'0, changed') /\\ satisf te e'0) ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0.","proofString":"intros (e1 & changed1 & P & Q).\napply IHr.\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) (e1 : typenv) (changed1 : bool) (P : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e1, changed1)) (Q : satisf te e1) : exists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0.","proofString":"apply IHr.\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) (e1 : typenv) (changed1 : bool) (P : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e1, changed1)) (Q : satisf te e1) : satisf te e'.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (H : satisf te e) : exists e' : typenv, Error msg = OK e' /\\ satisf te e'.","proofString":"exploit (solve_rec_complete te (te_equ e) {| te_typ := te_typ e; te_equ := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\ncongruence."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (H : satisf te e) : satisf te {| te_typ := te_typ e; te_equ := nil |}.","proofString":"destruct H; split; auto.\nsimpl; tauto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (H : forall (x : positive) (ty : T.t), (te_typ e) ! x = Some ty -> te x = ty) (H0 : forall x y : positive, In (x, y) (te_equ e) -> te x = te y) : forall x y : positive,\nIn (x, y) (te_equ {| te_typ := te_typ e; te_equ := nil |}) -> te x = te y.","proofString":"simpl; tauto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (H : satisf te e) : forall r1 r2 : positive, In (r1, r2) (te_equ e) -> te r1 = te r2.","proofString":"destruct H; auto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (H : satisf te e) : (exists (e' : typenv) (changed' : bool),\n   solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\n   OK (e', changed') /\\ satisf te e') ->\nexists e' : typenv, Error msg = OK e' /\\ satisf te e'.","proofString":"intros (e1 & changed1 & P & Q).\ncongruence."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nError msg) (H : satisf te e) (e1 : typenv) (changed1 : bool) (P : solve_rec {| te_typ := te_typ e; te_equ := nil |} false (te_equ e) =\nOK (e1, changed1)) (Q : satisf te e1) : exists e' : typenv, Error msg = OK e' /\\ satisf te e'.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) : exists te' : typassign, solve e = OK te'.","proofString":"unfold solve.\ndestruct (solve_constraints_complete te e H) as (e' & P & Q).\neconstructor.\nrewrite P.\nsimpl.\neauto."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) : exists te' : typassign,\n  (do e' <- solve_constraints e; OK (makeassign e')) = OK te'.","proofString":"destruct (solve_constraints_complete te e H) as (e' & P & Q).\neconstructor.\nrewrite P.\nsimpl.\neauto."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) (e' : typenv) (P : solve_constraints e = OK e') (Q : satisf te e') : exists te' : typassign,\n  (do e'0 <- solve_constraints e; OK (makeassign e'0)) = OK te'.","proofString":"econstructor.\nrewrite P.\nsimpl.\neauto."}]}