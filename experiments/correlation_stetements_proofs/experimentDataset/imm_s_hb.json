[{"statement":"Lemma hb_trans : transitive hb.","proof":"vauto.\n"},{"statement":"Lemma sb_in_hb : sb ⊆ hb.","proof":"vauto.\n"},{"statement":"Lemma sw_in_hb : sw ⊆ hb.","proof":"vauto.\n"},{"statement":"Lemma cr_hb_hb : hb^? ⨾ hb ≡ hb.","proof":"generalize hb_trans; basic_solver.\n"},{"statement":"Lemma cr_hb_cr_hb : hb^? ⨾ hb^? ≡ hb^?.","proof":"generalize hb_trans; basic_solver 20.\n"},{"statement":"Lemma hb_sb_sw : hb ≡ hb^? ⨾ (sb ∪ sw).","proof":"unfold hb; rewrite ct_end at 1; rels.\n"},{"statement":"Lemma loceq_rs WF : funeq loc rs.","proof":"destruct WF; unfold rs; desf; eauto 10 with hahn.\n"},{"statement":"Lemma wf_rsE WF : rs ≡ ⦗W⦘ ∪ ⦗E⦘ ⨾ rs ⨾ ⦗E⦘.","proof":"unfold rs.\nsplit; [|basic_solver 12].\nrewrite rtE; relsf; unionL.\nrewrite wf_sbE; basic_solver 21.\nunionR right -> right.\nrewrite (dom_r (wf_rmwE WF)) at 1.\nrewrite <- !seqA.\nsin_rewrite inclusion_ct_seq_eqv_r.\nrewrite !seqA.\narewrite (⦗E⦘ ⨾ ⦗W⦘ ≡ ⦗W⦘ ⨾ ⦗E⦘) by basic_solver.\nhahn_frame.\nrewrite ct_begin.\nrewrite (dom_l (@wf_sbE G)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nbasic_solver 21.\n"},{"statement":"Lemma wf_releaseE WF : release ≡ ⦗W ∩₁ Rel⦘ ∪ ⦗E⦘ ⨾ release ⨾ ⦗E⦘.","proof":"unfold release.\nrewrite (wf_rsE WF).\nrewrite (@wf_sbE G) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_swE_right WF : sw ≡ sw ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold sw.\nrewrite wf_sbE at 1 2.\nrewrite (wf_rfE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_swE WF : sw ≡ ⦗E⦘ ⨾ sw ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nrewrite (wf_swE_right WF) at 1.\nhahn_frame.\nunfold sw.\nrewrite (wf_releaseE WF).\nrewrite (dom_l (wf_rfE WF)).\nrewrite (dom_l (@wf_sbE G)).\nbasic_solver 40.\n"},{"statement":"Lemma wf_hbE WF : hb ≡ ⦗E⦘ ⨾ hb ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold hb.\nrewrite <- inclusion_ct_seq_eqv_r, <- inclusion_ct_seq_eqv_l.\napply inclusion_t_t.\nrewrite wf_sbE at 1.\nrewrite (wf_swE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_rsD WF : rs ≡ ⦗W⦘ ⨾ rs ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\nunfold rs.\nrewrite rtE; relsf; unionL; [basic_solver 12|].\nrewrite (dom_r (wf_rmwD WF)) at 1.\nrewrite <- !seqA.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver 42.\n"},{"statement":"Lemma wf_releaseD WF : release ≡ ⦗FW∩₁Rel⦘ ⨾ release ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\nunfold release.\nrewrite (wf_rsD WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_swD WF : sw ≡ ⦗FW∩₁Rel⦘ ⨾ sw ⨾ ⦗FR∩₁Acq⦘.","proof":"split; [|basic_solver].\nunfold sw.\nrewrite (wf_releaseD WF) at 1.\nrewrite (wf_rfD WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma no_release_from_init WF: release ≡ ⦗set_compl is_init⦘ ⨾ release.","proof":"split; [| basic_solver].\napply doma_helper.\nunfold release.\nrewrite init_pln; eauto.\nmode_solver.\n"},{"statement":"Lemma no_sw_to_init WF : sw ≡ sw ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nrewrite (wf_swD WF) at 1.\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42.\n"},{"statement":"Lemma no_hb_to_init WF : hb ≡ hb ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nunfold hb.\nrewrite ct_end.\nrewrite (no_sw_to_init WF) at 2.\nrewrite no_sb_to_init at 2.\nbasic_solver 42.\n"},{"statement":"Lemma release_rf_in_sw WF: release ⨾ rf ⨾ ⦗Acq⦘ ⊆ sw.","proof":"rewrite (wf_rfD WF); unfold sw; basic_solver 42.\n"},{"statement":"Lemma sw_in_release_rf WF: \n  sw ⨾ ⦗R⦘ ⊆ release ⨾ rf ⨾ ⦗Acq⦘.","proof":"unfold sw; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗R⦘ ⊆ ⦗Acq⦘) by type_solver 42.\n"},{"statement":"Lemma rs_in_co WF SC_PER_LOC : rs ⊆ ⦗W⦘ ⨾ co^?.","proof":"unfold rs.\nassert (A: ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ ⦗W⦘ ⨾ co^?).\n{\narewrite (⦗W⦘ ⊆ ⦗W⦘ ⨾ ⦗W⦘) at 1 by basic_solver.\nrewrite crE; relsf; unionL; [basic_solver|].\nsin_rewrite (w_sb_loc_w_in_coi WF SC_PER_LOC).\nsin_rewrite (dom_l (wf_coiD WF)).\nie_unfolder; basic_solver.\n}\nrewrite rtE; relsf; unionL; [done|].\nsin_rewrite !(rf_rmw_in_co WF SC_PER_LOC).\nsin_rewrite (dom_r (wf_coD WF)).\nsin_rewrite A.\nrewrite !seqA.\nhahn_frame.\narewrite_id ⦗W⦘.\ngeneralize (co_trans WF); ins; relsf.\n"},{"statement":"Lemma release_in_hb_co WF SC_PER_LOC : release ⊆ (hb^? ⨾ co^?).","proof":"unfold release; rewrite rs_in_co; try done.\nrewrite sb_in_hb; basic_solver 10.\n"},{"statement":"Lemma hb_W WF : hb ⨾ ⦗ W ⦘ ⊆ (hb ⨾ ⦗FR∩₁Acq⦘)^? ⨾ sb.","proof":"unfold hb; rewrite path_ut_last at 1.\ngeneralize (@sb_trans G); ins; relsf; unionL.\nbasic_solver.\nrewrite !seqA; rewrite (dom_r (wf_swD WF)) at 2.\nrewrite !seqA.\narewrite (sw ⊆ (sb ∪ sw)＊) at 2.\nrewrite crE; relsf; unionL.\ntype_solver.\nbasic_solver 12.\n"},{"statement":"Lemma hb_first_Rel WF : hb ⊆ sb ∪ sb^? ⨾ ⦗FW ∩₁ Rel⦘ ⨾ hb.","proof":"unfold hb.\nrewrite path_ut_first at 1.\ngeneralize (@sb_trans G); ins; relsf; unionL.\nbasic_solver.\nrewrite (dom_l (wf_swE WF)) at 1.\nrewrite (dom_l (wf_swD WF)) at 1.\narewrite (sw ⊆ (sb ∪ sw)⁺) at 1; relsf.\nbasic_solver 21.\n"},{"statement":"Lemma release_int : release ⊆ release ⨾ ⦗W_ex⦘ ∪ ⦗F ∩₁ Rel⦘ ⨾ sb ⨾ ⦗W⦘ ∪ \n  ⦗W ∩₁ Rel⦘ ⨾  (sb ∩ same_loc)^? ⨾ ⦗W⦘.","proof":"unfold release, rs.\nrewrite rtE; relsf; unionL.\ngeneralize (@sb_trans G); basic_solver 21.\nrewrite rmw_W_ex at 1.\nrewrite <- !seqA, inclusion_ct_seq_eqv_r, !seqA.\nbasic_solver 21.\n"},{"statement":"Lemma release_rf_rmw_step : release ⨾ rf ⨾ rmw ⊆ release.","proof":"unfold release at 1.\nunfold rs.\nrewrite !seqA.\narewrite (rf ⨾ rmw ⊆ (rf ⨾ rmw)＊) at 2.\nby rewrite rt_rt.\n"},{"statement":"Lemma release_rf_rmw_steps : release ⨾ (rf ⨾ rmw)＊ ⊆ release.","proof":"unfold release at 1.\nunfold rs.\nrewrite !seqA.\nby rewrite rt_rt.\n"},{"statement":"Lemma coherence_sc_per_loc COH : sc_per_loc G.","proof":"red; rewrite sb_in_hb.\nred in COH; unfolder in *; basic_solver 12.\n"},{"statement":"Lemma hb_irr WF COH : irreflexive hb.","proof":"red in COH.\nunfolder in *; eauto 20.\n"},{"statement":"Proposition coherence_alt :\n  irreflexive (hb ∪ hb ⨾ rfe ∪ hb ⨾ co ∪ hb ⨾ co ⨾ rfe ∪ hb ⨾ fr ∪ hb ⨾ fr ⨾ rfe) -> coherence.","proof":"unfold coherence; unfold Execution_eco.eco; relsf.\nrewrite rfi_union_rfe; relsf.\narewrite (rfi ⊆ sb); rewrite sb_in_hb; rewrite !crE; relsf.\nins; unionL.\nall: try rotate 1.\nall: generalize hb_trans; ins; relsf.\nall: try (unfolder in *; basic_solver 12).\n"}]