{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/hardware/HardwareFairness.v","fileSamples":[{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) (x : BinNums.positive) (IN : BinPos.Pos.compare x b = Lt) : BinPos.Pos.to_nat x < Datatypes.S (BinPos.Pos.to_nat b).","proofString":"apply Pnat.Pos2Nat.inj_lt in IN.\nlia."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) (x : BinNums.positive) (IN : BinPos.Pos.to_nat x < BinPos.Pos.to_nat b) : BinPos.Pos.to_nat x < Datatypes.S (BinPos.Pos.to_nat b).","proofString":"lia."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) : ~\nset_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a)).","proofString":"intros FIN.\ndestruct INF.\nrewrite set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : False.","proofString":"destruct INF.\nrewrite set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (f ↓₁ S).","proofString":"rewrite set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (f ↓₁ (⋃₁b0, S ∩₁ Tid_ b0)).","proofString":"rewrite set_map_bunion.\nrewrite set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (⋃₁x, f ↓₁ (S ∩₁ Tid_ x)).","proofString":"rewrite set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite\n  (⋃₁x ∈ flip BinPos.Pos.lt b ∪₁ set_compl (flip BinPos.Pos.lt b),\n    f ↓₁ (S ∩₁ Tid_ x)).","proofString":"rewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (⋃₁x ∈ flip BinPos.Pos.lt b, f ↓₁ (S ∩₁ Tid_ x)) /\\\nset_finite (⋃₁x ∈ set_compl (flip BinPos.Pos.lt b), f ↓₁ (S ∩₁ Tid_ x)).","proofString":"split; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (⋃₁x ∈ set_compl (flip BinPos.Pos.lt b), f ↓₁ (S ∩₁ Tid_ x)).","proofString":"exists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (IN : (⋃₁x0 ∈ set_compl (flip BinPos.Pos.lt b), f ↓₁ (S ∩₁ Tid_ x0)) x) : False.","proofString":"unfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (IN : exists y : BinNums.positive,\n  ~ flip BinPos.Pos.lt b y /\\ S (f x) /\\ tid (f x) = y) : False.","proofString":"desc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN : ~ flip BinPos.Pos.lt b y) (IN0 : S (f x)) (IN1 : tid (f x) = y) : False.","proofString":"destruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : flip BinPos.Pos.lt b y.","proofString":"red.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : BinPos.Pos.lt y b.","proofString":"rewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : BinPos.Pos.lt (tid (f x)) b.","proofString":"apply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : E (f x).","proofString":"apply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : (f ↑₁ ⊤₁) (f x).","proofString":"vauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) : ~ set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a)).","proofString":"intros FIN.\ndestruct INF.\nrewrite set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : False.","proofString":"destruct INF.\nrewrite set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (f ↓₁ S).","proofString":"rewrite set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (f ↓₁ (⋃₁b, S ∩₁ Loc_ b)).","proofString":"rewrite set_map_bunion.\nrewrite set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (⋃₁x, f ↓₁ (S ∩₁ Loc_ x)).","proofString":"rewrite set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite\n  (⋃₁\n    x ∈ (fun l : option location => In l locs)\n        ∪₁ set_compl (fun l : option location => In l locs),\n    f ↓₁ (S ∩₁ Loc_ x)).","proofString":"rewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (⋃₁x ∈ fun l : option location => In l locs, f ↓₁ (S ∩₁ Loc_ x)) /\\\nset_finite\n  (⋃₁x ∈ set_compl (fun l : option location => In l locs), f ↓₁ (S ∩₁ Loc_ x)).","proofString":"split; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite\n  (⋃₁x ∈ set_compl (fun l : option location => In l locs), f ↓₁ (S ∩₁ Loc_ x)).","proofString":"exists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (IN : (⋃₁x0 ∈ set_compl (fun l : option location => In l locs), f ↓₁ (S ∩₁ Loc_ x0))\n  x) : False.","proofString":"unfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (IN : exists y : option location, ~ In y locs /\\ S (f x) /\\ loc (f x) = y) : False.","proofString":"desc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN : ~ In y locs) (IN0 : S (f x)) (IN1 : loc (f x) = y) : False.","proofString":"destruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : In y locs.","proofString":"rewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : In (loc (f x)) locs.","proofString":"apply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : (E \\₁ (fun a : actid => is_init a)) (f x).","proofString":"apply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : (f ↑₁ ⊤₁) (f x).","proofString":"vauto."}]}