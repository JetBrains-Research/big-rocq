{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Linking.v","fileSamples":[{"statement":"(p : program F V) (E : (if\n  ident_eq (prog_main p1) (prog_main p2) &&\n  PTree_Properties.for_all dm1 link_prog_check\n then\n  Some\n    {|\n      prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n      prog_public := prog_public p1 ++ prog_public p2;\n      prog_main := prog_main p1\n    |}\n else None) = Some p) : prog_main p1 = prog_main p2 /\\\n(forall (id : positive) (gd1 gd2 : globdef F V),\n dm1 ! id = Some gd1 ->\n dm2 ! id = Some gd2 ->\n In id (prog_public p1) /\\\n In id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd)) /\\\np =\n{|\n  prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}.","proofString":"destruct (ident_eq (prog_main p1) (prog_main p2)); try discriminate.\ndestruct (PTree_Properties.for_all dm1 link_prog_check) eqn:C; inv E.\nrewrite PTree_Properties.for_all_correct in C.\nsplit; auto.\nsplit; auto.\nintros.\nexploit C; eauto.\nunfold link_prog_check.\nrewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : PTree_Properties.for_all dm1 link_prog_check = true) : prog_main p1 = prog_main p2 /\\\n(forall (id : positive) (gd1 gd2 : globdef F V),\n dm1 ! id = Some gd1 ->\n dm2 ! id = Some gd2 ->\n In id (prog_public p1) /\\\n In id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd)) /\\\n{|\n  prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|} =\n{|\n  prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}.","proofString":"rewrite PTree_Properties.for_all_correct in C.\nsplit; auto.\nsplit; auto.\nintros.\nexploit C; eauto.\nunfold link_prog_check.\nrewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) : prog_main p1 = prog_main p2 /\\\n(forall (id : positive) (gd1 gd2 : globdef F V),\n dm1 ! id = Some gd1 ->\n dm2 ! id = Some gd2 ->\n In id (prog_public p1) /\\\n In id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd)) /\\\n{|\n  prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|} =\n{|\n  prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}.","proofString":"split; auto.\nsplit; auto.\nintros.\nexploit C; eauto.\nunfold link_prog_check.\nrewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) : (forall (id : positive) (gd1 gd2 : globdef F V),\n dm1 ! id = Some gd1 ->\n dm2 ! id = Some gd2 ->\n In id (prog_public p1) /\\\n In id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd)) /\\\n{|\n  prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|} =\n{|\n  prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}.","proofString":"split; auto.\nintros.\nexploit C; eauto.\nunfold link_prog_check.\nrewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd).","proofString":"intros.\nexploit C; eauto.\nunfold link_prog_check.\nrewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) (id : positive) (gd1 gd2 : globdef F V) (H : dm1 ! id = Some gd1) (H0 : dm2 ! id = Some gd2) : In id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd).","proofString":"exploit C; eauto.\nunfold link_prog_check.\nrewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) (id : positive) (gd1 gd2 : globdef F V) (H : dm1 ! id = Some gd1) (H0 : dm2 ! id = Some gd2) : link_prog_check id gd1 = true ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd).","proofString":"unfold link_prog_check.\nrewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) (id : positive) (gd1 gd2 : globdef F V) (H : dm1 ! id = Some gd1) (H0 : dm2 ! id = Some gd2) : match dm2 ! id with\n| Some gd3 =>\n    in_dec peq id (prog_public p1) && in_dec peq id (prog_public p2) &&\n    match link gd1 gd3 with\n    | Some _ => true\n    | None => false\n    end\n| None => true\nend = true ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd).","proofString":"rewrite H0.\nintros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) (id : positive) (gd1 gd2 : globdef F V) (H : dm1 ! id = Some gd1) (H0 : dm2 ! id = Some gd2) : in_dec peq id (prog_public p1) && in_dec peq id (prog_public p2) &&\nmatch link gd1 gd2 with\n| Some _ => true\n| None => false\nend = true ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd).","proofString":"intros.\ndestruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(e : prog_main p1 = prog_main p2) (C : forall (x : PTree.elt) (a : globdef F V),\ndm1 ! x = Some a -> link_prog_check x a = true) (id : positive) (gd1 gd2 : globdef F V) (H : dm1 ! id = Some gd1) (H0 : dm2 ! id = Some gd2) (H1 : in_dec peq id (prog_public p1) && in_dec peq id (prog_public p2) &&\nmatch link gd1 gd2 with\n| Some _ => true\n| None => false\nend = true) : In id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F V, link gd1 gd2 = Some gd).","proofString":"destruct (in_dec peq id (prog_public p1)); try discriminate.\ndestruct (in_dec peq id (prog_public p2)); try discriminate.\ndestruct (link gd1 gd2) eqn:L; try discriminate.\nintuition auto.\nexists g; auto."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) : link_prog =\nSome\n  {|\n    prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"unfold link_prog.\nunfold proj_sumbool.\nrewrite H, dec_eq_true.\nsimpl.\nreplace (PTree_Properties.for_all dm1 link_prog_check) with true; auto.\nsymmetry.\napply PTree_Properties.for_all_correct; intros.\nrename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) : (if\n  ident_eq (prog_main p1) (prog_main p2) &&\n  PTree_Properties.for_all dm1 link_prog_check\n then\n  Some\n    {|\n      prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n      prog_public := prog_public p1 ++ prog_public p2;\n      prog_main := prog_main p1\n    |}\n else None) =\nSome\n  {|\n    prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"unfold proj_sumbool.\nrewrite H, dec_eq_true.\nsimpl.\nreplace (PTree_Properties.for_all dm1 link_prog_check) with true; auto.\nsymmetry.\napply PTree_Properties.for_all_correct; intros.\nrename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) : (if\n  (if ident_eq (prog_main p1) (prog_main p2) then true else false) &&\n  PTree_Properties.for_all dm1 link_prog_check\n then\n  Some\n    {|\n      prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n      prog_public := prog_public p1 ++ prog_public p2;\n      prog_main := prog_main p1\n    |}\n else None) =\nSome\n  {|\n    prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"rewrite H, dec_eq_true.\nsimpl.\nreplace (PTree_Properties.for_all dm1 link_prog_check) with true; auto.\nsymmetry.\napply PTree_Properties.for_all_correct; intros.\nrename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) : (if true && PTree_Properties.for_all dm1 link_prog_check\n then\n  Some\n    {|\n      prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n      prog_public := prog_public p1 ++ prog_public p2;\n      prog_main := prog_main p2\n    |}\n else None) =\nSome\n  {|\n    prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p2\n  |}.","proofString":"simpl.\nreplace (PTree_Properties.for_all dm1 link_prog_check) with true; auto.\nsymmetry.\napply PTree_Properties.for_all_correct; intros.\nrename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) : (if PTree_Properties.for_all dm1 link_prog_check\n then\n  Some\n    {|\n      prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n      prog_public := prog_public p1 ++ prog_public p2;\n      prog_main := prog_main p2\n    |}\n else None) =\nSome\n  {|\n    prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2);\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p2\n  |}.","proofString":"replace (PTree_Properties.for_all dm1 link_prog_check) with true; auto.\nsymmetry.\napply PTree_Properties.for_all_correct; intros.\nrename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) : true = PTree_Properties.for_all dm1 link_prog_check.","proofString":"symmetry.\napply PTree_Properties.for_all_correct; intros.\nrename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) : PTree_Properties.for_all dm1 link_prog_check = true.","proofString":"apply PTree_Properties.for_all_correct; intros.\nrename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd1 gd2 : globdef F V),\ndm1 ! id = Some gd1 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd1 gd2 <> None) (x : PTree.elt) (a : globdef F V) (H1 : dm1 ! x = Some a) : link_prog_check x a = true.","proofString":"rename a into gd1.\nunfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd0 gd2 : globdef F V),\ndm1 ! id = Some gd0 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd0 gd2 <> None) (x : PTree.elt) (gd1 : globdef F V) (H1 : dm1 ! x = Some gd1) : link_prog_check x gd1 = true.","proofString":"unfold link_prog_check.\ndestruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd0 gd2 : globdef F V),\ndm1 ! id = Some gd0 ->\ndm2 ! id = Some gd2 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd0 gd2 <> None) (x : PTree.elt) (gd1 : globdef F V) (H1 : dm1 ! x = Some gd1) : match dm2 ! x with\n| Some gd2 =>\n    in_dec peq x (prog_public p1) && in_dec peq x (prog_public p2) &&\n    match link gd1 gd2 with\n    | Some _ => true\n    | None => false\n    end\n| None => true\nend = true.","proofString":"destruct dm2!x as [gd2|] eqn:G2; auto.\nexploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd0 gd3 : globdef F V),\ndm1 ! id = Some gd0 ->\ndm2 ! id = Some gd3 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd0 gd3 <> None) (x : PTree.elt) (gd1 : globdef F V) (H1 : dm1 ! x = Some gd1) (gd2 : globdef F V) (G2 : dm2 ! x = Some gd2) : in_dec peq x (prog_public p1) && in_dec peq x (prog_public p2) &&\nmatch link gd1 gd2 with\n| Some _ => true\n| None => false\nend = true.","proofString":"exploit H0; eauto.\nintros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd0 gd3 : globdef F V),\ndm1 ! id = Some gd0 ->\ndm2 ! id = Some gd3 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd0 gd3 <> None) (x : PTree.elt) (gd1 : globdef F V) (H1 : dm1 ! x = Some gd1) (gd2 : globdef F V) (G2 : dm2 ! x = Some gd2) : In x (prog_public p1) /\\ In x (prog_public p2) /\\ link gd1 gd2 <> None ->\nin_dec peq x (prog_public p1) && in_dec peq x (prog_public p2) &&\nmatch link gd1 gd2 with\n| Some _ => true\n| None => false\nend = true.","proofString":"intros (P & Q & R).\nunfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd0 gd3 : globdef F V),\ndm1 ! id = Some gd0 ->\ndm2 ! id = Some gd3 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd0 gd3 <> None) (x : PTree.elt) (gd1 : globdef F V) (H1 : dm1 ! x = Some gd1) (gd2 : globdef F V) (G2 : dm2 ! x = Some gd2) (P : In x (prog_public p1)) (Q : In x (prog_public p2)) (R : link gd1 gd2 <> None) : in_dec peq x (prog_public p1) && in_dec peq x (prog_public p2) &&\nmatch link gd1 gd2 with\n| Some _ => true\n| None => false\nend = true.","proofString":"unfold proj_sumbool; rewrite ! pred_dec_true by auto.\ndestruct (link gd1 gd2); auto; discriminate."},{"statement":"(H : prog_main p1 = prog_main p2) (H0 : forall (id : positive) (gd0 gd3 : globdef F V),\ndm1 ! id = Some gd0 ->\ndm2 ! id = Some gd3 ->\nIn id (prog_public p1) /\\ In id (prog_public p2) /\\ link gd0 gd3 <> None) (x : PTree.elt) (gd1 : globdef F V) (H1 : dm1 ! x = Some gd1) (gd2 : globdef F V) (G2 : dm2 ! x = Some gd2) (P : In x (prog_public p1)) (Q : In x (prog_public p2)) (R : link gd1 gd2 <> None) : true && true && match link gd1 gd2 with\n                | Some _ => true\n                | None => false\n                end = true.","proofString":"destruct (link gd1 gd2); auto; discriminate."},{"statement":"(m : PTree.t (globdef F V)) (pub : list ident) (mn : ident) (x : positive) : (prog_defmap\n   {| prog_defs := PTree.elements m; prog_public := pub; prog_main := mn |})\n! x = m ! x.","proofString":"unfold prog_defmap; simpl.\napply PTree_Properties.of_list_elements."},{"statement":"(m : PTree.t (globdef F V)) (pub : list ident) (mn : ident) (x : positive) : (PTree_Properties.of_list (PTree.elements m)) ! x = m ! x.","proofString":"apply PTree_Properties.of_list_elements."},{"statement":"(F : Type) (V : Type) (LF : Linker F) (LV : Linker V) (p1 p2 : program F V) (id : positive) (gd1 : globdef F V) (H : linkorder p1 p2) (H0 : (prog_defmap p1) ! id = Some gd1) : exists gd2 : globdef F V,\n  (prog_defmap p2) ! id = Some gd2 /\\ linkorder gd1 gd2.","proofString":"destruct H as (A & B & C).\nexploit C; eauto.\nintros (gd2 & P & Q & R).\nexists gd2; auto."},{"statement":"(F : Type) (V : Type) (LF : Linker F) (LV : Linker V) (p1 p2 : program F V) (id : positive) (gd1 : globdef F V) (A : prog_main p1 = prog_main p2) (B : incl (prog_public p1) (prog_public p2)) (C : forall (id0 : positive) (gd0 : globdef F V),\n(prog_defmap p1) ! id0 = Some gd0 ->\nexists gd2 : globdef F V,\n  (prog_defmap p2) ! id0 = Some gd2 /\\\n  linkorder gd0 gd2 /\\ (~ In id0 (prog_public p2) -> gd2 = gd0)) (H0 : (prog_defmap p1) ! id = Some gd1) : exists gd2 : globdef F V,\n  (prog_defmap p2) ! id = Some gd2 /\\ linkorder gd1 gd2.","proofString":"exploit C; eauto.\nintros (gd2 & P & Q & R).\nexists gd2; auto."},{"statement":"(F : Type) (V : Type) (LF : Linker F) (LV : Linker V) (p1 p2 : program F V) (id : positive) (gd1 : globdef F V) (A : prog_main p1 = prog_main p2) (B : incl (prog_public p1) (prog_public p2)) (C : forall (id0 : positive) (gd0 : globdef F V),\n(prog_defmap p1) ! id0 = Some gd0 ->\nexists gd2 : globdef F V,\n  (prog_defmap p2) ! id0 = Some gd2 /\\\n  linkorder gd0 gd2 /\\ (~ In id0 (prog_public p2) -> gd2 = gd0)) (H0 : (prog_defmap p1) ! id = Some gd1) : (exists gd2 : globdef F V,\n   (prog_defmap p2) ! id = Some gd2 /\\\n   linkorder gd1 gd2 /\\ (~ In id (prog_public p2) -> gd2 = gd1)) ->\nexists gd2 : globdef F V,\n  (prog_defmap p2) ! id = Some gd2 /\\ linkorder gd1 gd2.","proofString":"intros (gd2 & P & Q & R).\nexists gd2; auto."},{"statement":"(F : Type) (V : Type) (LF : Linker F) (LV : Linker V) (p1 p2 : program F V) (id : positive) (gd1 : globdef F V) (A : prog_main p1 = prog_main p2) (B : incl (prog_public p1) (prog_public p2)) (C : forall (id0 : positive) (gd0 : globdef F V),\n(prog_defmap p1) ! id0 = Some gd0 ->\nexists gd3 : globdef F V,\n  (prog_defmap p2) ! id0 = Some gd3 /\\\n  linkorder gd0 gd3 /\\ (~ In id0 (prog_public p2) -> gd3 = gd0)) (H0 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef F V) (P : (prog_defmap p2) ! id = Some gd2) (Q : linkorder gd1 gd2) (R : ~ In id (prog_public p2) -> gd2 = gd1) : exists gd0 : globdef F V,\n  (prog_defmap p2) ! id = Some gd0 /\\ linkorder gd1 gd0.","proofString":"exists gd2; auto."},{"statement":"(ctx : C) (p1 : program F1 V1) (p2 : program F2 V2) (H : match_program_gen ctx p1 p2) (id : positive) : option_rel (match_globdef ctx) (prog_defmap p1) ! id (prog_defmap p2) ! id.","proofString":"apply PTree_Properties.of_list_related.\napply H."},{"statement":"(ctx : C) (p1 : program F1 V1) (p2 : program F2 V2) (H : match_program_gen ctx p1 p2) (id : positive) : list_forall2\n  (fun (ka : PTree.elt * globdef F1 V1) (kb : PTree.elt * globdef F2 V2) =>\n   fst ka = fst kb /\\ match_globdef ctx (snd ka) (snd kb)) \n  (prog_defs p1) (prog_defs p2).","proofString":"apply H."},{"statement":"(ctx : C) (p1 : program F1 V1) (p2 : program F2 V2) (H : match_program_gen ctx p1 p2) : prog_main p2 = prog_main p1.","proofString":"apply H."},{"statement":"(ctx : C) (p1 : program F1 V1) (p2 : program F2 V2) (H : match_program_gen ctx p1 p2) : prog_public p2 = prog_public p1.","proofString":"apply H."},{"statement":"(F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LF : Linker F1) (LV : Linker V1) (match_fundef : program F1 V1 -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (p1 : program F1 V1) (p2 : program F2 V2) (H : match_program match_fundef match_varinfo p1 p2) : prog_main p2 = prog_main p1.","proofString":"apply H."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (tp : program F2 V2) (H : bind (transf_globdefs transf_fun transf_var (prog_defs p))\n  (fun gl' : list (ident * globdef F2 V2) =>\n   OK\n     {|\n       prog_defs := gl';\n       prog_public := prog_public p;\n       prog_main := prog_main p\n     |}) = OK tp) (H0 : forall (i : ident) (f : F1) (tf : F2),\ntransf_fun i f = OK tf -> match_fundef ctx f tf) (H1 : forall (i : ident) (v : V1) (tv : V2),\ntransf_var i v = OK tv -> match_varinfo v tv) : match_program_gen match_fundef match_varinfo ctx p tp.","proofString":"monadInv H.\nred; simpl; split; auto.\nrevert x EQ.\ngeneralize (prog_defs p).\ninduction l as [ | [i g] l]; simpl; intros.\nmonadInv EQ.\nconstructor.\ndestruct g as [f|v].\ndestruct (transf_fun i f) as [tf|?] eqn:TF; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\neconstructor.\napply linkorder_refl.\neauto.\ndestruct (transf_globvar transf_var i v) as [tv|?] eqn:TV; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\nconstructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i : ident) (f : F1) (tf : F2),\ntransf_fun i f = OK tf -> match_fundef ctx f tf) (H1 : forall (i : ident) (v : V1) (tv : V2),\ntransf_var i v = OK tv -> match_varinfo v tv) (x : list (ident * globdef F2 V2)) (EQ : transf_globdefs transf_fun transf_var (prog_defs p) = OK x) : match_program_gen match_fundef match_varinfo ctx p\n  {|\n    prog_defs := x; prog_public := prog_public p; prog_main := prog_main p\n  |}.","proofString":"red; simpl; split; auto.\nrevert x EQ.\ngeneralize (prog_defs p).\ninduction l as [ | [i g] l]; simpl; intros.\nmonadInv EQ.\nconstructor.\ndestruct g as [f|v].\ndestruct (transf_fun i f) as [tf|?] eqn:TF; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\neconstructor.\napply linkorder_refl.\neauto.\ndestruct (transf_globvar transf_var i v) as [tv|?] eqn:TV; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\nconstructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i : ident) (f : F1) (tf : F2),\ntransf_fun i f = OK tf -> match_fundef ctx f tf) (H1 : forall (i : ident) (v : V1) (tv : V2),\ntransf_var i v = OK tv -> match_varinfo v tv) (x : list (ident * globdef F2 V2)) (EQ : transf_globdefs transf_fun transf_var (prog_defs p) = OK x) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  (prog_defs p) x.","proofString":"revert x EQ.\ngeneralize (prog_defs p).\ninduction l as [ | [i g] l]; simpl; intros.\nmonadInv EQ.\nconstructor.\ndestruct g as [f|v].\ndestruct (transf_fun i f) as [tf|?] eqn:TF; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\neconstructor.\napply linkorder_refl.\neauto.\ndestruct (transf_globvar transf_var i v) as [tv|?] eqn:TV; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\nconstructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i : ident) (f : F1) (tf : F2),\ntransf_fun i f = OK tf -> match_fundef ctx f tf) (H1 : forall (i : ident) (v : V1) (tv : V2),\ntransf_var i v = OK tv -> match_varinfo v tv) (x : list (ident * globdef F2 V2)) (EQ : OK nil = OK x) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) nil x.","proofString":"monadInv EQ.\nconstructor."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i : ident) (f : F1) (tf : F2),\ntransf_fun i f = OK tf -> match_fundef ctx f tf) (H1 : forall (i : ident) (v : V1) (tv : V2),\ntransf_var i v = OK tv -> match_varinfo v tv) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) nil nil.","proofString":"constructor."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v : V1) (tv : V2),\ntransf_var i0 v = OK tv -> match_varinfo v tv) (i : ident) (g : globdef F1 V1) (l : list (ident * globdef F1 V1)) (IHl : forall x0 : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x0 ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x0) (x : list (ident * globdef F2 V2)) (EQ : match g with\n| Gfun f =>\n    match transf_fun i f with\n    | OK tf =>\n        bind (transf_globdefs transf_fun transf_var l)\n          (fun tl' : list (ident * globdef F2 V2) => OK ((i, Gfun tf) :: tl'))\n    | Error msg => Error (MSG \"In function \" :: CTX i :: MSG \": \" :: msg)\n    end\n| Gvar v =>\n    match transf_globvar transf_var i v with\n    | OK tv =>\n        bind (transf_globdefs transf_fun transf_var l)\n          (fun tl' : list (ident * globdef F2 V2) => OK ((i, Gvar tv) :: tl'))\n    | Error msg => Error (MSG \"In variable \" :: CTX i :: MSG \": \" :: msg)\n    end\nend = OK x) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  ((i, g) :: l) x.","proofString":"destruct g as [f|v].\ndestruct (transf_fun i f) as [tf|?] eqn:TF; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\neconstructor.\napply linkorder_refl.\neauto.\ndestruct (transf_globvar transf_var i v) as [tv|?] eqn:TV; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\nconstructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f0 : F1) (tf : F2),\ntransf_fun i0 f0 = OK tf -> match_fundef ctx f0 tf) (H1 : forall (i0 : ident) (v : V1) (tv : V2),\ntransf_var i0 v = OK tv -> match_varinfo v tv) (i : ident) (f : F1) (l : list (ident * globdef F1 V1)) (IHl : forall x0 : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x0 ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x0) (x : list (ident * globdef F2 V2)) (EQ : match transf_fun i f with\n| OK tf =>\n    bind (transf_globdefs transf_fun transf_var l)\n      (fun tl' : list (ident * globdef F2 V2) => OK ((i, Gfun tf) :: tl'))\n| Error msg => Error (MSG \"In function \" :: CTX i :: MSG \": \" :: msg)\nend = OK x) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  ((i, Gfun f) :: l) x.","proofString":"destruct (transf_fun i f) as [tf|?] eqn:TF; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\neconstructor.\napply linkorder_refl.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f0 : F1) (tf0 : F2),\ntransf_fun i0 f0 = OK tf0 -> match_fundef ctx f0 tf0) (H1 : forall (i0 : ident) (v : V1) (tv : V2),\ntransf_var i0 v = OK tv -> match_varinfo v tv) (i : ident) (f : F1) (l : list (ident * globdef F1 V1)) (IHl : forall x : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x) (tf : F2) (TF : transf_fun i f = OK tf) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  ((i, Gfun f) :: l) ((i, Gfun tf) :: x0).","proofString":"constructor; auto.\nsplit; simpl; auto.\neconstructor.\napply linkorder_refl.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f0 : F1) (tf0 : F2),\ntransf_fun i0 f0 = OK tf0 -> match_fundef ctx f0 tf0) (H1 : forall (i0 : ident) (v : V1) (tv : V2),\ntransf_var i0 v = OK tv -> match_varinfo v tv) (i : ident) (f : F1) (l : list (ident * globdef F1 V1)) (IHl : forall x : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x) (tf : F2) (TF : transf_fun i f = OK tf) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) : match_ident_globdef match_fundef match_varinfo ctx (i, Gfun f) (i, Gfun tf).","proofString":"split; simpl; auto.\neconstructor.\napply linkorder_refl.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f0 : F1) (tf0 : F2),\ntransf_fun i0 f0 = OK tf0 -> match_fundef ctx f0 tf0) (H1 : forall (i0 : ident) (v : V1) (tv : V2),\ntransf_var i0 v = OK tv -> match_varinfo v tv) (i : ident) (f : F1) (l : list (ident * globdef F1 V1)) (IHl : forall x : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x) (tf : F2) (TF : transf_fun i f = OK tf) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) : match_globdef match_fundef match_varinfo ctx (Gfun f) (Gfun tf).","proofString":"econstructor.\napply linkorder_refl.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v0 : V1) (tv : V2),\ntransf_var i0 v0 = OK tv -> match_varinfo v0 tv) (i : ident) (v : globvar V1) (l : list (ident * globdef F1 V1)) (IHl : forall x0 : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x0 ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x0) (x : list (ident * globdef F2 V2)) (EQ : match transf_globvar transf_var i v with\n| OK tv =>\n    bind (transf_globdefs transf_fun transf_var l)\n      (fun tl' : list (ident * globdef F2 V2) => OK ((i, Gvar tv) :: tl'))\n| Error msg => Error (MSG \"In variable \" :: CTX i :: MSG \": \" :: msg)\nend = OK x) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  ((i, Gvar v) :: l) x.","proofString":"destruct (transf_globvar transf_var i v) as [tv|?] eqn:TV; monadInv EQ.\nconstructor; auto.\nsplit; simpl; auto.\nconstructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v0 : V1) (tv0 : V2),\ntransf_var i0 v0 = OK tv0 -> match_varinfo v0 tv0) (i : ident) (v : globvar V1) (l : list (ident * globdef F1 V1)) (IHl : forall x : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x) (tv : globvar V2) (TV : transf_globvar transf_var i v = OK tv) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  ((i, Gvar v) :: l) ((i, Gvar tv) :: x0).","proofString":"constructor; auto.\nsplit; simpl; auto.\nconstructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v0 : V1) (tv0 : V2),\ntransf_var i0 v0 = OK tv0 -> match_varinfo v0 tv0) (i : ident) (v : globvar V1) (l : list (ident * globdef F1 V1)) (IHl : forall x : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x) (tv : globvar V2) (TV : transf_globvar transf_var i v = OK tv) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) : match_ident_globdef match_fundef match_varinfo ctx (i, Gvar v) (i, Gvar tv).","proofString":"split; simpl; auto.\nconstructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v0 : V1) (tv0 : V2),\ntransf_var i0 v0 = OK tv0 -> match_varinfo v0 tv0) (i : ident) (v : globvar V1) (l : list (ident * globdef F1 V1)) (IHl : forall x : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x) (tv : globvar V2) (TV : transf_globvar transf_var i v = OK tv) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) : match_globdef match_fundef match_varinfo ctx (Gvar v) (Gvar tv).","proofString":"constructor.\nmonadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v0 : V1) (tv0 : V2),\ntransf_var i0 v0 = OK tv0 -> match_varinfo v0 tv0) (i : ident) (v : globvar V1) (l : list (ident * globdef F1 V1)) (IHl : forall x : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x) (tv : globvar V2) (TV : transf_globvar transf_var i v = OK tv) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) : match_globvar match_varinfo v tv.","proofString":"monadInv TV.\ndestruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v0 : V1) (tv : V2),\ntransf_var i0 v0 = OK tv -> match_varinfo v0 tv) (i : ident) (v : globvar V1) (l : list (ident * globdef F1 V1)) (IHl : forall x1 : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x1 ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x1) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) (x : V2) (EQ : transf_var i (gvar_info v) = OK x) : match_globvar match_varinfo v\n  {|\n    gvar_info := x;\n    gvar_init := gvar_init v;\n    gvar_readonly := gvar_readonly v;\n    gvar_volatile := gvar_volatile v\n  |}.","proofString":"destruct v; simpl; constructor.\neauto."},{"statement":"(C : Type) (F1 : Type) (V1 : Type) (F2 : Type) (V2 : Type) (LC : Linker C) (LF : Linker F1) (LV : Linker V1) (match_fundef : C -> F1 -> F2 -> Prop) (match_varinfo : V1 -> V2 -> Prop) (transf_fun : ident -> F1 -> res F2) (transf_var : ident -> V1 -> res V2) (ctx : C) (p : program F1 V1) (H0 : forall (i0 : ident) (f : F1) (tf : F2),\ntransf_fun i0 f = OK tf -> match_fundef ctx f tf) (H1 : forall (i0 : ident) (v : V1) (tv : V2),\ntransf_var i0 v = OK tv -> match_varinfo v tv) (i : ident) (gvar_info : V1) (gvar_init : list init_data) (gvar_readonly gvar_volatile : bool) (l : list (ident * globdef F1 V1)) (IHl : forall x1 : list (ident * globdef F2 V2),\ntransf_globdefs transf_fun transf_var l = OK x1 ->\nlist_forall2 (match_ident_globdef match_fundef match_varinfo ctx) l x1) (x0 : list (ident * globdef F2 V2)) (EQ0 : transf_globdefs transf_fun transf_var l = OK x0) (x : V2) (EQ : transf_var i\n  (AST.gvar_info\n     {|\n       gvar_info := gvar_info;\n       gvar_init := gvar_init;\n       gvar_readonly := gvar_readonly;\n       gvar_volatile := gvar_volatile\n     |}) = OK x) : match_varinfo gvar_info x.","proofString":"eauto."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (match_fundef : program A V -> A -> B -> Prop) (transf_fun : A -> res B) (p : program A V) (tp : program B V) (H : transform_partial_program transf_fun p = OK tp) (H0 : forall (f : A) (tf : B), transf_fun f = OK tf -> match_fundef p f tf) : match_program match_fundef eq p tp.","proofString":"eapply match_transform_partial_program2.\neexact H.\nauto.\nsimpl; intros.\ncongruence."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (match_fundef : program A V -> A -> B -> Prop) (transf_fun : A -> res B) (p : program A V) (tp : program B V) (H : transform_partial_program transf_fun p = OK tp) (H0 : forall (f : A) (tf : B), transf_fun f = OK tf -> match_fundef p f tf) (i : ident) (v tv : V) (H1 : OK v = OK tv) : v = tv.","proofString":"congruence."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (match_fundef : program A V -> A -> B -> Prop) (transf_fun : A -> B) (p : program A V) (H : forall f : A, match_fundef p f (transf_fun f)) : match_program match_fundef eq p (transform_program transf_fun p).","proofString":"eapply match_transform_partial_program_contextual.\napply transform_program_partial_program with (transf_fun := transf_fun).\nsimpl; intros.\ninv H0.\nauto."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (match_fundef : program A V -> A -> B -> Prop) (transf_fun : A -> B) (p : program A V) (H : forall f0 : A, match_fundef p f0 (transf_fun f0)) (f : A) (tf : B) (H0 : OK (transf_fun f) = OK tf) : match_fundef p f tf.","proofString":"inv H0.\nauto."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (match_fundef : program A V -> A -> B -> Prop) (transf_fun : A -> B) (p : program A V) (H : forall f0 : A, match_fundef p f0 (transf_fun f0)) (f : A) : match_fundef p f (transf_fun f).","proofString":"auto."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (transf_fun : A -> res B) (p : program A V) (tp : program B V) (H : transform_partial_program transf_fun p = OK tp) : match_program\n  (fun (_ : program A V) (f : A) (tf : B) => transf_fun f = OK tf) eq p tp.","proofString":"eapply match_transform_partial_program2.\neexact H.\nauto.\nsimpl; intros.\ncongruence."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (transf_fun : A -> res B) (p : program A V) (tp : program B V) (H : transform_partial_program transf_fun p = OK tp) (i : ident) (v tv : V) (H0 : OK v = OK tv) : v = tv.","proofString":"congruence."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (transf : A -> B) (p : program A V) : match_program (fun (_ : program A V) (f : A) (tf : B) => tf = transf f) eq p\n  (transform_program transf p).","proofString":"apply match_transform_program_contextual.\nauto."},{"statement":"(A : Type) (B : Type) (V : Type) (LA : Linker A) (LV : Linker V) (transf : A -> B) (p : program A V) : forall f : A, transf f = transf f.","proofString":"auto."},{"statement":"(v1 : globvar V1) (tv1 : globvar V2) (v2 : globvar V1) (tv2 : globvar V2) (v : globvar V1) (H : link_vardef v1 v2 = Some v) (H0 : match_globvar match_varinfo v1 tv1) (H1 : match_globvar match_varinfo v2 tv2) : exists tv : globvar V2,\n  link_vardef tv1 tv2 = Some tv /\\ match_globvar match_varinfo v tv.","proofString":"unfold link_vardef in *.\ninv H0; inv H1; simpl in *.\ndestruct (link i1 i0) as [info'|] eqn:LINFO; try discriminate.\ndestruct (link init init0) as [init'|] eqn:LINIT; try discriminate.\ndestruct (eqb ro ro0 && eqb vo vo0); inv H.\nexploit link_match_varinfo; eauto.\nintros (tinfo & P & Q).\nrewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(v1 : globvar V1) (tv1 : globvar V2) (v2 : globvar V1) (tv2 : globvar V2) (v : globvar V1) (H : match link (gvar_info v1) (gvar_info v2) with\n| Some info =>\n    match link (gvar_init v1) (gvar_init v2) with\n    | Some init =>\n        if\n         eqb (gvar_readonly v1) (gvar_readonly v2) &&\n         eqb (gvar_volatile v1) (gvar_volatile v2)\n        then\n         Some\n           {|\n             gvar_info := info;\n             gvar_init := init;\n             gvar_readonly := gvar_readonly v1;\n             gvar_volatile := gvar_volatile v1\n           |}\n        else None\n    | None => None\n    end\n| None => None\nend = Some v) (H0 : match_globvar match_varinfo v1 tv1) (H1 : match_globvar match_varinfo v2 tv2) : exists tv : globvar V2,\n  match link (gvar_info tv1) (gvar_info tv2) with\n  | Some info =>\n      match link (gvar_init tv1) (gvar_init tv2) with\n      | Some init =>\n          if\n           eqb (gvar_readonly tv1) (gvar_readonly tv2) &&\n           eqb (gvar_volatile tv1) (gvar_volatile tv2)\n          then\n           Some\n             {|\n               gvar_info := info;\n               gvar_init := init;\n               gvar_readonly := gvar_readonly tv1;\n               gvar_volatile := gvar_volatile tv1\n             |}\n          else None\n      | None => None\n      end\n  | None => None\n  end = Some tv /\\ match_globvar match_varinfo v tv.","proofString":"inv H0; inv H1; simpl in *.\ndestruct (link i1 i0) as [info'|] eqn:LINFO; try discriminate.\ndestruct (link init init0) as [init'|] eqn:LINIT; try discriminate.\ndestruct (eqb ro ro0 && eqb vo vo0); inv H.\nexploit link_match_varinfo; eauto.\nintros (tinfo & P & Q).\nrewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(v : globvar V1) (i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (H : match link i1 i0 with\n| Some info =>\n    match link init init0 with\n    | Some init1 =>\n        if eqb ro ro0 && eqb vo vo0\n        then\n         Some\n           {|\n             gvar_info := info;\n             gvar_init := init1;\n             gvar_readonly := ro;\n             gvar_volatile := vo\n           |}\n        else None\n    | None => None\n    end\n| None => None\nend = Some v) (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) : exists tv : globvar V2,\n  match link i2 i3 with\n  | Some info =>\n      match link init init0 with\n      | Some init1 =>\n          if eqb ro ro0 && eqb vo vo0\n          then\n           Some\n             {|\n               gvar_info := info;\n               gvar_init := init1;\n               gvar_readonly := ro;\n               gvar_volatile := vo\n             |}\n          else None\n      | None => None\n      end\n  | None => None\n  end = Some tv /\\ match_globvar match_varinfo v tv.","proofString":"destruct (link i1 i0) as [info'|] eqn:LINFO; try discriminate.\ndestruct (link init init0) as [init'|] eqn:LINIT; try discriminate.\ndestruct (eqb ro ro0 && eqb vo vo0); inv H.\nexploit link_match_varinfo; eauto.\nintros (tinfo & P & Q).\nrewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(v : globvar V1) (i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (info' : V1) (LINFO : link i1 i0 = Some info') (H : match link init init0 with\n| Some init1 =>\n    if eqb ro ro0 && eqb vo vo0\n    then\n     Some\n       {|\n         gvar_info := info';\n         gvar_init := init1;\n         gvar_readonly := ro;\n         gvar_volatile := vo\n       |}\n    else None\n| None => None\nend = Some v) (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) : exists tv : globvar V2,\n  match link i2 i3 with\n  | Some info =>\n      match link init init0 with\n      | Some init1 =>\n          if eqb ro ro0 && eqb vo vo0\n          then\n           Some\n             {|\n               gvar_info := info;\n               gvar_init := init1;\n               gvar_readonly := ro;\n               gvar_volatile := vo\n             |}\n          else None\n      | None => None\n      end\n  | None => None\n  end = Some tv /\\ match_globvar match_varinfo v tv.","proofString":"destruct (link init init0) as [init'|] eqn:LINIT; try discriminate.\ndestruct (eqb ro ro0 && eqb vo vo0); inv H.\nexploit link_match_varinfo; eauto.\nintros (tinfo & P & Q).\nrewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(v : globvar V1) (i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (info' : V1) (LINFO : link i1 i0 = Some info') (init' : list init_data) (LINIT : link init init0 = Some init') (H : (if eqb ro ro0 && eqb vo vo0\n then\n  Some\n    {|\n      gvar_info := info';\n      gvar_init := init';\n      gvar_readonly := ro;\n      gvar_volatile := vo\n    |}\n else None) = Some v) (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) : exists tv : globvar V2,\n  match link i2 i3 with\n  | Some info =>\n      if eqb ro ro0 && eqb vo vo0\n      then\n       Some\n         {|\n           gvar_info := info;\n           gvar_init := init';\n           gvar_readonly := ro;\n           gvar_volatile := vo\n         |}\n      else None\n  | None => None\n  end = Some tv /\\ match_globvar match_varinfo v tv.","proofString":"destruct (eqb ro ro0 && eqb vo vo0); inv H.\nexploit link_match_varinfo; eauto.\nintros (tinfo & P & Q).\nrewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (info' : V1) (LINFO : link i1 i0 = Some info') (init' : list init_data) (LINIT : link init init0 = Some init') (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) : exists tv : globvar V2,\n  match link i2 i3 with\n  | Some info =>\n      Some\n        {|\n          gvar_info := info;\n          gvar_init := init';\n          gvar_readonly := ro;\n          gvar_volatile := vo\n        |}\n  | None => None\n  end = Some tv /\\\n  match_globvar match_varinfo\n    {|\n      gvar_info := info';\n      gvar_init := init';\n      gvar_readonly := ro;\n      gvar_volatile := vo\n    |} tv.","proofString":"exploit link_match_varinfo; eauto.\nintros (tinfo & P & Q).\nrewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (info' : V1) (LINFO : link i1 i0 = Some info') (init' : list init_data) (LINIT : link init init0 = Some init') (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) : (exists tv : V2, link i2 i3 = Some tv /\\ match_varinfo info' tv) ->\nexists tv : globvar V2,\n  match link i2 i3 with\n  | Some info =>\n      Some\n        {|\n          gvar_info := info;\n          gvar_init := init';\n          gvar_readonly := ro;\n          gvar_volatile := vo\n        |}\n  | None => None\n  end = Some tv /\\\n  match_globvar match_varinfo\n    {|\n      gvar_info := info';\n      gvar_init := init';\n      gvar_readonly := ro;\n      gvar_volatile := vo\n    |} tv.","proofString":"intros (tinfo & P & Q).\nrewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (info' : V1) (LINFO : link i1 i0 = Some info') (init' : list init_data) (LINIT : link init init0 = Some init') (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) (tinfo : V2) (P : link i2 i3 = Some tinfo) (Q : match_varinfo info' tinfo) : exists tv : globvar V2,\n  match link i2 i3 with\n  | Some info =>\n      Some\n        {|\n          gvar_info := info;\n          gvar_init := init';\n          gvar_readonly := ro;\n          gvar_volatile := vo\n        |}\n  | None => None\n  end = Some tv /\\\n  match_globvar match_varinfo\n    {|\n      gvar_info := info';\n      gvar_init := init';\n      gvar_readonly := ro;\n      gvar_volatile := vo\n    |} tv.","proofString":"rewrite P.\neconstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (info' : V1) (LINFO : link i1 i0 = Some info') (init' : list init_data) (LINIT : link init init0 = Some init') (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) (tinfo : V2) (P : link i2 i3 = Some tinfo) (Q : match_varinfo info' tinfo) : exists tv : globvar V2,\n  Some\n    {|\n      gvar_info := tinfo;\n      gvar_init := init';\n      gvar_readonly := ro;\n      gvar_volatile := vo\n    |} = Some tv /\\\n  match_globvar match_varinfo\n    {|\n      gvar_info := info';\n      gvar_init := init';\n      gvar_readonly := ro;\n      gvar_volatile := vo\n    |} tv.","proofString":"econstructor; split.\neauto.\nconstructor.\nauto."},{"statement":"(i1 : V1) (init : list init_data) (ro vo : bool) (i0 : V1) (init0 : list init_data) (ro0 vo0 : bool) (info' : V1) (LINFO : link i1 i0 = Some info') (init' : list init_data) (LINIT : link init init0 = Some init') (i2 : V2) (H2 : match_varinfo i1 i2) (i3 : V2) (H0 : match_varinfo i0 i3) (tinfo : V2) (P : link i2 i3 = Some tinfo) (Q : match_varinfo info' tinfo) : match_varinfo info' tinfo.","proofString":"auto."},{"statement":"forall (ctx1 ctx2 ctx : C) (g1 : globdef F1 V1) (tg1 : globdef F2 V2)\n  (g2 : globdef F1 V1) (tg2 : globdef F2 V2) (g : globdef F1 V1),\nlinkorder ctx1 ctx ->\nlinkorder ctx2 ctx ->\nlink_def g1 g2 = Some g ->\nmatch_globdef match_fundef match_varinfo ctx1 g1 tg1 ->\nmatch_globdef match_fundef match_varinfo ctx2 g2 tg2 ->\nexists tg : globdef F2 V2,\n  link_def tg1 tg2 = Some tg /\\\n  match_globdef match_fundef match_varinfo ctx g tg.","proofString":"unfold link_def.\nintros.\ninv H2; inv H3; try discriminate.\ndestruct (link f1 f0) as [f|] eqn:LF; inv H1.\nexploit link_match_fundef; eauto.\nintros (tf & P & Q).\nassert (X: exists ctx', linkorder ctx' ctx /\\ match_fundef ctx' f tf).\ndestruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto.\ndestruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto.\ndestruct (link v1 v0) as [v|] eqn:LVAR; inv H1.\nexploit link_match_globvar; eauto.\nintros (tv & P & Q).\nexists (Gvar tv); split.\nrewrite P; auto.\nconstructor; auto."},{"statement":"forall (ctx1 ctx2 ctx : C) (g1 : globdef F1 V1) (tg1 : globdef F2 V2)\n  (g2 : globdef F1 V1) (tg2 : globdef F2 V2) (g : globdef F1 V1),\nlinkorder ctx1 ctx ->\nlinkorder ctx2 ctx ->\nmatch g1 with\n| Gfun f1 =>\n    match g2 with\n    | Gfun f2 =>\n        match link f1 f2 with\n        | Some f => Some (Gfun f)\n        | None => None\n        end\n    | Gvar _ => None\n    end\n| Gvar v1 =>\n    match g2 with\n    | Gfun _ => None\n    | Gvar v2 =>\n        match link v1 v2 with\n        | Some v => Some (Gvar v)\n        | None => None\n        end\n    end\nend = Some g ->\nmatch_globdef match_fundef match_varinfo ctx1 g1 tg1 ->\nmatch_globdef match_fundef match_varinfo ctx2 g2 tg2 ->\nexists tg : globdef F2 V2,\n  match tg1 with\n  | Gfun f1 =>\n      match tg2 with\n      | Gfun f2 =>\n          match link f1 f2 with\n          | Some f => Some (Gfun f)\n          | None => None\n          end\n      | Gvar _ => None\n      end\n  | Gvar v1 =>\n      match tg2 with\n      | Gfun _ => None\n      | Gvar v2 =>\n          match link v1 v2 with\n          | Some v => Some (Gvar v)\n          | None => None\n          end\n      end\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx g tg.","proofString":"intros.\ninv H2; inv H3; try discriminate.\ndestruct (link f1 f0) as [f|] eqn:LF; inv H1.\nexploit link_match_fundef; eauto.\nintros (tf & P & Q).\nassert (X: exists ctx', linkorder ctx' ctx /\\ match_fundef ctx' f tf).\ndestruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto.\ndestruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto.\ndestruct (link v1 v0) as [v|] eqn:LVAR; inv H1.\nexploit link_match_globvar; eauto.\nintros (tv & P & Q).\nexists (Gvar tv); split.\nrewrite P; auto.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (g1 : globdef F1 V1) (tg1 : globdef F2 V2) (g2 : globdef F1 V1) (tg2 : globdef F2 V2) (g : globdef F1 V1) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (H1 : match g1 with\n| Gfun f1 =>\n    match g2 with\n    | Gfun f2 =>\n        match link f1 f2 with\n        | Some f => Some (Gfun f)\n        | None => None\n        end\n    | Gvar _ => None\n    end\n| Gvar v1 =>\n    match g2 with\n    | Gfun _ => None\n    | Gvar v2 =>\n        match link v1 v2 with\n        | Some v => Some (Gvar v)\n        | None => None\n        end\n    end\nend = Some g) (H2 : match_globdef match_fundef match_varinfo ctx1 g1 tg1) (H3 : match_globdef match_fundef match_varinfo ctx2 g2 tg2) : exists tg : globdef F2 V2,\n  match tg1 with\n  | Gfun f1 =>\n      match tg2 with\n      | Gfun f2 =>\n          match link f1 f2 with\n          | Some f => Some (Gfun f)\n          | None => None\n          end\n      | Gvar _ => None\n      end\n  | Gvar v1 =>\n      match tg2 with\n      | Gfun _ => None\n      | Gvar v2 =>\n          match link v1 v2 with\n          | Some v => Some (Gvar v)\n          | None => None\n          end\n      end\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx g tg.","proofString":"inv H2; inv H3; try discriminate.\ndestruct (link f1 f0) as [f|] eqn:LF; inv H1.\nexploit link_match_fundef; eauto.\nintros (tf & P & Q).\nassert (X: exists ctx', linkorder ctx' ctx /\\ match_fundef ctx' f tf).\ndestruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto.\ndestruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto.\ndestruct (link v1 v0) as [v|] eqn:LVAR; inv H1.\nexploit link_match_globvar; eauto.\nintros (tv & P & Q).\nexists (Gvar tv); split.\nrewrite P; auto.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (g : globdef F1 V1) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 : F1) (H1 : match link f1 f0 with\n| Some f => Some (Gfun f)\n| None => None\nend = Some g) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) : exists tg : globdef F2 V2,\n  match link f2 f3 with\n  | Some f => Some (Gfun f)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx g tg.","proofString":"destruct (link f1 f0) as [f|] eqn:LF; inv H1.\nexploit link_match_fundef; eauto.\nintros (tf & P & Q).\nassert (X: exists ctx', linkorder ctx' ctx /\\ match_fundef ctx' f tf).\ndestruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto.\ndestruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) : exists tg : globdef F2 V2,\n  match link f2 f3 with\n  | Some f4 => Some (Gfun f4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gfun f) tg.","proofString":"exploit link_match_fundef; eauto.\nintros (tf & P & Q).\nassert (X: exists ctx', linkorder ctx' ctx /\\ match_fundef ctx' f tf).\ndestruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto.\ndestruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) : (exists tf : F2,\n   link f2 f3 = Some tf /\\\n   (match_fundef ctx' f tf \\/ match_fundef ctx'0 f tf)) ->\nexists tg : globdef F2 V2,\n  match link f2 f3 with\n  | Some f4 => Some (Gfun f4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gfun f) tg.","proofString":"intros (tf & P & Q).\nassert (X: exists ctx', linkorder ctx' ctx /\\ match_fundef ctx' f tf).\ndestruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto.\ndestruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) (tf : F2) (P : link f2 f3 = Some tf) (Q : match_fundef ctx' f tf \\/ match_fundef ctx'0 f tf) : exists tg : globdef F2 V2,\n  match link f2 f3 with\n  | Some f4 => Some (Gfun f4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gfun f) tg.","proofString":"assert (X: exists ctx', linkorder ctx' ctx /\\ match_fundef ctx' f tf).\ndestruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto.\ndestruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) (tf : F2) (P : link f2 f3 = Some tf) (Q : match_fundef ctx' f tf \\/ match_fundef ctx'0 f tf) : exists ctx'1 : C, linkorder ctx'1 ctx /\\ match_fundef ctx'1 f tf.","proofString":"destruct Q as [Q|Q]; econstructor; (split; [|eassumption]).\napply linkorder_trans with ctx1; auto.\napply linkorder_trans with ctx2; auto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) (tf : F2) (P : link f2 f3 = Some tf) (Q : match_fundef ctx' f tf) : linkorder ctx' ctx.","proofString":"apply linkorder_trans with ctx1; auto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) (tf : F2) (P : link f2 f3 = Some tf) (Q : match_fundef ctx'0 f tf) : linkorder ctx'0 ctx.","proofString":"apply linkorder_trans with ctx2; auto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) (tf : F2) (P : link f2 f3 = Some tf) (Q : match_fundef ctx' f tf \\/ match_fundef ctx'0 f tf) (X : exists ctx'1 : C, linkorder ctx'1 ctx /\\ match_fundef ctx'1 f tf) : exists tg : globdef F2 V2,\n  match link f2 f3 with\n  | Some f4 => Some (Gfun f4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gfun f) tg.","proofString":"destruct X as (cu & X & Y).\nexists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) (tf : F2) (P : link f2 f3 = Some tf) (Q : match_fundef ctx' f tf \\/ match_fundef ctx'0 f tf) (cu : C) (X : linkorder cu ctx) (Y : match_fundef cu f tf) : exists tg : globdef F2 V2,\n  match link f2 f3 with\n  | Some f4 => Some (Gfun f4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gfun f) tg.","proofString":"exists (Gfun tf); split.\nrewrite P; auto.\neconstructor; eauto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (f1 f0 f : F1) (LF : link f1 f0 = Some f) (ctx' : C) (f2 : F2) (H4 : linkorder ctx' ctx1) (H5 : match_fundef ctx' f1 f2) (ctx'0 : C) (f3 : F2) (H2 : linkorder ctx'0 ctx2) (H6 : match_fundef ctx'0 f0 f3) (tf : F2) (P : link f2 f3 = Some tf) (Q : match_fundef ctx' f tf \\/ match_fundef ctx'0 f tf) (cu : C) (X : linkorder cu ctx) (Y : match_fundef cu f tf) : match_globdef match_fundef match_varinfo ctx (Gfun f) (Gfun tf).","proofString":"econstructor; eauto."},{"statement":"(ctx1 ctx2 ctx : C) (g : globdef F1 V1) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (v1 v0 : globvar V1) (H1 : match link v1 v0 with\n| Some v => Some (Gvar v)\n| None => None\nend = Some g) (v2 : globvar V2) (H4 : match_globvar match_varinfo v1 v2) (v3 : globvar V2) (H2 : match_globvar match_varinfo v0 v3) : exists tg : globdef F2 V2,\n  match link v2 v3 with\n  | Some v => Some (Gvar v)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx g tg.","proofString":"destruct (link v1 v0) as [v|] eqn:LVAR; inv H1.\nexploit link_match_globvar; eauto.\nintros (tv & P & Q).\nexists (Gvar tv); split.\nrewrite P; auto.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (v1 v0 v : globvar V1) (LVAR : link v1 v0 = Some v) (v2 : globvar V2) (H4 : match_globvar match_varinfo v1 v2) (v3 : globvar V2) (H2 : match_globvar match_varinfo v0 v3) : exists tg : globdef F2 V2,\n  match link v2 v3 with\n  | Some v4 => Some (Gvar v4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gvar v) tg.","proofString":"exploit link_match_globvar; eauto.\nintros (tv & P & Q).\nexists (Gvar tv); split.\nrewrite P; auto.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (v1 v0 v : globvar V1) (LVAR : link v1 v0 = Some v) (v2 : globvar V2) (H4 : match_globvar match_varinfo v1 v2) (v3 : globvar V2) (H2 : match_globvar match_varinfo v0 v3) : (exists tv : globvar V2,\n   link v2 v3 = Some tv /\\ match_globvar match_varinfo v tv) ->\nexists tg : globdef F2 V2,\n  match link v2 v3 with\n  | Some v4 => Some (Gvar v4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gvar v) tg.","proofString":"intros (tv & P & Q).\nexists (Gvar tv); split.\nrewrite P; auto.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (v1 v0 v : globvar V1) (LVAR : link v1 v0 = Some v) (v2 : globvar V2) (H4 : match_globvar match_varinfo v1 v2) (v3 : globvar V2) (H2 : match_globvar match_varinfo v0 v3) (tv : globvar V2) (P : link v2 v3 = Some tv) (Q : match_globvar match_varinfo v tv) : exists tg : globdef F2 V2,\n  match link v2 v3 with\n  | Some v4 => Some (Gvar v4)\n  | None => None\n  end = Some tg /\\ match_globdef match_fundef match_varinfo ctx (Gvar v) tg.","proofString":"exists (Gvar tv); split.\nrewrite P; auto.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (H : linkorder ctx1 ctx) (H0 : linkorder ctx2 ctx) (v1 v0 v : globvar V1) (LVAR : link v1 v0 = Some v) (v2 : globvar V2) (H4 : match_globvar match_varinfo v1 v2) (v3 : globvar V2) (H2 : match_globvar match_varinfo v0 v3) (tv : globvar V2) (P : link v2 v3 = Some tv) (Q : match_globvar match_varinfo v tv) : match_globdef match_fundef match_varinfo ctx (Gvar v) (Gvar tv).","proofString":"constructor; auto."},{"statement":"(ctx ctx' : C) (g : globdef F1 V1) (tg : globdef F2 V2) (H : match_globdef match_fundef match_varinfo ctx g tg) (H0 : linkorder ctx ctx') : match_globdef match_fundef match_varinfo ctx' g tg.","proofString":"inv H.\neconstructor.\neapply linkorder_trans; eauto.\nauto.\nconstructor; auto."},{"statement":"(ctx ctx' : C) (H0 : linkorder ctx ctx') (ctx'0 : C) (f1 : F1) (f2 : F2) (H1 : linkorder ctx'0 ctx) (H2 : match_fundef ctx'0 f1 f2) : match_globdef match_fundef match_varinfo ctx' (Gfun f1) (Gfun f2).","proofString":"econstructor.\neapply linkorder_trans; eauto.\nauto."},{"statement":"(ctx ctx' : C) (H0 : linkorder ctx ctx') (v1 : globvar V1) (v2 : globvar V2) (H1 : match_globvar match_varinfo v1 v2) : match_globdef match_fundef match_varinfo ctx' (Gvar v1) (Gvar v2).","proofString":"constructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) : exists tp : program F2 V2,\n  link tp1 tp2 = Some tp /\\\n  match_program_gen match_fundef match_varinfo ctx p tp.","proofString":"destruct (link_prog_inv _ _ _ H) as (P & Q & R).\ngeneralize H0; intros (A1 & B1 & C1).\ngeneralize H1; intros (A2 & B2 & C2).\neconstructor; split.\napply link_prog_succeeds.\ncongruence.\nintros.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nrewrite H4, H5.\nintros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence.\nsplit; [|split].\nrewrite R.\napply PTree.elements_canonical_order'.\nintros id.\nrewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto.\nrewrite R; simpl; auto.\nrewrite R; simpl.\ncongruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : exists tp : program F2 V2,\n  link tp1 tp2 = Some tp /\\\n  match_program_gen match_fundef match_varinfo ctx p tp.","proofString":"generalize H0; intros (A1 & B1 & C1).\ngeneralize H1; intros (A2 & B2 & C2).\neconstructor; split.\napply link_prog_succeeds.\ncongruence.\nintros.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nrewrite H4, H5.\nintros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence.\nsplit; [|split].\nrewrite R.\napply PTree.elements_canonical_order'.\nintros id.\nrewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto.\nrewrite R; simpl; auto.\nrewrite R; simpl.\ncongruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) : exists tp : program F2 V2,\n  link tp1 tp2 = Some tp /\\\n  match_program_gen match_fundef match_varinfo ctx p tp.","proofString":"generalize H1; intros (A2 & B2 & C2).\neconstructor; split.\napply link_prog_succeeds.\ncongruence.\nintros.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nrewrite H4, H5.\nintros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence.\nsplit; [|split].\nrewrite R.\napply PTree.elements_canonical_order'.\nintros id.\nrewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto.\nrewrite R; simpl; auto.\nrewrite R; simpl.\ncongruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : exists tp : program F2 V2,\n  link tp1 tp2 = Some tp /\\\n  match_program_gen match_fundef match_varinfo ctx p tp.","proofString":"econstructor; split.\napply link_prog_succeeds.\ncongruence.\nintros.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nrewrite H4, H5.\nintros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence.\nsplit; [|split].\nrewrite R.\napply PTree.elements_canonical_order'.\nintros id.\nrewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto.\nrewrite R; simpl; auto.\nrewrite R; simpl.\ncongruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : prog_main tp1 = prog_main tp2.","proofString":"congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : forall (id : positive) (gd1 gd2 : globdef F2 V2),\n(prog_defmap tp1) ! id = Some gd1 ->\n(prog_defmap tp2) ! id = Some gd2 ->\nIn id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"intros.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nrewrite H4, H5.\nintros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd0 gd3 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd0 gd3 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (gd1 gd2 : globdef F2 V2) (H4 : (prog_defmap tp1) ! id = Some gd1) (H5 : (prog_defmap tp2) ! id = Some gd2) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"generalize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nrewrite H4, H5.\nintros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd0 gd3 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd0 gd3 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (gd1 gd2 : globdef F2 V2) (H4 : (prog_defmap tp1) ! id = Some gd1) (H5 : (prog_defmap tp2) ! id = Some gd2) : option_rel (match_globdef match_fundef match_varinfo ctx1)\n  (prog_defmap p1) ! id (prog_defmap tp1) ! id ->\noption_rel (match_globdef match_fundef match_varinfo ctx2)\n  (prog_defmap p2) ! id (prog_defmap tp2) ! id ->\nIn id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"rewrite H4, H5.\nintros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd0 gd3 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd0 gd3 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (gd1 gd2 : globdef F2 V2) (H4 : (prog_defmap tp1) ! id = Some gd1) (H5 : (prog_defmap tp2) ! id = Some gd2) : option_rel (match_globdef match_fundef match_varinfo ctx1)\n  (prog_defmap p1) ! id (Some gd1) ->\noption_rel (match_globdef match_fundef match_varinfo ctx2)\n  (prog_defmap p2) ! id (Some gd2) ->\nIn id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"intros R1 R2; inv R1; inv R2.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (H : link p1 p2 =\nSome\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd0 gd3 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd0 gd3 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (gd1 gd2 : globdef F2 V2) (H4 : (prog_defmap tp1) ! id = Some gd1) (H5 : (prog_defmap tp2) ! id = Some gd2) (x : globdef F1 V1) (H8 : match_globdef match_fundef match_varinfo ctx1 x gd1) (H6 : Some x = (prog_defmap p1) ! id) (x0 : globdef F1 V1) (H10 : match_globdef match_fundef match_varinfo ctx2 x0 gd2) (H7 : Some x0 = (prog_defmap p2) ! id) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"exploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (H : link p1 p2 =\nSome\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd0 gd3 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd0 gd3 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (gd1 gd2 : globdef F2 V2) (H4 : (prog_defmap tp1) ! id = Some gd1) (H5 : (prog_defmap tp2) ! id = Some gd2) (x : globdef F1 V1) (H8 : match_globdef match_fundef match_varinfo ctx1 x gd1) (H6 : Some x = (prog_defmap p1) ! id) (x0 : globdef F1 V1) (H10 : match_globdef match_fundef match_varinfo ctx2 x0 gd2) (H7 : Some x0 = (prog_defmap p2) ! id) : In id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link x x0 = Some gd) ->\nIn id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"intros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (H : link p1 p2 =\nSome\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd0 gd3 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef F1 V1, link gd0 gd3 = Some gd4)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (gd1 gd2 : globdef F2 V2) (H4 : (prog_defmap tp1) ! id = Some gd1) (H5 : (prog_defmap tp2) ! id = Some gd2) (x : globdef F1 V1) (H8 : match_globdef match_fundef match_varinfo ctx1 x gd1) (H6 : Some x = (prog_defmap p1) ! id) (x0 : globdef F1 V1) (H10 : match_globdef match_fundef match_varinfo ctx2 x0 gd2) (H7 : Some x0 = (prog_defmap p2) ! id) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef F1 V1) (Z : link x x0 = Some gd) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"exploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & _).\nintuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (H : link p1 p2 =\nSome\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd0 gd3 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef F1 V1, link gd0 gd3 = Some gd4)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (gd1 gd2 : globdef F2 V2) (H4 : (prog_defmap tp1) ! id = Some gd1) (H5 : (prog_defmap tp2) ! id = Some gd2) (x : globdef F1 V1) (H8 : match_globdef match_fundef match_varinfo ctx1 x gd1) (H6 : Some x = (prog_defmap p1) ! id) (x0 : globdef F1 V1) (H10 : match_globdef match_fundef match_varinfo ctx2 x0 gd2) (H7 : Some x0 = (prog_defmap p2) ! id) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef F1 V1) (Z : link x x0 = Some gd) (tg : globdef F2 V2) (TL : link gd1 gd2 = Some tg) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"intuition congruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  (prog_defs p)\n  (prog_defs\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n       prog_public := prog_public tp1 ++ prog_public tp2;\n       prog_main := prog_main tp1\n     |}).","proofString":"rewrite R.\napply PTree.elements_canonical_order'.\nintros id.\nrewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  (prog_defs\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |})\n  (prog_defs\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n       prog_public := prog_public tp1 ++ prog_public tp2;\n       prog_main := prog_main tp1\n     |}).","proofString":"apply PTree.elements_canonical_order'.\nintros id.\nrewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : forall i : positive,\noption_rel (match_globdef match_fundef match_varinfo ctx)\n  (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2)) ! i\n  (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2)) ! i.","proofString":"intros id.\nrewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) : option_rel (match_globdef match_fundef match_varinfo ctx)\n  (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2)) ! id\n  (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2)) ! id.","proofString":"rewrite ! PTree.gcombine by auto.\ngeneralize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) : option_rel (match_globdef match_fundef match_varinfo ctx)\n  (link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id)\n  (link_prog_merge (prog_defmap tp1) ! id (prog_defmap tp2) ! id).","proofString":"generalize (match_program_defmap _ _ _ _ _ H0 id) (match_program_defmap _ _ _ _ _ H1 id).\nclear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) : option_rel (match_globdef match_fundef match_varinfo ctx1)\n  (prog_defmap p1) ! id (prog_defmap tp1) ! id ->\noption_rel (match_globdef match_fundef match_varinfo ctx2)\n  (prog_defmap p2) ! id (prog_defmap tp2) ! id ->\noption_rel (match_globdef match_fundef match_varinfo ctx)\n  (link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id)\n  (link_prog_merge (prog_defmap tp1) ! id (prog_defmap tp2) ! id).","proofString":"clear R.\nintros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) : option_rel (match_globdef match_fundef match_varinfo ctx1)\n  (prog_defmap p1) ! id (prog_defmap tp1) ! id ->\noption_rel (match_globdef match_fundef match_varinfo ctx2)\n  (prog_defmap p2) ! id (prog_defmap tp2) ! id ->\noption_rel (match_globdef match_fundef match_varinfo ctx)\n  (link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id)\n  (link_prog_merge (prog_defmap tp1) ! id (prog_defmap tp2) ! id).","proofString":"intros R1 R2; inv R1; inv R2; unfold link_prog_merge.\nconstructor.\nconstructor.\napply match_globdef_linkorder with ctx2; auto.\nconstructor.\napply match_globdef_linkorder with ctx1; auto.\nexploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (H5 : None = (prog_defmap p1) ! id) (H6 : None = (prog_defmap tp1) ! id) (H7 : None = (prog_defmap p2) ! id) (H8 : None = (prog_defmap tp2) ! id) : option_rel (match_globdef match_fundef match_varinfo ctx) None None.","proofString":"constructor."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (H5 : None = (prog_defmap p1) ! id) (H6 : None = (prog_defmap tp1) ! id) (x : globdef F1 V1) (y : globdef F2 V2) (H8 : match_globdef match_fundef match_varinfo ctx2 x y) (H4 : Some x = (prog_defmap p2) ! id) (H7 : Some y = (prog_defmap tp2) ! id) : option_rel (match_globdef match_fundef match_varinfo ctx) (Some x) (Some y).","proofString":"constructor.\napply match_globdef_linkorder with ctx2; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (H5 : None = (prog_defmap p1) ! id) (H6 : None = (prog_defmap tp1) ! id) (x : globdef F1 V1) (y : globdef F2 V2) (H8 : match_globdef match_fundef match_varinfo ctx2 x y) (H4 : Some x = (prog_defmap p2) ! id) (H7 : Some y = (prog_defmap tp2) ! id) : match_globdef match_fundef match_varinfo ctx x y.","proofString":"apply match_globdef_linkorder with ctx2; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (x : globdef F1 V1) (y : globdef F2 V2) (H6 : match_globdef match_fundef match_varinfo ctx1 x y) (H4 : Some x = (prog_defmap p1) ! id) (H5 : Some y = (prog_defmap tp1) ! id) (H8 : None = (prog_defmap p2) ! id) (H9 : None = (prog_defmap tp2) ! id) : option_rel (match_globdef match_fundef match_varinfo ctx) (Some x) (Some y).","proofString":"constructor.\napply match_globdef_linkorder with ctx1; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (x : globdef F1 V1) (y : globdef F2 V2) (H6 : match_globdef match_fundef match_varinfo ctx1 x y) (H4 : Some x = (prog_defmap p1) ! id) (H5 : Some y = (prog_defmap tp1) ! id) (H8 : None = (prog_defmap p2) ! id) (H9 : None = (prog_defmap tp2) ! id) : match_globdef match_fundef match_varinfo ctx x y.","proofString":"apply match_globdef_linkorder with ctx1; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (x : globdef F1 V1) (y : globdef F2 V2) (H6 : match_globdef match_fundef match_varinfo ctx1 x y) (H4 : Some x = (prog_defmap p1) ! id) (H5 : Some y = (prog_defmap tp1) ! id) (x0 : globdef F1 V1) (y0 : globdef F2 V2) (H9 : match_globdef match_fundef match_varinfo ctx2 x0 y0) (H7 : Some x0 = (prog_defmap p2) ! id) (H8 : Some y0 = (prog_defmap tp2) ! id) : option_rel (match_globdef match_fundef match_varinfo ctx) \n  (link x x0) (link y y0).","proofString":"exploit Q; eauto.\nintros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (x : globdef F1 V1) (y : globdef F2 V2) (H6 : match_globdef match_fundef match_varinfo ctx1 x y) (H4 : Some x = (prog_defmap p1) ! id) (H5 : Some y = (prog_defmap tp1) ! id) (x0 : globdef F1 V1) (y0 : globdef F2 V2) (H9 : match_globdef match_fundef match_varinfo ctx2 x0 y0) (H7 : Some x0 = (prog_defmap p2) ! id) (H8 : Some y0 = (prog_defmap tp2) ! id) : In id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link x x0 = Some gd) ->\noption_rel (match_globdef match_fundef match_varinfo ctx) \n  (link x x0) (link y y0).","proofString":"intros (X & Y & gd & Z).\nexploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef F1 V1, link gd1 gd2 = Some gd0)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (x : globdef F1 V1) (y : globdef F2 V2) (H6 : match_globdef match_fundef match_varinfo ctx1 x y) (H4 : Some x = (prog_defmap p1) ! id) (H5 : Some y = (prog_defmap tp1) ! id) (x0 : globdef F1 V1) (y0 : globdef F2 V2) (H9 : match_globdef match_fundef match_varinfo ctx2 x0 y0) (H7 : Some x0 = (prog_defmap p2) ! id) (H8 : Some y0 = (prog_defmap tp2) ! id) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef F1 V1) (Z : link x x0 = Some gd) : option_rel (match_globdef match_fundef match_varinfo ctx) \n  (link x x0) (link y y0).","proofString":"exploit link_match_globdef.\neexact H2.\neexact H3.\neauto.\neauto.\neauto.\nintros (tg & TL & MG).\nrewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef F1 V1, link gd1 gd2 = Some gd0)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (x : globdef F1 V1) (y : globdef F2 V2) (H6 : match_globdef match_fundef match_varinfo ctx1 x y) (H4 : Some x = (prog_defmap p1) ! id) (H5 : Some y = (prog_defmap tp1) ! id) (x0 : globdef F1 V1) (y0 : globdef F2 V2) (H9 : match_globdef match_fundef match_varinfo ctx2 x0 y0) (H7 : Some x0 = (prog_defmap p2) ! id) (H8 : Some y0 = (prog_defmap tp2) ! id) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef F1 V1) (Z : link x x0 = Some gd) (tg : globdef F2 V2) (TL : link y y0 = Some tg) (MG : match_globdef match_fundef match_varinfo ctx gd tg) : option_rel (match_globdef match_fundef match_varinfo ctx) \n  (link x x0) (link y y0).","proofString":"rewrite Z, TL.\nconstructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id0 : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef F1 V1, link gd1 gd2 = Some gd0)) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) (id : positive) (x : globdef F1 V1) (y : globdef F2 V2) (H6 : match_globdef match_fundef match_varinfo ctx1 x y) (H4 : Some x = (prog_defmap p1) ! id) (H5 : Some y = (prog_defmap tp1) ! id) (x0 : globdef F1 V1) (y0 : globdef F2 V2) (H9 : match_globdef match_fundef match_varinfo ctx2 x0 y0) (H7 : Some x0 = (prog_defmap p2) ! id) (H8 : Some y0 = (prog_defmap tp2) ! id) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef F1 V1) (Z : link x x0 = Some gd) (tg : globdef F2 V2) (TL : link y y0 = Some tg) (MG : match_globdef match_fundef match_varinfo ctx gd tg) : option_rel (match_globdef match_fundef match_varinfo ctx) (Some gd) (Some tg).","proofString":"constructor; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : prog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n    prog_public := prog_public tp1 ++ prog_public tp2;\n    prog_main := prog_main tp1\n  |} = prog_main p.","proofString":"rewrite R; simpl; auto."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : prog_public\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n    prog_public := prog_public tp1 ++ prog_public tp2;\n    prog_main := prog_main tp1\n  |} = prog_public p.","proofString":"rewrite R; simpl.\ncongruence."},{"statement":"(ctx1 ctx2 ctx : C) (p1 p2 : program F1 V1) (tp1 tp2 : program F2 V2) (p : program F1 V1) (H : link p1 p2 = Some p) (H0 : match_program_gen match_fundef match_varinfo ctx1 p1 tp1) (H1 : match_program_gen match_fundef match_varinfo ctx2 p2 tp2) (H2 : linkorder ctx1 ctx) (H3 : linkorder ctx2 ctx) (P : prog_main p1 = prog_main p2) (Q : forall (id : positive) (gd1 gd2 : globdef F1 V1),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\ (exists gd : globdef F1 V1, link gd1 gd2 = Some gd)) (R : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (A1 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx1)\n  (prog_defs p1) (prog_defs tp1)) (B1 : prog_main tp1 = prog_main p1) (C1 : prog_public tp1 = prog_public p1) (A2 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx2)\n  (prog_defs p2) (prog_defs tp2)) (B2 : prog_main tp2 = prog_main p2) (C2 : prog_public tp2 = prog_public p2) : prog_public tp1 ++ prog_public tp2 = prog_public p1 ++ prog_public p2.","proofString":"congruence."},{"statement":"(a a0 b : A) (H : Some a0 = Some b) (H0 : a0 = a) : linkorder a b.","proofString":"inv H.\nsubst.\napply linkorder_refl."},{"statement":"(b : A) : linkorder b b.","proofString":"subst.\napply linkorder_refl."},{"statement":"(b : A) : linkorder b b.","proofString":"apply linkorder_refl."},{"statement":"(a a0 : A) (l : nlist A) (IHl : forall b0 : A, link_list l = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : match link_list l with\n| Some b0 => link a0 b0\n| None => None\nend = Some b) (H0 : a0 = a \\/ nIn a l) : linkorder a b.","proofString":"destruct (link_list l) as [b'|]; try discriminate.\napply link_linkorder in H.\ndestruct H0.\nsubst a0.\ntauto.\napply linkorder_trans with b'.\nauto.\ntauto."},{"statement":"(a a0 : A) (l : nlist A) (b' : A) (IHl : forall b0 : A, Some b' = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : link a0 b' = Some b) (H0 : a0 = a \\/ nIn a l) : linkorder a b.","proofString":"apply link_linkorder in H.\ndestruct H0.\nsubst a0.\ntauto.\napply linkorder_trans with b'.\nauto.\ntauto."},{"statement":"(a a0 : A) (l : nlist A) (b' : A) (IHl : forall b0 : A, Some b' = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : linkorder a0 b /\\ linkorder b' b) (H0 : a0 = a \\/ nIn a l) : linkorder a b.","proofString":"destruct H0.\nsubst a0.\ntauto.\napply linkorder_trans with b'.\nauto.\ntauto."},{"statement":"(a a0 : A) (l : nlist A) (b' : A) (IHl : forall b0 : A, Some b' = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : linkorder a0 b /\\ linkorder b' b) (H0 : a0 = a) : linkorder a b.","proofString":"subst a0.\ntauto."},{"statement":"(a : A) (l : nlist A) (b' : A) (IHl : forall b0 : A, Some b' = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : linkorder a b /\\ linkorder b' b) : linkorder a b.","proofString":"tauto."},{"statement":"(a a0 : A) (l : nlist A) (b' : A) (IHl : forall b0 : A, Some b' = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : linkorder a0 b /\\ linkorder b' b) (H0 : nIn a l) : linkorder a b.","proofString":"apply linkorder_trans with b'.\nauto.\ntauto."},{"statement":"(a a0 : A) (l : nlist A) (b' : A) (IHl : forall b0 : A, Some b' = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : linkorder a0 b /\\ linkorder b' b) (H0 : nIn a l) : linkorder a b'.","proofString":"auto."},{"statement":"(a a0 : A) (l : nlist A) (b' : A) (IHl : forall b0 : A, Some b' = Some b0 -> nIn a l -> linkorder a b0) (b : A) (H : linkorder a0 b /\\ linkorder b' b) (H0 : nIn a l) : linkorder b' b.","proofString":"tauto."},{"statement":"(a : A) (b : B) (H : prog_match a b) (a' : A) (L : Some a = Some a') : exists b0 : B, Some b = Some b0 /\\ prog_match a' b0.","proofString":"inv L.\nexists b; auto."},{"statement":"(b : B) (a' : A) (H : prog_match a' b) : exists b0 : B, Some b = Some b0 /\\ prog_match a' b0.","proofString":"exists b; auto."},{"statement":"(a : A) (l : nlist A) (b : B) (m : nlist B) (H : prog_match a b) (H0 : nlist_forall2 prog_match l m) (IHnlist_forall2 : forall a0 : A,\nlink_list l = Some a0 ->\nexists b0 : B, link_list m = Some b0 /\\ prog_match a0 b0) (a' : A) (L : match link_list l with\n| Some b0 => link a b0\n| None => None\nend = Some a') : exists b0 : B,\n  match link_list m with\n  | Some b1 => link b b1\n  | None => None\n  end = Some b0 /\\ prog_match a' b0.","proofString":"destruct (link_list l) as [a1|] eqn:LL; try discriminate.\nexploit IHnlist_forall2; eauto.\nintros (b' & P & Q).\nred in TL.\nexploit TL; eauto.\nintros (b'' & U & V).\nrewrite P; exists b''; auto."},{"statement":"(a : A) (l : nlist A) (b : B) (m : nlist B) (H : prog_match a b) (H0 : nlist_forall2 prog_match l m) (a1 : A) (LL : link_list l = Some a1) (IHnlist_forall2 : forall a0 : A,\nSome a1 = Some a0 -> exists b0 : B, link_list m = Some b0 /\\ prog_match a0 b0) (a' : A) (L : link a a1 = Some a') : exists b0 : B,\n  match link_list m with\n  | Some b1 => link b b1\n  | None => None\n  end = Some b0 /\\ prog_match a' b0.","proofString":"exploit IHnlist_forall2; eauto.\nintros (b' & P & Q).\nred in TL.\nexploit TL; eauto.\nintros (b'' & U & V).\nrewrite P; exists b''; auto."},{"statement":"(a : A) (l : nlist A) (b : B) (m : nlist B) (H : prog_match a b) (H0 : nlist_forall2 prog_match l m) (a1 : A) (LL : link_list l = Some a1) (IHnlist_forall2 : forall a0 : A,\nSome a1 = Some a0 -> exists b0 : B, link_list m = Some b0 /\\ prog_match a0 b0) (a' : A) (L : link a a1 = Some a') : (exists b0 : B, link_list m = Some b0 /\\ prog_match a1 b0) ->\nexists b0 : B,\n  match link_list m with\n  | Some b1 => link b b1\n  | None => None\n  end = Some b0 /\\ prog_match a' b0.","proofString":"intros (b' & P & Q).\nred in TL.\nexploit TL; eauto.\nintros (b'' & U & V).\nrewrite P; exists b''; auto."},{"statement":"(a : A) (l : nlist A) (b : B) (m : nlist B) (H : prog_match a b) (H0 : nlist_forall2 prog_match l m) (a1 : A) (LL : link_list l = Some a1) (IHnlist_forall2 : forall a0 : A,\nSome a1 = Some a0 -> exists b0 : B, link_list m = Some b0 /\\ prog_match a0 b0) (a' : A) (L : link a a1 = Some a') (b' : B) (P : link_list m = Some b') (Q : prog_match a1 b') : exists b0 : B,\n  match link_list m with\n  | Some b1 => link b b1\n  | None => None\n  end = Some b0 /\\ prog_match a' b0.","proofString":"red in TL.\nexploit TL; eauto.\nintros (b'' & U & V).\nrewrite P; exists b''; auto."},{"statement":"(a : A) (l : nlist A) (b : B) (m : nlist B) (H : prog_match a b) (H0 : nlist_forall2 prog_match l m) (a1 : A) (LL : link_list l = Some a1) (IHnlist_forall2 : forall a0 : A,\nSome a1 = Some a0 -> exists b0 : B, link_list m = Some b0 /\\ prog_match a0 b0) (a' : A) (L : link a a1 = Some a') (b' : B) (P : link_list m = Some b') (Q : prog_match a1 b') : exists b0 : B,\n  match link_list m with\n  | Some b1 => link b b1\n  | None => None\n  end = Some b0 /\\ prog_match a' b0.","proofString":"exploit TL; eauto.\nintros (b'' & U & V).\nrewrite P; exists b''; auto."},{"statement":"(a : A) (l : nlist A) (b : B) (m : nlist B) (H : prog_match a b) (H0 : nlist_forall2 prog_match l m) (a1 : A) (LL : link_list l = Some a1) (IHnlist_forall2 : forall a0 : A,\nSome a1 = Some a0 -> exists b0 : B, link_list m = Some b0 /\\ prog_match a0 b0) (a' : A) (L : link a a1 = Some a') (b' : B) (P : link_list m = Some b') (Q : prog_match a1 b') : (exists tp : B, link b b' = Some tp /\\ prog_match a' tp) ->\nexists b0 : B,\n  match link_list m with\n  | Some b1 => link b b1\n  | None => None\n  end = Some b0 /\\ prog_match a' b0.","proofString":"intros (b'' & U & V).\nrewrite P; exists b''; auto."},{"statement":"(a : A) (l : nlist A) (b : B) (m : nlist B) (H : prog_match a b) (H0 : nlist_forall2 prog_match l m) (a1 : A) (LL : link_list l = Some a1) (IHnlist_forall2 : forall a0 : A,\nSome a1 = Some a0 -> exists b0 : B, link_list m = Some b0 /\\ prog_match a0 b0) (a' : A) (L : link a a1 = Some a') (b' : B) (P : link_list m = Some b') (Q : prog_match a1 b') (b'' : B) (U : link b b' = Some b'') (V : prog_match a' b'') : exists b0 : B,\n  match link_list m with\n  | Some b1 => link b b1\n  | None => None\n  end = Some b0 /\\ prog_match a' b0.","proofString":"rewrite P; exists b''; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (R1 : A -> B -> Prop) (R2 : B -> C -> Prop) (a : A) (b : C) (H : exists b0 : B, R1 a b0 /\\ R2 b0 b) : exists lb : nlist B,\n  nlist_forall2 R1 (nbase a) lb /\\ nlist_forall2 R2 lb (nbase b).","proofString":"rename b into c.\ndestruct H as (b & P & Q).\nexists (nbase b); split; constructor; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (R1 : A -> B -> Prop) (R2 : B -> C -> Prop) (a : A) (c : C) (H : exists b : B, R1 a b /\\ R2 b c) : exists lb : nlist B,\n  nlist_forall2 R1 (nbase a) lb /\\ nlist_forall2 R2 lb (nbase c).","proofString":"destruct H as (b & P & Q).\nexists (nbase b); split; constructor; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (R1 : A -> B -> Prop) (R2 : B -> C -> Prop) (a : A) (c : C) (b : B) (P : R1 a b) (Q : R2 b c) : exists lb : nlist B,\n  nlist_forall2 R1 (nbase a) lb /\\ nlist_forall2 R2 lb (nbase c).","proofString":"exists (nbase b); split; constructor; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (R1 : A -> B -> Prop) (R2 : B -> C -> Prop) (a : A) (l : nlist A) (b : C) (m : nlist C) (H : exists b0 : B, R1 a b0 /\\ R2 b0 b) (H0 : nlist_forall2 (fun (a0 : A) (c : C) => exists b0 : B, R1 a0 b0 /\\ R2 b0 c) l\n  m) (IHnlist_forall2 : exists lb : nlist B, nlist_forall2 R1 l lb /\\ nlist_forall2 R2 lb m) : exists lb : nlist B,\n  nlist_forall2 R1 (ncons a l) lb /\\ nlist_forall2 R2 lb (ncons b m).","proofString":"rename b into c.\ndestruct H as (b & P & Q).\ndestruct IHnlist_forall2 as (lb & U & V).\nexists (ncons b lb); split; constructor; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (R1 : A -> B -> Prop) (R2 : B -> C -> Prop) (a : A) (l : nlist A) (c : C) (m : nlist C) (H : exists b : B, R1 a b /\\ R2 b c) (H0 : nlist_forall2 (fun (a0 : A) (c0 : C) => exists b : B, R1 a0 b /\\ R2 b c0) l m) (IHnlist_forall2 : exists lb : nlist B, nlist_forall2 R1 l lb /\\ nlist_forall2 R2 lb m) : exists lb : nlist B,\n  nlist_forall2 R1 (ncons a l) lb /\\ nlist_forall2 R2 lb (ncons c m).","proofString":"destruct H as (b & P & Q).\ndestruct IHnlist_forall2 as (lb & U & V).\nexists (ncons b lb); split; constructor; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (R1 : A -> B -> Prop) (R2 : B -> C -> Prop) (a : A) (l : nlist A) (c : C) (m : nlist C) (b : B) (P : R1 a b) (Q : R2 b c) (H0 : nlist_forall2 (fun (a0 : A) (c0 : C) => exists b0 : B, R1 a0 b0 /\\ R2 b0 c0)\n  l m) (IHnlist_forall2 : exists lb : nlist B, nlist_forall2 R1 l lb /\\ nlist_forall2 R2 lb m) : exists lb : nlist B,\n  nlist_forall2 R1 (ncons a l) lb /\\ nlist_forall2 R2 lb (ncons c m).","proofString":"destruct IHnlist_forall2 as (lb & U & V).\nexists (ncons b lb); split; constructor; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (R1 : A -> B -> Prop) (R2 : B -> C -> Prop) (a : A) (l : nlist A) (c : C) (m : nlist C) (b : B) (P : R1 a b) (Q : R2 b c) (H0 : nlist_forall2 (fun (a0 : A) (c0 : C) => exists b0 : B, R1 a0 b0 /\\ R2 b0 c0)\n  l m) (lb : nlist B) (U : nlist_forall2 R1 l lb) (V : nlist_forall2 R2 lb m) : exists lb0 : nlist B,\n  nlist_forall2 R1 (ncons a l) lb0 /\\ nlist_forall2 R2 lb0 (ncons c m).","proofString":"exists (ncons b lb); split; constructor; auto."}]}