{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Clight.v","fileSamples":[{"statement":"(p : program) : receptive (semantics1 p).","conclusion":"receptive (semantics1 p)","hypotheses":"(p : program)","proofString":"unfold semantics1.\nset (ge := globalenv p).\nconstructor; simpl; intros.\nassert (t1 = E0 -> exists s2, step1 ge s t2 s2).\nintros.\nsubst.\ninv H0.\nexists s1; auto.\ninversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\neconstructor; econstructor; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto.\nred; simpl; intros.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) : receptive\n  {|\n    Smallstep.state := state;\n    genvtype := genv;\n    Smallstep.step := step1;\n    Smallstep.initial_state := initial_state p;\n    Smallstep.final_state := final_state;\n    Smallstep.globalenv := globalenv p;\n    symbolenv := globalenv p\n  |}.","conclusion":"receptive\n  {|\n    Smallstep.state := state;\n    genvtype := genv;\n    Smallstep.step := step1;\n    Smallstep.initial_state := initial_state p;\n    Smallstep.final_state := final_state;\n    Smallstep.globalenv := globalenv p;\n    symbolenv := globalenv p\n  |}","hypotheses":"(p : program)","proofString":"set (ge := globalenv p).\nconstructor; simpl; intros.\nassert (t1 = E0 -> exists s2, step1 ge s t2 s2).\nintros.\nsubst.\ninv H0.\nexists s1; auto.\ninversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\neconstructor; econstructor; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto.\nred; simpl; intros.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (ge : genv) : receptive\n  {|\n    Smallstep.state := state;\n    genvtype := genv;\n    Smallstep.step := step1;\n    Smallstep.initial_state := initial_state p;\n    Smallstep.final_state := final_state;\n    Smallstep.globalenv := ge;\n    symbolenv := ge\n  |}.","conclusion":"receptive\n  {|\n    Smallstep.state := state;\n    genvtype := genv;\n    Smallstep.step := step1;\n    Smallstep.initial_state := initial_state p;\n    Smallstep.final_state := final_state;\n    Smallstep.globalenv := ge;\n    symbolenv := ge\n  |}","hypotheses":"(p : program) (ge : genv)","proofString":"constructor; simpl; intros.\nassert (t1 = E0 -> exists s2, step1 ge s t2 s2).\nintros.\nsubst.\ninv H0.\nexists s1; auto.\ninversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\neconstructor; econstructor; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto.\nred; simpl; intros.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (ge : genv) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step1 ge s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) : t1 = E0 -> exists s2 : state, step1 ge s t2 s2.","conclusion":"t1 = E0 -> exists s2 : state, step1 ge s t2 s2","hypotheses":"(p : program) (ge : genv) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step1 ge s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2)","proofString":"intros.\nsubst.\ninv H0.\nexists s1; auto."},{"statement":"(p : program) (ge : genv) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step1 ge s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0) : exists s2 : state, step1 ge s t2 s2.","conclusion":"exists s2 : state, step1 ge s t2 s2","hypotheses":"(p : program) (ge : genv) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step1 ge s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0)","proofString":"subst.\ninv H0.\nexists s1; auto."},{"statement":"(p : program) (ge : genv) (s s1 : state) (t2 : trace) (H0 : match_traces (Genv.globalenv p) E0 t2) (H : step1 ge s E0 s1) : exists s2 : state, step1 ge s t2 s2.","conclusion":"exists s2 : state, step1 ge s t2 s2","hypotheses":"(p : program) (ge : genv) (s s1 : state) (t2 : trace) (H0 : match_traces (Genv.globalenv p) E0 t2) (H : step1 ge s E0 s1)","proofString":"inv H0.\nexists s1; auto."},{"statement":"(p : program) (ge : genv) (s s1 : state) (H : step1 ge s E0 s1) : exists s2 : state, step1 ge s nil s2.","conclusion":"exists s2 : state, step1 ge s nil s2","hypotheses":"(p : program) (ge : genv) (s s1 : state) (H : step1 ge s E0 s1)","proofString":"exists s1; auto."},{"statement":"(p : program) (ge : genv) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vres : val) (m' : mem) (H : step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t1\n  (State f Sskip k e (set_opttemp optid vres le) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2) (vargs : list val) (H2 : eval_exprlist ge e le m al tyargs vargs) (H3 : external_call ef ge vargs m t1 vres m') : (exists (vres2 : val) (m2 : mem), external_call ef ge vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2.","conclusion":"(exists (vres2 : val) (m2 : mem), external_call ef ge vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2","hypotheses":"(p : program) (ge : genv) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vres : val) (m' : mem) (H : step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t1\n  (State f Sskip k e (set_opttemp optid vres le) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2) (vargs : list val) (H2 : eval_exprlist ge e le m al tyargs vargs) (H3 : external_call ef ge vargs m t1 vres m')","proofString":"intros [vres2 [m2 EC2]].\neconstructor; econstructor; eauto."},{"statement":"(p : program) (ge : genv) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vres : val) (m' : mem) (H : step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t1\n  (State f Sskip k e (set_opttemp optid vres le) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2) (vargs : list val) (H2 : eval_exprlist ge e le m al tyargs vargs) (H3 : external_call ef ge vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m t2 vres2 m2) : exists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2.","conclusion":"exists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2","hypotheses":"(p : program) (ge : genv) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vres : val) (m' : mem) (H : step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t1\n  (State f Sskip k e (set_opttemp optid vres le) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (State f (Sbuiltin optid ef tyargs al) k e le m) t2 s2) (vargs : list val) (H2 : eval_exprlist ge e le m al tyargs vargs) (H3 : external_call ef ge vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m t2 vres2 m2)","proofString":"econstructor; econstructor; eauto."},{"statement":"(p : program) (ge : genv) (t1 t2 : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step1 ge (Callstate (External ef targs tres cconv) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2) (H2 : external_call ef ge vargs m t1 vres m') : (exists (vres2 : val) (m2 : mem), external_call ef ge vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2.","conclusion":"(exists (vres2 : val) (m2 : mem), external_call ef ge vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2","hypotheses":"(p : program) (ge : genv) (t1 t2 : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step1 ge (Callstate (External ef targs tres cconv) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2) (H2 : external_call ef ge vargs m t1 vres m')","proofString":"intros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto."},{"statement":"(p : program) (ge : genv) (t1 t2 : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step1 ge (Callstate (External ef targs tres cconv) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2) (H2 : external_call ef ge vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m t2 vres2 m2) : exists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2.","conclusion":"exists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2","hypotheses":"(p : program) (ge : genv) (t1 t2 : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step1 ge (Callstate (External ef targs tres cconv) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2) (H2 : external_call ef ge vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m t2 vres2 m2)","proofString":"exists (Returnstate vres2 k m2).\neconstructor; eauto."},{"statement":"(p : program) (ge : genv) (t1 t2 : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step1 ge (Callstate (External ef targs tres cconv) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2) (H2 : external_call ef ge vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m t2 vres2 m2) : step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2\n  (Returnstate vres2 k m2).","conclusion":"step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2\n  (Returnstate vres2 k m2)","hypotheses":"(p : program) (ge : genv) (t1 t2 : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step1 ge (Callstate (External ef targs tres cconv) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step1 ge (Callstate (External ef targs tres cconv) vargs k m) t2 s2) (H2 : external_call ef ge vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m t2 vres2 m2)","proofString":"econstructor; eauto."},{"statement":"(p : program) (ge : genv) : single_events\n  {|\n    Smallstep.state := state;\n    genvtype := genv;\n    Smallstep.step := step1;\n    Smallstep.initial_state := initial_state p;\n    Smallstep.final_state := final_state;\n    Smallstep.globalenv := ge;\n    symbolenv := Genv.globalenv p\n  |}.","conclusion":"single_events\n  {|\n    Smallstep.state := state;\n    genvtype := genv;\n    Smallstep.step := step1;\n    Smallstep.initial_state := initial_state p;\n    Smallstep.final_state := final_state;\n    Smallstep.globalenv := ge;\n    symbolenv := Genv.globalenv p\n  |}","hypotheses":"(p : program) (ge : genv)","proofString":"red; simpl; intros.\ninv H; simpl; try lia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (ge : genv) (s : state) (t : trace) (s' : state) (H : step1 ge s t s') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (ge : genv) (s : state) (t : trace) (s' : state) (H : step1 ge s t s')","proofString":"inv H; simpl; try lia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (ge : genv) (t : trace) (f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : eval_exprlist ge e le m al tyargs vargs) (H1 : external_call ef ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (ge : genv) (t : trace) (f : function) (optid : option ident) (ef : external_function) (tyargs : list type) (al : list expr) (k : cont) (e : env) (le : temp_env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : eval_exprlist ge e le m al tyargs vargs) (H1 : external_call ef ge vargs m t vres m')","proofString":"eapply external_call_trace_length; eauto."},{"statement":"(p : program) (ge : genv) (t : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H0 : external_call ef ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (ge : genv) (t : trace) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H0 : external_call ef ge vargs m t vres m')","proofString":"eapply external_call_trace_length; eauto."}]}