{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/reordering/ReorderingExecA.v","fileSamples":[{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : E_t' ≡₁ E_t ∪₁ eq a_t.","conclusion":"E_t' ≡₁ E_t ∪₁ eq a_t","hypotheses":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : tid a_t <> tid_init.","conclusion":"tid a_t <> tid_init","hypotheses":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ~ is_init a_t.","conclusion":"~ is_init a_t","hypotheses":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ~ E_t a_t.","conclusion":"~ E_t a_t","hypotheses":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"apply ADD'."},{"statement":"(E_t ∪₁ eq a_t) a_t.","conclusion":"(E_t ∪₁ eq a_t) a_t","hypotheses":"","proofString":"now right."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : lab_t' = upd lab_t a_t l_a.","conclusion":"lab_t' = upd lab_t a_t l_a","hypotheses":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"apply ADD'."},{"statement":"E_t b_t.","conclusion":"E_t b_t","hypotheses":"","proofString":"assert (NEQ : a_t <> b_t) by apply INV'.\nassert (IN' : E_t' b_t) by apply rsr_bt_in'.\napply rsr_step_acts in IN'.\nunfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) : E_t b_t.","conclusion":"E_t b_t","hypotheses":"(NEQ : a_t <> b_t)","proofString":"assert (IN' : E_t' b_t) by apply rsr_bt_in'.\napply rsr_step_acts in IN'.\nunfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (IN' : E_t' b_t) : E_t b_t.","conclusion":"E_t b_t","hypotheses":"(NEQ : a_t <> b_t) (IN' : E_t' b_t)","proofString":"apply rsr_step_acts in IN'.\nunfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (IN' : (E_t ∪₁ eq a_t) b_t) : E_t b_t.","conclusion":"E_t b_t","hypotheses":"(NEQ : a_t <> b_t) (IN' : (E_t ∪₁ eq a_t) b_t)","proofString":"unfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (IN' : E_t b_t \\/ a_t = b_t) : E_t b_t.","conclusion":"E_t b_t","hypotheses":"(NEQ : a_t <> b_t) (IN' : E_t b_t \\/ a_t = b_t)","proofString":"desf."},{"statement":"E_t b_t.","conclusion":"E_t b_t","hypotheses":"","proofString":"apply rsr_bt_in."},{"statement":"eq_dom E_t' lab_t' (lab_s' ∘ mapper).","conclusion":"eq_dom E_t' lab_t' (lab_s' ∘ mapper)","hypotheses":"","proofString":"exact rsr_nanb_lab."},{"statement":"(NEQ : a_t <> b_t) : inj_dom E_t' mapper.","conclusion":"inj_dom E_t' mapper","hypotheses":"(NEQ : a_t <> b_t)","proofString":"eapply inj_dom_mori; auto with xmm.\nred; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) : flip set_subset ⊤₁ E_t'.","conclusion":"flip set_subset ⊤₁ E_t'","hypotheses":"(NEQ : a_t <> b_t)","proofString":"red; auto with hahn."},{"statement":"eq_dom cmt (upd lab_s b_t l_a) lab_s.","conclusion":"eq_dom cmt (upd lab_s b_t l_a) lab_s","hypotheses":"","proofString":"apply eq_dom_upd_l; [| reflexivity].\nunfold cmt.\nclear.\nunfolder.\ntauto."},{"statement":"~ cmt b_t.","conclusion":"~ cmt b_t","hypotheses":"","proofString":"unfold cmt.\nclear.\nunfolder.\ntauto."},{"statement":"~ (E_s \\₁ eq b_t) b_t.","conclusion":"~ (E_s \\₁ eq b_t) b_t","hypotheses":"","proofString":"clear.\nunfolder.\ntauto."},{"statement":"~ (E_s \\₁ eq b_t) b_t.","conclusion":"~ (E_s \\₁ eq b_t) b_t","hypotheses":"","proofString":"unfolder.\ntauto."},{"statement":"~ (E_s b_t /\\ b_t <> b_t).","conclusion":"~ (E_s b_t /\\ b_t <> b_t)","hypotheses":"","proofString":"tauto."},{"statement":"eq_dom cmt lab_s' lab_s.","conclusion":"eq_dom cmt lab_s' lab_s","hypotheses":"","proofString":"exact rsr_a_labeq."},{"statement":"(mapper ↑₁ E_t ∪₁ A_s) b_t.","conclusion":"(mapper ↑₁ E_t ∪₁ A_s) b_t","hypotheses":"","proofString":"right.\nnow apply rsr_old_exa."},{"statement":"A_s b_t.","conclusion":"A_s b_t","hypotheses":"","proofString":"now apply rsr_old_exa."},{"statement":"(NEQ : a_t <> b_t) : E_s a_t.","conclusion":"E_s a_t","hypotheses":"(NEQ : a_t <> b_t)","proofString":"apply (rsr_acts SIMREL).\nleft.\nexists b_t; split; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) : (mapper ↑₁ E_t ∪₁ A_s) a_t.","conclusion":"(mapper ↑₁ E_t ∪₁ A_s) a_t","hypotheses":"(NEQ : a_t <> b_t)","proofString":"left.\nexists b_t; split; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) : (mapper ↑₁ E_t) a_t.","conclusion":"(mapper ↑₁ E_t) a_t","hypotheses":"(NEQ : a_t <> b_t)","proofString":"exists b_t; split; auto with xmm."},{"statement":"⦗E_s'⦘ ⨾ ext_sb ⨾ ⦗E_s'⦘ ≡ sb_s.","conclusion":"⦗E_s'⦘ ⨾ ext_sb ⨾ ⦗E_s'⦘ ≡ sb_s","hypotheses":"","proofString":"simpl.\nnow change (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s."},{"statement":"⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ≡ sb_s.","conclusion":"⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ≡ sb_s","hypotheses":"","proofString":"now change (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s."},{"statement":"(ANIN : ~ E_t a_t) : ⦗eq a_t⦘ ⨾ sb_s ⊆ ∅₂.","conclusion":"⦗eq a_t⦘ ⨾ sb_s ⊆ ∅₂","hypotheses":"(ANIN : ~ E_t a_t)","proofString":"assert (ANINI : ~is_init a_t) by apply INV.\nrewrite (rsr_sbE INV SIMREL), seq_union_r.\napply inclusion_union_l.\nrewrite wf_sbE.\nbasic_solver.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ sb_s ⊆ ∅₂.","conclusion":"⦗eq a_t⦘ ⨾ sb_s ⊆ ∅₂","hypotheses":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t)","proofString":"rewrite (rsr_sbE INV SIMREL), seq_union_r.\napply inclusion_union_l.\nrewrite wf_sbE.\nbasic_solver.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ sb_t ∪ ⦗eq a_t⦘ ⨾ (is_init ∪₁ E_t ∩₁ Tid_ (tid b_t)) × B_s ⊆ ∅₂.","conclusion":"⦗eq a_t⦘ ⨾ sb_t ∪ ⦗eq a_t⦘ ⨾ (is_init ∪₁ E_t ∩₁ Tid_ (tid b_t)) × B_s ⊆ ∅₂","hypotheses":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t)","proofString":"apply inclusion_union_l.\nrewrite wf_sbE.\nbasic_solver.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ sb_t ⊆ ∅₂.","conclusion":"⦗eq a_t⦘ ⨾ sb_t ⊆ ∅₂","hypotheses":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t)","proofString":"rewrite wf_sbE.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ ⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘ ⊆ ∅₂.","conclusion":"⦗eq a_t⦘ ⨾ ⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘ ⊆ ∅₂","hypotheses":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t)","proofString":"basic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ (is_init ∪₁ E_t ∩₁ Tid_ (tid b_t)) × B_s ⊆ ∅₂.","conclusion":"⦗eq a_t⦘ ⨾ (is_init ∪₁ E_t ∩₁ Tid_ (tid b_t)) × B_s ⊆ ∅₂","hypotheses":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t)","proofString":"basic_solver."},{"statement":"(WF_t : Wf G_t) : rf_s' ≡ mapper ↑ rf_t'.","conclusion":"rf_s' ≡ mapper ↑ rf_t'","hypotheses":"(WF_t : Wf G_t)","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nsimpl.\nrewrite (rsr_rf SIMREL), (rf_delta_RE WF_t ADD'),          !seq_union_l.\narewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : rf_s' ≡ mapper ↑ rf_t'.","conclusion":"rf_s' ≡ mapper ↑ rf_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"simpl.\nrewrite (rsr_rf SIMREL), (rf_delta_RE WF_t ADD'),          !seq_union_l.\narewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : rf_s ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ (rf_t' ⨾ ⦗eq a_t⦘) ≡ mapper ↑ rf_t'.","conclusion":"rf_s ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ (rf_t' ⨾ ⦗eq a_t⦘) ≡ mapper ↑ rf_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite (rsr_rf SIMREL), (rf_delta_RE WF_t ADD'),          !seq_union_l.\narewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ (srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘\n∪ mapper ↑ WCore.rf_delta_R a_t w ≡ mapper ↑ rf_t'.","conclusion":"mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ (srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘\n∪ mapper ↑ WCore.rf_delta_R a_t w ≡ mapper ↑ rf_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"arewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : (srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘ ⊆ ∅₂.","conclusion":"(srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘ ⊆ ∅₂","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite rsr_old_exa.\nbasic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : (srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘ ⊆ ∅₂.","conclusion":"(srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘ ⊆ ∅₂","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"basic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ ∅₂ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ rf_t'.","conclusion":"mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ ∅₂ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ rf_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ ∅₂ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ (rf_t ∪ WCore.rf_delta_R a_t w ∪ ∅₂).","conclusion":"mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ ∅₂ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ (rf_t ∪ WCore.rf_delta_R a_t w ∪ ∅₂)","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ rf_t ∪ mapper ↑ WCore.rf_delta_R a_t w.","conclusion":"mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ rf_t ∪ mapper ↑ WCore.rf_delta_R a_t w","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"apply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ≡ mapper ↑ rf_t.","conclusion":"mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ≡ mapper ↑ rf_t","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"split; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘.","conclusion":"mapper ↑ rf_t ⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ (⦗E_t⦘ ⨾ rf_t ⨾ ⦗E_t⦘) ⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘.","conclusion":"mapper ↑ (⦗E_t⦘ ⨾ rf_t ⨾ ⦗E_t⦘) ⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ⦗E_s \\₁ eq b_t⦘ ⨾ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘\n⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘.","conclusion":"⦗E_s \\₁ eq b_t⦘ ⨾ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘\n⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"basic_solver 11."},{"statement":"(WF_t : Wf G_t) : co_s' ≡ mapper ↑ co_t'.","conclusion":"co_s' ≡ mapper ↑ co_t'","hypotheses":"(WF_t : Wf G_t)","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nsimpl.\nrewrite (rsr_co SIMREL), (co_deltaE WF_t ADD'),          restr_union.\narewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : co_s' ≡ mapper ↑ co_t'.","conclusion":"co_s' ≡ mapper ↑ co_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"simpl.\nrewrite (rsr_co SIMREL), (co_deltaE WF_t ADD'),          restr_union.\narewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) co_s\n∪ mapper ↑ (⦗eq a_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq a_t⦘) ≡ \nmapper ↑ co_t'.","conclusion":"restr_rel (E_s \\₁ eq b_t) co_s\n∪ mapper ↑ (⦗eq a_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq a_t⦘) ≡ \nmapper ↑ co_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite (rsr_co SIMREL), (co_deltaE WF_t ADD'),          restr_union.\narewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t)\n∪ restr_rel (E_s \\₁ eq b_t)\n    (add_max (extra_co_D E_s lab_s (loc_s b_t)) (A_s ∩₁ W_s))\n∪ mapper ↑ WCore.co_delta a_t W1 W2 ≡ mapper ↑ co_t'.","conclusion":"restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t)\n∪ restr_rel (E_s \\₁ eq b_t)\n    (add_max (extra_co_D E_s lab_s (loc_s b_t)) (A_s ∩₁ W_s))\n∪ mapper ↑ WCore.co_delta a_t W1 W2 ≡ mapper ↑ co_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"arewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t)\n  (add_max (extra_co_D E_s lab_s (loc_s b_t)) (A_s ∩₁ W_s)) ⊆ ∅₂.","conclusion":"restr_rel (E_s \\₁ eq b_t)\n  (add_max (extra_co_D E_s lab_s (loc_s b_t)) (A_s ∩₁ W_s)) ⊆ ∅₂","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite rsr_old_exa.\nbasic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t)\n  (add_max (extra_co_D E_s lab_s (loc_s b_t)) (eq b_t ∩₁ W_s)) ⊆ ∅₂.","conclusion":"restr_rel (E_s \\₁ eq b_t)\n  (add_max (extra_co_D E_s lab_s (loc_s b_t)) (eq b_t ∩₁ W_s)) ⊆ ∅₂","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"basic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ ∅₂\n∪ mapper ↑ WCore.co_delta a_t W1 W2 ≡ mapper ↑ co_t'.","conclusion":"restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ ∅₂\n∪ mapper ↑ WCore.co_delta a_t W1 W2 ≡ mapper ↑ co_t'","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ ∅₂\n∪ mapper ↑ WCore.co_delta a_t W1 W2\n≡ mapper ↑ (co_t ∪ WCore.co_delta a_t W1 W2).","conclusion":"restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ ∅₂\n∪ mapper ↑ WCore.co_delta a_t W1 W2\n≡ mapper ↑ (co_t ∪ WCore.co_delta a_t W1 W2)","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ mapper ↑ WCore.co_delta a_t W1 W2\n≡ mapper ↑ co_t ∪ mapper ↑ WCore.co_delta a_t W1 W2.","conclusion":"restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ mapper ↑ WCore.co_delta a_t W1 W2\n≡ mapper ↑ co_t ∪ mapper ↑ WCore.co_delta a_t W1 W2","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"apply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ≡ mapper ↑ co_t.","conclusion":"restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ≡ mapper ↑ co_t","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"split; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ co_t ⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t).","conclusion":"mapper ↑ co_t ⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t)","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘) ⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t).","conclusion":"mapper ↑ (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘) ⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t)","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ⦗E_s \\₁ eq b_t⦘ ⨾ mapper ↑ co_t ⨾ ⦗E_s \\₁ eq b_t⦘\n⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t).","conclusion":"⦗E_s \\₁ eq b_t⦘ ⨾ mapper ↑ co_t ⨾ ⦗E_s \\₁ eq b_t⦘\n⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t)","hypotheses":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"basic_solver 11."},{"statement":"(NEQ : a_t <> b_t) : E_s' ≡₁ mapper ↑₁ E_t'.","conclusion":"E_s' ≡₁ mapper ↑₁ E_t'","hypotheses":"(NEQ : a_t <> b_t)","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nsimpl.\nrewrite (rsr_acts SIMREL), (WCore.add_event_acts ADD'),          set_collect_union, set_collect_eq, rsr_old_exa.\nrewrite rsr_mapper_at; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : E_s' ≡₁ mapper ↑₁ E_t'.","conclusion":"E_s' ≡₁ mapper ↑₁ E_t'","hypotheses":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"simpl.\nrewrite (rsr_acts SIMREL), (WCore.add_event_acts ADD'),          set_collect_union, set_collect_eq, rsr_old_exa.\nrewrite rsr_mapper_at; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : E_s ≡₁ mapper ↑₁ E_t'.","conclusion":"E_s ≡₁ mapper ↑₁ E_t'","hypotheses":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite (rsr_acts SIMREL), (WCore.add_event_acts ADD'),          set_collect_union, set_collect_eq, rsr_old_exa.\nrewrite rsr_mapper_at; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑₁ E_t ∪₁ eq b_t ≡₁ mapper ↑₁ E_t ∪₁ eq (mapper a_t).","conclusion":"mapper ↑₁ E_t ∪₁ eq b_t ≡₁ mapper ↑₁ E_t ∪₁ eq (mapper a_t)","hypotheses":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2)","proofString":"rewrite rsr_mapper_at; auto with hahn."},{"statement":"E_s ≡₁ E_s.","conclusion":"E_s ≡₁ E_s","hypotheses":"","proofString":"reflexivity."},{"statement":"E_s \\₁ (eq b_t ∪₁ eq a_t) ⊆₁ E_s.","conclusion":"E_s \\₁ (eq b_t ∪₁ eq a_t) ⊆₁ E_s","hypotheses":"","proofString":"basic_solver."},{"statement":"E_s \\₁ eq b_t ⊆₁ E_s.","conclusion":"E_s \\₁ eq b_t ⊆₁ E_s","hypotheses":"","proofString":"basic_solver."},{"statement":"E_s \\₁ (eq b_t ∪₁ eq a_t) ⊆₁ E_s \\₁ eq b_t.","conclusion":"E_s \\₁ (eq b_t ∪₁ eq a_t) ⊆₁ E_s \\₁ eq b_t","hypotheses":"","proofString":"basic_solver."},{"statement":"(ANINI : ~ is_init b_t) : is_init ⊆₁ dtrmt.","conclusion":"is_init ⊆₁ dtrmt","hypotheses":"(ANINI : ~ is_init b_t)","proofString":"assert (BNINI : ~is_init a_t) by apply INV.\nunfold dtrmt.\nrewrite <- (rsr_init_acts_s INV SIMREL).\nrewrite set_minus_disjoint; basic_solver."},{"statement":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t) : is_init ⊆₁ dtrmt.","conclusion":"is_init ⊆₁ dtrmt","hypotheses":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t)","proofString":"unfold dtrmt.\nrewrite <- (rsr_init_acts_s INV SIMREL).\nrewrite set_minus_disjoint; basic_solver."},{"statement":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t) : is_init ⊆₁ E_s \\₁ (eq b_t ∪₁ eq a_t).","conclusion":"is_init ⊆₁ E_s \\₁ (eq b_t ∪₁ eq a_t)","hypotheses":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t)","proofString":"rewrite <- (rsr_init_acts_s INV SIMREL).\nrewrite set_minus_disjoint; basic_solver."},{"statement":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t) : is_init ⊆₁ is_init \\₁ (eq b_t ∪₁ eq a_t).","conclusion":"is_init ⊆₁ is_init \\₁ (eq b_t ∪₁ eq a_t)","hypotheses":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t)","proofString":"rewrite set_minus_disjoint; basic_solver."},{"statement":"(BIN : E_s a_t) : cmt \\₁ dtrmt ≡₁ eq a_t.","conclusion":"cmt \\₁ dtrmt ≡₁ eq a_t","hypotheses":"(BIN : E_s a_t)","proofString":"assert (NEQ : a_t <> b_t) by apply INV'.\nunfold cmt, dtrmt.\nrewrite set_minus_union_r, set_minus_inter_r.\nrewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : cmt \\₁ dtrmt ≡₁ eq a_t.","conclusion":"cmt \\₁ dtrmt ≡₁ eq a_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"unfold cmt, dtrmt.\nrewrite set_minus_union_r, set_minus_inter_r.\nrewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ (E_s \\₁ (eq b_t ∪₁ eq a_t)) ≡₁ eq a_t.","conclusion":"(E_s \\₁ eq b_t) \\₁ (E_s \\₁ (eq b_t ∪₁ eq a_t)) ≡₁ eq a_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"rewrite set_minus_union_r, set_minus_inter_r.\nrewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq b_t) ∪₁ (E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq a_t)\n≡₁ eq a_t.","conclusion":"(E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq b_t) ∪₁ (E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq a_t)\n≡₁ eq a_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"rewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq a_t) ≡₁ eq a_t.","conclusion":"(E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq a_t) ≡₁ eq a_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"rewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ E_s ∪₁ (E_s \\₁ eq b_t) ∩₁ eq a_t ≡₁ eq a_t.","conclusion":"(E_s \\₁ eq b_t) \\₁ E_s ∪₁ (E_s \\₁ eq b_t) ∩₁ eq a_t ≡₁ eq a_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"arewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅.","conclusion":"(E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"basic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : ∅ ∪₁ (E_s \\₁ eq b_t) ∩₁ eq a_t ≡₁ eq a_t.","conclusion":"∅ ∪₁ (E_s \\₁ eq b_t) ∩₁ eq a_t ≡₁ eq a_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"rewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : eq a_t ≡₁ eq a_t.","conclusion":"eq a_t ≡₁ eq a_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"reflexivity."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : eq a_t ⊆₁ E_s \\₁ eq b_t.","conclusion":"eq a_t ⊆₁ E_s \\₁ eq b_t","hypotheses":"(BIN : E_s a_t) (NEQ : a_t <> b_t)","proofString":"basic_solver."},{"statement":"tid ↑₁ (E_s' \\₁ dtrmt) ≡₁ eq (tid b_t).","conclusion":"tid ↑₁ (E_s' \\₁ dtrmt) ≡₁ eq (tid b_t)","hypotheses":"","proofString":"rewrite rsr_a_ndtrmt.\nrewrite set_collect_union, !set_collect_eq.\nrewrite set_union_absorb_r; [reflexivity |].\nunfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"tid ↑₁ (eq b_t ∪₁ eq a_t) ≡₁ eq (tid b_t).","conclusion":"tid ↑₁ (eq b_t ∪₁ eq a_t) ≡₁ eq (tid b_t)","hypotheses":"","proofString":"rewrite set_collect_union, !set_collect_eq.\nrewrite set_union_absorb_r; [reflexivity |].\nunfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"eq (tid b_t) ∪₁ eq (tid a_t) ≡₁ eq (tid b_t).","conclusion":"eq (tid b_t) ∪₁ eq (tid a_t) ≡₁ eq (tid b_t)","hypotheses":"","proofString":"rewrite set_union_absorb_r; [reflexivity |].\nunfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"eq (tid a_t) ⊆₁ eq (tid b_t).","conclusion":"eq (tid a_t) ⊆₁ eq (tid b_t)","hypotheses":"","proofString":"unfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"forall x : BinNums.positive, tid a_t = x -> tid b_t = x.","conclusion":"forall x : BinNums.positive, tid a_t = x -> tid b_t = x","hypotheses":"","proofString":"ins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"(x : BinNums.positive) (H : tid a_t = x) : tid b_t = x.","conclusion":"tid b_t = x","hypotheses":"(x : BinNums.positive) (H : tid a_t = x)","proofString":"desf.\nsymmetry.\napply INV'."},{"statement":"tid b_t = tid a_t.","conclusion":"tid b_t = tid a_t","hypotheses":"","proofString":"symmetry.\napply INV'."},{"statement":"tid a_t = tid b_t.","conclusion":"tid a_t = tid b_t","hypotheses":"","proofString":"apply INV'."},{"statement":"(BTID : tid b_t <> tid_init) : strict_partial_order thrdle.","conclusion":"strict_partial_order thrdle","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"constructor; unfold thrdle.\nbasic_solver.\nunfolder.\nintros x y z HXY HYZ.\ndesf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) : irreflexive\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)).","conclusion":"irreflexive\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t))","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"basic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : transitive\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)).","conclusion":"transitive\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t))","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"unfolder.\nintros x y z HXY HYZ.\ndesf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) : forall x y z : BinNums.positive,\ntid_init = x /\\ tid_init <> y \\/ tid b_t <> x /\\ tid b_t = y ->\ntid_init = y /\\ tid_init <> z \\/ tid b_t <> y /\\ tid b_t = z ->\ntid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z.","conclusion":"forall x y z : BinNums.positive,\ntid_init = x /\\ tid_init <> y \\/ tid b_t <> x /\\ tid b_t = y ->\ntid_init = y /\\ tid_init <> z \\/ tid b_t <> y /\\ tid b_t = z ->\ntid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"intros x y z HXY HYZ.\ndesf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) (x y z : BinNums.positive) (HXY : tid_init = x /\\ tid_init <> y \\/ tid b_t <> x /\\ tid b_t = y) (HYZ : tid_init = y /\\ tid_init <> z \\/ tid b_t <> y /\\ tid b_t = z) : tid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z.","conclusion":"tid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z","hypotheses":"(BTID : tid b_t <> tid_init) (x y z : BinNums.positive) (HXY : tid_init = x /\\ tid_init <> y \\/ tid b_t <> x /\\ tid b_t = y) (HYZ : tid_init = y /\\ tid_init <> z \\/ tid b_t <> y /\\ tid b_t = z)","proofString":"desf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) (x z : BinNums.positive) (HXY : tid b_t <> x) (HYZ : tid_init = tid b_t) (HYZ0 : tid_init <> z) : tid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z.","conclusion":"tid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z","hypotheses":"(BTID : tid b_t <> tid_init) (x z : BinNums.positive) (HXY : tid b_t <> x) (HYZ : tid_init = tid b_t) (HYZ0 : tid_init <> z)","proofString":"congruence."},{"statement":"(BTID : tid b_t <> tid_init) : WCore.stable_uncmt_reads_gen X_s' cmt thrdle.","conclusion":"WCore.stable_uncmt_reads_gen X_s' cmt thrdle","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"constructor.\nunfold thrdle.\nbasic_solver.\nunfold thrdle.\nunfolder.\nintros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV).\napply rsr_a_thrdle.\nrewrite rsr_a_ncmt.\nseq_rewrite (    split_rel ⊤₁ ⊤₁      (vf_s' ⨾ same_tid)      same_tid  ).\nrewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : least_elt thrdle tid_init.","conclusion":"least_elt thrdle tid_init","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"unfold thrdle.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : least_elt\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)) tid_init.","conclusion":"least_elt\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)) tid_init","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"basic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : min_elt thrdle tid_init.","conclusion":"min_elt thrdle tid_init","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"unfold thrdle.\nunfolder.\nintros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) : min_elt\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)) tid_init.","conclusion":"min_elt\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)) tid_init","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"unfolder.\nintros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) : forall b : BinNums.positive,\ntid_init = b /\\ tid_init <> tid_init \\/ tid b_t <> b /\\ tid b_t = tid_init ->\nFalse.","conclusion":"forall b : BinNums.positive,\ntid_init = b /\\ tid_init <> tid_init \\/ tid b_t <> b /\\ tid b_t = tid_init ->\nFalse","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"intros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) (b : BinNums.positive) (NB : tid b_t <> b) (IN : tid b_t = tid_init) : False.","conclusion":"False","hypotheses":"(BTID : tid b_t <> tid_init) (b : BinNums.positive) (NB : tid b_t <> b) (IN : tid b_t = tid_init)","proofString":"now apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) : strict_partial_order thrdle.","conclusion":"strict_partial_order thrdle","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"apply rsr_a_thrdle."},{"statement":"(BTID : tid b_t <> tid_init) : vf_s' ⨾ same_tid ⨾ ⦗E_s' \\₁ cmt⦘ ⊆ tid ↓ thrdle ∪ same_tid.","conclusion":"vf_s' ⨾ same_tid ⨾ ⦗E_s' \\₁ cmt⦘ ⊆ tid ↓ thrdle ∪ same_tid","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"rewrite rsr_a_ncmt.\nseq_rewrite (    split_rel ⊤₁ ⊤₁      (vf_s' ⨾ same_tid)      same_tid  ).\nrewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : vf_s' ⨾ same_tid ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle ∪ same_tid.","conclusion":"vf_s' ⨾ same_tid ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle ∪ same_tid","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"seq_rewrite (    split_rel ⊤₁ ⊤₁      (vf_s' ⨾ same_tid)      same_tid  ).\nrewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : ((vf_s' ⨾ same_tid) ∩ same_tid ∪ vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ thrdle ∪ same_tid.","conclusion":"((vf_s' ⨾ same_tid) ∩ same_tid ∪ vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ thrdle ∪ same_tid","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"rewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘\n∪ (vf_s' ⨾ same_tid) ∩ same_tid ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle ∪ same_tid.","conclusion":"(vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘\n∪ (vf_s' ⨾ same_tid) ∩ same_tid ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle ∪ same_tid","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"apply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle.","conclusion":"(vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"remember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : vfsbt ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle.","conclusion":"vfsbt ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"arewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt.","conclusion":"vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"rewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : vfsbt ⊆ ⦗is_init ∪₁ set_compl is_init⦘ ⨾ vfsbt.","conclusion":"vfsbt ⊆ ⦗is_init ∪₁ set_compl is_init⦘ ⨾ vfsbt","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"now rewrite set_compl_union_id, seq_id_l."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle.","conclusion":"(⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"unfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid\n  ↓ (eq tid_init × set_compl (eq tid_init)\n     ∪ set_compl (eq (tid b_t)) × eq (tid b_t)).","conclusion":"(⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid\n  ↓ (eq tid_init × set_compl (eq tid_init)\n     ∪ set_compl (eq (tid b_t)) × eq (tid b_t))","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"rewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ∪ (⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ eq tid_init × set_compl (eq tid_init)\n  ∪ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","conclusion":"(⦗is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ∪ (⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ eq tid_init × set_compl (eq tid_init)\n  ∪ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t)","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"apply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ eq tid_init × set_compl (eq tid_init).","conclusion":"(⦗is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ eq tid_init × set_compl (eq tid_init)","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"unfold is_init.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗fun e : actid =>\n  match e with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ eq tid_init × set_compl (eq tid_init).","conclusion":"(⦗fun e : actid =>\n  match e with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ eq tid_init × set_compl (eq tid_init)","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"basic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","conclusion":"(⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t)","hypotheses":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid)","proofString":"subst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (⦗set_compl is_init⦘ ⨾ (vf_s' ⨾ same_tid \\ same_tid)) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","conclusion":"(⦗set_compl is_init⦘ ⨾ (vf_s' ⨾ same_tid \\ same_tid)) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t)","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"unfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (⦗set_compl is_init⦘\n ⨾ (vf_s' ⨾ (fun x y : actid => tid x = tid y) \\\n    (fun x y : actid => tid x = tid y))) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","conclusion":"(⦗set_compl is_init⦘\n ⨾ (vf_s' ⨾ (fun x y : actid => tid x = tid y) \\\n    (fun x y : actid => tid x = tid y))) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t)","hypotheses":"(BTID : tid b_t <> tid_init)","proofString":"basic_solver."},{"statement":"(NEQ : a_t <> b_t) : upward_closed rpo_imm_s' cmt.","conclusion":"upward_closed rpo_imm_s' cmt","hypotheses":"(NEQ : a_t <> b_t)","proofString":"unfold upward_closed, cmt.\nintros x y RPO CMT.\nsplit.\napply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf.\nintro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) : forall x y : actid, rpo_imm_s' x y -> (E_s \\₁ eq b_t) y -> (E_s \\₁ eq b_t) x.","conclusion":"forall x y : actid, rpo_imm_s' x y -> (E_s \\₁ eq b_t) y -> (E_s \\₁ eq b_t) x","hypotheses":"(NEQ : a_t <> b_t)","proofString":"intros x y RPO CMT.\nsplit.\napply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf.\nintro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) : (E_s \\₁ eq b_t) x.","conclusion":"(E_s \\₁ eq b_t) x","hypotheses":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"split.\napply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf.\nintro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) : E_s x.","conclusion":"E_s x","hypotheses":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"apply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : (⦗E_s'⦘ ⨾ rpo_imm_s' ⨾ ⦗E_s'⦘) x y) (CMT : (E_s \\₁ eq b_t) y) : E_s x.","conclusion":"E_s x","hypotheses":"(NEQ : a_t <> b_t) (x y : actid) (RPO : (⦗E_s'⦘ ⨾ rpo_imm_s' ⨾ ⦗E_s'⦘) x y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"unfolder in RPO.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (CMT : (E_s \\₁ eq b_t) y) (RPO : E_s' x /\\ rpo_imm_s' x y /\\ E_s' y) : E_s x.","conclusion":"E_s x","hypotheses":"(NEQ : a_t <> b_t) (x y : actid) (CMT : (E_s \\₁ eq b_t) y) (RPO : E_s' x /\\ rpo_imm_s' x y /\\ E_s' y)","proofString":"desf."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) : b_t <> x.","conclusion":"b_t <> x","hypotheses":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"intro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) (FALSO : b_t = x) : False.","conclusion":"False","hypotheses":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) (FALSO : b_t = x)","proofString":"subst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : False.","conclusion":"False","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"assert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : (⦗eq b_t⦘ ⨾ sb_s') b_t y.","conclusion":"(⦗eq b_t⦘ ⨾ sb_s') b_t y","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"exists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : ⦗eq b_t⦘ b_t b_t /\\ sb_s' b_t y.","conclusion":"⦗eq b_t⦘ b_t b_t /\\ sb_s' b_t y","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"split; [basic_solver 1|].\nnow apply rpo_imm_in_sb."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : sb_s' b_t y.","conclusion":"sb_s' b_t y","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y)","proofString":"now apply rpo_imm_in_sb."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y) : False.","conclusion":"False","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y)","proofString":"assert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y) : y = a_t.","conclusion":"y = a_t","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y)","proofString":"apply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (eq b_t × eq a_t) b_t y) : y = a_t.","conclusion":"y = a_t","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (eq b_t × eq a_t) b_t y)","proofString":"unfolder in SB.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : b_t = b_t /\\ a_t = y) : y = a_t.","conclusion":"y = a_t","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : b_t = b_t /\\ a_t = y)","proofString":"desf."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y) (YEQ : y = a_t) : False.","conclusion":"False","hypotheses":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y) (YEQ : y = a_t)","proofString":"subst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : False.","conclusion":"False","hypotheses":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t)","proofString":"apply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : (⦗mapper ↑₁ (eq a_t ∩₁ E_t')⦘ ⨾ rpo_s' ⨾ ⦗mapper ↑₁ (eq b_t ∩₁ E_t')⦘) b_t\n  a_t.","conclusion":"(⦗mapper ↑₁ (eq a_t ∩₁ E_t')⦘ ⨾ rpo_s' ⨾ ⦗mapper ↑₁ (eq b_t ∩₁ E_t')⦘) b_t\n  a_t","hypotheses":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t)","proofString":"unfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : (exists y : actid, (a_t = y /\\ E_t' y) /\\ mapper y = b_t) /\\\nrpo_s' b_t a_t /\\ (exists y : actid, (b_t = y /\\ E_t' y) /\\ mapper y = a_t).","conclusion":"(exists y : actid, (a_t = y /\\ E_t' y) /\\ mapper y = b_t) /\\\nrpo_s' b_t a_t /\\ (exists y : actid, (b_t = y /\\ E_t' y) /\\ mapper y = a_t)","hypotheses":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t)","proofString":"splits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : rpo_s' b_t a_t.","conclusion":"rpo_s' b_t a_t","hypotheses":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t)","proofString":"unfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : rpo_imm_s'⁺ b_t a_t.","conclusion":"rpo_imm_s'⁺ b_t a_t","hypotheses":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t)","proofString":"now apply ct_step."},{"statement":"(AIN : E_s b_t) : restr_rel cmt rpo_s' ⊆ rpo_s.","conclusion":"restr_rel cmt rpo_s' ⊆ rpo_s","hypotheses":"(AIN : E_s b_t)","proofString":"assert (BIN : E_s a_t) by apply rsr_a_bin.\nunfold rpo at 1.\nrewrite restr_rel_ct; [| apply rsr_a_rpoimm_upward].\nnow rewrite rsr_a_restr_rpoimm."},{"statement":"(AIN : E_s b_t) (BIN : E_s a_t) : restr_rel cmt rpo_s' ⊆ rpo_s.","conclusion":"restr_rel cmt rpo_s' ⊆ rpo_s","hypotheses":"(AIN : E_s b_t) (BIN : E_s a_t)","proofString":"unfold rpo at 1.\nrewrite restr_rel_ct; [| apply rsr_a_rpoimm_upward].\nnow rewrite rsr_a_restr_rpoimm."},{"statement":"(AIN : E_s b_t) (BIN : E_s a_t) : restr_rel cmt rpo_imm_s'⁺ ⊆ rpo_s.","conclusion":"restr_rel cmt rpo_imm_s'⁺ ⊆ rpo_s","hypotheses":"(AIN : E_s b_t) (BIN : E_s a_t)","proofString":"rewrite restr_rel_ct; [| apply rsr_a_rpoimm_upward].\nnow rewrite rsr_a_restr_rpoimm."},{"statement":"(AIN : E_s b_t) (BIN : E_s a_t) : (restr_rel cmt rpo_imm_s')⁺ ⊆ rpo_s.","conclusion":"(restr_rel cmt rpo_imm_s')⁺ ⊆ rpo_s","hypotheses":"(AIN : E_s b_t) (BIN : E_s a_t)","proofString":"now rewrite rsr_a_restr_rpoimm."},{"statement":"dtrmt ⊆₁ dtrmt ∩₁ E_s.","conclusion":"dtrmt ⊆₁ dtrmt ∩₁ E_s","hypotheses":"","proofString":"rewrite set_inter_absorb_r; auto with xmm hahn."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) : WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","conclusion":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s)","proofString":"assert (NEQ : a_t <> b_t) by apply INV'.\nassert (NEQ' : b_t <> a_t) by now symmetry.\nconstructor; ins.\nrewrite set_inter_absorb_r; basic_solver.\nunfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf.\nnow rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_data rsr_a_pfx).\nnow rewrite (prf_ctrl rsr_a_pfx).\nnow rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) : WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","conclusion":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t)","proofString":"assert (NEQ' : b_t <> a_t) by now symmetry.\nconstructor; ins.\nrewrite set_inter_absorb_r; basic_solver.\nunfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf.\nnow rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_data rsr_a_pfx).\nnow rewrite (prf_ctrl rsr_a_pfx).\nnow rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","conclusion":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"constructor; ins.\nrewrite set_inter_absorb_r; basic_solver.\nunfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf.\nnow rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_data rsr_a_pfx).\nnow rewrite (prf_ctrl rsr_a_pfx).\nnow rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : dtrmt ∩₁ E_s ∩₁ dtrmt ≡₁ E_s ∩₁ dtrmt.","conclusion":"dtrmt ∩₁ E_s ∩₁ dtrmt ≡₁ E_s ∩₁ dtrmt","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"rewrite set_inter_absorb_r; basic_solver."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : eq_dom dtrmt lab_s (upd lab_s b_t l_a).","conclusion":"eq_dom dtrmt lab_s (upd lab_s b_t l_a)","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"unfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : eq_dom (E_s \\₁ (eq b_t ∪₁ eq a_t)) lab_s (upd lab_s b_t l_a).","conclusion":"eq_dom (E_s \\₁ (eq b_t ∪₁ eq a_t)) lab_s (upd lab_s b_t l_a)","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"rewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : eq_dom ((E_s \\₁ eq b_t) ∩₁ (E_s \\₁ eq a_t)) lab_s (upd lab_s b_t l_a).","conclusion":"eq_dom ((E_s \\₁ eq b_t) ∩₁ (E_s \\₁ eq a_t)) lab_s (upd lab_s b_t l_a)","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"apply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : ~ ((E_s \\₁ eq b_t) ∩₁ (E_s \\₁ eq a_t)) b_t.","conclusion":"~ ((E_s \\₁ eq b_t) ∩₁ (E_s \\₁ eq a_t)) b_t","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"unfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : ~ ((E_s b_t /\\ b_t <> b_t) /\\ E_s b_t /\\ a_t <> b_t).","conclusion":"~ ((E_s b_t /\\ b_t <> b_t) /\\ E_s b_t /\\ a_t <> b_t)","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"intro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt (rf_s ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ (rf_t' ⨾ ⦗eq a_t⦘)).","conclusion":"restr_rel dtrmt (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt (rf_s ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ (rf_t' ⨾ ⦗eq a_t⦘))","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"now rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ co_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt\n    (restr_rel (E_s \\₁ eq b_t) co_s\n     ∪ mapper ↑ (⦗eq a_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq a_t⦘)).","conclusion":"restr_rel dtrmt (⦗dtrmt⦘ ⨾ co_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt\n    (restr_rel (E_s \\₁ eq b_t) co_s\n     ∪ mapper ↑ (⦗eq a_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq a_t⦘))","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"now rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ rmw_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt (mapper ↑ rmw_t').","conclusion":"restr_rel dtrmt (⦗dtrmt⦘ ⨾ rmw_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt (mapper ↑ rmw_t')","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"now rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ data_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt data_s.","conclusion":"restr_rel dtrmt (⦗dtrmt⦘ ⨾ data_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt data_s","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"now rewrite (prf_data rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ ctrl_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt ctrl_s.","conclusion":"restr_rel dtrmt (⦗dtrmt⦘ ⨾ ctrl_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt ctrl_s","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"now rewrite (prf_ctrl rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ rmw_dep_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt rmw_dep_s.","conclusion":"restr_rel dtrmt (⦗dtrmt⦘ ⨾ rmw_dep_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt rmw_dep_s","hypotheses":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t)","proofString":"now rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"Wf (WCore.G (WCore.X_start X_s dtrmt)).","conclusion":"Wf (WCore.G (WCore.X_start X_s dtrmt))","hypotheses":"","proofString":"apply sub_WF with (G := G_s) (sc := ∅₂) (sc' := ∅₂).\nins.\nnow rewrite <- rsr_a_dtrmt_init.\napply (G_s_wf INV SIMREL).\napply restrict_sub; [basic_solver |].\nauto with xmm."},{"statement":"is_init ∩₁ E_s ⊆₁ acts_set (WCore.G (WCore.X_start X_s dtrmt)).","conclusion":"is_init ∩₁ E_s ⊆₁ acts_set (WCore.G (WCore.X_start X_s dtrmt))","hypotheses":"","proofString":"ins.\nnow rewrite <- rsr_a_dtrmt_init."},{"statement":"is_init ∩₁ E_s ⊆₁ dtrmt ∩₁ E_s.","conclusion":"is_init ∩₁ E_s ⊆₁ dtrmt ∩₁ E_s","hypotheses":"","proofString":"now rewrite <- rsr_a_dtrmt_init."},{"statement":"Wf G_s.","conclusion":"Wf G_s","hypotheses":"","proofString":"apply (G_s_wf INV SIMREL)."},{"statement":"sub_execution G_s (WCore.G (WCore.X_start X_s dtrmt)) ∅₂ ∅₂.","conclusion":"sub_execution G_s (WCore.G (WCore.X_start X_s dtrmt)) ∅₂ ∅₂","hypotheses":"","proofString":"apply restrict_sub; [basic_solver |].\nauto with xmm."},{"statement":"dtrmt ⊆₁ E_s.","conclusion":"dtrmt ⊆₁ E_s","hypotheses":"","proofString":"auto with xmm."},{"statement":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s'\n  (acts_set (WCore.G (WCore.X_start X_s dtrmt)) ∩₁ cmt).","conclusion":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s'\n  (acts_set (WCore.G (WCore.X_start X_s dtrmt)) ∩₁ cmt)","hypotheses":"","proofString":"ins.\nrewrite set_interA, set_inter_absorb_r.\napply rsr_a_restr_eq.\nrewrite set_inter_absorb_l; auto with xmm."},{"statement":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' (dtrmt ∩₁ E_s ∩₁ cmt).","conclusion":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' (dtrmt ∩₁ E_s ∩₁ cmt)","hypotheses":"","proofString":"rewrite set_interA, set_inter_absorb_r.\napply rsr_a_restr_eq.\nrewrite set_inter_absorb_l; auto with xmm."},{"statement":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","conclusion":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt","hypotheses":"","proofString":"apply rsr_a_restr_eq."},{"statement":"dtrmt ⊆₁ E_s ∩₁ cmt.","conclusion":"dtrmt ⊆₁ E_s ∩₁ cmt","hypotheses":"","proofString":"rewrite set_inter_absorb_l; auto with xmm."},{"statement":"rf_complete (restrict G_s' cmt).","conclusion":"rf_complete (restrict G_s' cmt)","hypotheses":"","proofString":"apply rsr_a_gs_crfc."},{"statement":"acts_set (WCore.G (WCore.X_start X_s dtrmt))\n∩₁ (fun a : actid => is_r (lab (WCore.G (WCore.X_start X_s dtrmt))) a)\n⊆₁ codom_rel (rf (WCore.G (WCore.X_start X_s dtrmt))) ∪₁ cmt.","conclusion":"acts_set (WCore.G (WCore.X_start X_s dtrmt))\n∩₁ (fun a : actid => is_r (lab (WCore.G (WCore.X_start X_s dtrmt))) a)\n⊆₁ codom_rel (rf (WCore.G (WCore.X_start X_s dtrmt))) ∪₁ cmt","hypotheses":"","proofString":"ins.\nrewrite <- rsr_a_dtrmt_in_cmt.\nbasic_solver."},{"statement":"dtrmt ∩₁ E_s ∩₁ R_s ⊆₁ codom_rel (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘) ∪₁ cmt.","conclusion":"dtrmt ∩₁ E_s ∩₁ R_s ⊆₁ codom_rel (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘) ∪₁ cmt","hypotheses":"","proofString":"rewrite <- rsr_a_dtrmt_in_cmt.\nbasic_solver."},{"statement":"dtrmt ∩₁ E_s ∩₁ R_s ⊆₁ codom_rel (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘) ∪₁ dtrmt.","conclusion":"dtrmt ∩₁ E_s ∩₁ R_s ⊆₁ codom_rel (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘) ∪₁ dtrmt","hypotheses":"","proofString":"basic_solver."}]}