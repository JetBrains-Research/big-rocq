{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/arm/Asmgenproof1.v","fileSamples":[{"statement":"(rs : regset) (v1 v2 : val) (m : mem) (rs1 : PregEq.t -> val) : nextinstr (compare_int rs v1 v2 m) CN = Val.negative (Val.sub v1 v2) /\\\nnextinstr (compare_int rs v1 v2 m) CZ =\nVal.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\nnextinstr (compare_int rs v1 v2 m) CC =\nVal.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\nnextinstr (compare_int rs v1 v2 m) CV = Val.sub_overflow v1 v2.","conclusion":"nextinstr (compare_int rs v1 v2 m) CN = Val.negative (Val.sub v1 v2) /\\\nnextinstr (compare_int rs v1 v2 m) CZ =\nVal.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\nnextinstr (compare_int rs v1 v2 m) CC =\nVal.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\nnextinstr (compare_int rs v1 v2 m) CV = Val.sub_overflow v1 v2","hypotheses":"(rs : regset) (v1 v2 : val) (m : mem) (rs1 : PregEq.t -> val)","proofString":"intuition."},{"statement":"(x y : int) : Int.eq x y = zeq (Int.signed x) (Int.signed y).","conclusion":"Int.eq x y = zeq (Int.signed x) (Int.signed y)","hypotheses":"(x y : int)","proofString":"unfold Int.eq.\nunfold proj_sumbool.\ndestruct (zeq (Int.unsigned x) (Int.unsigned y));  destruct (zeq (Int.signed x) (Int.signed y)); auto.\nelim n.\nunfold Int.signed.\nrewrite e; auto.\nelim n.\napply Int.eqm_small_eq; auto with ints.\neapply Int.eqm_trans.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned.\nrewrite e.\napply Int.eqm_signed_unsigned."},{"statement":"(x y : int) : (if zeq (Int.unsigned x) (Int.unsigned y) then true else false) =\nzeq (Int.signed x) (Int.signed y).","conclusion":"(if zeq (Int.unsigned x) (Int.unsigned y) then true else false) =\nzeq (Int.signed x) (Int.signed y)","hypotheses":"(x y : int)","proofString":"unfold proj_sumbool.\ndestruct (zeq (Int.unsigned x) (Int.unsigned y));  destruct (zeq (Int.signed x) (Int.signed y)); auto.\nelim n.\nunfold Int.signed.\nrewrite e; auto.\nelim n.\napply Int.eqm_small_eq; auto with ints.\neapply Int.eqm_trans.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned.\nrewrite e.\napply Int.eqm_signed_unsigned."},{"statement":"(x y : int) : (if zeq (Int.unsigned x) (Int.unsigned y) then true else false) =\n(if zeq (Int.signed x) (Int.signed y) then true else false).","conclusion":"(if zeq (Int.unsigned x) (Int.unsigned y) then true else false) =\n(if zeq (Int.signed x) (Int.signed y) then true else false)","hypotheses":"(x y : int)","proofString":"destruct (zeq (Int.unsigned x) (Int.unsigned y));  destruct (zeq (Int.signed x) (Int.signed y)); auto.\nelim n.\nunfold Int.signed.\nrewrite e; auto.\nelim n.\napply Int.eqm_small_eq; auto with ints.\neapply Int.eqm_trans.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned.\nrewrite e.\napply Int.eqm_signed_unsigned."},{"statement":"(x y : int) (e : Int.unsigned x = Int.unsigned y) (n : Int.signed x <> Int.signed y) : true = false.","conclusion":"true = false","hypotheses":"(x y : int) (e : Int.unsigned x = Int.unsigned y) (n : Int.signed x <> Int.signed y)","proofString":"elim n.\nunfold Int.signed.\nrewrite e; auto."},{"statement":"(x y : int) (e : Int.unsigned x = Int.unsigned y) (n : Int.signed x <> Int.signed y) : Int.signed x = Int.signed y.","conclusion":"Int.signed x = Int.signed y","hypotheses":"(x y : int) (e : Int.unsigned x = Int.unsigned y) (n : Int.signed x <> Int.signed y)","proofString":"unfold Int.signed.\nrewrite e; auto."},{"statement":"(x y : int) (e : Int.unsigned x = Int.unsigned y) (n : Int.signed x <> Int.signed y) : (if zlt (Int.unsigned x) Int.half_modulus\n then Int.unsigned x\n else Int.unsigned x - Int.modulus) =\n(if zlt (Int.unsigned y) Int.half_modulus\n then Int.unsigned y\n else Int.unsigned y - Int.modulus).","conclusion":"(if zlt (Int.unsigned x) Int.half_modulus\n then Int.unsigned x\n else Int.unsigned x - Int.modulus) =\n(if zlt (Int.unsigned y) Int.half_modulus\n then Int.unsigned y\n else Int.unsigned y - Int.modulus)","hypotheses":"(x y : int) (e : Int.unsigned x = Int.unsigned y) (n : Int.signed x <> Int.signed y)","proofString":"rewrite e; auto."},{"statement":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y) : false = true.","conclusion":"false = true","hypotheses":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y)","proofString":"elim n.\napply Int.eqm_small_eq; auto with ints.\neapply Int.eqm_trans.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned.\nrewrite e.\napply Int.eqm_signed_unsigned."},{"statement":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y) : Int.unsigned x = Int.unsigned y.","conclusion":"Int.unsigned x = Int.unsigned y","hypotheses":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y)","proofString":"apply Int.eqm_small_eq; auto with ints.\neapply Int.eqm_trans.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned.\nrewrite e.\napply Int.eqm_signed_unsigned."},{"statement":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y) : Int.eqm (Int.unsigned x) (Int.unsigned y).","conclusion":"Int.eqm (Int.unsigned x) (Int.unsigned y)","hypotheses":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y)","proofString":"eapply Int.eqm_trans.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned.\nrewrite e.\napply Int.eqm_signed_unsigned."},{"statement":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y) : Int.eqm (Int.signed y) (Int.unsigned y).","conclusion":"Int.eqm (Int.signed y) (Int.unsigned y)","hypotheses":"(x y : int) (n : Int.unsigned x <> Int.unsigned y) (e : Int.signed x = Int.signed y)","proofString":"apply Int.eqm_signed_unsigned."},{"statement":"(x y : int) : negb (Int.lt y x) = Int.lt x y || Int.eq x y.","conclusion":"negb (Int.lt y x) = Int.lt x y || Int.eq x y","hypotheses":"(x y : int)","proofString":"unfold Int.lt.\nrewrite int_signed_eq.\nunfold proj_sumbool.\ndestruct (zlt (Int.signed y) (Int.signed x)).\nrewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia.\ndestruct (zeq (Int.signed x) (Int.signed y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) : negb (if zlt (Int.signed y) (Int.signed x) then true else false) =\n(if zlt (Int.signed x) (Int.signed y) then true else false) || Int.eq x y.","conclusion":"negb (if zlt (Int.signed y) (Int.signed x) then true else false) =\n(if zlt (Int.signed x) (Int.signed y) then true else false) || Int.eq x y","hypotheses":"(x y : int)","proofString":"rewrite int_signed_eq.\nunfold proj_sumbool.\ndestruct (zlt (Int.signed y) (Int.signed x)).\nrewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia.\ndestruct (zeq (Int.signed x) (Int.signed y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) : negb (if zlt (Int.signed y) (Int.signed x) then true else false) =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| zeq (Int.signed x) (Int.signed y).","conclusion":"negb (if zlt (Int.signed y) (Int.signed x) then true else false) =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| zeq (Int.signed x) (Int.signed y)","hypotheses":"(x y : int)","proofString":"unfold proj_sumbool.\ndestruct (zlt (Int.signed y) (Int.signed x)).\nrewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia.\ndestruct (zeq (Int.signed x) (Int.signed y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) : negb (if zlt (Int.signed y) (Int.signed x) then true else false) =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| (if zeq (Int.signed x) (Int.signed y) then true else false).","conclusion":"negb (if zlt (Int.signed y) (Int.signed x) then true else false) =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| (if zeq (Int.signed x) (Int.signed y) then true else false)","hypotheses":"(x y : int)","proofString":"destruct (zlt (Int.signed y) (Int.signed x)).\nrewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia.\ndestruct (zeq (Int.signed x) (Int.signed y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) (l : Int.signed y < Int.signed x) : negb true =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| (if zeq (Int.signed x) (Int.signed y) then true else false).","conclusion":"negb true =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| (if zeq (Int.signed x) (Int.signed y) then true else false)","hypotheses":"(x y : int) (l : Int.signed y < Int.signed x)","proofString":"rewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia."},{"statement":"(x y : int) (l : Int.signed y < Int.signed x) : negb true =\nfalse || (if zeq (Int.signed x) (Int.signed y) then true else false).","conclusion":"negb true =\nfalse || (if zeq (Int.signed x) (Int.signed y) then true else false)","hypotheses":"(x y : int) (l : Int.signed y < Int.signed x)","proofString":"rewrite zeq_false.\nauto.\nlia."},{"statement":"(x y : int) (l : Int.signed y < Int.signed x) : negb true = false || false.","conclusion":"negb true = false || false","hypotheses":"(x y : int) (l : Int.signed y < Int.signed x)","proofString":"auto."},{"statement":"(x y : int) (l : Int.signed y < Int.signed x) : Int.signed x <> Int.signed y.","conclusion":"Int.signed x <> Int.signed y","hypotheses":"(x y : int) (l : Int.signed y < Int.signed x)","proofString":"lia."},{"statement":"(x y : int) (l : Int.signed y < Int.signed x) : Int.signed x >= Int.signed y.","conclusion":"Int.signed x >= Int.signed y","hypotheses":"(x y : int) (l : Int.signed y < Int.signed x)","proofString":"lia."},{"statement":"(x y : int) (g : Int.signed y >= Int.signed x) : negb false =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| (if zeq (Int.signed x) (Int.signed y) then true else false).","conclusion":"negb false =\n(if zlt (Int.signed x) (Int.signed y) then true else false)\n|| (if zeq (Int.signed x) (Int.signed y) then true else false)","hypotheses":"(x y : int) (g : Int.signed y >= Int.signed x)","proofString":"destruct (zeq (Int.signed x) (Int.signed y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) (g : Int.signed y >= Int.signed x) (e : Int.signed x = Int.signed y) : negb false =\n(if zlt (Int.signed x) (Int.signed y) then true else false) || true.","conclusion":"negb false =\n(if zlt (Int.signed x) (Int.signed y) then true else false) || true","hypotheses":"(x y : int) (g : Int.signed y >= Int.signed x) (e : Int.signed x = Int.signed y)","proofString":"rewrite zlt_false.\nauto.\nlia."},{"statement":"(x y : int) (g : Int.signed y >= Int.signed x) (e : Int.signed x = Int.signed y) : negb false = false || true.","conclusion":"negb false = false || true","hypotheses":"(x y : int) (g : Int.signed y >= Int.signed x) (e : Int.signed x = Int.signed y)","proofString":"auto."},{"statement":"(x y : int) (g : Int.signed y >= Int.signed x) (e : Int.signed x = Int.signed y) : Int.signed x >= Int.signed y.","conclusion":"Int.signed x >= Int.signed y","hypotheses":"(x y : int) (g : Int.signed y >= Int.signed x) (e : Int.signed x = Int.signed y)","proofString":"lia."},{"statement":"(x y : int) (g : Int.signed y >= Int.signed x) (n : Int.signed x <> Int.signed y) : negb false =\n(if zlt (Int.signed x) (Int.signed y) then true else false) || false.","conclusion":"negb false =\n(if zlt (Int.signed x) (Int.signed y) then true else false) || false","hypotheses":"(x y : int) (g : Int.signed y >= Int.signed x) (n : Int.signed x <> Int.signed y)","proofString":"rewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) (g : Int.signed y >= Int.signed x) (n : Int.signed x <> Int.signed y) : negb false = true || false.","conclusion":"negb false = true || false","hypotheses":"(x y : int) (g : Int.signed y >= Int.signed x) (n : Int.signed x <> Int.signed y)","proofString":"auto."},{"statement":"(x y : int) (g : Int.signed y >= Int.signed x) (n : Int.signed x <> Int.signed y) : Int.signed x < Int.signed y.","conclusion":"Int.signed x < Int.signed y","hypotheses":"(x y : int) (g : Int.signed y >= Int.signed x) (n : Int.signed x <> Int.signed y)","proofString":"lia."},{"statement":"(x y : int) : Int.lt y x = negb (Int.lt x y) && negb (Int.eq x y).","conclusion":"Int.lt y x = negb (Int.lt x y) && negb (Int.eq x y)","hypotheses":"(x y : int)","proofString":"rewrite <- negb_orb.\nrewrite <- int_not_lt.\nrewrite negb_involutive.\nauto."},{"statement":"(x y : int) : Int.lt y x = negb (Int.lt x y || Int.eq x y).","conclusion":"Int.lt y x = negb (Int.lt x y || Int.eq x y)","hypotheses":"(x y : int)","proofString":"rewrite <- int_not_lt.\nrewrite negb_involutive.\nauto."},{"statement":"(x y : int) : Int.lt y x = negb (negb (Int.lt y x)).","conclusion":"Int.lt y x = negb (negb (Int.lt y x))","hypotheses":"(x y : int)","proofString":"rewrite negb_involutive.\nauto."},{"statement":"(x y : int) : Int.lt y x = Int.lt y x.","conclusion":"Int.lt y x = Int.lt y x","hypotheses":"(x y : int)","proofString":"auto."},{"statement":"(x y : int) : negb (Int.ltu y x) = Int.ltu x y || Int.eq x y.","conclusion":"negb (Int.ltu y x) = Int.ltu x y || Int.eq x y","hypotheses":"(x y : int)","proofString":"unfold Int.ltu, Int.eq.\ndestruct (zlt (Int.unsigned y) (Int.unsigned x)).\nrewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia.\ndestruct (zeq (Int.unsigned x) (Int.unsigned y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) : negb (if zlt (Int.unsigned y) (Int.unsigned x) then true else false) =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false)\n|| (if zeq (Int.unsigned x) (Int.unsigned y) then true else false).","conclusion":"negb (if zlt (Int.unsigned y) (Int.unsigned x) then true else false) =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false)\n|| (if zeq (Int.unsigned x) (Int.unsigned y) then true else false)","hypotheses":"(x y : int)","proofString":"destruct (zlt (Int.unsigned y) (Int.unsigned x)).\nrewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia.\ndestruct (zeq (Int.unsigned x) (Int.unsigned y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) (l : Int.unsigned y < Int.unsigned x) : negb true =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false)\n|| (if zeq (Int.unsigned x) (Int.unsigned y) then true else false).","conclusion":"negb true =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false)\n|| (if zeq (Int.unsigned x) (Int.unsigned y) then true else false)","hypotheses":"(x y : int) (l : Int.unsigned y < Int.unsigned x)","proofString":"rewrite zlt_false.\nrewrite zeq_false.\nauto.\nlia.\nlia."},{"statement":"(x y : int) (l : Int.unsigned y < Int.unsigned x) : negb true =\nfalse || (if zeq (Int.unsigned x) (Int.unsigned y) then true else false).","conclusion":"negb true =\nfalse || (if zeq (Int.unsigned x) (Int.unsigned y) then true else false)","hypotheses":"(x y : int) (l : Int.unsigned y < Int.unsigned x)","proofString":"rewrite zeq_false.\nauto.\nlia."},{"statement":"(x y : int) (l : Int.unsigned y < Int.unsigned x) : negb true = false || false.","conclusion":"negb true = false || false","hypotheses":"(x y : int) (l : Int.unsigned y < Int.unsigned x)","proofString":"auto."},{"statement":"(x y : int) (l : Int.unsigned y < Int.unsigned x) : Int.unsigned x <> Int.unsigned y.","conclusion":"Int.unsigned x <> Int.unsigned y","hypotheses":"(x y : int) (l : Int.unsigned y < Int.unsigned x)","proofString":"lia."},{"statement":"(x y : int) (l : Int.unsigned y < Int.unsigned x) : Int.unsigned x >= Int.unsigned y.","conclusion":"Int.unsigned x >= Int.unsigned y","hypotheses":"(x y : int) (l : Int.unsigned y < Int.unsigned x)","proofString":"lia."},{"statement":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) : negb false =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false)\n|| (if zeq (Int.unsigned x) (Int.unsigned y) then true else false).","conclusion":"negb false =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false)\n|| (if zeq (Int.unsigned x) (Int.unsigned y) then true else false)","hypotheses":"(x y : int) (g : Int.unsigned y >= Int.unsigned x)","proofString":"destruct (zeq (Int.unsigned x) (Int.unsigned y)).\nrewrite zlt_false.\nauto.\nlia.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (e : Int.unsigned x = Int.unsigned y) : negb false =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false) || true.","conclusion":"negb false =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false) || true","hypotheses":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (e : Int.unsigned x = Int.unsigned y)","proofString":"rewrite zlt_false.\nauto.\nlia."},{"statement":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (e : Int.unsigned x = Int.unsigned y) : negb false = false || true.","conclusion":"negb false = false || true","hypotheses":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (e : Int.unsigned x = Int.unsigned y)","proofString":"auto."},{"statement":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (e : Int.unsigned x = Int.unsigned y) : Int.unsigned x >= Int.unsigned y.","conclusion":"Int.unsigned x >= Int.unsigned y","hypotheses":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (e : Int.unsigned x = Int.unsigned y)","proofString":"lia."},{"statement":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (n : Int.unsigned x <> Int.unsigned y) : negb false =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false) || false.","conclusion":"negb false =\n(if zlt (Int.unsigned x) (Int.unsigned y) then true else false) || false","hypotheses":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (n : Int.unsigned x <> Int.unsigned y)","proofString":"rewrite zlt_true.\nauto.\nlia."},{"statement":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (n : Int.unsigned x <> Int.unsigned y) : negb false = true || false.","conclusion":"negb false = true || false","hypotheses":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (n : Int.unsigned x <> Int.unsigned y)","proofString":"auto."},{"statement":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (n : Int.unsigned x <> Int.unsigned y) : Int.unsigned x < Int.unsigned y.","conclusion":"Int.unsigned x < Int.unsigned y","hypotheses":"(x y : int) (g : Int.unsigned y >= Int.unsigned x) (n : Int.unsigned x <> Int.unsigned y)","proofString":"lia."},{"statement":"(x y : int) : Int.ltu y x = negb (Int.ltu x y) && negb (Int.eq x y).","conclusion":"Int.ltu y x = negb (Int.ltu x y) && negb (Int.eq x y)","hypotheses":"(x y : int)","proofString":"rewrite <- negb_orb.\nrewrite <- int_not_ltu.\nrewrite negb_involutive.\nauto."},{"statement":"(x y : int) : Int.ltu y x = negb (Int.ltu x y || Int.eq x y).","conclusion":"Int.ltu y x = negb (Int.ltu x y || Int.eq x y)","hypotheses":"(x y : int)","proofString":"rewrite <- int_not_ltu.\nrewrite negb_involutive.\nauto."},{"statement":"(x y : int) : Int.ltu y x = negb (negb (Int.ltu y x)).","conclusion":"Int.ltu y x = negb (negb (Int.ltu y x))","hypotheses":"(x y : int)","proofString":"rewrite negb_involutive.\nauto."},{"statement":"(x y : int) : Int.ltu y x = Int.ltu y x.","conclusion":"Int.ltu y x = Int.ltu y x","hypotheses":"(x y : int)","proofString":"auto."},{"statement":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b) : eval_testcond (cond_for_signed_cmp c) (nextinstr (compare_int rs v1 v2 m)) =\nSome b.","conclusion":"eval_testcond (cond_for_signed_cmp c) (nextinstr (compare_int rs v1 v2 m)) =\nSome b","hypotheses":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b)","proofString":"generalize (compare_int_spec rs v1 v2 m).\nset (rs' := nextinstr (compare_int rs v1 v2 m)).\nintros [A [B [C D]]].\ndestruct v1; destruct v2; simpl in H; inv H.\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\nsimpl.\nunfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b) : (let rs1 := nextinstr (compare_int rs v1 v2 m) in\n rs1 CN = Val.negative (Val.sub v1 v2) /\\\n rs1 CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs1 CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs1 CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) (nextinstr (compare_int rs v1 v2 m)) =\nSome b.","conclusion":"(let rs1 := nextinstr (compare_int rs v1 v2 m) in\n rs1 CN = Val.negative (Val.sub v1 v2) /\\\n rs1 CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs1 CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs1 CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) (nextinstr (compare_int rs v1 v2 m)) =\nSome b","hypotheses":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b)","proofString":"set (rs' := nextinstr (compare_int rs v1 v2 m)).\nintros [A [B [C D]]].\ndestruct v1; destruct v2; simpl in H; inv H.\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\nsimpl.\nunfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) : (let rs1 := rs' in\n rs1 CN = Val.negative (Val.sub v1 v2) /\\\n rs1 CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs1 CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs1 CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) rs' = Some b.","conclusion":"(let rs1 := rs' in\n rs1 CN = Val.negative (Val.sub v1 v2) /\\\n rs1 CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs1 CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs1 CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) rs' = Some b","hypotheses":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b) (rs' : PregEq.t -> val)","proofString":"intros [A [B [C D]]].\ndestruct v1; destruct v2; simpl in H; inv H.\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\nsimpl.\nunfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub v1 v2)) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2) (D : rs' CV = Val.sub_overflow v1 v2) : eval_testcond (cond_for_signed_cmp c) rs' = Some b.","conclusion":"eval_testcond (cond_for_signed_cmp c) rs' = Some b","hypotheses":"(c : comparison) (v1 v2 : val) (rs : regset) (m : mem) (b : bool) (H : Val.cmp_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub v1 v2)) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2) (D : rs' CV = Val.sub_overflow v1 v2)","proofString":"destruct v1; destruct v2; simpl in H; inv H.\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\nsimpl.\nunfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : eval_testcond (cond_for_signed_cmp c) rs' = Some (Int.cmp c i i0).","conclusion":"eval_testcond (cond_for_signed_cmp c) rs' = Some (Int.cmp c i i0)","hypotheses":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"unfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\nsimpl.\nunfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int.cmp c i i0).","conclusion":"match cond_for_signed_cmp c with\n| TCeq =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int.cmp c i i0)","hypotheses":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"rewrite A; rewrite B; rewrite C; rewrite D.\nsimpl.\nunfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int.cmp c i i0).","conclusion":"match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int.cmp c i i0)","hypotheses":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"simpl.\nunfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.zero)\n| TClt =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.one)\n| TCgt =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.zero && \n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.one || \n           Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmp c i i0).","conclusion":"match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.zero)\n| TClt =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.one)\n| TCgt =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.zero && \n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.one || \n           Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmp c i i0)","hypotheses":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"unfold Val.cmp, Val.cmpu.\nrewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.zero)\n| TClt =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.one)\n| TCgt =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.zero && \n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.one || \n           Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmp c i i0).","conclusion":"match cond_for_signed_cmp c with\n| TCeq =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.zero)\n| TClt =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.one)\n| TCgt =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.zero && \n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.one || \n           Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmp c i i0)","hypotheses":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"rewrite Int.lt_sub_overflow.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge => Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero)\n| TClt => Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one)\n| TCgt =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero &&\n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one\n           || Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmp c i i0).","conclusion":"match cond_for_signed_cmp c with\n| TCeq =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Cge (Vint i) (Vint i0))\n    with\n    | Vint c0 =>\n        match\n          Val.of_optbool\n            (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge => Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero)\n| TClt => Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one)\n| TCgt =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero &&\n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_optbool\n        (Val.cmpu_bool (Mem.valid_pointer m) Ceq (Vint i) (Vint i0))\n    with\n    | Vint z =>\n        Some\n          (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one\n           || Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmp c i i0)","hypotheses":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"destruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.lt i i0); auto.\nrewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto.\nrewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity.\ndestruct (Int.lt i i0); reflexivity."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Int.eq i i0).","conclusion":"match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Int.eq i i0)","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Int.eq i i0)).","conclusion":"match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Int.eq i i0))","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one) =\nSome (Int.lt i i0).","conclusion":"Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one) =\nSome (Int.lt i i0)","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"destruct (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one\n       || Int.eq z Int.one)\n| _ => None\nend = Some (negb (Int.lt i0 i)).","conclusion":"match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one\n       || Int.eq z Int.one)\n| _ => None\nend = Some (negb (Int.lt i0 i))","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"rewrite int_not_lt.\ndestruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one\n       || Int.eq z Int.one)\n| _ => None\nend = Some (Int.lt i i0 || Int.eq i i0).","conclusion":"match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one\n       || Int.eq z Int.one)\n| _ => None\nend = Some (Int.lt i i0 || Int.eq i i0)","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"destruct (Int.lt i i0); simpl; destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero &&\n       Int.eq z Int.zero)\n| _ => None\nend = Some (Int.lt i0 i).","conclusion":"match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero &&\n       Int.eq z Int.zero)\n| _ => None\nend = Some (Int.lt i0 i)","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"rewrite (int_lt_not i i0).\ndestruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero &&\n       Int.eq z Int.zero)\n| _ => None\nend = Some (negb (Int.lt i i0) && negb (Int.eq i i0)).","conclusion":"match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero &&\n       Int.eq z Int.zero)\n| _ => None\nend = Some (negb (Int.lt i i0) && negb (Int.eq i i0))","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"destruct (Int.lt i i0); destruct (Int.eq i i0); reflexivity."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero) =\nSome (negb (Int.lt i i0)).","conclusion":"Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero) =\nSome (negb (Int.lt i i0))","hypotheses":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (A : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (B : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (C : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (D : rs' CV = Val.sub_overflow (Vint i) (Vint i0))","proofString":"destruct (Int.lt i i0); reflexivity."},{"statement":"(rs : regset) (v1 v2 : val) : nextinstr (compare_float rs v1 v2) PC = Val.offset_ptr (rs PC) Ptrofs.one.","conclusion":"nextinstr (compare_float rs v1 v2) PC = Val.offset_ptr (rs PC) Ptrofs.one","hypotheses":"(rs : regset) (v1 v2 : val)","proofString":"unfold compare_float.\ndestruct v1; destruct v2; reflexivity."},{"statement":"(rs : regset) (v1 v2 : val) : nextinstr\n  match v1 with\n  | Vfloat f1 =>\n      match v2 with\n      | Vfloat f2 =>\n          (((rs # CN <- (Val.of_bool (Float.cmp Clt f1 f2))) # CZ <-\n            (Val.of_bool (Float.cmp Ceq f1 f2))) # CC <-\n           (Val.of_bool (negb (Float.cmp Clt f1 f2)))) # CV <-\n          (Val.of_bool (negb (Float.ordered f1 f2)))\n      | _ =>\n          (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <-\n          Vundef\n      end\n  | _ => (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <- Vundef\n  end PC = Val.offset_ptr (rs PC) Ptrofs.one.","conclusion":"nextinstr\n  match v1 with\n  | Vfloat f1 =>\n      match v2 with\n      | Vfloat f2 =>\n          (((rs # CN <- (Val.of_bool (Float.cmp Clt f1 f2))) # CZ <-\n            (Val.of_bool (Float.cmp Ceq f1 f2))) # CC <-\n           (Val.of_bool (negb (Float.cmp Clt f1 f2)))) # CV <-\n          (Val.of_bool (negb (Float.ordered f1 f2)))\n      | _ =>\n          (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <-\n          Vundef\n      end\n  | _ => (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <- Vundef\n  end PC = Val.offset_ptr (rs PC) Ptrofs.one","hypotheses":"(rs : regset) (v1 v2 : val)","proofString":"destruct v1; destruct v2; reflexivity."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) : eval_testcond (cond_for_float_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (Float.cmp c n1 n2).","conclusion":"eval_testcond (cond_for_float_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (Float.cmp c n1 n2)","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset)","proofString":"generalize (compare_float_spec rs n1 n2).\nset (rs' := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))).\nintros [A [B [C D]]].\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) : (let rs1 := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2)) in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (Float.cmp c n1 n2).","conclusion":"(let rs1 := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2)) in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (Float.cmp c n1 n2)","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset)","proofString":"set (rs' := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))).\nintros [A [B [C D]]].\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) : (let rs1 := rs' in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_cmp c) rs' = Some (Float.cmp c n1 n2).","conclusion":"(let rs1 := rs' in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_cmp c) rs' = Some (Float.cmp c n1 n2)","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val)","proofString":"intros [A [B [C D]]].\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : eval_testcond (cond_for_float_cmp c) rs' = Some (Float.cmp c n1 n2).","conclusion":"eval_testcond (cond_for_float_cmp c) rs' = Some (Float.cmp c n1 n2)","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"unfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match cond_for_float_cmp c with\n| TCeq =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Float.cmp c n1 n2).","conclusion":"match cond_for_float_cmp c with\n| TCeq =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Float.cmp c n1 n2)","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match cond_for_float_cmp c with\n| TCeq =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Float.cmp c n1 n2).","conclusion":"match cond_for_float_cmp c with\n| TCeq =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Float.cmp c n1 n2)","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Float.cmp Ceq n1 n2).","conclusion":"match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Float.cmp Ceq n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (Float.cmp Cne n1 n2).","conclusion":"match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (Float.cmp Cne n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Float.cmp Ceq n1 n2)).","conclusion":"match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Float.cmp Ceq n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Clt n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Float.cmp Clt n1 n2).","conclusion":"match Val.of_bool (Float.cmp Clt n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Float.cmp Clt n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Clt n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cle n1 n2).","conclusion":"match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cle n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Clt n1 n2 || Float.cmp Ceq n1 n2).","conclusion":"match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Clt n1 n2 || Float.cmp Ceq n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Clt n1 n2); destruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cgt n1 n2).","conclusion":"match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cgt n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true))) : match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some true.","conclusion":"match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some true","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = false) (A : rs' CN = Val.of_bool false) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb false)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || false || true))) : match Val.of_bool (negb (true || false || true)) with\n| Vint o =>\n    match Val.of_bool false with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some true.","conclusion":"match Val.of_bool (negb (true || false || true)) with\n| Vint o =>\n    match Val.of_bool false with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some true","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = false) (A : rs' CN = Val.of_bool false) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb false)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || false || true)))","proofString":"exfalso; eapply Float.cmp_gt_eq_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true))) : match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool false with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some true.","conclusion":"match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool false with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some true","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cge n1 n2).","conclusion":"match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cge n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cgt n1 n2 || Float.cmp Ceq n1 n2).","conclusion":"match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (Float.cmp Cgt n1 n2 || Float.cmp Ceq n1 n2)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true))) : match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (true || true).","conclusion":"match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (true || true)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_eq_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = false) (D : rs' CV = Val.of_bool (negb (true || true || false))) : match Val.of_bool (negb (true || true || false)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (false || true).","conclusion":"match Val.of_bool (negb (true || true || false)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (false || true)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = false) (D : rs' CV = Val.of_bool (negb (true || true || false)))","proofString":"exfalso; eapply Float.cmp_lt_eq_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true))) : match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (true || false).","conclusion":"match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (true || false)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) : eval_testcond (cond_for_float_not_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (negb (Float.cmp c n1 n2)).","conclusion":"eval_testcond (cond_for_float_not_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (negb (Float.cmp c n1 n2))","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset)","proofString":"generalize (compare_float_spec rs n1 n2).\nset (rs' := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))).\nintros [A [B [C D]]].\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) : (let rs1 := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2)) in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_not_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (negb (Float.cmp c n1 n2)).","conclusion":"(let rs1 := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2)) in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_not_cmp c)\n  (nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))) =\nSome (negb (Float.cmp c n1 n2))","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset)","proofString":"set (rs' := nextinstr (compare_float rs (Vfloat n1) (Vfloat n2))).\nintros [A [B [C D]]].\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) : (let rs1 := rs' in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_not_cmp c) rs' =\nSome (negb (Float.cmp c n1 n2)).","conclusion":"(let rs1 := rs' in\n rs1 CN = Val.of_bool (Float.cmp Clt n1 n2) /\\\n rs1 CZ = Val.of_bool (Float.cmp Ceq n1 n2) /\\\n rs1 CC = Val.of_bool (negb (Float.cmp Clt n1 n2)) /\\\n rs1 CV =\n Val.of_bool\n   (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) ->\neval_testcond (cond_for_float_not_cmp c) rs' =\nSome (negb (Float.cmp c n1 n2))","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val)","proofString":"intros [A [B [C D]]].\nunfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : eval_testcond (cond_for_float_not_cmp c) rs' =\nSome (negb (Float.cmp c n1 n2)).","conclusion":"eval_testcond (cond_for_float_not_cmp c) rs' =\nSome (negb (Float.cmp c n1 n2))","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"unfold eval_testcond.\nrewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match cond_for_float_not_cmp c with\n| TCeq =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (negb (Float.cmp c n1 n2)).","conclusion":"match cond_for_float_not_cmp c with\n| TCeq =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs' CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs' CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs' CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs' CC with\n    | Vint c0 =>\n        match rs' CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs' CV with\n    | Vint o =>\n        match rs' CN with\n        | Vint s =>\n            match rs' CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (negb (Float.cmp c n1 n2))","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite A; rewrite B; rewrite C; rewrite D.\ndestruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match cond_for_float_not_cmp c with\n| TCeq =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (negb (Float.cmp c n1 n2)).","conclusion":"match cond_for_float_not_cmp c with\n| TCeq =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n    | Vint c0 =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match\n      Val.of_bool\n        (negb\n           (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\n    with\n    | Vint o =>\n        match Val.of_bool (Float.cmp Clt n1 n2) with\n        | Vint s =>\n            match Val.of_bool (Float.cmp Ceq n1 n2) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (negb (Float.cmp c n1 n2))","hypotheses":"(c : comparison) (n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct c; simpl.\ndestruct (Float.cmp Ceq n1 n2); auto.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto.\ndestruct (Float.cmp Clt n1 n2); auto.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Float.cmp Ceq n1 n2)).","conclusion":"match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Float.cmp Ceq n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (negb (Float.cmp Cne n1 n2)).","conclusion":"match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (negb (Float.cmp Cne n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (negb (negb (Float.cmp Ceq n1 n2))).","conclusion":"match Val.of_bool (Float.cmp Ceq n1 n2) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (negb (negb (Float.cmp Ceq n1 n2)))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (Float.cmp Clt n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Float.cmp Clt n1 n2)).","conclusion":"match Val.of_bool (Float.cmp Clt n1 n2) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Float.cmp Clt n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Clt n1 n2); auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cle n1 n2)).","conclusion":"match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cle n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Clt n1 n2 || Float.cmp Ceq n1 n2)).","conclusion":"match Val.of_bool (negb (Float.cmp Clt n1 n2)) with\n| Vint c =>\n    match Val.of_bool (Float.cmp Ceq n1 n2) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Clt n1 n2 || Float.cmp Ceq n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Clt n1 n2) eqn:LT; destruct (Float.cmp Ceq n1 n2) eqn:EQ; auto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cgt n1 n2)).","conclusion":"match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s =>\n        match Val.of_bool (Float.cmp Ceq n1 n2) with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cgt n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto.\nexfalso; eapply Float.cmp_gt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true))) : match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb true).","conclusion":"match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb true)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = false) (A : rs' CN = Val.of_bool false) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb false)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || false || true))) : match Val.of_bool (negb (true || false || true)) with\n| Vint o =>\n    match Val.of_bool false with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb true).","conclusion":"match Val.of_bool (negb (true || false || true)) with\n| Vint o =>\n    match Val.of_bool false with\n    | Vint s =>\n        match Val.of_bool true with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb true)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = false) (A : rs' CN = Val.of_bool false) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb false)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || false || true)))","proofString":"exfalso; eapply Float.cmp_gt_eq_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true))) : match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool false with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb true).","conclusion":"match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s =>\n        match Val.of_bool false with\n        | Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (negb true)","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cge n1 n2)).","conclusion":"match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cge n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"rewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))) : match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cgt n1 n2 || Float.cmp Ceq n1 n2)).","conclusion":"match\n  Val.of_bool\n    (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2))\nwith\n| Vint o =>\n    match Val.of_bool (Float.cmp Clt n1 n2) with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Float.cmp Cgt n1 n2 || Float.cmp Ceq n1 n2))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (A : rs' CN = Val.of_bool (Float.cmp Clt n1 n2)) (B : rs' CZ = Val.of_bool (Float.cmp Ceq n1 n2)) (C : rs' CC = Val.of_bool (negb (Float.cmp Clt n1 n2))) (D : rs' CV =\nVal.of_bool\n  (negb (Float.cmp Ceq n1 n2 || Float.cmp Clt n1 n2 || Float.cmp Cgt n1 n2)))","proofString":"destruct (Float.cmp Ceq n1 n2) eqn:EQ;  destruct (Float.cmp Clt n1 n2) eqn:LT;  destruct (Float.cmp Cgt n1 n2) eqn:GT; auto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_eq_false; eauto.\nexfalso; eapply Float.cmp_lt_gt_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true))) : match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (true || true)).","conclusion":"match Val.of_bool (negb (true || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (true || true))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (true || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_eq_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = false) (D : rs' CV = Val.of_bool (negb (true || true || false))) : match Val.of_bool (negb (true || true || false)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (false || true)).","conclusion":"match Val.of_bool (negb (true || true || false)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (false || true))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = true) (B : rs' CZ = Val.of_bool true) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = false) (D : rs' CV = Val.of_bool (negb (true || true || false)))","proofString":"exfalso; eapply Float.cmp_lt_eq_false; eauto."},{"statement":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true))) : match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (true || false)).","conclusion":"match Val.of_bool (negb (false || true || true)) with\n| Vint o =>\n    match Val.of_bool true with\n    | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (true || false))","hypotheses":"(n1 n2 : float) (rs : regset) (rs' : PregEq.t -> val) (LT : Float.cmp Clt n1 n2 = true) (A : rs' CN = Val.of_bool true) (EQ : Float.cmp Ceq n1 n2 = false) (B : rs' CZ = Val.of_bool false) (C : rs' CC = Val.of_bool (negb true)) (GT : Float.cmp Cgt n1 n2 = true) (D : rs' CV = Val.of_bool (negb (false || true || true)))","proofString":"exfalso; eapply Float.cmp_lt_gt_false; eauto."}]}