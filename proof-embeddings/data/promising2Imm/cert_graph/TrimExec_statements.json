{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/cert_graph/TrimExec.v","fileSamples":[{"statement":"acts_set G \\₁ (fun a : actid => is_init a)\n≡₁ acts_set\n     {|\n       acts_set :=\n         acts_set G\n         ∩₁ (fun e : actid =>\n             exists e' : actid,\n               acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e e');\n       threads_set := threads_set G;\n       lab := lab G;\n       rmw := rmw G;\n       data := data G;\n       addr := addr G;\n       ctrl := ctrl G;\n       rmw_dep := rmw_dep G;\n       rf := rf G;\n       co := co G\n     |} \\₁ (fun a : actid => is_init a).","proofString":"simpl.\nsplit; [| basic_solver].\nunfolder.\nins.\ndesc.\nsplits; auto.\nexists x.\nsplits; auto.\nbasic_solver."},{"statement":"acts_set G \\₁ (fun a : actid => is_init a)\n≡₁ acts_set G\n   ∩₁ (fun e : actid =>\n       exists e' : actid,\n         acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e e') \\₁\n   (fun a : actid => is_init a).","proofString":"split; [| basic_solver].\nunfolder.\nins.\ndesc.\nsplits; auto.\nexists x.\nsplits; auto.\nbasic_solver."},{"statement":"acts_set G \\₁ (fun a : actid => is_init a)\n⊆₁ acts_set G\n   ∩₁ (fun e : actid =>\n       exists e' : actid,\n         acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e e') \\₁\n   (fun a : actid => is_init a).","proofString":"unfolder.\nins.\ndesc.\nsplits; auto.\nexists x.\nsplits; auto.\nbasic_solver."},{"statement":"forall x : actid,\nacts_set G x /\\ ~ is_init x ->\n(acts_set G x /\\\n (exists e' : actid, acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) x e')) /\\\n~ is_init x.","proofString":"ins.\ndesc.\nsplits; auto.\nexists x.\nsplits; auto.\nbasic_solver."},{"statement":"(x : actid) (H : acts_set G x /\\ ~ is_init x) : (acts_set G x /\\\n (exists e' : actid, acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) x e')) /\\\n~ is_init x.","proofString":"desc.\nsplits; auto.\nexists x.\nsplits; auto.\nbasic_solver."},{"statement":"(x : actid) (H : acts_set G x) (H0 : ~ is_init x) : (acts_set G x /\\\n (exists e' : actid, acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) x e')) /\\\n~ is_init x.","proofString":"splits; auto.\nexists x.\nsplits; auto.\nbasic_solver."},{"statement":"(x : actid) (H : acts_set G x) (H0 : ~ is_init x) : exists e' : actid, acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) x e'.","proofString":"exists x.\nsplits; auto.\nbasic_solver."},{"statement":"(x : actid) (H : acts_set G x) (H0 : ~ is_init x) : acts_set G x /\\ ~ is_init x /\\ same_loc (lab G) x x.","proofString":"splits; auto.\nbasic_solver."},{"statement":"(x : actid) (H : acts_set G x) (H0 : ~ is_init x) : same_loc (lab G) x x.","proofString":"basic_solver."},{"statement":"(findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (H : ~ inhabited location) : forall (e : actid) (l : location),\nacts_set (trim_exec G) e -> loc (lab G) e = Some l -> In l [].","proofString":"ins.\neauto."},{"statement":"(findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (H : ~ inhabited location) (e : actid) (l : location) (E'e : trim_events G e) (LOC : loc (lab G) e = Some l) : False.","proofString":"eauto."},{"statement":"(findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (l0 : location) (defloc : actid -> location) (e : actid) (l : location) (E'e : acts_set G e) (e' : actid) (E'e0 : acts_set G e') (E'e1 : ~ is_init e') (E'e2 : same_loc (lab G) e e') (LOC : loc (lab G) e = Some l) : match loc (lab G) e' with\n| Some l1 => l1\n| None => l0\nend = l.","proofString":"by rewrite <- E'e2, LOC."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l : location),\nacts_set (trim_exec G) e -> loc (lab G) e = Some l -> In l locs) : Basics.flip set_subset (acts_set G \\₁ (fun a : actid => is_init a))\n  (acts_set G\n   ∩₁ (fun e : actid =>\n       exists e' : actid,\n         acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e e')\n   ∩₁ set_compl (fun a : actid => is_init a)).","proofString":"red.\nbasic_solver."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l : location),\nacts_set (trim_exec G) e -> loc (lab G) e = Some l -> In l locs) : acts_set G\n∩₁ (fun e : actid =>\n    exists e' : actid, acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e e')\n∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ acts_set G \\₁ (fun a : actid => is_init a).","proofString":"basic_solver."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l : location),\ntrim_events G e -> loc (lab G) e = Some l -> In l locs) (x : actid) (IN : (acts_set G\n ∩₁ (fun e : actid =>\n     exists e' : actid,\n       acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e e')\n ∩₁ (fun a : actid => is_init a)) x) : In x (map InitEvent locs).","proofString":"unfolder in IN.\ndesc.\ndestruct x; [| done].\napply in_map_iff.\neexists.\nsplit; eauto.\neapply FIN_LOCS; eauto.\nred.\nunfolder.\nsplits; eauto.\nexists e'.\nsplits; eauto.\nbasic_solver.\nrewrite <- IN3.\nunfold loc.\nrewrite wf_init_lab; auto."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l : location),\ntrim_events G e -> loc (lab G) e = Some l -> In l locs) (x : actid) (IN : (acts_set G x /\\\n (exists e' : actid, acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) x e')) /\\\nis_init x) : In x (map InitEvent locs).","proofString":"desc.\ndestruct x; [| done].\napply in_map_iff.\neexists.\nsplit; eauto.\neapply FIN_LOCS; eauto.\nred.\nunfolder.\nsplits; eauto.\nexists e'.\nsplits; eauto.\nbasic_solver.\nrewrite <- IN3.\nunfold loc.\nrewrite wf_init_lab; auto."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l : location),\ntrim_events G e -> loc (lab G) e = Some l -> In l locs) (x : actid) (IN : acts_set G x) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) x e') (IN0 : is_init x) : In x (map InitEvent locs).","proofString":"destruct x; [| done].\napply in_map_iff.\neexists.\nsplit; eauto.\neapply FIN_LOCS; eauto.\nred.\nunfolder.\nsplits; eauto.\nexists e'.\nsplits; eauto.\nbasic_solver.\nrewrite <- IN3.\nunfold loc.\nrewrite wf_init_lab; auto."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : In (InitEvent l) (map InitEvent locs).","proofString":"apply in_map_iff.\neexists.\nsplit; eauto.\neapply FIN_LOCS; eauto.\nred.\nunfolder.\nsplits; eauto.\nexists e'.\nsplits; eauto.\nbasic_solver.\nrewrite <- IN3.\nunfold loc.\nrewrite wf_init_lab; auto."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : exists x : location, InitEvent x = InitEvent l /\\ In x locs.","proofString":"eexists.\nsplit; eauto.\neapply FIN_LOCS; eauto.\nred.\nunfolder.\nsplits; eauto.\nexists e'.\nsplits; eauto.\nbasic_solver.\nrewrite <- IN3.\nunfold loc.\nrewrite wf_init_lab; auto."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : In l locs.","proofString":"eapply FIN_LOCS; eauto.\nred.\nunfolder.\nsplits; eauto.\nexists e'.\nsplits; eauto.\nbasic_solver.\nrewrite <- IN3.\nunfold loc.\nrewrite wf_init_lab; auto."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : exists e'0 : actid,\n  acts_set G e'0 /\\ ~ is_init e'0 /\\ same_loc (lab G) e' e'0.","proofString":"exists e'.\nsplits; eauto.\nbasic_solver."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e' e'.","proofString":"splits; eauto.\nbasic_solver."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : same_loc (lab G) e' e'.","proofString":"basic_solver."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : loc (lab G) (InitEvent l) = Some l.","proofString":"unfold loc.\nrewrite wf_init_lab; auto."},{"statement":"(FIN' : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) (locs : list location) (FIN_LOCS : forall (e : actid) (l0 : location),\ntrim_events G e -> loc (lab G) e = Some l0 -> In l0 locs) (l : location) (IN : acts_set G (InitEvent l)) (e' : actid) (IN1 : acts_set G e') (IN2 : ~ is_init e') (IN3 : same_loc (lab G) (InitEvent l) e') (IN0 : is_init (InitEvent l)) : match lab G (InitEvent l) with\n| Aload _ _ l0 _ | Astore _ _ l0 _ => Some l0\n| Afence _ => None\nend = Some l.","proofString":"rewrite wf_init_lab; auto."},{"statement":"acts_set G\n∩₁ (fun e : actid =>\n    exists e' : actid, acts_set G e' /\\ ~ is_init e' /\\ same_loc (lab G) e e')\n⊆₁ acts_set G.","proofString":"basic_solver."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : wf_sc (trim_exec G) (restr_rel (trim_events G) sc_).","proofString":"split; simpl.\nbasic_solver.\nrewrite wf_scD, restr_relE.\nbasic_solver.\nbasic_solver.\nred.\nins.\nred in wf_sc_total.\nunfolder in *.\ndesc.\nforward eapply (@trim_events_inclusion a) as Ea; [basic_solver| ].\nforward eapply (@trim_events_inclusion b) as Eb; [basic_solver| ].\nspecialize wf_sc_total with (a := a) (b := b).\nspecialize_full wf_sc_total; auto.\ndesf; auto.\nbasic_solver."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : restr_rel (trim_events G) sc_\n≡ ⦗trim_events G⦘ ⨾ restr_rel (trim_events G) sc_ ⨾ ⦗trim_events G⦘.","proofString":"basic_solver."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : restr_rel (trim_events G) sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ restr_rel (trim_events G) sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘.","proofString":"rewrite wf_scD, restr_relE.\nbasic_solver."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : ⦗trim_events G⦘\n⨾ (⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n   ⨾ sc_\n     ⨾ ⦗(fun a : actid => is_f (lab G) a)\n        ∩₁ (fun a : actid => is_sc (lab G) a)⦘) ⨾ ⦗\n  trim_events G⦘\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ (⦗trim_events G⦘\n     ⨾ (⦗(fun a : actid => is_f (lab G) a)\n         ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n        ⨾ sc_\n          ⨾ ⦗(fun a : actid => is_f (lab G) a)\n             ∩₁ (fun a : actid => is_sc (lab G) a)⦘) ⨾ ⦗\n       trim_events G⦘)\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘.","proofString":"basic_solver."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : transitive (restr_rel (trim_events G) sc_).","proofString":"basic_solver."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : is_total\n  (trim_events G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) (restr_rel (trim_events G) sc_).","proofString":"red.\nins.\nred in wf_sc_total.\nunfolder in *.\ndesc.\nforward eapply (@trim_events_inclusion a) as Ea; [basic_solver| ].\nforward eapply (@trim_events_inclusion b) as Eb; [basic_solver| ].\nspecialize wf_sc_total with (a := a) (b := b).\nspecialize_full wf_sc_total; auto.\ndesf; auto."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : forall a : actid,\n(trim_events G ∩₁ (fun a0 : actid => is_f (lab G) a0)\n ∩₁ (fun a0 : actid => is_sc (lab G) a0)) a ->\nforall b : actid,\n(trim_events G ∩₁ (fun a0 : actid => is_f (lab G) a0)\n ∩₁ (fun a0 : actid => is_sc (lab G) a0)) b ->\na <> b ->\nrestr_rel (trim_events G) sc_ a b \\/ restr_rel (trim_events G) sc_ b a.","proofString":"ins.\nred in wf_sc_total.\nunfolder in *.\ndesc.\nforward eapply (@trim_events_inclusion a) as Ea; [basic_solver| ].\nforward eapply (@trim_events_inclusion b) as Eb; [basic_solver| ].\nspecialize wf_sc_total with (a := a) (b := b).\nspecialize_full wf_sc_total; auto.\ndesf; auto."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a0 : actid => is_f (lab G) a0)\n   ∩₁ (fun a0 : actid => is_sc (lab G) a0)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a0 : actid => is_f (lab G) a0)\n       ∩₁ (fun a0 : actid => is_sc (lab G) a0)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a0 : actid => is_f (lab G) a0)\n   ∩₁ (fun a0 : actid => is_sc (lab G) a0)) sc_) (sc_irr : irreflexive sc_) (a : actid) (IWa : (trim_events G ∩₁ (fun a0 : actid => is_f (lab G) a0)\n ∩₁ (fun a0 : actid => is_sc (lab G) a0)) a) (b : actid) (IWb : (trim_events G ∩₁ (fun a0 : actid => is_f (lab G) a0)\n ∩₁ (fun a0 : actid => is_sc (lab G) a0)) b) (NEQ : a <> b) : restr_rel (trim_events G) sc_ a b \\/ restr_rel (trim_events G) sc_ b a.","proofString":"red in wf_sc_total.\nunfolder in *.\ndesc.\nforward eapply (@trim_events_inclusion a) as Ea; [basic_solver| ].\nforward eapply (@trim_events_inclusion b) as Eb; [basic_solver| ].\nspecialize wf_sc_total with (a := a) (b := b).\nspecialize_full wf_sc_total; auto.\ndesf; auto."},{"statement":"(wf_scE : forall x y : actid, sc_ x y -> acts_set G x /\\ sc_ x y /\\ acts_set G y) (wf_scE0 : forall x y : actid, acts_set G x /\\ sc_ x y /\\ acts_set G y -> sc_ x y) (wf_scD : forall x y : actid,\nsc_ x y ->\n(is_f (lab G) x /\\ is_sc (lab G) x) /\\\nsc_ x y /\\ is_f (lab G) y /\\ is_sc (lab G) y) (wf_scD0 : forall x y : actid,\n(is_f (lab G) x /\\ is_sc (lab G) x) /\\\nsc_ x y /\\ is_f (lab G) y /\\ is_sc (lab G) y -> sc_ x y) (sc_trans : forall x y z : actid, sc_ x y -> sc_ y z -> sc_ x z) (a b : actid) (wf_sc_total : (acts_set G a /\\ is_f (lab G) a) /\\ is_sc (lab G) a ->\n(acts_set G b /\\ is_f (lab G) b) /\\ is_sc (lab G) b ->\na <> b -> sc_ a b \\/ sc_ b a) (sc_irr : forall x : actid, sc_ x x -> False) (IWa : trim_events G a) (IWa1 : is_f (lab G) a) (IWa0 : is_sc (lab G) a) (IWb : trim_events G b) (IWb1 : is_f (lab G) b) (IWb0 : is_sc (lab G) b) (NEQ : a <> b) (Ea : acts_set G a) (Eb : acts_set G b) : sc_ a b /\\ trim_events G a /\\ trim_events G b \\/\nsc_ b a /\\ trim_events G b /\\ trim_events G a.","proofString":"specialize_full wf_sc_total; auto.\ndesf; auto."},{"statement":"(wf_scE : forall x y : actid, sc_ x y -> acts_set G x /\\ sc_ x y /\\ acts_set G y) (wf_scE0 : forall x y : actid, acts_set G x /\\ sc_ x y /\\ acts_set G y -> sc_ x y) (wf_scD : forall x y : actid,\nsc_ x y ->\n(is_f (lab G) x /\\ is_sc (lab G) x) /\\\nsc_ x y /\\ is_f (lab G) y /\\ is_sc (lab G) y) (wf_scD0 : forall x y : actid,\n(is_f (lab G) x /\\ is_sc (lab G) x) /\\\nsc_ x y /\\ is_f (lab G) y /\\ is_sc (lab G) y -> sc_ x y) (sc_trans : forall x y z : actid, sc_ x y -> sc_ y z -> sc_ x z) (a b : actid) (sc_irr : forall x : actid, sc_ x x -> False) (IWa : trim_events G a) (IWa1 : is_f (lab G) a) (IWa0 : is_sc (lab G) a) (IWb : trim_events G b) (IWb1 : is_f (lab G) b) (IWb0 : is_sc (lab G) b) (NEQ : a <> b) (Ea : acts_set G a) (Eb : acts_set G b) (wf_sc_total : sc_ a b \\/ sc_ b a) : sc_ a b /\\ trim_events G a /\\ trim_events G b \\/\nsc_ b a /\\ trim_events G b /\\ trim_events G a.","proofString":"desf; auto."},{"statement":"(wf_scE : sc_ ≡ ⦗acts_set G⦘ ⨾ sc_ ⨾ ⦗acts_set G⦘) (wf_scD : sc_\n≡ ⦗(fun a : actid => is_f (lab G) a) ∩₁ (fun a : actid => is_sc (lab G) a)⦘\n  ⨾ sc_\n    ⨾ ⦗(fun a : actid => is_f (lab G) a)\n       ∩₁ (fun a : actid => is_sc (lab G) a)⦘) (sc_trans : transitive sc_) (wf_sc_total : is_total\n  (acts_set G ∩₁ (fun a : actid => is_f (lab G) a)\n   ∩₁ (fun a : actid => is_sc (lab G) a)) sc_) (sc_irr : irreflexive sc_) : irreflexive (restr_rel (trim_events G) sc_).","proofString":"basic_solver."},{"statement":"⦗acts_set (trim_exec G)⦘ ⨾ ext_sb ⨾ ⦗acts_set (trim_exec G)⦘\n⊆ ⦗acts_set G⦘ ⨾ ext_sb ⨾ ⦗acts_set G⦘.","proofString":"rewrite <- !restr_relE.\napply restr_rel_mori; [apply trim_events_inclusion | done]."},{"statement":"restr_rel (acts_set (trim_exec G)) ext_sb ⊆ restr_rel (acts_set G) ext_sb.","proofString":"apply restr_rel_mori; [apply trim_events_inclusion | done]."}]}