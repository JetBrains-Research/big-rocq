{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/imm/CombRelationsMore.v","fileSamples":[{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : c_cur G sc thread l A ∪ c_cur G sc thread l (eq r)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘.","conclusion":"c_cur G sc thread l A ∪ c_cur G sc thread l (eq r)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unfold c_cur; split.\nunionL; [basic_solver 21|].\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘).\nby basic_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘) by basic_solver.\nunionR left -> left -> left.\nhahn_frame; revert SB; basic_solver.\nbasic_solver 21.\nbasic_solver 21.\ndone.\nunionL.\ncase_refl (sb ⨾ ⦗eq r⦘).\nby basic_solver 21.\narewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver 12.\nby unfold urr; basic_solver 21.\nby unfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21.\nrelsf; unionL.\nby sin_rewrite (msg_rel_urr WF); basic_solver 12.\nunfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unionL; [basic_solver 21|].\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘).\nby basic_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘) by basic_solver.\nunionR left -> left -> left.\nhahn_frame; revert SB; basic_solver.\nbasic_solver 21.\nbasic_solver 21.\ndone."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘).\nby basic_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘) by basic_solver.\nunionR left -> left -> left.\nhahn_frame; revert SB; basic_solver.\nbasic_solver 21.\nbasic_solver 21.\ndone."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"by basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"sin_rewrite (urr_non_f WF).\nrelsf; unionL.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘) by basic_solver.\nunionR left -> left -> left.\nhahn_frame; revert SB; basic_solver.\nbasic_solver 21.\nbasic_solver 21.\ndone."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : (urr G sc l ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘)\n⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘.","conclusion":"(urr G sc l ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘)\n⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"relsf; unionL.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘) by basic_solver.\nunionR left -> left -> left.\nhahn_frame; revert SB; basic_solver.\nbasic_solver 21.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : (urr G sc l ⨾ sb) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘).","conclusion":"(urr G sc l ⨾ sb) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘) by basic_solver.\nunionR left -> left -> left.\nhahn_frame; revert SB; basic_solver."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ sb ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘).","conclusion":"urr G sc l ⨾ sb ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unionR left -> left -> left.\nhahn_frame; revert SB; basic_solver."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ sb ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘.","conclusion":"urr G sc l ⨾ sb ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"hahn_frame; revert SB; basic_solver."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : (⦗W_ l⦘ ⨾ rf^?) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘).","conclusion":"(⦗W_ l⦘ ⨾ rf^?) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘).","conclusion":"(msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : wf_sc G sc.","conclusion":"wf_sc G sc","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"done."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘ ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘ ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unionL.\ncase_refl (sb ⨾ ⦗eq r⦘).\nby basic_solver 21.\narewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver 12.\nby unfold urr; basic_solver 21.\nby unfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21.\nrelsf; unionL.\nby sin_rewrite (msg_rel_urr WF); basic_solver 12.\nunfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"case_refl (sb ⨾ ⦗eq r⦘).\nby basic_solver 21.\narewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver 12."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"by basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘) ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘) ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"arewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver 12."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ sb ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ sb ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"arewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver 12."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ hb^? ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ hb^? ⨾ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"sin_rewrite urr_hb; basic_solver 12."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : ⦗W_ l⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"⦗W_ l⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"by unfold urr; basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"by unfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"(msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"relsf; unionL.\nby sin_rewrite (msg_rel_urr WF); basic_solver 12.\nunfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"by sin_rewrite (msg_rel_urr WF); basic_solver 12."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘.","conclusion":"⦗Loc_ l⦘ ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n⊆ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq w⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq w⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq w⦘ ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq w⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq w⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq w⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq w⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq w⦘ ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq w⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq w⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq w⦘","hypotheses":"(l : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"rewrite (dom_r (wf_rfD WF)); type_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : ~ is_f lab w.","conclusion":"~ is_f lab w","hypotheses":"(l : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"type_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l\n⨾ (⦗fun _ : actid => True⦘ ∪ release ⨾ rf)\n  ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"urr G sc l\n⨾ (⦗fun _ : actid => True⦘ ∪ release ⨾ rf)\n  ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite seq_union_l; rewrite seq_union_r; rewrite seq_id_l.\narewrite (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘ ≡            c_cur G sc thread l (A ∪₁ eq r)).\nrewrite (id_union A); rewrite (unionC ⦗A⦘).\nrewrite !seq_union_r.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ⦗eq r⦘) by basic_solver.\nrewrite urr_n_f_alt_union_eqv; eauto.\nunfold msg_rel.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n∪ urr G sc l ⨾ (release ⨾ rf) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n∪ urr G sc l ⨾ (release ⨾ rf) ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"arewrite (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘ ≡            c_cur G sc thread l (A ∪₁ eq r)).\nrewrite (id_union A); rewrite (unionC ⦗A⦘).\nrewrite !seq_union_r.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ⦗eq r⦘) by basic_solver.\nrewrite urr_n_f_alt_union_eqv; eauto.\nunfold msg_rel.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : c_cur G sc thread l (A ∪₁ eq r)\n∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"c_cur G sc thread l (A ∪₁ eq r)\n∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite (id_union A); rewrite (unionC ⦗A⦘).\nrewrite !seq_union_r.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ⦗eq r⦘) by basic_solver.\nrewrite urr_n_f_alt_union_eqv; eauto.\nunfold msg_rel.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : c_cur G sc thread l (A ∪₁ eq r)\n∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ (⦗eq r⦘ ∪ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"c_cur G sc thread l (A ∪₁ eq r)\n∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ (⦗eq r⦘ ∪ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite !seq_union_r.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ⦗eq r⦘) by basic_solver.\nrewrite urr_n_f_alt_union_eqv; eauto.\nunfold msg_rel.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : c_cur G sc thread l (A ∪₁ eq r)\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"c_cur G sc thread l (A ∪₁ eq r)\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ⦗eq r⦘) by basic_solver.\nrewrite urr_n_f_alt_union_eqv; eauto.\nunfold msg_rel.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : c_cur G sc thread l (A ∪₁ eq r)\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"c_cur G sc thread l (A ∪₁ eq r)\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite urr_n_f_alt_union_eqv; eauto.\nunfold msg_rel.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘ ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘ ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n  ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unfold msg_rel.\nbasic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n∪ (urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ (urr G sc l ⨾ release) ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘\n∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n∪ (urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘\n∪ (urr G sc l ⨾ release ⨾ rf ⨾ ⦗eq r⦘\n   ∪ urr G sc l ⨾ release ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n≡ urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n  ∪ (urr G sc l ⨾ release) ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n  ∪ (urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘","hypotheses":"(l : location) (A : actid -> Prop) (r : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"basic_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘\n≡ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘\n≡ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"split.\nrewrite (id_union A) at 1; relsf.\nunionL.\nbasic_solver 21.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘).\nby type_solver 21.\narewrite (⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘  ⨾ ⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘).\nby type_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\nunionR right; revert SB; type_solver 21.\nunionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\nrewrite (dom_r (wf_rfD WF)); type_solver 21.\ndone.\nunionL.\nbasic_solver.\nunfold urr; basic_solver 21.\narewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"rewrite (id_union A) at 1; relsf.\nunionL.\nbasic_solver 21.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘).\nby type_solver 21.\narewrite (⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘  ⨾ ⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘).\nby type_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\nunionR right; revert SB; type_solver 21.\nunionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\nrewrite (dom_r (wf_rfD WF)); type_solver 21.\ndone."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n∪ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n∪ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"unionL.\nbasic_solver 21.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘).\nby type_solver 21.\narewrite (⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘  ⨾ ⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘).\nby type_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\nunionR right; revert SB; type_solver 21.\nunionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\nrewrite (dom_r (wf_rfD WF)); type_solver 21.\ndone."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"basic_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘).\nby type_solver 21.\narewrite (⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘  ⨾ ⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘).\nby type_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\nunionR right; revert SB; type_solver 21.\nunionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\nrewrite (dom_r (wf_rfD WF)); type_solver 21.\ndone."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘.","conclusion":"⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"by type_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l\n⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l\n⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"arewrite (⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘  ⨾ ⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘).\nby type_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\nunionR right; revert SB; type_solver 21.\nunionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\nrewrite (dom_r (wf_rfD WF)); type_solver 21.\ndone."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘ ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘.","conclusion":"⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘ ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"by type_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l\n⨾ ⦗set_compl F⦘ ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"urr G sc l\n⨾ ⦗set_compl F⦘ ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"sin_rewrite (urr_non_f WF).\nrelsf; unionL.\nunionR right; revert SB; type_solver 21.\nunionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\nrewrite (dom_r (wf_rfD WF)); type_solver 21.\ndone."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : (urr G sc l ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘)\n⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"(urr G sc l ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘)\n⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"relsf; unionL.\nunionR right; revert SB; type_solver 21.\nunionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\nrewrite (dom_r (wf_rfD WF)); type_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : (urr G sc l ⨾ sb) ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"(urr G sc l ⨾ sb) ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"unionR right; revert SB; type_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : (⦗W_ l⦘ ⨾ rf^?) ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"(⦗W_ l⦘ ⨾ rf^?) ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"unionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : (msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘)\n⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","conclusion":"(msg_rel G sc l ⨾ rf ⨾ ⦗Acq⦘)\n⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n  ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n  ∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"rewrite (dom_r (wf_rfD WF)); type_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : wf_sc G sc.","conclusion":"wf_sc G sc","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"done."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘.","conclusion":"urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n∪ urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"unionL.\nbasic_solver.\nunfold urr; basic_solver 21.\narewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘.","conclusion":"urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"basic_solver."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘.","conclusion":"⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"unfold urr; basic_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘.","conclusion":"urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"arewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘.","conclusion":"urr G sc l ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"arewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver."},{"statement":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread) : urr G sc l ⨾ hb^? ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘.","conclusion":"urr G sc l ⨾ hb^? ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘\n⊆ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq w⦘","hypotheses":"(l l' : location) (A : actid -> Prop) (w : actid) (thread : BinNums.positive) (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A) (WW : W w) (TID : tid w = thread)","proofString":"sin_rewrite urr_hb; basic_solver."},{"statement":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread) : dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n⊆₁ (if LocSet.Facts.eq_dec l locr then eq w else ∅).","conclusion":"dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n⊆₁ (if LocSet.Facts.eq_dec l locr then eq w else ∅)","hypotheses":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread)","proofString":"unfolder; ins; desf.\ngeneralize (wf_rff WF); basic_solver.\napply n; eauto.\ngeneralize (((wf_rfl WF) x y) H0); unfold same_loc; ins; congruence."},{"statement":"(locr : location) (w y : actid) (RF : rf w y) (LOC : loc lab y = Some locr) (x : actid) (H : loc lab x = Some locr) (H0 : rf x y) : w = x.","conclusion":"w = x","hypotheses":"(locr : location) (w y : actid) (RF : rf w y) (LOC : loc lab y = Some locr) (x : actid) (H : loc lab x = Some locr) (H0 : rf x y)","proofString":"generalize (wf_rff WF); basic_solver."},{"statement":"(l locr : location) (w y : actid) (RF : rf w y) (LOC : loc lab y = Some locr) (x : actid) (H : loc lab x = Some l) (H0 : rf x y) (n : l <> locr) : False.","conclusion":"False","hypotheses":"(l locr : location) (w y : actid) (RF : rf w y) (LOC : loc lab y = Some locr) (x : actid) (H : loc lab x = Some l) (H0 : rf x y) (n : l <> locr)","proofString":"apply n; eauto.\ngeneralize (((wf_rfl WF) x y) H0); unfold same_loc; ins; congruence."},{"statement":"(l locr : location) (w y : actid) (RF : rf w y) (LOC : loc lab y = Some locr) (x : actid) (H : loc lab x = Some l) (H0 : rf x y) (n : l <> locr) : l = locr.","conclusion":"l = locr","hypotheses":"(l locr : location) (w y : actid) (RF : rf w y) (LOC : loc lab y = Some locr) (x : actid) (H : loc lab x = Some l) (H0 : rf x y) (n : l <> locr)","proofString":"generalize (((wf_rfl WF) x y) H0); unfold same_loc; ins; congruence."},{"statement":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread) : (if LocSet.Facts.eq_dec l locr then eq w else ∅)\n⊆₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘).","conclusion":"(if LocSet.Facts.eq_dec l locr then eq w else ∅)\n⊆₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)","hypotheses":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread)","proofString":"assert (loc lab w = Some locr).\nby generalize (((wf_rfl WF) w r) RF); unfold same_loc; ins; congruence.\ndesf; basic_solver 21."},{"statement":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread) : loc lab w = Some locr.","conclusion":"loc lab w = Some locr","hypotheses":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread)","proofString":"by generalize (((wf_rfl WF) w r) RF); unfold same_loc; ins; congruence."},{"statement":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread) (H : loc lab w = Some locr) : (if LocSet.Facts.eq_dec l locr then eq w else ∅)\n⊆₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘).","conclusion":"(if LocSet.Facts.eq_dec l locr then eq w else ∅)\n⊆₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)","hypotheses":"(l locr : location) (thread : BinNums.positive) (w r : actid) (LOC : loc lab r = Some locr) (RF : rf w r) (TID : tid r = thread) (H : loc lab w = Some locr)","proofString":"desf; basic_solver 21."},{"statement":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : dom_rel (c_cur G sc thread l (A ∪₁ eq r))\n≡₁ dom_rel (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)).","conclusion":"dom_rel (c_cur G sc thread l (A ∪₁ eq r))\n≡₁ dom_rel (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘))","hypotheses":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite urr_n_f_alt_union_eqv; auto.\nrewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20."},{"statement":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)).","conclusion":"dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗Acq⦘ ⨾ ⦗eq r⦘))","hypotheses":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20."},{"statement":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : dom_rel (c_acq G sc thread l (A ∪₁ eq r))\n≡₁ dom_rel (c_acq G sc thread l A)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)).","conclusion":"dom_rel (c_acq G sc thread l (A ∪₁ eq r))\n≡₁ dom_rel (c_acq G sc thread l A)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘))","hypotheses":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite urr_acq_n_f_alt_union_eqv; eauto.\nunfold c_acq.\nunfold msg_rel.\nrewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20."},{"statement":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n   ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)\n≡₁ dom_rel (c_acq G sc thread l A)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)).","conclusion":"dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n   ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)\n≡₁ dom_rel (c_acq G sc thread l A)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘))","hypotheses":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unfold c_acq.\nunfold msg_rel.\nrewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20."},{"statement":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n   ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)).","conclusion":"dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ msg_rel G sc l ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘ ∪ \n   ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘))","hypotheses":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"unfold msg_rel.\nrewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20."},{"statement":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread) : dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ (urr G sc l ⨾ release) ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n   ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)).","conclusion":"dom_rel\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘\n   ∪ (urr G sc l ⨾ release) ⨾ rf ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n   ∪ ⦗W_ l⦘ ⨾ ⦗eq r⦘ ∪ ⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘\n   ∪ (urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)\n   ∪₁ (W_ l ∩₁ eq r ∪₁ dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘)\n       ∪₁ dom_rel ((urr G sc l ⨾ release ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘))","hypotheses":"(l : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (NF : ~ F r) (TID : tid r = thread)","proofString":"rewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20."},{"statement":"(l l' : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (RR : R r) (TID : tid r = thread) : dom_rel\n  (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘).","conclusion":"dom_rel\n  (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)","hypotheses":"(l l' : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (RR : R r) (TID : tid r = thread)","proofString":"rewrite (id_union A); rewrite !seq_union_r.\narewrite (⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ∅₂); rels.\ntype_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (RR : R r) (TID : tid r = thread) : dom_rel\n  (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n   ∪ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘).","conclusion":"dom_rel\n  (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘\n   ∪ urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘)\n≡₁ dom_rel (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A⦘)","hypotheses":"(l l' : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (RR : R r) (TID : tid r = thread)","proofString":"arewrite (⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ∅₂); rels.\ntype_solver 21."},{"statement":"(l l' : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (RR : R r) (TID : tid r = thread) : ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ∅₂.","conclusion":"⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ∅₂","hypotheses":"(l l' : location) (A : actid -> Prop) (thread : BinNums.positive) (r : actid) (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A) (RR : R r) (TID : tid r = thread)","proofString":"type_solver 21."},{"statement":"(wi : actid) (C : actid -> Prop) (l : location) (thread : BinNums.positive) (INC : C wi) (INIT : is_init wi) (LOC : Loc_ l wi) : dom_rel\n  ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?)\n   ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C⦘) wi.","conclusion":"dom_rel\n  ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?)\n   ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C⦘) wi","hypotheses":"(wi : actid) (C : actid -> Prop) (l : location) (thread : BinNums.positive) (INC : C wi) (INIT : is_init wi) (LOC : Loc_ l wi)","proofString":"generalize (init_w WF); unfold seq; basic_solver 42."},{"statement":"(l : location) (y : actid) (YW : W y) (LOC : loc lab y = Some l) : (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) y y.","conclusion":"(⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) y y","hypotheses":"(l : location) (y : actid) (YW : W y) (LOC : loc lab y = Some l)","proofString":"basic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : (if LocSet.Facts.eq_dec l l' then W_ l' ∩₁ Tid_ thread ∩₁ C' else ∅)\n≡₁ (if LocSet.Facts.eq_dec l l' then W_ l' ∩₁ Tid_ thread ∩₁ C else ∅).","conclusion":"(if LocSet.Facts.eq_dec l l' then W_ l' ∩₁ Tid_ thread ∩₁ C' else ∅)\n≡₁ (if LocSet.Facts.eq_dec l l' then W_ l' ∩₁ Tid_ thread ∩₁ C else ∅)","hypotheses":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a)","proofString":"desf; basic_solver 21."},{"statement":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a) : dom_rel (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗C'⦘)\n≡₁ dom_rel (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗C⦘).","conclusion":"dom_rel (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗C'⦘)\n≡₁ dom_rel (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗C⦘)","hypotheses":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a)","proofString":"arewrite (⦗F∩₁Sc⦘ ⨾ ⦗C'⦘ ≡ ⦗F∩₁Sc⦘ ⨾ ⦗C⦘); [|done].\nsplit; [|by rewrite CINCL].\nunfolder; ins; desf.\ndestruct (classic (C y)) as [H|H]; auto.\nexfalso; eapply COVSTEP; basic_solver."},{"statement":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a) : ⦗F ∩₁ Sc⦘ ⨾ ⦗C'⦘ ≡ ⦗F ∩₁ Sc⦘ ⨾ ⦗C⦘.","conclusion":"⦗F ∩₁ Sc⦘ ⨾ ⦗C'⦘ ≡ ⦗F ∩₁ Sc⦘ ⨾ ⦗C⦘","hypotheses":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a)","proofString":"split; [|by rewrite CINCL].\nunfolder; ins; desf.\ndestruct (classic (C y)) as [H|H]; auto.\nexfalso; eapply COVSTEP; basic_solver."},{"statement":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a) : ⦗F ∩₁ Sc⦘ ⨾ ⦗C'⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗C⦘.","conclusion":"⦗F ∩₁ Sc⦘ ⨾ ⦗C'⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗C⦘","hypotheses":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a)","proofString":"unfolder; ins; desf.\ndestruct (classic (C y)) as [H|H]; auto.\nexfalso; eapply COVSTEP; basic_solver."},{"statement":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a) (y : actid) (H1 : C' y) (H2 : is_sc lab y) (H0 : is_f lab y) : y = y /\\ (true /\\ true) /\\ C y.","conclusion":"y = y /\\ (true /\\ true) /\\ C y","hypotheses":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a) (y : actid) (H1 : C' y) (H2 : is_sc lab y) (H0 : is_f lab y)","proofString":"destruct (classic (C y)) as [H|H]; auto.\nexfalso; eapply COVSTEP; basic_solver."},{"statement":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a) (y : actid) (H1 : C' y) (H2 : is_sc lab y) (H0 : is_f lab y) (H : ~ C y) : y = y /\\ (true /\\ true) /\\ C y.","conclusion":"y = y /\\ (true /\\ true) /\\ C y","hypotheses":"(C C' : actid -> Prop) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (COVSTEP : forall a : actid, C' a -> ~ C a -> ~ (F ∩₁ Sc) a) (y : actid) (H1 : C' y) (H2 : is_sc lab y) (H0 : is_f lab y) (H : ~ C y)","proofString":"exfalso; eapply COVSTEP; basic_solver."}]}